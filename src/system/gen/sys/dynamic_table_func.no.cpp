/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <runtime/base/hphp_system.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>
#include <sys/literal_strings.h>


using namespace std;

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////


// Function Invoke Table
Variant i_utf8_encode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(utf8_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("utf8_encode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_utf8_encode(arg0));
  }
}
Variant ifa_utf8_encode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("utf8_encode", count, 1, 1, 1);
  return (f_utf8_encode(a0));
}
Variant i_hphp_splfileobject___construct(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject___construct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("hphp_splfileobject___construct", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject___construct(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_hphp_splfileobject___construct(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("hphp_splfileobject___construct", count, 5, 5, 1);
  return (f_hphp_splfileobject___construct(a0, a1, a2, a3, a4));
}
Variant i_dom_document_create_comment(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_comment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_comment", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_comment(arg0, arg1));
  }
}
Variant ifa_dom_document_create_comment(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_create_comment", count, 2, 2, 1);
  return (f_dom_document_create_comment(a0, a1));
}
Variant i_func_get_args(void *extra, CArrRef params) {
  FUNCTION_INJECTION(func_get_args);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("func_get_args", 0, 1);
  return (f_func_get_args());
}
Variant ifa_func_get_args(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("func_get_args", 0, 1);
  return (f_func_get_args());
}
Variant i_php_uname(void *extra, CArrRef params) {
  FUNCTION_INJECTION(php_uname);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("php_uname", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_php_uname());
    CVarRef arg0((ad->getValue(pos)));
    return (f_php_uname(arg0));
  }
}
Variant ifa_php_uname(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("php_uname", 1, 1);
  if (count <= 0) return (f_php_uname());
  return (f_php_uname(a0));
}
Variant i_posix_uname(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_uname);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_uname", 0, 1);
  return (f_posix_uname());
}
Variant ifa_posix_uname(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_uname", 0, 1);
  return (f_posix_uname());
}
Variant i_curl_multi_remove_handle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_multi_remove_handle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_remove_handle", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_multi_remove_handle(arg0, arg1));
  }
}
Variant ifa_curl_multi_remove_handle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("curl_multi_remove_handle", count, 2, 2, 1);
  return (f_curl_multi_remove_handle(a0, a1));
}
Variant i_memcache_get_server_status(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_get_server_status);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_get_server_status", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_get_server_status(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_get_server_status(arg0, arg1, arg2));
  }
}
Variant ifa_memcache_get_server_status(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_get_server_status", count, 2, 3, 1);
  if (count <= 2) return (f_memcache_get_server_status(a0, a1));
  return (f_memcache_get_server_status(a0, a1, a2));
}
Variant i_mysql_result(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_result);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_result", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mysql_result(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_result(arg0, arg1, arg2));
  }
}
Variant ifa_mysql_result(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_result", count, 2, 3, 1);
  if (count <= 2) return (f_mysql_result(a0, a1));
  return (f_mysql_result(a0, a1, a2));
}
Variant i_hphp_splfileobject_current(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_current);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_current", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_current(arg0));
  }
}
Variant ifa_hphp_splfileobject_current(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_current", count, 1, 1, 1);
  return (f_hphp_splfileobject_current(a0));
}
Variant i_hphp_splfileinfo_getgroup(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getgroup);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getgroup", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getgroup(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getgroup(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getgroup", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getgroup(a0));
}
Variant i_register_shutdown_function(void *extra, CArrRef params) {
  FUNCTION_INJECTION(register_shutdown_function);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_shutdown_function", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_register_shutdown_function(count, arg0), null);
    return (f_register_shutdown_function(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant ifa_register_shutdown_function(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("register_shutdown_function", count+1, 1);
  if (count <= 1) return (f_register_shutdown_function(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_register_shutdown_function(count,a0, params), null);
}
Variant i_pixelsetmagentaquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetmagentaquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetmagentaquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetmagentaquantum(arg0, arg1), null);
  }
}
Variant ifa_pixelsetmagentaquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetmagentaquantum", count, 2, 2, 1);
  return (f_pixelsetmagentaquantum(a0, a1), null);
}
Variant i_newmagickwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(newmagickwand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("newmagickwand", 0, 1);
  return (f_newmagickwand());
}
Variant ifa_newmagickwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("newmagickwand", 0, 1);
  return (f_newmagickwand());
}
Variant i_natsort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(natsort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("natsort", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_natsort(arg0));
  }
}
Variant ifa_natsort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("natsort", count, 1, 1, 1);
  return (f_natsort(ref(a0)));
}
Variant i_socket_accept(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_accept);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_accept", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_accept(arg0));
  }
}
Variant ifa_socket_accept(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("socket_accept", count, 1, 1, 1);
  return (f_socket_accept(a0));
}
Variant i_vprintf(void *extra, CArrRef params) {
  FUNCTION_INJECTION(vprintf);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("vprintf", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_vprintf(arg0, arg1));
  }
}
Variant ifa_vprintf(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("vprintf", count, 2, 2, 1);
  return (f_vprintf(a0, a1));
}
Variant i_collator_set_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_set_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("collator_set_attribute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_set_attribute(arg0, arg1, arg2));
  }
}
Variant ifa_collator_set_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("collator_set_attribute", count, 3, 3, 1);
  return (f_collator_set_attribute(a0, a1, a2));
}
Variant i_ucwords(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ucwords);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ucwords", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ucwords(arg0));
  }
}
Variant ifa_ucwords(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ucwords", count, 1, 1, 1);
  return (f_ucwords(a0));
}
Variant i_header(void *extra, CArrRef params) {
  FUNCTION_INJECTION(header);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("header", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_header(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_header(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_header(arg0, arg1, arg2), null);
  }
}
Variant ifa_header(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("header", count, 1, 3, 1);
  if (count <= 1) return (f_header(a0), null);
  if (count == 2) return (f_header(a0, a1), null);
  return (f_header(a0, a1, a2), null);
}
Variant i_dom_element_has_attribute_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_has_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_has_attribute_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_has_attribute_ns(arg0, arg1, arg2));
  }
}
Variant ifa_dom_element_has_attribute_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_element_has_attribute_ns", count, 3, 3, 1);
  return (f_dom_element_has_attribute_ns(a0, a1, a2));
}
Variant i_date_default_timezone_set(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_default_timezone_set);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_default_timezone_set", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_date_default_timezone_set(arg0));
  }
}
Variant ifa_date_default_timezone_set(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("date_default_timezone_set", count, 1, 1, 1);
  return (f_date_default_timezone_set(a0));
}
Variant i_is_object(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_object);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_object", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_object(arg0));
  }
}
Variant ifa_is_object(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_object", count, 1, 1, 1);
  return (f_is_object(a0));
}
Variant i_magicksetimagebias(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagebias);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebias", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagebias(arg0, arg1));
  }
}
Variant ifa_magicksetimagebias(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagebias", count, 2, 2, 1);
  return (f_magicksetimagebias(a0, a1));
}
Variant i_exif_imagetype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(exif_imagetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exif_imagetype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_exif_imagetype(arg0));
  }
}
Variant ifa_exif_imagetype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("exif_imagetype", count, 1, 1, 1);
  return (f_exif_imagetype(a0));
}
Variant i_imagegrabscreen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagegrabscreen);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("imagegrabscreen", 0, 1);
  return (f_imagegrabscreen());
}
Variant ifa_imagegrabscreen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("imagegrabscreen", 0, 1);
  return (f_imagegrabscreen());
}
Variant i_bcmod(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bcmod);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("bcmod", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcmod(arg0, arg1));
  }
}
Variant ifa_bcmod(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("bcmod", count, 2, 2, 1);
  return (f_bcmod(a0, a1));
}
Variant i_chr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(chr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chr", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_chr(arg0));
  }
}
Variant ifa_chr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("chr", count, 1, 1, 1);
  return (f_chr(a0));
}
Variant i_drawsetfontstretch(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetfontstretch);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontstretch", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfontstretch(arg0, arg1), null);
  }
}
Variant ifa_drawsetfontstretch(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetfontstretch", count, 2, 2, 1);
  return (f_drawsetfontstretch(a0, a1), null);
}
Variant i_posix_setsid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_setsid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_setsid", 0, 1);
  return (f_posix_setsid());
}
Variant ifa_posix_setsid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_setsid", 0, 1);
  return (f_posix_setsid());
}
Variant i_hphp_splfileinfo_setfileclass(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_setfileclass);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_setfileclass", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_setfileclass(arg0, arg1), null);
  }
}
Variant ifa_hphp_splfileinfo_setfileclass(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_setfileclass", count, 2, 2, 1);
  return (f_hphp_splfileinfo_setfileclass(a0, a1), null);
}
Variant i_posix_getpwnam(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getpwnam);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpwnam", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getpwnam(arg0));
  }
}
Variant ifa_posix_getpwnam(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_getpwnam", count, 1, 1, 1);
  return (f_posix_getpwnam(a0));
}
Variant i_mcrypt_enc_get_supported_key_sizes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_supported_key_sizes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_supported_key_sizes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_supported_key_sizes(arg0));
  }
}
Variant ifa_mcrypt_enc_get_supported_key_sizes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_supported_key_sizes", count, 1, 1, 1);
  return (f_mcrypt_enc_get_supported_key_sizes(a0));
}
Variant i_phpinfo(void *extra, CArrRef params) {
  FUNCTION_INJECTION(phpinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpinfo", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_phpinfo());
    CVarRef arg0((ad->getValue(pos)));
    return (f_phpinfo(arg0));
  }
}
Variant ifa_phpinfo(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("phpinfo", 1, 1);
  if (count <= 0) return (f_phpinfo());
  return (f_phpinfo(a0));
}
Variant i_evhttp_async_get(void *extra, CArrRef params) {
  FUNCTION_INJECTION(evhttp_async_get);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("evhttp_async_get", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_evhttp_async_get(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_evhttp_async_get(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_evhttp_async_get(arg0, arg1, arg2));
  }
}
Variant ifa_evhttp_async_get(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("evhttp_async_get", count, 1, 3, 1);
  if (count <= 1) return (f_evhttp_async_get(a0));
  if (count == 2) return (f_evhttp_async_get(a0, a1));
  return (f_evhttp_async_get(a0, a1, a2));
}
Variant i_ldap_parse_result(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_parse_result);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("ldap_parse_result", count, 3, 6, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_ldap_parse_result(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_ldap_parse_result(arg0, arg1, arg2, arg3));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_ldap_parse_result(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_ldap_parse_result(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_ldap_parse_result(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 6) return throw_wrong_arguments("ldap_parse_result", count, 3, 6, 1);
  if (count <= 3) return (f_ldap_parse_result(a0, a1, ref(a2)));
  if (count == 4) return (f_ldap_parse_result(a0, a1, ref(a2), ref(a3)));
  if (count == 5) return (f_ldap_parse_result(a0, a1, ref(a2), ref(a3), ref(a4)));
  return (f_ldap_parse_result(a0, a1, ref(a2), ref(a3), ref(a4), ref(a5)));
}
Variant i_drawgettextantialias(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgettextantialias);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextantialias", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgettextantialias(arg0));
  }
}
Variant ifa_drawgettextantialias(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgettextantialias", count, 1, 1, 1);
  return (f_drawgettextantialias(a0));
}
Variant i_array_fill_keys(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_fill_keys);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_fill_keys", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_fill_keys(arg0, arg1));
  }
}
Variant ifa_array_fill_keys(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("array_fill_keys", count, 2, 2, 1);
  return (f_array_fill_keys(a0, a1));
}
Variant i_openssl_seal(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_seal);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("openssl_seal", count, 4, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_seal(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_seal(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("openssl_seal", count, 4, 4, 1);
  return (f_openssl_seal(a0, ref(a1), ref(a2), a3));
}
Variant i_socket_clear_error(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_clear_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("socket_clear_error", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_socket_clear_error(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_clear_error(arg0), null);
  }
}
Variant ifa_socket_clear_error(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("socket_clear_error", 1, 1);
  if (count <= 0) return (f_socket_clear_error(), null);
  return (f_socket_clear_error(a0), null);
}
Variant i_die(void *extra, CArrRef params) {
  FUNCTION_INJECTION(die);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("die", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_die());
    CVarRef arg0((ad->getValue(pos)));
    return (f_die(arg0));
  }
}
Variant ifa_die(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("die", 1, 1);
  if (count <= 0) return (f_die());
  return (f_die(a0));
}
Variant i_diskfreespace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(diskfreespace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("diskfreespace", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_diskfreespace(arg0));
  }
}
Variant ifa_diskfreespace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("diskfreespace", count, 1, 1, 1);
  return (f_diskfreespace(a0));
}
Variant i_xml_set_start_namespace_decl_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_set_start_namespace_decl_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_start_namespace_decl_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_start_namespace_decl_handler(arg0, arg1));
  }
}
Variant ifa_xml_set_start_namespace_decl_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xml_set_start_namespace_decl_handler", count, 2, 2, 1);
  return (f_xml_set_start_namespace_decl_handler(a0, a1));
}
Variant i_decbin(void *extra, CArrRef params) {
  FUNCTION_INJECTION(decbin);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("decbin", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_decbin(arg0));
  }
}
Variant ifa_decbin(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("decbin", count, 1, 1, 1);
  return (f_decbin(a0));
}
Variant i_sizeof(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sizeof);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sizeof", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_sizeof(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_sizeof(arg0, arg1));
  }
}
Variant ifa_sizeof(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("sizeof", count, 1, 2, 1);
  if (count <= 1) return (f_sizeof(a0));
  return (f_sizeof(a0, a1));
}
Variant i_mb_convert_case(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_convert_case);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_convert_case", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_convert_case(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_convert_case(arg0, arg1, arg2));
  }
}
Variant ifa_mb_convert_case(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_convert_case", count, 2, 3, 1);
  if (count <= 2) return (f_mb_convert_case(a0, a1));
  return (f_mb_convert_case(a0, a1, a2));
}
Variant i_fb_set_taint(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_set_taint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_set_taint", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_set_taint(arg0, arg1), null);
  }
}
Variant ifa_fb_set_taint(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("fb_set_taint", count, 2, 2, 1);
  return (f_fb_set_taint(ref(a0), a1), null);
}
Variant i_dir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dir(arg0));
  }
}
Variant ifa_dir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dir", count, 1, 1, 1);
  return (f_dir(a0));
}
Variant i_array_combine(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_combine);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_combine", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_combine(arg0, arg1));
  }
}
Variant ifa_array_combine(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("array_combine", count, 2, 2, 1);
  return (f_array_combine(a0, a1));
}
Variant i_strpos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strpos", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strpos(arg0, arg1, arg2));
  }
}
Variant ifa_strpos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("strpos", count, 2, 3, 1);
  if (count <= 2) return (f_strpos(a0, a1));
  return (f_strpos(a0, a1, a2));
}
Variant i_array_reverse(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_reverse);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_reverse", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_reverse(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_reverse(arg0, arg1));
  }
}
Variant ifa_array_reverse(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("array_reverse", count, 1, 2, 1);
  if (count <= 1) return (f_array_reverse(a0));
  return (f_array_reverse(a0, a1));
}
Variant i_strrev(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strrev);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strrev", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_strrev(arg0));
  }
}
Variant ifa_strrev(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("strrev", count, 1, 1, 1);
  return (f_strrev(a0));
}
Variant i_msg_set_queue(void *extra, CArrRef params) {
  FUNCTION_INJECTION(msg_set_queue);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("msg_set_queue", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_msg_set_queue(arg0, arg1));
  }
}
Variant ifa_msg_set_queue(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("msg_set_queue", count, 2, 2, 1);
  return (f_msg_set_queue(a0, a1));
}
Variant i_cos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(cos);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cos", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_cos(arg0));
  }
}
Variant ifa_cos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("cos", count, 1, 1, 1);
  return (f_cos(a0));
}
Variant i_hphp_recursivedirectoryiterator_valid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_valid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_valid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_valid(arg0));
  }
}
Variant ifa_hphp_recursivedirectoryiterator_valid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_valid", count, 1, 1, 1);
  return (f_hphp_recursivedirectoryiterator_valid(a0));
}
Variant i_bcmul(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bcmul);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcmul", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bcmul(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcmul(arg0, arg1, arg2));
  }
}
Variant ifa_bcmul(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("bcmul", count, 2, 3, 1);
  if (count <= 2) return (f_bcmul(a0, a1));
  return (f_bcmul(a0, a1, a2));
}
Variant i_openlog(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openlog);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("openlog", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openlog(arg0, arg1, arg2));
  }
}
Variant ifa_openlog(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("openlog", count, 3, 3, 1);
  return (f_openlog(a0, a1, a2));
}
Variant i_get_include_path(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_include_path);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_include_path", 0, 1);
  return (f_get_include_path());
}
Variant ifa_get_include_path(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("get_include_path", 0, 1);
  return (f_get_include_path());
}
Variant i_socket_select(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_select);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("socket_select", count, 4, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_socket_select(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_select(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_socket_select(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("socket_select", count, 4, 5, 1);
  if (count <= 4) return (f_socket_select(ref(a0), ref(a1), ref(a2), a3));
  return (f_socket_select(ref(a0), ref(a1), ref(a2), a3, a4));
}
Variant i_magickraiseimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickraiseimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickraiseimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickraiseimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_magickraiseimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("magickraiseimage", count, 6, 6, 1);
  return (f_magickraiseimage(a0, a1, a2, a3, a4, a5));
}
Variant i_gzputs(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzputs);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzputs", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_gzputs(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzputs(arg0, arg1, arg2));
  }
}
Variant ifa_gzputs(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("gzputs", count, 2, 3, 1);
  if (count <= 2) return (f_gzputs(a0, a1));
  return (f_gzputs(a0, a1, a2));
}
Variant i_strpbrk(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strpbrk);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strpbrk", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strpbrk(arg0, arg1));
  }
}
Variant ifa_strpbrk(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("strpbrk", count, 2, 2, 1);
  return (f_strpbrk(a0, a1));
}
Variant i_shm_remove_var(void *extra, CArrRef params) {
  FUNCTION_INJECTION(shm_remove_var);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("shm_remove_var", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_shm_remove_var(arg0, arg1));
  }
}
Variant ifa_shm_remove_var(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("shm_remove_var", count, 2, 2, 1);
  return (f_shm_remove_var(a0, a1));
}
Variant i_posix_setuid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_setuid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setuid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_setuid(arg0));
  }
}
Variant ifa_posix_setuid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_setuid", count, 1, 1, 1);
  return (f_posix_setuid(a0));
}
Variant i_pixelgetyellow(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetyellow);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetyellow", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetyellow(arg0));
  }
}
Variant ifa_pixelgetyellow(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetyellow", count, 1, 1, 1);
  return (f_pixelgetyellow(a0));
}
Variant i_convert_uudecode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(convert_uudecode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("convert_uudecode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_convert_uudecode(arg0));
  }
}
Variant ifa_convert_uudecode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("convert_uudecode", count, 1, 1, 1);
  return (f_convert_uudecode(a0));
}
Variant i_htmlspecialchars_decode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(htmlspecialchars_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("htmlspecialchars_decode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_htmlspecialchars_decode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_htmlspecialchars_decode(arg0, arg1));
  }
}
Variant ifa_htmlspecialchars_decode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("htmlspecialchars_decode", count, 1, 2, 1);
  if (count <= 1) return (f_htmlspecialchars_decode(a0));
  return (f_htmlspecialchars_decode(a0, a1));
}
Variant i_xmlwriter_end_document(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_document);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_document", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_document(arg0));
  }
}
Variant ifa_xmlwriter_end_document(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_document", count, 1, 1, 1);
  return (f_xmlwriter_end_document(a0));
}
Variant i_magickgetimagehistogram(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagehistogram);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagehistogram", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagehistogram(arg0));
  }
}
Variant ifa_magickgetimagehistogram(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagehistogram", count, 1, 1, 1);
  return (f_magickgetimagehistogram(a0));
}
Variant i_preg_last_error(void *extra, CArrRef params) {
  FUNCTION_INJECTION(preg_last_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("preg_last_error", 0, 1);
  return (f_preg_last_error());
}
Variant ifa_preg_last_error(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("preg_last_error", 0, 1);
  return (f_preg_last_error());
}
Variant i_end(void *extra, CArrRef params) {
  FUNCTION_INJECTION(end);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("end", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_end(arg0));
  }
}
Variant ifa_end(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("end", count, 1, 1, 1);
  return (f_end(ref(a0)));
}
Variant i_stream_get_line(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_get_line);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_get_line", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_get_line(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_stream_get_line(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_get_line(arg0, arg1, arg2));
  }
}
Variant ifa_stream_get_line(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_get_line", count, 1, 3, 1);
  if (count <= 1) return (f_stream_get_line(a0));
  if (count == 2) return (f_stream_get_line(a0, a1));
  return (f_stream_get_line(a0, a1, a2));
}
Variant i_deg2rad(void *extra, CArrRef params) {
  FUNCTION_INJECTION(deg2rad);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("deg2rad", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_deg2rad(arg0));
  }
}
Variant ifa_deg2rad(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("deg2rad", count, 1, 1, 1);
  return (f_deg2rad(a0));
}
Variant i_magickrollimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickrollimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickrollimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickrollimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickrollimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magickrollimage", count, 3, 3, 1);
  return (f_magickrollimage(a0, a1, a2));
}
Variant i_ldap_sort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_sort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_sort", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_sort(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_sort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ldap_sort", count, 3, 3, 1);
  return (f_ldap_sort(a0, a1, a2));
}
Variant i_imagetruecolortopalette(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagetruecolortopalette);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagetruecolortopalette", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagetruecolortopalette(arg0, arg1, arg2));
  }
}
Variant ifa_imagetruecolortopalette(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("imagetruecolortopalette", count, 3, 3, 1);
  return (f_imagetruecolortopalette(a0, a1, a2));
}
Variant i_defined(void *extra, CArrRef params) {
  FUNCTION_INJECTION(defined);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("defined", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_defined(arg0));
  }
}
Variant ifa_defined(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("defined", count, 1, 1, 1);
  return (f_defined(a0));
}
Variant i_magickgetimageunits(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageunits);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageunits", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageunits(arg0));
  }
}
Variant ifa_magickgetimageunits(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimageunits", count, 1, 1, 1);
  return (f_magickgetimageunits(a0));
}
Variant i_magicksetimageblueprimary(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimageblueprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageblueprimary", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageblueprimary(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetimageblueprimary(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksetimageblueprimary", count, 3, 3, 1);
  return (f_magicksetimageblueprimary(a0, a1, a2));
}
Variant i_session_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_name);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_name", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_name());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_name(arg0));
  }
}
Variant ifa_session_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("session_name", 1, 1);
  if (count <= 0) return (f_session_name());
  return (f_session_name(a0));
}
Variant i_get_class_vars(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_class_vars);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_class_vars", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_class_vars(arg0));
  }
}
Variant ifa_get_class_vars(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("get_class_vars", count, 1, 1, 1);
  return (f_get_class_vars(a0));
}
Variant i_syslog(void *extra, CArrRef params) {
  FUNCTION_INJECTION(syslog);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("syslog", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_syslog(arg0, arg1));
  }
}
Variant ifa_syslog(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("syslog", count, 2, 2, 1);
  return (f_syslog(a0, a1));
}
Variant i_array_unique(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_unique);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_unique", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_unique(arg0));
  }
}
Variant ifa_array_unique(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("array_unique", count, 1, 1, 1);
  return (f_array_unique(a0));
}
Variant i_bcpow(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bcpow);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcpow", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bcpow(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcpow(arg0, arg1, arg2));
  }
}
Variant ifa_bcpow(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("bcpow", count, 2, 3, 1);
  if (count <= 2) return (f_bcpow(a0, a1));
  return (f_bcpow(a0, a1, a2));
}
Variant i_pixelgetopacityquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetopacityquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetopacityquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetopacityquantum(arg0));
  }
}
Variant ifa_pixelgetopacityquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetopacityquantum", count, 1, 1, 1);
  return (f_pixelgetopacityquantum(a0));
}
Variant i_php_check_syntax(void *extra, CArrRef params) {
  FUNCTION_INJECTION(php_check_syntax);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("php_check_syntax", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_php_check_syntax(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_php_check_syntax(arg0, arg1));
  }
}
Variant ifa_php_check_syntax(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("php_check_syntax", count, 1, 2, 1);
  if (count <= 1) return (f_php_check_syntax(a0));
  return (f_php_check_syntax(a0, ref(a1)));
}
Variant i_mysql_connect_with_db(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_connect_with_db);
  int count __attribute__((__unused__)) = params.size();
  if (count > 8) return throw_toomany_arguments("mysql_connect_with_db", 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_connect_with_db());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mysql_connect_with_db(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mysql_connect_with_db(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mysql_connect_with_db(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mysql_connect_with_db(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_mysql_connect_with_db(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_mysql_connect_with_db(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_mysql_connect_with_db(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_connect_with_db(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant ifa_mysql_connect_with_db(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 8) return throw_toomany_arguments("mysql_connect_with_db", 8, 1);
  if (count <= 0) return (f_mysql_connect_with_db());
  if (count == 1) return (f_mysql_connect_with_db(a0));
  if (count == 2) return (f_mysql_connect_with_db(a0, a1));
  if (count == 3) return (f_mysql_connect_with_db(a0, a1, a2));
  if (count == 4) return (f_mysql_connect_with_db(a0, a1, a2, a3));
  if (count == 5) return (f_mysql_connect_with_db(a0, a1, a2, a3, a4));
  return (f_mysql_connect_with_db(a0, a1, a2, a3, a4, a5));
}
Variant i_drawgetstrokemiterlimit(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokemiterlimit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokemiterlimit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokemiterlimit(arg0));
  }
}
Variant ifa_drawgetstrokemiterlimit(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetstrokemiterlimit", count, 1, 1, 1);
  return (f_drawgetstrokemiterlimit(a0));
}
Variant i_hphp_splfileobject_fpassthru(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fpassthru);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fpassthru", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_fpassthru(arg0));
  }
}
Variant ifa_hphp_splfileobject_fpassthru(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fpassthru", count, 1, 1, 1);
  return (f_hphp_splfileobject_fpassthru(a0));
}
Variant i_intl_error_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(intl_error_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("intl_error_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_intl_error_name(arg0));
  }
}
Variant ifa_intl_error_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("intl_error_name", count, 1, 1, 1);
  return (f_intl_error_name(a0));
}
Variant i_pixelsetquantumcolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetquantumcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("pixelsetquantumcolor", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_pixelsetquantumcolor(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetquantumcolor(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant ifa_pixelsetquantumcolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("pixelsetquantumcolor", count, 4, 5, 1);
  if (count <= 4) return (f_pixelsetquantumcolor(a0, a1, a2, a3), null);
  return (f_pixelsetquantumcolor(a0, a1, a2, a3, a4), null);
}
Variant i_gztell(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gztell);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gztell", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gztell(arg0));
  }
}
Variant ifa_gztell(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("gztell", count, 1, 1, 1);
  return (f_gztell(a0));
}
Variant i_strval(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strval);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strval", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_strval(arg0));
  }
}
Variant ifa_strval(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("strval", count, 1, 1, 1);
  return (f_strval(a0));
}
Variant i_evhttp_recv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(evhttp_recv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("evhttp_recv", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_evhttp_recv(arg0));
  }
}
Variant ifa_evhttp_recv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("evhttp_recv", count, 1, 1, 1);
  return (f_evhttp_recv(a0));
}
Variant i_dom_node_replace_child(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_replace_child);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_node_replace_child", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_replace_child(arg0, arg1, arg2));
  }
}
Variant ifa_dom_node_replace_child(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_node_replace_child", count, 3, 3, 1);
  return (f_dom_node_replace_child(a0, a1, a2));
}
Variant i_strspn(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strspn);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("strspn", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strspn(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_strspn(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strspn(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_strspn(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("strspn", count, 2, 4, 1);
  if (count <= 2) return (f_strspn(a0, a1));
  if (count == 3) return (f_strspn(a0, a1, a2));
  return (f_strspn(a0, a1, a2, a3));
}
Variant i_ini_restore(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ini_restore);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ini_restore", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ini_restore(arg0), null);
  }
}
Variant ifa_ini_restore(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ini_restore", count, 1, 1, 1);
  return (f_ini_restore(a0), null);
}
Variant i_ldap_dn2ufn(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_dn2ufn);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_dn2ufn", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_dn2ufn(arg0));
  }
}
Variant ifa_ldap_dn2ufn(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ldap_dn2ufn", count, 1, 1, 1);
  return (f_ldap_dn2ufn(a0));
}
Variant i_ceil(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ceil);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ceil", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ceil(arg0));
  }
}
Variant ifa_ceil(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ceil", count, 1, 1, 1);
  return (f_ceil(a0));
}
Variant i_xmlwriter_end_dtd_attlist(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_dtd_attlist);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_attlist", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_dtd_attlist(arg0));
  }
}
Variant ifa_xmlwriter_end_dtd_attlist(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_attlist", count, 1, 1, 1);
  return (f_xmlwriter_end_dtd_attlist(a0));
}
Variant i_phpversion(void *extra, CArrRef params) {
  FUNCTION_INJECTION(phpversion);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpversion", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_phpversion());
    CVarRef arg0((ad->getValue(pos)));
    return (f_phpversion(arg0));
  }
}
Variant ifa_phpversion(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("phpversion", 1, 1);
  if (count <= 0) return (f_phpversion());
  return (f_phpversion(a0));
}
Variant i_stream_filter_remove(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_filter_remove);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_filter_remove", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_filter_remove(arg0));
  }
}
Variant ifa_stream_filter_remove(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("stream_filter_remove", count, 1, 1, 1);
  return (f_stream_filter_remove(a0));
}
Variant i_mcrypt_generic(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_generic);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_generic", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_generic(arg0, arg1));
  }
}
Variant ifa_mcrypt_generic(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("mcrypt_generic", count, 2, 2, 1);
  return (f_mcrypt_generic(a0, a1));
}
Variant i_is_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_file", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_file(arg0));
  }
}
Variant ifa_is_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_file", count, 1, 1, 1);
  return (f_is_file(a0));
}
Variant i_xml_set_end_namespace_decl_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_set_end_namespace_decl_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_end_namespace_decl_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_end_namespace_decl_handler(arg0, arg1));
  }
}
Variant ifa_xml_set_end_namespace_decl_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xml_set_end_namespace_decl_handler", count, 2, 2, 1);
  return (f_xml_set_end_namespace_decl_handler(a0, a1));
}
Variant i_openssl_x509_export_to_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_export_to_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_x509_export_to_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_x509_export_to_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_x509_export_to_file(arg0, arg1, arg2));
  }
}
Variant ifa_openssl_x509_export_to_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_x509_export_to_file", count, 2, 3, 1);
  if (count <= 2) return (f_openssl_x509_export_to_file(a0, a1));
  return (f_openssl_x509_export_to_file(a0, a1, a2));
}
Variant i_imagesetstyle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagesetstyle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetstyle", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesetstyle(arg0, arg1));
  }
}
Variant ifa_imagesetstyle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagesetstyle", count, 2, 2, 1);
  return (f_imagesetstyle(a0, a1));
}
Variant i_drawcolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawcolor", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawcolor(arg0, arg1, arg2, arg3), null);
  }
}
Variant ifa_drawcolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("drawcolor", count, 4, 4, 1);
  return (f_drawcolor(a0, a1, a2, a3), null);
}
Variant i_get_headers(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_headers);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("get_headers", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_get_headers(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_get_headers(arg0, arg1));
  }
}
Variant ifa_get_headers(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("get_headers", count, 1, 2, 1);
  if (count <= 1) return (f_get_headers(a0));
  return (f_get_headers(a0, a1));
}
Variant i_mysql_drop_db(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_drop_db);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_drop_db", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_drop_db(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_drop_db(arg0, arg1));
  }
}
Variant ifa_mysql_drop_db(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_drop_db", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_drop_db(a0));
  return (f_mysql_drop_db(a0, a1));
}
Variant i_spl_object_hash(void *extra, CArrRef params) {
  FUNCTION_INJECTION(spl_object_hash);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("spl_object_hash", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_spl_object_hash(arg0));
  }
}
Variant ifa_spl_object_hash(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("spl_object_hash", count, 1, 1, 1);
  return (f_spl_object_hash(a0));
}
Variant i_magickresampleimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickresampleimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickresampleimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickresampleimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_magickresampleimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("magickresampleimage", count, 5, 5, 1);
  return (f_magickresampleimage(a0, a1, a2, a3, a4));
}
Variant i_i18n_loc_get_default(void *extra, CArrRef params) {
  FUNCTION_INJECTION(i18n_loc_get_default);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("i18n_loc_get_default", 0, 1);
  return (f_i18n_loc_get_default());
}
Variant ifa_i18n_loc_get_default(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("i18n_loc_get_default", 0, 1);
  return (f_i18n_loc_get_default());
}
Variant i_strtok(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strtok);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strtok", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_strtok(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strtok(arg0, arg1));
  }
}
Variant ifa_strtok(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("strtok", count, 1, 2, 1);
  if (count <= 1) return (f_strtok(a0));
  return (f_strtok(a0, a1));
}
Variant i_array_key_exists(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_key_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_key_exists", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_key_exists(arg0, arg1));
  }
}
Variant ifa_array_key_exists(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("array_key_exists", count, 2, 2, 1);
  return (f_array_key_exists(a0, a1));
}
Variant i_exp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(exp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exp", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_exp(arg0));
  }
}
Variant ifa_exp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("exp", count, 1, 1, 1);
  return (f_exp(a0));
}
Variant i_strstr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strstr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strstr", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strstr(arg0, arg1));
  }
}
Variant ifa_strstr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("strstr", count, 2, 2, 1);
  return (f_strstr(a0, a1));
}
Variant i_realpath(void *extra, CArrRef params) {
  FUNCTION_INJECTION(realpath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("realpath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_realpath(arg0));
  }
}
Variant ifa_realpath(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("realpath", count, 1, 1, 1);
  return (f_realpath(a0));
}
Variant i_memcache_setoptimeout(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_setoptimeout);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("memcache_setoptimeout", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_setoptimeout(arg0, arg1));
  }
}
Variant ifa_memcache_setoptimeout(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("memcache_setoptimeout", count, 2, 2, 1);
  return (f_memcache_setoptimeout(a0, a1));
}
Variant i_stream_filter_append(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_filter_append);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_filter_append", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_filter_append(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_filter_append(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_filter_append(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_stream_filter_append(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_filter_append", count, 2, 4, 1);
  if (count <= 2) return (f_stream_filter_append(a0, a1));
  if (count == 3) return (f_stream_filter_append(a0, a1, a2));
  return (f_stream_filter_append(a0, a1, a2, a3));
}
Variant i_dom_characterdata_insert_data(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_characterdata_insert_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_insert_data", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_characterdata_insert_data(arg0, arg1, arg2));
  }
}
Variant ifa_dom_characterdata_insert_data(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_characterdata_insert_data", count, 3, 3, 1);
  return (f_dom_characterdata_insert_data(a0, a1, a2));
}
Variant i_hphp_get_property(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_get_property);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_get_property", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_get_property(arg0, arg1, arg2));
  }
}
Variant ifa_hphp_get_property(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("hphp_get_property", count, 3, 3, 1);
  return (f_hphp_get_property(a0, a1, a2));
}
Variant i_dom_characterdata_replace_data(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_characterdata_replace_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_characterdata_replace_data", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_characterdata_replace_data(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_dom_characterdata_replace_data(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("dom_characterdata_replace_data", count, 4, 4, 1);
  return (f_dom_characterdata_replace_data(a0, a1, a2, a3));
}
Variant i_magickgetcharheight(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetcharheight);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetcharheight", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgetcharheight(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetcharheight(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickgetcharheight(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetcharheight", count, 3, 4, 1);
  if (count <= 3) return (f_magickgetcharheight(a0, a1, a2));
  return (f_magickgetcharheight(a0, a1, a2, a3));
}
Variant i_imagerotate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagerotate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("imagerotate", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_imagerotate(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagerotate(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagerotate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("imagerotate", count, 3, 4, 1);
  if (count <= 3) return (f_imagerotate(a0, a1, a2));
  return (f_imagerotate(a0, a1, a2, a3));
}
Variant i_magickcompositeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickcompositeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickcompositeimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcompositeimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_magickcompositeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("magickcompositeimage", count, 5, 5, 1);
  return (f_magickcompositeimage(a0, a1, a2, a3, a4));
}
Variant i_openssl_sign(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_sign);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_sign", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_sign(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_sign(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_sign(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_sign", count, 3, 4, 1);
  if (count <= 3) return (f_openssl_sign(a0, ref(a1), a2));
  return (f_openssl_sign(a0, ref(a1), a2, a3));
}
Variant i_version_compare(void *extra, CArrRef params) {
  FUNCTION_INJECTION(version_compare);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("version_compare", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_version_compare(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_version_compare(arg0, arg1, arg2));
  }
}
Variant ifa_version_compare(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("version_compare", count, 2, 3, 1);
  if (count <= 2) return (f_version_compare(a0, a1));
  return (f_version_compare(a0, a1, a2));
}
Variant i_timezone_name_get(void *extra, CArrRef params) {
  FUNCTION_INJECTION(timezone_name_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_name_get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_timezone_name_get(arg0));
  }
}
Variant ifa_timezone_name_get(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("timezone_name_get", count, 1, 1, 1);
  return (f_timezone_name_get(a0));
}
Variant i_posix_getpgid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getpgid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpgid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getpgid(arg0));
  }
}
Variant ifa_posix_getpgid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_getpgid", count, 1, 1, 1);
  return (f_posix_getpgid(a0));
}
Variant i_dom_node_has_attributes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_has_attributes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_has_attributes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_node_has_attributes(arg0));
  }
}
Variant ifa_dom_node_has_attributes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dom_node_has_attributes", count, 1, 1, 1);
  return (f_dom_node_has_attributes(a0));
}
Variant i_dom_text_is_whitespace_in_element_content(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_text_is_whitespace_in_element_content);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_text_is_whitespace_in_element_content", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_text_is_whitespace_in_element_content(arg0));
  }
}
Variant ifa_dom_text_is_whitespace_in_element_content(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dom_text_is_whitespace_in_element_content", count, 1, 1, 1);
  return (f_dom_text_is_whitespace_in_element_content(a0));
}
Variant i_imagestring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagestring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagestring", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagestring(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imagestring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("imagestring", count, 6, 6, 1);
  return (f_imagestring(a0, a1, a2, a3, a4, a5));
}
Variant i_mcrypt_list_modes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_list_modes);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mcrypt_list_modes", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mcrypt_list_modes());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_list_modes(arg0));
  }
}
Variant ifa_mcrypt_list_modes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mcrypt_list_modes", 1, 1);
  if (count <= 0) return (f_mcrypt_list_modes());
  return (f_mcrypt_list_modes(a0));
}
Variant i_session_unregister(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_unregister);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_unregister", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_unregister(arg0));
  }
}
Variant ifa_session_unregister(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("session_unregister", count, 1, 1, 1);
  return (f_session_unregister(a0));
}
Variant i_mcrypt_list_algorithms(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_list_algorithms);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mcrypt_list_algorithms", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mcrypt_list_algorithms());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_list_algorithms(arg0));
  }
}
Variant ifa_mcrypt_list_algorithms(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mcrypt_list_algorithms", 1, 1);
  if (count <= 0) return (f_mcrypt_list_algorithms());
  return (f_mcrypt_list_algorithms(a0));
}
Variant i_mcrypt_get_cipher_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_get_cipher_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_get_cipher_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_get_cipher_name(arg0));
  }
}
Variant ifa_mcrypt_get_cipher_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_get_cipher_name", count, 1, 1, 1);
  return (f_mcrypt_get_cipher_name(a0));
}
Variant i_idn_to_unicode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(idn_to_unicode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_unicode", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_idn_to_unicode(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_idn_to_unicode(arg0, arg1));
  }
}
Variant ifa_idn_to_unicode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_unicode", count, 1, 2, 1);
  if (count <= 1) return (f_idn_to_unicode(a0));
  return (f_idn_to_unicode(a0, ref(a1)));
}
Variant i_lchown(void *extra, CArrRef params) {
  FUNCTION_INJECTION(lchown);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("lchown", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_lchown(arg0, arg1));
  }
}
Variant ifa_lchown(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("lchown", count, 2, 2, 1);
  return (f_lchown(a0, a1));
}
Variant i_drawcomposite(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawcomposite);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawcomposite", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawcomposite(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant ifa_drawcomposite(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 7) return throw_wrong_arguments("drawcomposite", count, 7, 7, 1);
  return (f_drawcomposite(a0, a1, a2, a3, a4, a5, null));
}
Variant i_dechex(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dechex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dechex", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dechex(arg0));
  }
}
Variant ifa_dechex(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dechex", count, 1, 1, 1);
  return (f_dechex(a0));
}
Variant i_imagecolortransparent(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolortransparent);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagecolortransparent", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagecolortransparent(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolortransparent(arg0, arg1));
  }
}
Variant ifa_imagecolortransparent(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("imagecolortransparent", count, 1, 2, 1);
  if (count <= 1) return (f_imagecolortransparent(a0));
  return (f_imagecolortransparent(a0, a1));
}
Variant i_socket_get_option(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_get_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("socket_get_option", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_get_option(arg0, arg1, arg2));
  }
}
Variant ifa_socket_get_option(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("socket_get_option", count, 3, 3, 1);
  return (f_socket_get_option(a0, a1, a2));
}
Variant i_stream_filter_register(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_filter_register);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_filter_register", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_filter_register(arg0, arg1));
  }
}
Variant ifa_stream_filter_register(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stream_filter_register", count, 2, 2, 1);
  return (f_stream_filter_register(a0, a1));
}
Variant i_apache_response_headers(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apache_response_headers);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_response_headers", 0, 1);
  return (f_apache_response_headers());
}
Variant ifa_apache_response_headers(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("apache_response_headers", 0, 1);
  return (f_apache_response_headers());
}
Variant i_array_merge(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_merge);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_merge", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_merge(count, arg0));
    return (f_array_merge(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_array_merge(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("array_merge", count+1, 1);
  if (count <= 1) return (f_array_merge(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_merge(count,a0, params));
}
Variant i_md5(void *extra, CArrRef params) {
  FUNCTION_INJECTION(md5);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("md5", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_md5(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_md5(arg0, arg1));
  }
}
Variant ifa_md5(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("md5", count, 1, 2, 1);
  if (count <= 1) return (f_md5(a0));
  return (f_md5(a0, a1));
}
Variant i_session_write_close(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_write_close);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_write_close", 0, 1);
  return (f_session_write_close(), null);
}
Variant ifa_session_write_close(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("session_write_close", 0, 1);
  return (f_session_write_close(), null);
}
Variant i_dom_namednodemap_item(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_namednodemap_item);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_namednodemap_item", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_namednodemap_item(arg0, arg1));
  }
}
Variant ifa_dom_namednodemap_item(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_namednodemap_item", count, 2, 2, 1);
  return (f_dom_namednodemap_item(a0, a1));
}
Variant i_bcsub(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bcsub);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcsub", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bcsub(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcsub(arg0, arg1, arg2));
  }
}
Variant ifa_bcsub(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("bcsub", count, 2, 3, 1);
  if (count <= 2) return (f_bcsub(a0, a1));
  return (f_bcsub(a0, a1, a2));
}
Variant i_xmlwriter_flush(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xmlwriter_flush", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_xmlwriter_flush(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_flush(arg0, arg1));
  }
}
Variant ifa_xmlwriter_flush(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("xmlwriter_flush", count, 1, 2, 1);
  if (count <= 1) return (f_xmlwriter_flush(a0));
  return (f_xmlwriter_flush(a0, a1));
}
Variant i_sha1_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sha1_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sha1_file", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_sha1_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_sha1_file(arg0, arg1));
  }
}
Variant ifa_sha1_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("sha1_file", count, 1, 2, 1);
  if (count <= 1) return (f_sha1_file(a0));
  return (f_sha1_file(a0, a1));
}
Variant i_posix_ctermid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_ctermid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_ctermid", 0, 1);
  return (f_posix_ctermid());
}
Variant ifa_posix_ctermid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_ctermid", 0, 1);
  return (f_posix_ctermid());
}
Variant i_date(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("date", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_date(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date(arg0, arg1));
  }
}
Variant ifa_date(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("date", count, 1, 2, 1);
  if (count <= 1) return (f_date(a0));
  return (f_date(a0, a1));
}
Variant i_evhttp_post(void *extra, CArrRef params) {
  FUNCTION_INJECTION(evhttp_post);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("evhttp_post", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_evhttp_post(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_evhttp_post(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_evhttp_post(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_evhttp_post(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("evhttp_post", count, 2, 4, 1);
  if (count <= 2) return (f_evhttp_post(a0, a1));
  if (count == 3) return (f_evhttp_post(a0, a1, a2));
  return (f_evhttp_post(a0, a1, a2, a3));
}
Variant i_ldap_connect(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_connect);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("ldap_connect", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ldap_connect());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_ldap_connect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_connect(arg0, arg1));
  }
}
Variant ifa_ldap_connect(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("ldap_connect", 2, 1);
  if (count <= 0) return (f_ldap_connect());
  if (count == 1) return (f_ldap_connect(a0));
  return (f_ldap_connect(a0, a1));
}
Variant i_shuffle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(shuffle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shuffle", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_shuffle(arg0));
  }
}
Variant ifa_shuffle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("shuffle", count, 1, 1, 1);
  return (f_shuffle(ref(a0)));
}
Variant i_mcrypt_module_get_algo_block_size(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_get_algo_block_size);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_algo_block_size", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_get_algo_block_size(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_get_algo_block_size(arg0, arg1));
  }
}
Variant ifa_mcrypt_module_get_algo_block_size(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_algo_block_size", count, 1, 2, 1);
  if (count <= 1) return (f_mcrypt_module_get_algo_block_size(a0));
  return (f_mcrypt_module_get_algo_block_size(a0, a1));
}
Variant i_hphp_splfileobject_ftruncate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_ftruncate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_ftruncate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_ftruncate(arg0, arg1));
  }
}
Variant ifa_hphp_splfileobject_ftruncate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_ftruncate", count, 2, 2, 1);
  return (f_hphp_splfileobject_ftruncate(a0, a1));
}
Variant i_key(void *extra, CArrRef params) {
  FUNCTION_INJECTION(key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("key", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_key(arg0));
  }
}
Variant ifa_key(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("key", count, 1, 1, 1);
  return (f_key(ref(a0)));
}
Variant i_xmlwriter_start_dtd_entity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_dtd_entity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_start_dtd_entity", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_dtd_entity(arg0, arg1, arg2));
  }
}
Variant ifa_xmlwriter_start_dtd_entity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("xmlwriter_start_dtd_entity", count, 3, 3, 1);
  return (f_xmlwriter_start_dtd_entity(a0, a1, a2));
}
Variant i_readfile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(readfile);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("readfile", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_readfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_readfile(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_readfile(arg0, arg1, arg2));
  }
}
Variant ifa_readfile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("readfile", count, 1, 3, 1);
  if (count <= 1) return (f_readfile(a0));
  if (count == 2) return (f_readfile(a0, a1));
  return (f_readfile(a0, a1, a2));
}
Variant i_atan(void *extra, CArrRef params) {
  FUNCTION_INJECTION(atan);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("atan", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_atan(arg0));
  }
}
Variant ifa_atan(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("atan", count, 1, 1, 1);
  return (f_atan(a0));
}
Variant i_magickmodulateimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickmodulateimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickmodulateimage", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmodulateimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickmodulateimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("magickmodulateimage", count, 4, 4, 1);
  return (f_magickmodulateimage(a0, a1, a2, a3));
}
Variant i_mysql_set_charset(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_set_charset);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_set_charset", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_set_charset(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_set_charset(arg0, arg1));
  }
}
Variant ifa_mysql_set_charset(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_set_charset", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_set_charset(a0));
  return (f_mysql_set_charset(a0, a1));
}
Variant i_fb_unset_taint(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_unset_taint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_unset_taint", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_unset_taint(arg0, arg1), null);
  }
}
Variant ifa_fb_unset_taint(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("fb_unset_taint", count, 2, 2, 1);
  return (f_fb_unset_taint(ref(a0), a1), null);
}
Variant i_dom_document_xinclude(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_xinclude);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_document_xinclude", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dom_document_xinclude(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_xinclude(arg0, arg1));
  }
}
Variant ifa_dom_document_xinclude(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_document_xinclude", count, 1, 2, 1);
  if (count <= 1) return (f_dom_document_xinclude(a0));
  return (f_dom_document_xinclude(a0, a1));
}
Variant i_drawgetfontweight(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetfontweight);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontweight", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfontweight(arg0));
  }
}
Variant ifa_drawgetfontweight(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetfontweight", count, 1, 1, 1);
  return (f_drawgetfontweight(a0));
}
Variant i_magickgetimageheight(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageheight);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageheight", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageheight(arg0));
  }
}
Variant ifa_magickgetimageheight(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimageheight", count, 1, 1, 1);
  return (f_magickgetimageheight(a0));
}
Variant i_posix_getpgrp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getpgrp);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getpgrp", 0, 1);
  return (f_posix_getpgrp());
}
Variant ifa_posix_getpgrp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_getpgrp", 0, 1);
  return (f_posix_getpgrp());
}
Variant i_i18n_loc_get_error_code(void *extra, CArrRef params) {
  FUNCTION_INJECTION(i18n_loc_get_error_code);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("i18n_loc_get_error_code", 0, 1);
  return (f_i18n_loc_get_error_code());
}
Variant ifa_i18n_loc_get_error_code(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("i18n_loc_get_error_code", 0, 1);
  return (f_i18n_loc_get_error_code());
}
Variant i_hash_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hash_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_hash_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_file(arg0, arg1, arg2));
  }
}
Variant ifa_hash_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_file", count, 2, 3, 1);
  if (count <= 2) return (f_hash_file(a0, a1));
  return (f_hash_file(a0, a1, a2));
}
Variant i_is_callable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_callable);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("is_callable", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_is_callable(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_is_callable(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_is_callable(arg0, arg1, arg2));
  }
}
Variant ifa_is_callable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("is_callable", count, 1, 3, 1);
  if (count <= 1) return (f_is_callable(a0));
  if (count == 2) return (f_is_callable(a0, a1));
  return (f_is_callable(a0, a1, ref(a2)));
}
Variant i_asin(void *extra, CArrRef params) {
  FUNCTION_INJECTION(asin);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("asin", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_asin(arg0));
  }
}
Variant ifa_asin(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("asin", count, 1, 1, 1);
  return (f_asin(a0));
}
Variant i_openssl_public_encrypt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_public_encrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_public_encrypt", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_public_encrypt(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_public_encrypt(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_public_encrypt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_public_encrypt", count, 3, 4, 1);
  if (count <= 3) return (f_openssl_public_encrypt(a0, ref(a1), a2));
  return (f_openssl_public_encrypt(a0, ref(a1), a2, a3));
}
Variant i_curl_multi_init(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_multi_init);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("curl_multi_init", 0, 1);
  return (f_curl_multi_init());
}
Variant ifa_curl_multi_init(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("curl_multi_init", 0, 1);
  return (f_curl_multi_init());
}
Variant i_posix_getpwuid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getpwuid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpwuid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getpwuid(arg0));
  }
}
Variant ifa_posix_getpwuid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_getpwuid", count, 1, 1, 1);
  return (f_posix_getpwuid(a0));
}
Variant i_json_encode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(json_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("json_encode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_json_encode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_json_encode(arg0, arg1));
  }
}
Variant ifa_json_encode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("json_encode", count, 1, 2, 1);
  if (count <= 1) return (f_json_encode(a0));
  return (f_json_encode(a0, a1));
}
Variant i_show_source(void *extra, CArrRef params) {
  FUNCTION_INJECTION(show_source);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("show_source", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_show_source(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_show_source(arg0, arg1));
  }
}
Variant ifa_show_source(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("show_source", count, 1, 2, 1);
  if (count <= 1) return (f_show_source(a0));
  return (f_show_source(a0, a1));
}
Variant i_mcrypt_module_self_test(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_self_test);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_self_test", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_self_test(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_self_test(arg0, arg1));
  }
}
Variant ifa_mcrypt_module_self_test(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_self_test", count, 1, 2, 1);
  if (count <= 1) return (f_mcrypt_module_self_test(a0));
  return (f_mcrypt_module_self_test(a0, a1));
}
Variant i_sscanf(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sscanf);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("sscanf", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_sscanf(count, arg0, arg1));
    return (f_sscanf(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_sscanf(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("sscanf", count+1, 1);
  if (count <= 2) return (f_sscanf(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_sscanf(count,a0, a1, params));
}
Variant i_chop(void *extra, CArrRef params) {
  FUNCTION_INJECTION(chop);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("chop", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_chop(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_chop(arg0, arg1));
  }
}
Variant ifa_chop(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("chop", count, 1, 2, 1);
  if (count <= 1) return (f_chop(a0));
  return (f_chop(a0, a1));
}
Variant i_mb_convert_variables(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_convert_variables);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("mb_convert_variables", count+1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mb_convert_variables(count, arg0, arg1, arg2));
    return (f_mb_convert_variables(count,arg0, arg1, ref(arg2), params.slice(3, count - 3, false)));
  }
}
Variant ifa_mb_convert_variables(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3) return throw_missing_arguments("mb_convert_variables", count+1, 1);
  if (count <= 3) return (f_mb_convert_variables(count, a0, a1, ref(a2)));
  Array params;
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_mb_convert_variables(count,a0, a1, ref(a2), params));
}
Variant i_hphp_recursivedirectoryiterator_getsubpathname(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_getsubpathname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getsubpathname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_getsubpathname(arg0));
  }
}
Variant ifa_hphp_recursivedirectoryiterator_getsubpathname(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getsubpathname", count, 1, 1, 1);
  return (f_hphp_recursivedirectoryiterator_getsubpathname(a0));
}
Variant i_socket_close(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_close(arg0), null);
  }
}
Variant ifa_socket_close(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("socket_close", count, 1, 1, 1);
  return (f_socket_close(a0), null);
}
Variant i_max(void *extra, CArrRef params) {
  FUNCTION_INJECTION(max);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("max", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_max(count, arg0));
    return (f_max(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_max(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("max", count+1, 1);
  if (count <= 1) return (f_max(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_max(count,a0, params));
}
Variant i_magickadaptivethresholdimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickadaptivethresholdimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickadaptivethresholdimage", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickadaptivethresholdimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickadaptivethresholdimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("magickadaptivethresholdimage", count, 4, 4, 1);
  return (f_magickadaptivethresholdimage(a0, a1, a2, a3));
}
Variant i_each(void *extra, CArrRef params) {
  FUNCTION_INJECTION(each);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("each", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_each(arg0));
  }
}
Variant ifa_each(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("each", count, 1, 1, 1);
  return (f_each(ref(a0)));
}
Variant i_magickremoveimageprofiles(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickremoveimageprofiles);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickremoveimageprofiles", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickremoveimageprofiles(arg0));
  }
}
Variant ifa_magickremoveimageprofiles(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickremoveimageprofiles", count, 1, 1, 1);
  return (f_magickremoveimageprofiles(a0));
}
Variant i_drawgettextalignment(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgettextalignment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextalignment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgettextalignment(arg0));
  }
}
Variant ifa_drawgettextalignment(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgettextalignment", count, 1, 1, 1);
  return (f_drawgettextalignment(a0));
}
Variant i_xbox_send_message(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xbox_send_message);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("xbox_send_message", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_xbox_send_message(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xbox_send_message(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_xbox_send_message(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("xbox_send_message", count, 3, 4, 1);
  if (count <= 3) return (f_xbox_send_message(a0, ref(a1), a2));
  return (f_xbox_send_message(a0, ref(a1), a2, a3));
}
Variant i_thrift_protocol_write_binary(void *extra, CArrRef params) {
  FUNCTION_INJECTION(thrift_protocol_write_binary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("thrift_protocol_write_binary", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_thrift_protocol_write_binary(arg0, arg1, arg2, arg3, arg4, arg5), null);
  }
}
Variant ifa_thrift_protocol_write_binary(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("thrift_protocol_write_binary", count, 6, 6, 1);
  return (f_thrift_protocol_write_binary(a0, a1, a2, a3, a4, a5), null);
}
Variant i_wandgetexceptiontype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(wandgetexceptiontype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexceptiontype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_wandgetexceptiontype(arg0));
  }
}
Variant ifa_wandgetexceptiontype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("wandgetexceptiontype", count, 1, 1, 1);
  return (f_wandgetexceptiontype(a0));
}
Variant i_drawpathellipticarcabsolute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathellipticarcabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("drawpathellipticarcabsolute", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathellipticarcabsolute(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7), null);
  }
}
Variant ifa_drawpathellipticarcabsolute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 8) return throw_wrong_arguments("drawpathellipticarcabsolute", count, 8, 8, 1);
  return (f_drawpathellipticarcabsolute(a0, a1, a2, a3, a4, a5, null, null), null);
}
Variant i_pixelsetgreen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetgreen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetgreen", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetgreen(arg0, arg1), null);
  }
}
Variant ifa_pixelsetgreen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetgreen", count, 2, 2, 1);
  return (f_pixelsetgreen(a0, a1), null);
}
Variant i_magickgetimagecolorspace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecolorspace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecolorspace", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagecolorspace(arg0));
  }
}
Variant ifa_magickgetimagecolorspace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagecolorspace", count, 1, 1, 1);
  return (f_magickgetimagecolorspace(a0));
}
Variant i_pixelsetalphaquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetalphaquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetalphaquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetalphaquantum(arg0, arg1), null);
  }
}
Variant ifa_pixelsetalphaquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetalphaquantum", count, 2, 2, 1);
  return (f_pixelsetalphaquantum(a0, a1), null);
}
Variant i_stream_bucket_append(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_bucket_append);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_append", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_bucket_append(arg0, arg1), null);
  }
}
Variant ifa_stream_bucket_append(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stream_bucket_append", count, 2, 2, 1);
  return (f_stream_bucket_append(a0, a1), null);
}
Variant i_msg_stat_queue(void *extra, CArrRef params) {
  FUNCTION_INJECTION(msg_stat_queue);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("msg_stat_queue", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_msg_stat_queue(arg0));
  }
}
Variant ifa_msg_stat_queue(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("msg_stat_queue", count, 1, 1, 1);
  return (f_msg_stat_queue(a0));
}
Variant i_system(void *extra, CArrRef params) {
  FUNCTION_INJECTION(system);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("system", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_system(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_system(arg0, arg1));
  }
}
Variant ifa_system(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("system", count, 1, 2, 1);
  if (count <= 1) return (f_system(a0));
  return (f_system(a0, ref(a1)));
}
Variant i_mb_parse_str(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_parse_str);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_parse_str", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_parse_str(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_mb_parse_str(arg0, arg1));
  }
}
Variant ifa_mb_parse_str(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_parse_str", count, 1, 2, 1);
  if (count <= 1) return (f_mb_parse_str(a0));
  return (f_mb_parse_str(a0, ref(a1)));
}
Variant i_dom_characterdata_append_data(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_characterdata_append_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_characterdata_append_data", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_characterdata_append_data(arg0, arg1));
  }
}
Variant ifa_dom_characterdata_append_data(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_characterdata_append_data", count, 2, 2, 1);
  return (f_dom_characterdata_append_data(a0, a1));
}
Variant i_log(void *extra, CArrRef params) {
  FUNCTION_INJECTION(log);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("log", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_log(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_log(arg0, arg1));
  }
}
Variant ifa_log(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("log", count, 1, 2, 1);
  if (count <= 1) return (f_log(a0));
  return (f_log(a0, a1));
}
Variant i_memcache_decrement(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_decrement);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_decrement", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_decrement(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_decrement(arg0, arg1, arg2));
  }
}
Variant ifa_memcache_decrement(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_decrement", count, 2, 3, 1);
  if (count <= 2) return (f_memcache_decrement(a0, a1));
  return (f_memcache_decrement(a0, a1, a2));
}
Variant i_drawskewx(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawskewx);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawskewx", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawskewx(arg0, arg1), null);
  }
}
Variant ifa_drawskewx(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawskewx", count, 2, 2, 1);
  return (f_drawskewx(a0, a1), null);
}
Variant i_min(void *extra, CArrRef params) {
  FUNCTION_INJECTION(min);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("min", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_min(count, arg0));
    return (f_min(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_min(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("min", count+1, 1);
  if (count <= 1) return (f_min(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_min(count,a0, params));
}
Variant i_curl_multi_getcontent(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_multi_getcontent);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_multi_getcontent", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_multi_getcontent(arg0));
  }
}
Variant ifa_curl_multi_getcontent(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("curl_multi_getcontent", count, 1, 1, 1);
  return (f_curl_multi_getcontent(a0));
}
Variant i_drawskewy(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawskewy);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawskewy", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawskewy(arg0, arg1), null);
  }
}
Variant ifa_drawskewy(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawskewy", count, 2, 2, 1);
  return (f_drawskewy(a0, a1), null);
}
Variant i_is_uploaded_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_uploaded_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_uploaded_file", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_uploaded_file(arg0));
  }
}
Variant ifa_is_uploaded_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_uploaded_file", count, 1, 1, 1);
  return (f_is_uploaded_file(a0));
}
Variant i_magicksetresourcelimit(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetresourcelimit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetresourcelimit", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetresourcelimit(arg0, arg1));
  }
}
Variant ifa_magicksetresourcelimit(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetresourcelimit", count, 2, 2, 1);
  return (f_magicksetresourcelimit(a0, a1));
}
Variant i_date_timezone_get(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_timezone_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_timezone_get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_date_timezone_get(arg0));
  }
}
Variant ifa_date_timezone_get(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("date_timezone_get", count, 1, 1, 1);
  return (f_date_timezone_get(a0));
}
Variant i_hphp_splfileobject_fwrite(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fwrite);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_splfileobject_fwrite", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_fwrite(arg0, arg1, arg2));
  }
}
Variant ifa_hphp_splfileobject_fwrite(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("hphp_splfileobject_fwrite", count, 3, 3, 1);
  return (f_hphp_splfileobject_fwrite(a0, a1, a2));
}
Variant i_apache_get_rewrite_rules(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apache_get_rewrite_rules);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_rewrite_rules", 0, 1);
  return (f_apache_get_rewrite_rules());
}
Variant ifa_apache_get_rewrite_rules(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("apache_get_rewrite_rules", 0, 1);
  return (f_apache_get_rewrite_rules());
}
Variant i_is_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_string", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_string(arg0));
  }
}
Variant ifa_is_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_string", count, 1, 1, 1);
  return (f_is_string(a0));
}
Variant i_pcntl_wtermsig(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_wtermsig);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wtermsig", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wtermsig(arg0));
  }
}
Variant ifa_pcntl_wtermsig(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pcntl_wtermsig", count, 1, 1, 1);
  return (f_pcntl_wtermsig(a0));
}
Variant i_stream_context_get_default(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_context_get_default);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("stream_context_get_default", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_stream_context_get_default());
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_context_get_default(arg0));
  }
}
Variant ifa_stream_context_get_default(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("stream_context_get_default", 1, 1);
  if (count <= 0) return (f_stream_context_get_default());
  return (f_stream_context_get_default(a0));
}
Variant i_drawpathlinetorelative(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetorelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathlinetorelative", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetorelative(arg0, arg1, arg2), null);
  }
}
Variant ifa_drawpathlinetorelative(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("drawpathlinetorelative", count, 3, 3, 1);
  return (f_drawpathlinetorelative(a0, a1, a2), null);
}
Variant i_urlencode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(urlencode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("urlencode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_urlencode(arg0));
  }
}
Variant ifa_urlencode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("urlencode", count, 1, 1, 1);
  return (f_urlencode(a0));
}
Variant i_mb_preferred_mime_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_preferred_mime_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_preferred_mime_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_preferred_mime_name(arg0));
  }
}
Variant ifa_mb_preferred_mime_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mb_preferred_mime_name", count, 1, 1, 1);
  return (f_mb_preferred_mime_name(a0));
}
Variant i_pixelgetgreenquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetgreenquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetgreenquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetgreenquantum(arg0));
  }
}
Variant ifa_pixelgetgreenquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetgreenquantum", count, 1, 1, 1);
  return (f_pixelgetgreenquantum(a0));
}
Variant i_magicksetfilename(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetfilename);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magicksetfilename", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magicksetfilename(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetfilename(arg0, arg1));
  }
}
Variant ifa_magicksetfilename(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("magicksetfilename", count, 1, 2, 1);
  if (count <= 1) return (f_magicksetfilename(a0));
  return (f_magicksetfilename(a0, a1));
}
Variant i_magickappendimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickappendimages);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickappendimages", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magickappendimages(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickappendimages(arg0, arg1));
  }
}
Variant ifa_magickappendimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("magickappendimages", count, 1, 2, 1);
  if (count <= 1) return (f_magickappendimages(a0));
  return (f_magickappendimages(a0, a1));
}
Variant i_pcntl_wifstopped(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_wifstopped);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifstopped", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wifstopped(arg0));
  }
}
Variant ifa_pcntl_wifstopped(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pcntl_wifstopped", count, 1, 1, 1);
  return (f_pcntl_wifstopped(a0));
}
Variant i_mb_ereg_search(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_ereg_search());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mb_ereg_search(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_search(arg0, arg1));
  }
}
Variant ifa_mb_ereg_search(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("mb_ereg_search", 2, 1);
  if (count <= 0) return (f_mb_ereg_search());
  if (count == 1) return (f_mb_ereg_search(a0));
  return (f_mb_ereg_search(a0, a1));
}
Variant i_rewind(void *extra, CArrRef params) {
  FUNCTION_INJECTION(rewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_rewind(arg0));
  }
}
Variant ifa_rewind(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("rewind", count, 1, 1, 1);
  return (f_rewind(a0));
}
Variant i_chunk_split(void *extra, CArrRef params) {
  FUNCTION_INJECTION(chunk_split);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("chunk_split", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_chunk_split(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_chunk_split(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_chunk_split(arg0, arg1, arg2));
  }
}
Variant ifa_chunk_split(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("chunk_split", count, 1, 3, 1);
  if (count <= 1) return (f_chunk_split(a0));
  if (count == 2) return (f_chunk_split(a0, a1));
  return (f_chunk_split(a0, a1, a2));
}
Variant i_mb_list_encodings_alias_names(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_list_encodings_alias_names);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_list_encodings_alias_names", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_list_encodings_alias_names());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_list_encodings_alias_names(arg0));
  }
}
Variant ifa_mb_list_encodings_alias_names(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mb_list_encodings_alias_names", 1, 1);
  if (count <= 0) return (f_mb_list_encodings_alias_names());
  return (f_mb_list_encodings_alias_names(a0));
}
Variant i_i18n_loc_set_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(i18n_loc_set_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("i18n_loc_set_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_i18n_loc_set_attribute(arg0, arg1));
  }
}
Variant ifa_i18n_loc_set_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("i18n_loc_set_attribute", count, 2, 2, 1);
  return (f_i18n_loc_set_attribute(a0, a1));
}
Variant i_pixelsynciterator(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsynciterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelsynciterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelsynciterator(arg0));
  }
}
Variant ifa_pixelsynciterator(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelsynciterator", count, 1, 1, 1);
  return (f_pixelsynciterator(a0));
}
Variant i_openssl_error_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_error_string);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("openssl_error_string", 0, 1);
  return (f_openssl_error_string());
}
Variant ifa_openssl_error_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("openssl_error_string", 0, 1);
  return (f_openssl_error_string());
}
Variant i_ismagickwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ismagickwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ismagickwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ismagickwand(arg0));
  }
}
Variant ifa_ismagickwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ismagickwand", count, 1, 1, 1);
  return (f_ismagickwand(a0));
}
Variant i_dom_element_has_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_has_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_has_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_has_attribute(arg0, arg1));
  }
}
Variant ifa_dom_element_has_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_element_has_attribute", count, 2, 2, 1);
  return (f_dom_element_has_attribute(a0, a1));
}
Variant i_strrchr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strrchr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strrchr", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strrchr(arg0, arg1));
  }
}
Variant ifa_strrchr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("strrchr", count, 2, 2, 1);
  return (f_strrchr(a0, a1));
}
Variant i_xmlwriter_start_dtd_element(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_dtd_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_dtd_element", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_dtd_element(arg0, arg1));
  }
}
Variant ifa_xmlwriter_start_dtd_element(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_dtd_element", count, 2, 2, 1);
  return (f_xmlwriter_start_dtd_element(a0, a1));
}
Variant i_str_ireplace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(str_ireplace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("str_ireplace", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_str_ireplace(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_str_ireplace(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_str_ireplace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("str_ireplace", count, 3, 4, 1);
  if (count <= 3) return (f_str_ireplace(a0, a1, a2));
  return (f_str_ireplace(a0, a1, a2, ref(a3)));
}
Variant i_magickpainttransparentimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickpainttransparentimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("magickpainttransparentimage", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickpainttransparentimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_magickpainttransparentimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickpainttransparentimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickpainttransparentimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("magickpainttransparentimage", count, 2, 4, 1);
  if (count <= 2) return (f_magickpainttransparentimage(a0, a1));
  if (count == 3) return (f_magickpainttransparentimage(a0, a1, a2));
  return (f_magickpainttransparentimage(a0, a1, a2, a3));
}
Variant i_drawsettextundercolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsettextundercolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextundercolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsettextundercolor(arg0, arg1), null);
  }
}
Variant ifa_drawsettextundercolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsettextundercolor", count, 2, 2, 1);
  return (f_drawsettextundercolor(a0, a1), null);
}
Variant i_memcache_get_version(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_get_version);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_get_version", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_memcache_get_version(arg0));
  }
}
Variant ifa_memcache_get_version(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("memcache_get_version", count, 1, 1, 1);
  return (f_memcache_get_version(a0));
}
Variant i_hphp_splfileobject_getflags(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_getflags);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getflags", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_getflags(arg0));
  }
}
Variant ifa_hphp_splfileobject_getflags(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getflags", count, 1, 1, 1);
  return (f_hphp_splfileobject_getflags(a0));
}
Variant i_hphp_recursivedirectoryiterator_rewind(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_rewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_rewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_rewind(arg0), null);
  }
}
Variant ifa_hphp_recursivedirectoryiterator_rewind(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_rewind", count, 1, 1, 1);
  return (f_hphp_recursivedirectoryiterator_rewind(a0), null);
}
Variant i_magickgetstringwidth(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetstringwidth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetstringwidth", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgetstringwidth(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetstringwidth(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickgetstringwidth(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetstringwidth", count, 3, 4, 1);
  if (count <= 3) return (f_magickgetstringwidth(a0, a1, a2));
  return (f_magickgetstringwidth(a0, a1, a2, a3));
}
Variant i_echo(void *extra, CArrRef params) {
  FUNCTION_INJECTION(echo);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("echo", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_echo(count, arg0), null);
    return (f_echo(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant ifa_echo(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("echo", count+1, 1);
  if (count <= 1) return (f_echo(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_echo(count,a0, params), null);
}
Variant i_ldap_parse_reference(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_parse_reference);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_parse_reference", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_ldap_parse_reference(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_parse_reference(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ldap_parse_reference", count, 3, 3, 1);
  return (f_ldap_parse_reference(a0, a1, ref(a2)));
}
Variant i_ctype_xdigit(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ctype_xdigit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_xdigit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_xdigit(arg0));
  }
}
Variant ifa_ctype_xdigit(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ctype_xdigit", count, 1, 1, 1);
  return (f_ctype_xdigit(a0));
}
Variant i_gmstrftime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gmstrftime);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gmstrftime", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gmstrftime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gmstrftime(arg0, arg1));
  }
}
Variant ifa_gmstrftime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("gmstrftime", count, 1, 2, 1);
  if (count <= 1) return (f_gmstrftime(a0));
  return (f_gmstrftime(a0, a1));
}
Variant i_hphp_recursiveiteratoriterator_next(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_next);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_next", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_next(arg0), null);
  }
}
Variant ifa_hphp_recursiveiteratoriterator_next(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_next", count, 1, 1, 1);
  return (f_hphp_recursiveiteratoriterator_next(a0), null);
}
Variant i_stream_socket_get_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_socket_get_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_socket_get_name", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_get_name(arg0, arg1));
  }
}
Variant ifa_stream_socket_get_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stream_socket_get_name", count, 2, 2, 1);
  return (f_stream_socket_get_name(a0, a1));
}
Variant i_socket_set_option(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_set_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_set_option", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_set_option(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_socket_set_option(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("socket_set_option", count, 4, 4, 1);
  return (f_socket_set_option(a0, a1, a2, a3));
}
Variant i_array_multisort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_multisort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_multisort", count+1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_array_multisort(count, arg0));
    return (f_array_multisort(count,ref(arg0), params.slice(1, count - 1, false)));
  }
}
Variant ifa_array_multisort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("array_multisort", count+1, 1);
  if (count <= 1) return (f_array_multisort(count, ref(a0)));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_multisort(count,ref(a0), params));
}
Variant i_imagepsbbox(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagepsbbox);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("imagepsbbox", count, 3, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_imagepsbbox(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_imagepsbbox(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_imagepsbbox(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepsbbox(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imagepsbbox(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 6) return throw_wrong_arguments("imagepsbbox", count, 3, 6, 1);
  if (count <= 3) return (f_imagepsbbox(a0, a1, a2));
  if (count == 4) return (f_imagepsbbox(a0, a1, a2, a3));
  if (count == 5) return (f_imagepsbbox(a0, a1, a2, a3, a4));
  return (f_imagepsbbox(a0, a1, a2, a3, a4, a5));
}
Variant i_drawpathlinetoverticalabsolute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetoverticalabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetoverticalabsolute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetoverticalabsolute(arg0, arg1), null);
  }
}
Variant ifa_drawpathlinetoverticalabsolute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawpathlinetoverticalabsolute", count, 2, 2, 1);
  return (f_drawpathlinetoverticalabsolute(a0, a1), null);
}
Variant i_mailparse_msg_get_structure(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_get_structure);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_get_structure", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_msg_get_structure(arg0));
  }
}
Variant ifa_mailparse_msg_get_structure(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mailparse_msg_get_structure", count, 1, 1, 1);
  return (f_mailparse_msg_get_structure(a0));
}
Variant i_mb_ereg(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_ereg);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_ereg", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_ereg(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_mb_ereg(arg0, arg1, arg2));
  }
}
Variant ifa_mb_ereg(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_ereg", count, 2, 3, 1);
  if (count <= 2) return (f_mb_ereg(a0, a1));
  return (f_mb_ereg(a0, a1, ref(a2)));
}
Variant i_decoct(void *extra, CArrRef params) {
  FUNCTION_INJECTION(decoct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("decoct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_decoct(arg0));
  }
}
Variant ifa_decoct(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("decoct", count, 1, 1, 1);
  return (f_decoct(a0));
}
Variant i_xml_parse(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_parse);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("xml_parse", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_xml_parse(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_parse(arg0, arg1, arg2));
  }
}
Variant ifa_xml_parse(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("xml_parse", count, 2, 3, 1);
  if (count <= 2) return (f_xml_parse(a0, a1));
  return (f_xml_parse(a0, a1, a2));
}
Variant i_xml_get_current_line_number(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_get_current_line_number);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_line_number", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_get_current_line_number(arg0));
  }
}
Variant ifa_xml_get_current_line_number(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xml_get_current_line_number", count, 1, 1, 1);
  return (f_xml_get_current_line_number(a0));
}
Variant i_drawaffine(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawaffine);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawaffine", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawaffine(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant ifa_drawaffine(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 7) return throw_wrong_arguments("drawaffine", count, 7, 7, 1);
  return (f_drawaffine(a0, a1, a2, a3, a4, a5, null), null);
}
Variant i_session_destroy(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_destroy);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_destroy", 0, 1);
  return (f_session_destroy());
}
Variant ifa_session_destroy(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("session_destroy", 0, 1);
  return (f_session_destroy());
}
Variant i_magicksetimagewhitepoint(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagewhitepoint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagewhitepoint", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagewhitepoint(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetimagewhitepoint(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksetimagewhitepoint", count, 3, 3, 1);
  return (f_magicksetimagewhitepoint(a0, a1, a2));
}
Variant i_dom_document_get_elements_by_tag_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_get_elements_by_tag_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_get_elements_by_tag_name", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_get_elements_by_tag_name(arg0, arg1));
  }
}
Variant ifa_dom_document_get_elements_by_tag_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_get_elements_by_tag_name", count, 2, 2, 1);
  return (f_dom_document_get_elements_by_tag_name(a0, a1));
}
Variant i_gzclose(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzclose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzclose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzclose(arg0));
  }
}
Variant ifa_gzclose(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("gzclose", count, 1, 1, 1);
  return (f_gzclose(a0));
}
Variant i_imagecolorat(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagecolorat", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorat(arg0, arg1, arg2));
  }
}
Variant ifa_imagecolorat(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("imagecolorat", count, 3, 3, 1);
  return (f_imagecolorat(a0, a1, a2));
}
Variant i_magickgetimageextrema(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageextrema);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickgetimageextrema", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magickgetimageextrema(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimageextrema(arg0, arg1));
  }
}
Variant ifa_magickgetimageextrema(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("magickgetimageextrema", count, 1, 2, 1);
  if (count <= 1) return (f_magickgetimageextrema(a0));
  return (f_magickgetimageextrema(a0, a1));
}
Variant i_dom_node_insert_before(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_insert_before);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_node_insert_before", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_node_insert_before(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_insert_before(arg0, arg1, arg2));
  }
}
Variant ifa_dom_node_insert_before(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_node_insert_before", count, 2, 3, 1);
  if (count <= 2) return (f_dom_node_insert_before(a0, a1));
  return (f_dom_node_insert_before(a0, a1, a2));
}
Variant i_ord(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ord);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ord", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ord(arg0));
  }
}
Variant ifa_ord(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ord", count, 1, 1, 1);
  return (f_ord(a0));
}
Variant i_mktime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mktime);
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("mktime", 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mktime());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mktime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mktime(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mktime(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mktime(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_mktime(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mktime(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_mktime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 6) return throw_toomany_arguments("mktime", 6, 1);
  if (count <= 0) return (f_mktime());
  if (count == 1) return (f_mktime(a0));
  if (count == 2) return (f_mktime(a0, a1));
  if (count == 3) return (f_mktime(a0, a1, a2));
  if (count == 4) return (f_mktime(a0, a1, a2, a3));
  if (count == 5) return (f_mktime(a0, a1, a2, a3, a4));
  return (f_mktime(a0, a1, a2, a3, a4, a5));
}
Variant i_sem_get(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sem_get);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("sem_get", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_sem_get(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_sem_get(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_sem_get(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_sem_get(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_sem_get(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("sem_get", count, 1, 4, 1);
  if (count <= 1) return (f_sem_get(a0));
  if (count == 2) return (f_sem_get(a0, a1));
  if (count == 3) return (f_sem_get(a0, a1, a2));
  return (f_sem_get(a0, a1, a2, a3));
}
Variant i_drawsetstrokelinejoin(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokelinejoin);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokelinejoin", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokelinejoin(arg0, arg1), null);
  }
}
Variant ifa_drawsetstrokelinejoin(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetstrokelinejoin", count, 2, 2, 1);
  return (f_drawsetstrokelinejoin(a0, a1), null);
}
Variant i_array_intersect(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_intersect);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_intersect(count, arg0, arg1));
    return (f_array_intersect(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_array_intersect(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("array_intersect", count+1, 1);
  if (count <= 2) return (f_array_intersect(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_intersect(count,a0, a1, params));
}
Variant i_mailparse_msg_extract_whole_part_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_extract_whole_part_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_whole_part_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mailparse_msg_extract_whole_part_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_msg_extract_whole_part_file(arg0, arg1, arg2));
  }
}
Variant ifa_mailparse_msg_extract_whole_part_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_whole_part_file", count, 2, 3, 1);
  if (count <= 2) return (f_mailparse_msg_extract_whole_part_file(a0, a1));
  return (f_mailparse_msg_extract_whole_part_file(a0, a1, a2));
}
Variant i_mb_strrichr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strrichr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrichr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strrichr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strrichr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strrichr(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_strrichr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrichr", count, 2, 4, 1);
  if (count <= 2) return (f_mb_strrichr(a0, a1));
  if (count == 3) return (f_mb_strrichr(a0, a1, a2));
  return (f_mb_strrichr(a0, a1, a2, a3));
}
Variant i_socket_sendto(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_sendto);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("socket_sendto", count, 5, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_socket_sendto(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_sendto(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_socket_sendto(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 5 || count > 6) return throw_wrong_arguments("socket_sendto", count, 5, 6, 1);
  if (count <= 5) return (f_socket_sendto(a0, a1, a2, a3, a4));
  return (f_socket_sendto(a0, a1, a2, a3, a4, a5));
}
Variant i_memcache_flush(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("memcache_flush", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_memcache_flush(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_flush(arg0, arg1));
  }
}
Variant ifa_memcache_flush(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("memcache_flush", count, 1, 2, 1);
  if (count <= 1) return (f_memcache_flush(a0));
  return (f_memcache_flush(a0, a1));
}
Variant i_mb_output_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_output_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mb_output_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_output_handler(arg0, arg1));
  }
}
Variant ifa_mb_output_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("mb_output_handler", count, 2, 2, 1);
  return (f_mb_output_handler(a0, a1));
}
Variant i_fclose(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fclose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fclose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fclose(arg0));
  }
}
Variant ifa_fclose(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fclose", count, 1, 1, 1);
  return (f_fclose(a0));
}
Variant i_drawpathcurvetoquadraticbeziersmoothabsolute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetoquadraticbeziersmoothabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathcurvetoquadraticbeziersmoothabsolute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetoquadraticbeziersmoothabsolute(arg0, arg1, arg2), null);
  }
}
Variant ifa_drawpathcurvetoquadraticbeziersmoothabsolute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("drawpathcurvetoquadraticbeziersmoothabsolute", count, 3, 3, 1);
  return (f_drawpathcurvetoquadraticbeziersmoothabsolute(a0, a1, a2), null);
}
Variant i_function_exists(void *extra, CArrRef params) {
  FUNCTION_INJECTION(function_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("function_exists", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_function_exists(arg0));
  }
}
Variant ifa_function_exists(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("function_exists", count, 1, 1, 1);
  return (f_function_exists(a0));
}
Variant i_ctype_alpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ctype_alpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_alpha", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_alpha(arg0));
  }
}
Variant ifa_ctype_alpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ctype_alpha", count, 1, 1, 1);
  return (f_ctype_alpha(a0));
}
Variant i_pos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pos);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pos", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_pos(arg0));
  }
}
Variant ifa_pos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pos", count, 1, 1, 1);
  return (f_pos(ref(a0)));
}
Variant i_pagelet_server_is_enabled(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pagelet_server_is_enabled);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pagelet_server_is_enabled", 0, 1);
  return (f_pagelet_server_is_enabled());
}
Variant ifa_pagelet_server_is_enabled(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("pagelet_server_is_enabled", 0, 1);
  return (f_pagelet_server_is_enabled());
}
Variant i_xbox_get_thread_timeout(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xbox_get_thread_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_get_thread_timeout", 0, 1);
  return (f_xbox_get_thread_timeout());
}
Variant ifa_xbox_get_thread_timeout(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("xbox_get_thread_timeout", 0, 1);
  return (f_xbox_get_thread_timeout());
}
Variant i_imagecolorexactalpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorexactalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorexactalpha", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorexactalpha(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_imagecolorexactalpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("imagecolorexactalpha", count, 5, 5, 1);
  return (f_imagecolorexactalpha(a0, a1, a2, a3, a4));
}
Variant i_pow(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pow);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pow", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pow(arg0, arg1));
  }
}
Variant ifa_pow(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pow", count, 2, 2, 1);
  return (f_pow(a0, a1));
}
Variant i_pixelgetredquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetredquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetredquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetredquantum(arg0));
  }
}
Variant ifa_pixelgetredquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetredquantum", count, 1, 1, 1);
  return (f_pixelgetredquantum(a0));
}
Variant i_imagecolorsforindex(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorsforindex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolorsforindex", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorsforindex(arg0, arg1));
  }
}
Variant ifa_imagecolorsforindex(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagecolorsforindex", count, 2, 2, 1);
  return (f_imagecolorsforindex(a0, a1));
}
Variant i_libxml_set_streams_context(void *extra, CArrRef params) {
  FUNCTION_INJECTION(libxml_set_streams_context);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("libxml_set_streams_context", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_libxml_set_streams_context(arg0), null);
  }
}
Variant ifa_libxml_set_streams_context(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("libxml_set_streams_context", count, 1, 1, 1);
  return (f_libxml_set_streams_context(a0), null);
}
Variant i_dom_node_clone_node(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_clone_node);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_node_clone_node", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dom_node_clone_node(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_clone_node(arg0, arg1));
  }
}
Variant ifa_dom_node_clone_node(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_node_clone_node", count, 1, 2, 1);
  if (count <= 1) return (f_dom_node_clone_node(a0));
  return (f_dom_node_clone_node(a0, a1));
}
Variant i_image_type_to_mime_type(void *extra, CArrRef params) {
  FUNCTION_INJECTION(image_type_to_mime_type);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("image_type_to_mime_type", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_image_type_to_mime_type(arg0));
  }
}
Variant ifa_image_type_to_mime_type(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("image_type_to_mime_type", count, 1, 1, 1);
  return (f_image_type_to_mime_type(a0));
}
Variant i_socket_create(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_create);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("socket_create", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_create(arg0, arg1, arg2));
  }
}
Variant ifa_socket_create(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("socket_create", count, 3, 3, 1);
  return (f_socket_create(a0, a1, a2));
}
Variant i_xmlwriter_write_pi(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_pi);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_pi", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_pi(arg0, arg1, arg2));
  }
}
Variant ifa_xmlwriter_write_pi(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_pi", count, 3, 3, 1);
  return (f_xmlwriter_write_pi(a0, a1, a2));
}
Variant i_posix_getppid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getppid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getppid", 0, 1);
  return (f_posix_getppid());
}
Variant ifa_posix_getppid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_getppid", 0, 1);
  return (f_posix_getppid());
}
Variant i_mb_stripos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_stripos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_stripos", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_stripos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_stripos(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_stripos(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_stripos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_stripos", count, 2, 4, 1);
  if (count <= 2) return (f_mb_stripos(a0, a1));
  if (count == 3) return (f_mb_stripos(a0, a1, a2));
  return (f_mb_stripos(a0, a1, a2, a3));
}
Variant i_magickpingimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickpingimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickpingimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickpingimage(arg0, arg1));
  }
}
Variant ifa_magickpingimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickpingimage", count, 2, 2, 1);
  return (f_magickpingimage(a0, a1));
}
Variant i_bcpowmod(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bcpowmod);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("bcpowmod", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_bcpowmod(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcpowmod(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_bcpowmod(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("bcpowmod", count, 3, 4, 1);
  if (count <= 3) return (f_bcpowmod(a0, a1, a2));
  return (f_bcpowmod(a0, a1, a2, a3));
}
Variant i_timezone_offset_get(void *extra, CArrRef params) {
  FUNCTION_INJECTION(timezone_offset_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("timezone_offset_get", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_timezone_offset_get(arg0, arg1));
  }
}
Variant ifa_timezone_offset_get(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("timezone_offset_get", count, 2, 2, 1);
  return (f_timezone_offset_get(a0, a1));
}
Variant i_dom_document_create_text_node(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_text_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_text_node", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_text_node(arg0, arg1));
  }
}
Variant ifa_dom_document_create_text_node(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_create_text_node", count, 2, 2, 1);
  return (f_dom_document_create_text_node(a0, a1));
}
Variant i_getrandmax(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getrandmax);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getrandmax", 0, 1);
  return (f_getrandmax());
}
Variant ifa_getrandmax(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("getrandmax", 0, 1);
  return (f_getrandmax());
}
Variant i_hphp_splfileobject_fseek(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fseek);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_splfileobject_fseek", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_fseek(arg0, arg1, arg2));
  }
}
Variant ifa_hphp_splfileobject_fseek(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("hphp_splfileobject_fseek", count, 3, 3, 1);
  return (f_hphp_splfileobject_fseek(a0, a1, a2));
}
Variant i_ctype_alnum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ctype_alnum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_alnum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_alnum(arg0));
  }
}
Variant ifa_ctype_alnum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ctype_alnum", count, 1, 1, 1);
  return (f_ctype_alnum(a0));
}
Variant i_tan(void *extra, CArrRef params) {
  FUNCTION_INJECTION(tan);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("tan", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_tan(arg0));
  }
}
Variant ifa_tan(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("tan", count, 1, 1, 1);
  return (f_tan(a0));
}
Variant i_set_exception_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(set_exception_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_exception_handler", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_set_exception_handler(arg0));
  }
}
Variant ifa_set_exception_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("set_exception_handler", count, 1, 1, 1);
  return (f_set_exception_handler(a0));
}
Variant i_imagegrabwindow(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagegrabwindow);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegrabwindow", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagegrabwindow(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagegrabwindow(arg0, arg1));
  }
}
Variant ifa_imagegrabwindow(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegrabwindow", count, 1, 2, 1);
  if (count <= 1) return (f_imagegrabwindow(a0));
  return (f_imagegrabwindow(a0, a1));
}
Variant i_memcache_add(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_add);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_add", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_memcache_add(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_memcache_add(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_add(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_memcache_add(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_add", count, 3, 5, 1);
  if (count <= 3) return (f_memcache_add(a0, a1, a2));
  if (count == 4) return (f_memcache_add(a0, a1, a2, a3));
  return (f_memcache_add(a0, a1, a2, a3, a4));
}
Variant i_magickstereoimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickstereoimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickstereoimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickstereoimage(arg0, arg1));
  }
}
Variant ifa_magickstereoimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickstereoimage", count, 2, 2, 1);
  return (f_magickstereoimage(a0, a1));
}
Variant i_magickgetimagescene(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagescene);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagescene", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagescene(arg0));
  }
}
Variant ifa_magickgetimagescene(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagescene", count, 1, 1, 1);
  return (f_magickgetimagescene(a0));
}
Variant i_hphp_splfileinfo_isfile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_isfile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isfile", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_isfile(arg0));
  }
}
Variant ifa_hphp_splfileinfo_isfile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isfile", count, 1, 1, 1);
  return (f_hphp_splfileinfo_isfile(a0));
}
Variant i_openssl_csr_sign(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_sign);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 6) return throw_wrong_arguments("openssl_csr_sign", count, 4, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_openssl_csr_sign(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_openssl_csr_sign(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_csr_sign(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_openssl_csr_sign(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 6) return throw_wrong_arguments("openssl_csr_sign", count, 4, 6, 1);
  if (count <= 4) return (f_openssl_csr_sign(a0, a1, a2, a3));
  if (count == 5) return (f_openssl_csr_sign(a0, a1, a2, a3, a4));
  return (f_openssl_csr_sign(a0, a1, a2, a3, a4, a5));
}
Variant i_openssl_pkcs12_export(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs12_export);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("openssl_pkcs12_export", count, 4, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_openssl_pkcs12_export(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs12_export(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_openssl_pkcs12_export(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("openssl_pkcs12_export", count, 4, 5, 1);
  if (count <= 4) return (f_openssl_pkcs12_export(a0, ref(a1), a2, a3));
  return (f_openssl_pkcs12_export(a0, ref(a1), a2, a3, a4));
}
Variant i_magickgetquantumdepth(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetquantumdepth);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetquantumdepth", 0, 1);
  return (f_magickgetquantumdepth());
}
Variant ifa_magickgetquantumdepth(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("magickgetquantumdepth", 0, 1);
  return (f_magickgetquantumdepth());
}
Variant i_socket_listen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_listen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_listen", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_socket_listen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_listen(arg0, arg1));
  }
}
Variant ifa_socket_listen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_listen", count, 1, 2, 1);
  if (count <= 1) return (f_socket_listen(a0));
  return (f_socket_listen(a0, a1));
}
Variant i_parse_str(void *extra, CArrRef params) {
  FUNCTION_INJECTION(parse_str);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("parse_str", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_parse_str(arg0), null);
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_parse_str(arg0, arg1), null);
  }
}
Variant ifa_parse_str(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("parse_str", count, 1, 2, 1);
  if (count <= 1) return (f_parse_str(a0), null);
  return (f_parse_str(a0, ref(a1)), null);
}
Variant i_sin(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sin);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sin", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sin(arg0));
  }
}
Variant ifa_sin(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("sin", count, 1, 1, 1);
  return (f_sin(a0));
}
Variant i_dom_node_append_child(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_append_child);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_append_child", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_append_child(arg0, arg1));
  }
}
Variant ifa_dom_node_append_child(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_node_append_child", count, 2, 2, 1);
  return (f_dom_node_append_child(a0, a1));
}
Variant i_cosh(void *extra, CArrRef params) {
  FUNCTION_INJECTION(cosh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cosh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_cosh(arg0));
  }
}
Variant ifa_cosh(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("cosh", count, 1, 1, 1);
  return (f_cosh(a0));
}
Variant i_copy(void *extra, CArrRef params) {
  FUNCTION_INJECTION(copy);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("copy", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_copy(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_copy(arg0, arg1, arg2));
  }
}
Variant ifa_copy(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("copy", count, 2, 3, 1);
  if (count <= 2) return (f_copy(a0, a1));
  return (f_copy(a0, a1, a2));
}
Variant i_imagechar(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagechar);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagechar", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagechar(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imagechar(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("imagechar", count, 6, 6, 1);
  return (f_imagechar(a0, a1, a2, a3, a4, a5));
}
Variant i_magicksetimagebackgroundcolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagebackgroundcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebackgroundcolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagebackgroundcolor(arg0, arg1));
  }
}
Variant ifa_magicksetimagebackgroundcolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagebackgroundcolor", count, 2, 2, 1);
  return (f_magicksetimagebackgroundcolor(a0, a1));
}
Variant i_ldap_mod_add(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_mod_add);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_add", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_mod_add(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_mod_add(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ldap_mod_add", count, 3, 3, 1);
  return (f_ldap_mod_add(a0, a1, a2));
}
Variant i_fb_thrift_serialize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_thrift_serialize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_thrift_serialize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_thrift_serialize(arg0));
  }
}
Variant ifa_fb_thrift_serialize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fb_thrift_serialize", count, 1, 1, 1);
  return (f_fb_thrift_serialize(a0));
}
Variant i_posix_ttyname(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_ttyname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_ttyname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_ttyname(arg0));
  }
}
Variant ifa_posix_ttyname(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_ttyname", count, 1, 1, 1);
  return (f_posix_ttyname(a0));
}
Variant i_filectime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(filectime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filectime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_filectime(arg0));
  }
}
Variant ifa_filectime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("filectime", count, 1, 1, 1);
  return (f_filectime(a0));
}
Variant i_newpixelwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(newpixelwand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("newpixelwand", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_newpixelwand());
    CVarRef arg0((ad->getValue(pos)));
    return (f_newpixelwand(arg0));
  }
}
Variant ifa_newpixelwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("newpixelwand", 1, 1);
  if (count <= 0) return (f_newpixelwand());
  return (f_newpixelwand(a0));
}
Variant i_pcntl_wait(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_wait);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("pcntl_wait", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_pcntl_wait(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_wait(arg0, arg1));
  }
}
Variant ifa_pcntl_wait(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("pcntl_wait", count, 1, 2, 1);
  if (count <= 1) return (f_pcntl_wait(ref(a0)));
  return (f_pcntl_wait(ref(a0), a1));
}
Variant i_hypot(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hypot);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hypot", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hypot(arg0, arg1));
  }
}
Variant ifa_hypot(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hypot", count, 2, 2, 1);
  return (f_hypot(a0, a1));
}
Variant i_parse_url(void *extra, CArrRef params) {
  FUNCTION_INJECTION(parse_url);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("parse_url", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_parse_url(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_parse_url(arg0, arg1));
  }
}
Variant ifa_parse_url(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("parse_url", count, 1, 2, 1);
  if (count <= 1) return (f_parse_url(a0));
  return (f_parse_url(a0, a1));
}
Variant i_magickreadimageblob(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickreadimageblob);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimageblob", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickreadimageblob(arg0, arg1));
  }
}
Variant ifa_magickreadimageblob(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickreadimageblob", count, 2, 2, 1);
  return (f_magickreadimageblob(a0, a1));
}
Variant i_eregi(void *extra, CArrRef params) {
  FUNCTION_INJECTION(eregi);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("eregi", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_eregi(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_eregi(arg0, arg1, arg2));
  }
}
Variant ifa_eregi(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("eregi", count, 2, 3, 1);
  if (count <= 2) return (f_eregi(a0, a1));
  return (f_eregi(a0, a1, ref(a2)));
}
Variant i_pixelsetcolorcount(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetcolorcount);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcolorcount", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetcolorcount(arg0, arg1), null);
  }
}
Variant ifa_pixelsetcolorcount(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetcolorcount", count, 2, 2, 1);
  return (f_pixelsetcolorcount(a0, a1), null);
}
Variant i_drawpathcurvetoquadraticbezierrelative(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetoquadraticbezierrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetoquadraticbezierrelative", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetoquadraticbezierrelative(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant ifa_drawpathcurvetoquadraticbezierrelative(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("drawpathcurvetoquadraticbezierrelative", count, 5, 5, 1);
  return (f_drawpathcurvetoquadraticbezierrelative(a0, a1, a2, a3, a4), null);
}
Variant i_posix_getgroups(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getgroups);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getgroups", 0, 1);
  return (f_posix_getgroups());
}
Variant ifa_posix_getgroups(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_getgroups", 0, 1);
  return (f_posix_getgroups());
}
Variant i_fileinode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fileinode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileinode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fileinode(arg0));
  }
}
Variant ifa_fileinode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fileinode", count, 1, 1, 1);
  return (f_fileinode(a0));
}
Variant i_magickgetnumberimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetnumberimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetnumberimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetnumberimages(arg0));
  }
}
Variant ifa_magickgetnumberimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetnumberimages", count, 1, 1, 1);
  return (f_magickgetnumberimages(a0));
}
Variant i_magickgetimagesblob(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagesblob);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesblob", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagesblob(arg0));
  }
}
Variant ifa_magickgetimagesblob(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagesblob", count, 1, 1, 1);
  return (f_magickgetimagesblob(a0));
}
Variant i_magickcontrastimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickcontrastimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcontrastimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcontrastimage(arg0, arg1));
  }
}
Variant ifa_magickcontrastimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickcontrastimage", count, 2, 2, 1);
  return (f_magickcontrastimage(a0, a1));
}
Variant i_pcntl_setpriority(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_setpriority);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pcntl_setpriority", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pcntl_setpriority(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_pcntl_setpriority(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_setpriority(arg0, arg1, arg2));
  }
}
Variant ifa_pcntl_setpriority(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("pcntl_setpriority", count, 1, 3, 1);
  if (count <= 1) return (f_pcntl_setpriority(a0));
  if (count == 2) return (f_pcntl_setpriority(a0, a1));
  return (f_pcntl_setpriority(a0, a1, a2));
}
Variant i_drawgetfontstretch(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetfontstretch);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontstretch", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfontstretch(arg0));
  }
}
Variant ifa_drawgetfontstretch(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetfontstretch", count, 1, 1, 1);
  return (f_drawgetfontstretch(a0));
}
Variant i_bcscale(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bcscale);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bcscale", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_bcscale(arg0));
  }
}
Variant ifa_bcscale(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("bcscale", count, 1, 1, 1);
  return (f_bcscale(a0));
}
Variant i_imageconvolution(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imageconvolution);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imageconvolution", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageconvolution(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imageconvolution(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("imageconvolution", count, 4, 4, 1);
  return (f_imageconvolution(a0, a1, a2, a3));
}
Variant i_utf8_decode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(utf8_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("utf8_decode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_utf8_decode(arg0));
  }
}
Variant ifa_utf8_decode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("utf8_decode", count, 1, 1, 1);
  return (f_utf8_decode(a0));
}
Variant i_ldap_unbind(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_unbind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_unbind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_unbind(arg0));
  }
}
Variant ifa_ldap_unbind(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ldap_unbind", count, 1, 1, 1);
  return (f_ldap_unbind(a0));
}
Variant i_newpixelregioniterator(void *extra, CArrRef params) {
  FUNCTION_INJECTION(newpixelregioniterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("newpixelregioniterator", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_newpixelregioniterator(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_newpixelregioniterator(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("newpixelregioniterator", count, 5, 5, 1);
  return (f_newpixelregioniterator(a0, a1, a2, a3, a4));
}
Variant i_array_intersect_assoc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_intersect_assoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect_assoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_intersect_assoc(count, arg0, arg1));
    return (f_array_intersect_assoc(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_array_intersect_assoc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("array_intersect_assoc", count+1, 1);
  if (count <= 2) return (f_array_intersect_assoc(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_intersect_assoc(count,a0, a1, params));
}
Variant i_ob_get_level(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_get_level);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_level", 0, 1);
  return (f_ob_get_level());
}
Variant ifa_ob_get_level(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("ob_get_level", 0, 1);
  return (f_ob_get_level());
}
Variant i_hebrev(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hebrev);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hebrev", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_hebrev(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hebrev(arg0, arg1));
  }
}
Variant ifa_hebrev(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("hebrev", count, 1, 2, 1);
  if (count <= 1) return (f_hebrev(a0));
  return (f_hebrev(a0, a1));
}
Variant i_socket_set_block(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_set_block);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_set_block", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_set_block(arg0));
  }
}
Variant ifa_socket_set_block(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("socket_set_block", count, 1, 1, 1);
  return (f_socket_set_block(a0));
}
Variant i_mcrypt_module_close(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_module_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_module_close(arg0));
  }
}
Variant ifa_mcrypt_module_close(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_module_close", count, 1, 1, 1);
  return (f_mcrypt_module_close(a0));
}
Variant i_mb_strwidth(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strwidth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strwidth", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_strwidth(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strwidth(arg0, arg1));
  }
}
Variant ifa_mb_strwidth(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strwidth", count, 1, 2, 1);
  if (count <= 1) return (f_mb_strwidth(a0));
  return (f_mb_strwidth(a0, a1));
}
Variant i_clonemagickwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(clonemagickwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clonemagickwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_clonemagickwand(arg0));
  }
}
Variant ifa_clonemagickwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("clonemagickwand", count, 1, 1, 1);
  return (f_clonemagickwand(a0));
}
Variant i_pixelgetred(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetred);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetred", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetred(arg0));
  }
}
Variant ifa_pixelgetred(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetred", count, 1, 1, 1);
  return (f_pixelgetred(a0));
}
Variant i_dom_document_create_processing_instruction(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_processing_instruction);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_create_processing_instruction", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_document_create_processing_instruction(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_processing_instruction(arg0, arg1, arg2));
  }
}
Variant ifa_dom_document_create_processing_instruction(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_create_processing_instruction", count, 2, 3, 1);
  if (count <= 2) return (f_dom_document_create_processing_instruction(a0, a1));
  return (f_dom_document_create_processing_instruction(a0, a1, a2));
}
Variant i_ip2long(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ip2long);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ip2long", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ip2long(arg0));
  }
}
Variant ifa_ip2long(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ip2long", count, 1, 1, 1);
  return (f_ip2long(a0));
}
Variant i_mb_stristr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_stristr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_stristr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_stristr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_stristr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_stristr(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_stristr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_stristr", count, 2, 4, 1);
  if (count <= 2) return (f_mb_stristr(a0, a1));
  if (count == 3) return (f_mb_stristr(a0, a1, a2));
  return (f_mb_stristr(a0, a1, a2, a3));
}
Variant i_array_diff_ukey(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_diff_ukey);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_diff_ukey", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_diff_ukey(count, arg0, arg1, arg2));
    return (f_array_diff_ukey(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant ifa_array_diff_ukey(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3) return throw_missing_arguments("array_diff_ukey", count+1, 1);
  if (count <= 3) return (f_array_diff_ukey(count, a0, a1, a2));
  Array params;
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_diff_ukey(count,a0, a1, a2, params));
}
Variant i_isdrawingwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(isdrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("isdrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_isdrawingwand(arg0));
  }
}
Variant ifa_isdrawingwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("isdrawingwand", count, 1, 1, 1);
  return (f_isdrawingwand(a0));
}
Variant i_magicksetimagemattecolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagemattecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagemattecolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagemattecolor(arg0, arg1));
  }
}
Variant ifa_magicksetimagemattecolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagemattecolor", count, 2, 2, 1);
  return (f_magicksetimagemattecolor(a0, a1));
}
Variant i_closedir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(closedir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("closedir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_closedir(arg0), null);
  }
}
Variant ifa_closedir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("closedir", count, 1, 1, 1);
  return (f_closedir(a0), null);
}
Variant i_fb_call_user_func_safe_return(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_call_user_func_safe_return);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fb_call_user_func_safe_return", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fb_call_user_func_safe_return(count, arg0, arg1));
    return (f_fb_call_user_func_safe_return(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_fb_call_user_func_safe_return(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("fb_call_user_func_safe_return", count+1, 1);
  if (count <= 2) return (f_fb_call_user_func_safe_return(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_fb_call_user_func_safe_return(count,a0, a1, params));
}
Variant i_magickwriteimagesfile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickwriteimagesfile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimagesfile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwriteimagesfile(arg0, arg1));
  }
}
Variant ifa_magickwriteimagesfile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickwriteimagesfile", count, 2, 2, 1);
  return (f_magickwriteimagesfile(a0, a1));
}
Variant i_magickdescribeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickdescribeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdescribeimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickdescribeimage(arg0));
  }
}
Variant ifa_magickdescribeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickdescribeimage", count, 1, 1, 1);
  return (f_magickdescribeimage(a0));
}
Variant i_imageftbbox(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imageftbbox);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("imageftbbox", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_imageftbbox(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageftbbox(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_imageftbbox(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("imageftbbox", count, 4, 5, 1);
  if (count <= 4) return (f_imageftbbox(a0, a1, a2, a3));
  return (f_imageftbbox(a0, a1, a2, a3, a4));
}
Variant i_magicksetlastiterator(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetlastiterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicksetlastiterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magicksetlastiterator(arg0), null);
  }
}
Variant ifa_magicksetlastiterator(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magicksetlastiterator", count, 1, 1, 1);
  return (f_magicksetlastiterator(a0), null);
}
Variant i_hphp_output_global_state(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_output_global_state);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("hphp_output_global_state", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_hphp_output_global_state());
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_output_global_state(arg0));
  }
}
Variant ifa_hphp_output_global_state(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("hphp_output_global_state", 1, 1);
  if (count <= 0) return (f_hphp_output_global_state());
  return (f_hphp_output_global_state(a0));
}
Variant i_imagefontheight(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagefontheight);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagefontheight", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagefontheight(arg0));
  }
}
Variant ifa_imagefontheight(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagefontheight", count, 1, 1, 1);
  return (f_imagefontheight(a0));
}
Variant i_putenv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(putenv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("putenv", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_putenv(arg0));
  }
}
Variant ifa_putenv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("putenv", count, 1, 1, 1);
  return (f_putenv(a0));
}
Variant i_magickedgeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickedgeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickedgeimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickedgeimage(arg0, arg1));
  }
}
Variant ifa_magickedgeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickedgeimage", count, 2, 2, 1);
  return (f_magickedgeimage(a0, a1));
}
Variant i_xml_error_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_error_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_error_string", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_error_string(arg0));
  }
}
Variant ifa_xml_error_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xml_error_string", count, 1, 1, 1);
  return (f_xml_error_string(a0));
}
Variant i_array_rand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_rand);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_rand", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_rand(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_rand(arg0, arg1));
  }
}
Variant ifa_array_rand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("array_rand", count, 1, 2, 1);
  if (count <= 1) return (f_array_rand(a0));
  return (f_array_rand(a0, a1));
}
Variant i_ldap_mod_del(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_mod_del);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_del", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_mod_del(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_mod_del(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ldap_mod_del", count, 3, 3, 1);
  return (f_ldap_mod_del(a0, a1, a2));
}
Variant i_range(void *extra, CArrRef params) {
  FUNCTION_INJECTION(range);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("range", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_range(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_range(arg0, arg1, arg2));
  }
}
Variant ifa_range(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("range", count, 2, 3, 1);
  if (count <= 2) return (f_range(a0, a1));
  return (f_range(a0, a1, a2));
}
Variant i_levenshtein(void *extra, CArrRef params) {
  FUNCTION_INJECTION(levenshtein);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("levenshtein", count, 2, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_levenshtein(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_levenshtein(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_levenshtein(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_levenshtein(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_levenshtein(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 5) return throw_wrong_arguments("levenshtein", count, 2, 5, 1);
  if (count <= 2) return (f_levenshtein(a0, a1));
  if (count == 3) return (f_levenshtein(a0, a1, a2));
  if (count == 4) return (f_levenshtein(a0, a1, a2, a3));
  return (f_levenshtein(a0, a1, a2, a3, a4));
}
Variant i_curl_multi_close(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_multi_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_multi_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_multi_close(arg0));
  }
}
Variant ifa_curl_multi_close(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("curl_multi_close", count, 1, 1, 1);
  return (f_curl_multi_close(a0));
}
Variant i_drawgetfillalpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetfillalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillalpha", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfillalpha(arg0));
  }
}
Variant ifa_drawgetfillalpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetfillalpha", count, 1, 1, 1);
  return (f_drawgetfillalpha(a0));
}
Variant i_hash_hmac(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hash_hmac);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("hash_hmac", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_hash_hmac(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_hmac(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_hash_hmac(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("hash_hmac", count, 3, 4, 1);
  if (count <= 3) return (f_hash_hmac(a0, a1, a2));
  return (f_hash_hmac(a0, a1, a2, a3));
}
Variant i_get_html_translation_table(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_html_translation_table);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("get_html_translation_table", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_html_translation_table());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_get_html_translation_table(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_get_html_translation_table(arg0, arg1));
  }
}
Variant ifa_get_html_translation_table(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("get_html_translation_table", 2, 1);
  if (count <= 0) return (f_get_html_translation_table());
  if (count == 1) return (f_get_html_translation_table(a0));
  return (f_get_html_translation_table(a0, a1));
}
Variant i_user_error(void *extra, CArrRef params) {
  FUNCTION_INJECTION(user_error);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("user_error", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_user_error(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_user_error(arg0, arg1));
  }
}
Variant ifa_user_error(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("user_error", count, 1, 2, 1);
  if (count <= 1) return (f_user_error(a0));
  return (f_user_error(a0, a1));
}
Variant i_feof(void *extra, CArrRef params) {
  FUNCTION_INJECTION(feof);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("feof", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_feof(arg0));
  }
}
Variant ifa_feof(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("feof", count, 1, 1, 1);
  return (f_feof(a0));
}
Variant i_filemtime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(filemtime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filemtime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_filemtime(arg0));
  }
}
Variant ifa_filemtime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("filemtime", count, 1, 1, 1);
  return (f_filemtime(a0));
}
Variant i_microtime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(microtime);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("microtime", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_microtime());
    CVarRef arg0((ad->getValue(pos)));
    return (f_microtime(arg0));
  }
}
Variant ifa_microtime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("microtime", 1, 1);
  if (count <= 0) return (f_microtime());
  return (f_microtime(a0));
}
Variant i_zend_version(void *extra, CArrRef params) {
  FUNCTION_INJECTION(zend_version);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_version", 0, 1);
  return (f_zend_version());
}
Variant ifa_zend_version(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("zend_version", 0, 1);
  return (f_zend_version());
}
Variant i_openssl_x509_free(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_free);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_x509_free", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_x509_free(arg0), null);
  }
}
Variant ifa_openssl_x509_free(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("openssl_x509_free", count, 1, 1, 1);
  return (f_openssl_x509_free(a0), null);
}
Variant i_fb_call_user_func_safe(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_call_user_func_safe);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("fb_call_user_func_safe", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fb_call_user_func_safe(count, arg0));
    return (f_fb_call_user_func_safe(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_fb_call_user_func_safe(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("fb_call_user_func_safe", count+1, 1);
  if (count <= 1) return (f_fb_call_user_func_safe(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_fb_call_user_func_safe(count,a0, params));
}
Variant i_var_export(void *extra, CArrRef params) {
  FUNCTION_INJECTION(var_export);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("var_export", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_var_export(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_var_export(arg0, arg1));
  }
}
Variant ifa_var_export(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("var_export", count, 1, 2, 1);
  if (count <= 1) return (f_var_export(a0));
  return (f_var_export(a0, a1));
}
Variant i_mb_strcut(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strcut);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strcut", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strcut(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strcut(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strcut(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_strcut(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strcut", count, 2, 4, 1);
  if (count <= 2) return (f_mb_strcut(a0, a1));
  if (count == 3) return (f_mb_strcut(a0, a1, a2));
  return (f_mb_strcut(a0, a1, a2, a3));
}
Variant i_xmlwriter_end_comment(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_comment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_comment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_comment(arg0));
  }
}
Variant ifa_xmlwriter_end_comment(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_comment", count, 1, 1, 1);
  return (f_xmlwriter_end_comment(a0));
}
Variant i_xmlwriter_end_dtd_element(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_dtd_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_element", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_dtd_element(arg0));
  }
}
Variant ifa_xmlwriter_end_dtd_element(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_element", count, 1, 1, 1);
  return (f_xmlwriter_end_dtd_element(a0));
}
Variant i_dom_text_split_text(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_text_split_text);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_text_split_text", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_text_split_text(arg0, arg1));
  }
}
Variant ifa_dom_text_split_text(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_text_split_text", count, 2, 2, 1);
  return (f_dom_text_split_text(a0, a1));
}
Variant i_openssl_pkey_export_to_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_export_to_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_pkey_export_to_file", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_pkey_export_to_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_openssl_pkey_export_to_file(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkey_export_to_file(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_pkey_export_to_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_pkey_export_to_file", count, 2, 4, 1);
  if (count <= 2) return (f_openssl_pkey_export_to_file(a0, a1));
  if (count == 3) return (f_openssl_pkey_export_to_file(a0, a1, a2));
  return (f_openssl_pkey_export_to_file(a0, a1, a2, a3));
}
Variant i_hphp_get_original_class_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_get_original_class_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_original_class_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_get_original_class_name(arg0));
  }
}
Variant ifa_hphp_get_original_class_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_get_original_class_name", count, 1, 1, 1);
  return (f_hphp_get_original_class_name(a0));
}
Variant i_imagecolorclosesthwb(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorclosesthwb);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorclosesthwb", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorclosesthwb(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagecolorclosesthwb(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("imagecolorclosesthwb", count, 4, 4, 1);
  return (f_imagecolorclosesthwb(a0, a1, a2, a3));
}
Variant i_ldap_get_attributes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_get_attributes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_attributes", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_get_attributes(arg0, arg1));
  }
}
Variant ifa_ldap_get_attributes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_get_attributes", count, 2, 2, 1);
  return (f_ldap_get_attributes(a0, a1));
}
Variant i_date_modify(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_modify);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_modify", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_modify(arg0, arg1), null);
  }
}
Variant ifa_date_modify(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("date_modify", count, 2, 2, 1);
  return (f_date_modify(a0, a1), null);
}
Variant i_hphp_splfileinfo_setinfoclass(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_setinfoclass);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_setinfoclass", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_setinfoclass(arg0, arg1), null);
  }
}
Variant ifa_hphp_splfileinfo_setinfoclass(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_setinfoclass", count, 2, 2, 1);
  return (f_hphp_splfileinfo_setinfoclass(a0, a1), null);
}
Variant i_umask(void *extra, CArrRef params) {
  FUNCTION_INJECTION(umask);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("umask", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_umask());
    CVarRef arg0((ad->getValue(pos)));
    return (f_umask(arg0));
  }
}
Variant ifa_umask(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("umask", 1, 1);
  if (count <= 0) return (f_umask());
  return (f_umask(a0));
}
Variant i_xml_get_current_column_number(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_get_current_column_number);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_column_number", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_get_current_column_number(arg0));
  }
}
Variant ifa_xml_get_current_column_number(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xml_get_current_column_number", count, 1, 1, 1);
  return (f_xml_get_current_column_number(a0));
}
Variant i_pixelsetblue(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetblue);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblue", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetblue(arg0, arg1), null);
  }
}
Variant ifa_pixelsetblue(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetblue", count, 2, 2, 1);
  return (f_pixelsetblue(a0, a1), null);
}
Variant i_mb_http_output(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_http_output);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_http_output", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_http_output());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_http_output(arg0));
  }
}
Variant ifa_mb_http_output(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mb_http_output", 1, 1);
  if (count <= 0) return (f_mb_http_output());
  return (f_mb_http_output(a0));
}
Variant i_flock(void *extra, CArrRef params) {
  FUNCTION_INJECTION(flock);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("flock", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_flock(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_flock(arg0, arg1, arg2));
  }
}
Variant ifa_flock(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("flock", count, 2, 3, 1);
  if (count <= 2) return (f_flock(a0, a1));
  return (f_flock(a0, a1, ref(a2)));
}
Variant i_hphp_splfileobject_ftell(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_ftell);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_ftell", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_ftell(arg0));
  }
}
Variant ifa_hphp_splfileobject_ftell(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_ftell", count, 1, 1, 1);
  return (f_hphp_splfileobject_ftell(a0));
}
Variant i_pcntl_wifexited(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_wifexited);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifexited", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wifexited(arg0));
  }
}
Variant ifa_pcntl_wifexited(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pcntl_wifexited", count, 1, 1, 1);
  return (f_pcntl_wifexited(a0));
}
Variant i_magicksetformat(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetformat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetformat", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetformat(arg0, arg1));
  }
}
Variant ifa_magicksetformat(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetformat", count, 2, 2, 1);
  return (f_magicksetformat(a0, a1));
}
Variant i_array_map(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_map);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_map", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_map(count, arg0, arg1));
    return (f_array_map(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_array_map(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("array_map", count+1, 1);
  if (count <= 2) return (f_array_map(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_map(count,a0, a1, params));
}
Variant i_magicksharpenimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksharpenimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magicksharpenimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magicksharpenimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksharpenimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magicksharpenimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magicksharpenimage", count, 3, 4, 1);
  if (count <= 3) return (f_magicksharpenimage(a0, a1, a2));
  return (f_magicksharpenimage(a0, a1, a2, a3));
}
Variant i_is_infinite(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_infinite);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_infinite", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_infinite(arg0));
  }
}
Variant ifa_is_infinite(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_infinite", count, 1, 1, 1);
  return (f_is_infinite(a0));
}
Variant i_date_timezone_set(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_timezone_set);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_timezone_set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_timezone_set(arg0, arg1), null);
  }
}
Variant ifa_date_timezone_set(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("date_timezone_set", count, 2, 2, 1);
  return (f_date_timezone_set(a0, a1), null);
}
Variant i_mb_ereg_search_init(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_init);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_ereg_search_init", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_ereg_search_init(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mb_ereg_search_init(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_search_init(arg0, arg1, arg2));
  }
}
Variant ifa_mb_ereg_search_init(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_ereg_search_init", count, 1, 3, 1);
  if (count <= 1) return (f_mb_ereg_search_init(a0));
  if (count == 2) return (f_mb_ereg_search_init(a0, a1));
  return (f_mb_ereg_search_init(a0, a1, a2));
}
Variant i_drawcircle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawcircle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawcircle", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawcircle(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant ifa_drawcircle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("drawcircle", count, 5, 5, 1);
  return (f_drawcircle(a0, a1, a2, a3, a4), null);
}
Variant i_is_readable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_readable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_readable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_readable(arg0));
  }
}
Variant ifa_is_readable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_readable", count, 1, 1, 1);
  return (f_is_readable(a0));
}
Variant i_image_type_to_extension(void *extra, CArrRef params) {
  FUNCTION_INJECTION(image_type_to_extension);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("image_type_to_extension", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_image_type_to_extension(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_image_type_to_extension(arg0, arg1));
  }
}
Variant ifa_image_type_to_extension(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("image_type_to_extension", count, 1, 2, 1);
  if (count <= 1) return (f_image_type_to_extension(a0));
  return (f_image_type_to_extension(a0, a1));
}
Variant i_printf(void *extra, CArrRef params) {
  FUNCTION_INJECTION(printf);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("printf", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_printf(count, arg0));
    return (f_printf(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_printf(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("printf", count+1, 1);
  if (count <= 1) return (f_printf(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_printf(count,a0, params));
}
Variant i_magicksetimagecompression(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagecompression);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompression", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagecompression(arg0, arg1));
  }
}
Variant ifa_magicksetimagecompression(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagecompression", count, 2, 2, 1);
  return (f_magicksetimagecompression(a0, a1));
}
Variant i_mcrypt_decrypt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_decrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_decrypt", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_decrypt(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_decrypt(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_mcrypt_decrypt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_decrypt", count, 4, 5, 1);
  if (count <= 4) return (f_mcrypt_decrypt(a0, a1, a2, a3));
  return (f_mcrypt_decrypt(a0, a1, a2, a3, a4));
}
Variant i_hphp_directoryiterator_next(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_next);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_next", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_next(arg0), null);
  }
}
Variant ifa_hphp_directoryiterator_next(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_next", count, 1, 1, 1);
  return (f_hphp_directoryiterator_next(a0), null);
}
Variant i_natcasesort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(natcasesort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("natcasesort", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_natcasesort(arg0));
  }
}
Variant ifa_natcasesort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("natcasesort", count, 1, 1, 1);
  return (f_natcasesort(ref(a0)));
}
Variant i_intl_get_error_message(void *extra, CArrRef params) {
  FUNCTION_INJECTION(intl_get_error_message);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("intl_get_error_message", 0, 1);
  return (f_intl_get_error_message());
}
Variant ifa_intl_get_error_message(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("intl_get_error_message", 0, 1);
  return (f_intl_get_error_message());
}
Variant i_memcache_get(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_get);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_get", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_get(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_memcache_get(arg0, arg1, arg2));
  }
}
Variant ifa_memcache_get(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_get", count, 2, 3, 1);
  if (count <= 2) return (f_memcache_get(a0, a1));
  return (f_memcache_get(a0, a1, ref(a2)));
}
Variant i_array_chunk(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_chunk);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_chunk", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_chunk(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_chunk(arg0, arg1, arg2));
  }
}
Variant ifa_array_chunk(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("array_chunk", count, 2, 3, 1);
  if (count <= 2) return (f_array_chunk(a0, a1));
  return (f_array_chunk(a0, a1, a2));
}
Variant i_collator_asort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_asort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("collator_asort", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_collator_asort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_asort(arg0, arg1, arg2));
  }
}
Variant ifa_collator_asort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("collator_asort", count, 2, 3, 1);
  if (count <= 2) return (f_collator_asort(a0, ref(a1)));
  return (f_collator_asort(a0, ref(a1), a2));
}
Variant i_imagefilledpolygon(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagefilledpolygon);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagefilledpolygon", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilledpolygon(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagefilledpolygon(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("imagefilledpolygon", count, 4, 4, 1);
  return (f_imagefilledpolygon(a0, a1, a2, a3));
}
Variant i_drawpoppattern(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpoppattern);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpoppattern", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpoppattern(arg0), null);
  }
}
Variant ifa_drawpoppattern(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawpoppattern", count, 1, 1, 1);
  return (f_drawpoppattern(a0), null);
}
Variant i_magickgetimagewidth(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagewidth);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagewidth", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagewidth(arg0));
  }
}
Variant ifa_magickgetimagewidth(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagewidth", count, 1, 1, 1);
  return (f_magickgetimagewidth(a0));
}
Variant i_drawgetfontfamily(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetfontfamily);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontfamily", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfontfamily(arg0));
  }
}
Variant ifa_drawgetfontfamily(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetfontfamily", count, 1, 1, 1);
  return (f_drawgetfontfamily(a0));
}
Variant i_dl(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dl);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dl", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dl(arg0));
  }
}
Variant ifa_dl(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dl", count, 1, 1, 1);
  return (f_dl(a0));
}
Variant i_touch(void *extra, CArrRef params) {
  FUNCTION_INJECTION(touch);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("touch", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_touch(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_touch(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_touch(arg0, arg1, arg2));
  }
}
Variant ifa_touch(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("touch", count, 1, 3, 1);
  if (count <= 1) return (f_touch(a0));
  if (count == 2) return (f_touch(a0, a1));
  return (f_touch(a0, a1, a2));
}
Variant i_hphp_recursivedirectoryiterator___tostring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator___tostring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator___tostring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator___tostring(arg0));
  }
}
Variant ifa_hphp_recursivedirectoryiterator___tostring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator___tostring", count, 1, 1, 1);
  return (f_hphp_recursivedirectoryiterator___tostring(a0));
}
Variant i_magicksetimagebordercolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagebordercolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebordercolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagebordercolor(arg0, arg1));
  }
}
Variant ifa_magicksetimagebordercolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagebordercolor", count, 2, 2, 1);
  return (f_magicksetimagebordercolor(a0, a1));
}
Variant i_hphp_directoryiterator_rewind(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_rewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_rewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_rewind(arg0), null);
  }
}
Variant ifa_hphp_directoryiterator_rewind(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_rewind", count, 1, 1, 1);
  return (f_hphp_directoryiterator_rewind(a0), null);
}
Variant i_magickspliceimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickspliceimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickspliceimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickspliceimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_magickspliceimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("magickspliceimage", count, 5, 5, 1);
  return (f_magickspliceimage(a0, a1, a2, a3, a4));
}
Variant i_define(void *extra, CArrRef params) {
  FUNCTION_INJECTION(define);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("define", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_define(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_define(arg0, arg1, arg2));
  }
}
Variant ifa_define(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("define", count, 2, 3, 1);
  if (count <= 2) return (f_define(a0, a1));
  return (f_define(a0, a1, a2));
}
Variant i_headers_sent(void *extra, CArrRef params) {
  FUNCTION_INJECTION(headers_sent);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("headers_sent", 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_headers_sent());
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count == 1) return (f_headers_sent(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_headers_sent(arg0, arg1));
  }
}
Variant ifa_headers_sent(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("headers_sent", 2, 1);
  if (count <= 0) return (f_headers_sent());
  if (count == 1) return (f_headers_sent(ref(a0)));
  return (f_headers_sent(ref(a0), ref(a1)));
}
Variant i_stream_context_get_options(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_context_get_options);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_context_get_options", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_context_get_options(arg0));
  }
}
Variant ifa_stream_context_get_options(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("stream_context_get_options", count, 1, 1, 1);
  return (f_stream_context_get_options(a0));
}
Variant i_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("file", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_file(arg0, arg1, arg2));
  }
}
Variant ifa_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("file", count, 1, 3, 1);
  if (count <= 1) return (f_file(a0));
  if (count == 2) return (f_file(a0, a1));
  return (f_file(a0, a1, a2));
}
Variant i_memcache_get_extended_stats(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_get_extended_stats);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_get_extended_stats", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_memcache_get_extended_stats(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_memcache_get_extended_stats(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_get_extended_stats(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_get_extended_stats(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_memcache_get_extended_stats(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_get_extended_stats", count, 1, 4, 1);
  if (count <= 1) return (f_memcache_get_extended_stats(a0));
  if (count == 2) return (f_memcache_get_extended_stats(a0, a1));
  if (count == 3) return (f_memcache_get_extended_stats(a0, a1, a2));
  return (f_memcache_get_extended_stats(a0, a1, a2, a3));
}
Variant i_hphp_crash_log(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_crash_log);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_crash_log", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_crash_log(arg0, arg1), null);
  }
}
Variant ifa_hphp_crash_log(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_crash_log", count, 2, 2, 1);
  return (f_hphp_crash_log(a0, a1), null);
}
Variant i_imagecolorresolvealpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorresolvealpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorresolvealpha", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorresolvealpha(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_imagecolorresolvealpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("imagecolorresolvealpha", count, 5, 5, 1);
  return (f_imagecolorresolvealpha(a0, a1, a2, a3, a4));
}
Variant i_strtr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strtr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strtr", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strtr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strtr(arg0, arg1, arg2));
  }
}
Variant ifa_strtr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("strtr", count, 2, 3, 1);
  if (count <= 2) return (f_strtr(a0, a1));
  return (f_strtr(a0, a1, a2));
}
Variant i_posix_strerror(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_strerror);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_strerror", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_strerror(arg0));
  }
}
Variant ifa_posix_strerror(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_strerror", count, 1, 1, 1);
  return (f_posix_strerror(a0));
}
Variant i_libxml_use_internal_errors(void *extra, CArrRef params) {
  FUNCTION_INJECTION(libxml_use_internal_errors);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("libxml_use_internal_errors", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_libxml_use_internal_errors());
    CVarRef arg0((ad->getValue(pos)));
    return (f_libxml_use_internal_errors(arg0));
  }
}
Variant ifa_libxml_use_internal_errors(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("libxml_use_internal_errors", 1, 1);
  if (count <= 0) return (f_libxml_use_internal_errors());
  return (f_libxml_use_internal_errors(a0));
}
Variant i_end_user_func_async(void *extra, CArrRef params) {
  FUNCTION_INJECTION(end_user_func_async);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("end_user_func_async", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_end_user_func_async(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_end_user_func_async(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_end_user_func_async(arg0, arg1, arg2));
  }
}
Variant ifa_end_user_func_async(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("end_user_func_async", count, 1, 3, 1);
  if (count <= 1) return (f_end_user_func_async(a0));
  if (count == 2) return (f_end_user_func_async(a0, a1));
  return (f_end_user_func_async(a0, a1, a2));
}
Variant i_openssl_get_publickey(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_get_publickey);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_get_publickey", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_get_publickey(arg0));
  }
}
Variant ifa_openssl_get_publickey(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("openssl_get_publickey", count, 1, 1, 1);
  return (f_openssl_get_publickey(a0));
}
Variant i_dom_node_lookup_prefix(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_lookup_prefix);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_lookup_prefix", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_lookup_prefix(arg0, arg1));
  }
}
Variant ifa_dom_node_lookup_prefix(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_node_lookup_prefix", count, 2, 2, 1);
  return (f_dom_node_lookup_prefix(a0, a1));
}
Variant i_time_nanosleep(void *extra, CArrRef params) {
  FUNCTION_INJECTION(time_nanosleep);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("time_nanosleep", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_time_nanosleep(arg0, arg1));
  }
}
Variant ifa_time_nanosleep(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("time_nanosleep", count, 2, 2, 1);
  return (f_time_nanosleep(a0, a1));
}
Variant i_magicksetimageunits(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimageunits);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageunits", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageunits(arg0, arg1));
  }
}
Variant ifa_magicksetimageunits(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimageunits", count, 2, 2, 1);
  return (f_magicksetimageunits(a0, a1));
}
Variant i_floor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(floor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("floor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_floor(arg0));
  }
}
Variant ifa_floor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("floor", count, 1, 1, 1);
  return (f_floor(a0));
}
Variant i_array_pad(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_pad);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("array_pad", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_pad(arg0, arg1, arg2));
  }
}
Variant ifa_array_pad(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("array_pad", count, 3, 3, 1);
  return (f_array_pad(a0, a1, a2));
}
Variant i_sem_release(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sem_release);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_release", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sem_release(arg0));
  }
}
Variant ifa_sem_release(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("sem_release", count, 1, 1, 1);
  return (f_sem_release(a0));
}
Variant i_hphp_splfileinfo_getctime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getctime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getctime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getctime(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getctime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getctime", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getctime(a0));
}
Variant i_highlight_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(highlight_string);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("highlight_string", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_highlight_string(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_highlight_string(arg0, arg1));
  }
}
Variant ifa_highlight_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("highlight_string", count, 1, 2, 1);
  if (count <= 1) return (f_highlight_string(a0));
  return (f_highlight_string(a0, a1));
}
Variant i_hphp_invoke(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_invoke);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_invoke", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_invoke(arg0, arg1));
  }
}
Variant ifa_hphp_invoke(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_invoke", count, 2, 2, 1);
  return (f_hphp_invoke(a0, a1));
}
Variant i_imageloadfont(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imageloadfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imageloadfont", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imageloadfont(arg0));
  }
}
Variant ifa_imageloadfont(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imageloadfont", count, 1, 1, 1);
  return (f_imageloadfont(a0));
}
Variant i_xmlwriter_start_element(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_element", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_element(arg0, arg1));
  }
}
Variant ifa_xmlwriter_start_element(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_element", count, 2, 2, 1);
  return (f_xmlwriter_start_element(a0, a1));
}
Variant i_localeconv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(localeconv);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("localeconv", 0, 1);
  return (f_localeconv());
}
Variant ifa_localeconv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("localeconv", 0, 1);
  return (f_localeconv());
}
Variant i_exif_thumbnail(void *extra, CArrRef params) {
  FUNCTION_INJECTION(exif_thumbnail);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("exif_thumbnail", count, 1, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_exif_thumbnail(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_exif_thumbnail(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_exif_thumbnail(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_exif_thumbnail(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_exif_thumbnail(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("exif_thumbnail", count, 1, 4, 1);
  if (count <= 1) return (f_exif_thumbnail(a0));
  if (count == 2) return (f_exif_thumbnail(a0, ref(a1)));
  if (count == 3) return (f_exif_thumbnail(a0, ref(a1), ref(a2)));
  return (f_exif_thumbnail(a0, ref(a1), ref(a2), ref(a3)));
}
Variant i_collator_get_error_message(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_get_error_message);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_error_message", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_collator_get_error_message(arg0));
  }
}
Variant ifa_collator_get_error_message(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("collator_get_error_message", count, 1, 1, 1);
  return (f_collator_get_error_message(a0));
}
Variant i_mysql_get_proto_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_get_proto_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_proto_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_get_proto_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_get_proto_info(arg0));
  }
}
Variant ifa_mysql_get_proto_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_get_proto_info", 1, 1);
  if (count <= 0) return (f_mysql_get_proto_info());
  return (f_mysql_get_proto_info(a0));
}
Variant i_imagefontwidth(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagefontwidth);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagefontwidth", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagefontwidth(arg0));
  }
}
Variant ifa_imagefontwidth(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagefontwidth", count, 1, 1, 1);
  return (f_imagefontwidth(a0));
}
Variant i_substr_compare(void *extra, CArrRef params) {
  FUNCTION_INJECTION(substr_compare);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("substr_compare", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_substr_compare(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_substr_compare(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_substr_compare(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_substr_compare(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 5) return throw_wrong_arguments("substr_compare", count, 3, 5, 1);
  if (count <= 3) return (f_substr_compare(a0, a1, a2));
  if (count == 4) return (f_substr_compare(a0, a1, a2, a3));
  return (f_substr_compare(a0, a1, a2, a3, a4));
}
Variant i_xbox_post_message(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xbox_post_message);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xbox_post_message", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_xbox_post_message(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xbox_post_message(arg0, arg1));
  }
}
Variant ifa_xbox_post_message(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("xbox_post_message", count, 1, 2, 1);
  if (count <= 1) return (f_xbox_post_message(a0));
  return (f_xbox_post_message(a0, a1));
}
Variant i_fb_rename_function(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_rename_function);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_rename_function", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_rename_function(arg0, arg1));
  }
}
Variant ifa_fb_rename_function(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("fb_rename_function", count, 2, 2, 1);
  return (f_fb_rename_function(a0, a1));
}
Variant i_array_walk_recursive(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_walk_recursive);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_walk_recursive", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_walk_recursive(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_walk_recursive(arg0, arg1, arg2));
  }
}
Variant ifa_array_walk_recursive(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("array_walk_recursive", count, 2, 3, 1);
  if (count <= 2) return (f_array_walk_recursive(ref(a0), a1));
  return (f_array_walk_recursive(ref(a0), a1, a2));
}
Variant i_mysql_list_processes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_list_processes);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_list_processes", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_list_processes());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_list_processes(arg0));
  }
}
Variant ifa_mysql_list_processes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_list_processes", 1, 1);
  if (count <= 0) return (f_mysql_list_processes());
  return (f_mysql_list_processes(a0));
}
Variant i_imagedashedline(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagedashedline);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagedashedline", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagedashedline(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imagedashedline(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("imagedashedline", count, 6, 6, 1);
  return (f_imagedashedline(a0, a1, a2, a3, a4, a5));
}
Variant i_magickgetimagedelay(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagedelay);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagedelay", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagedelay(arg0));
  }
}
Variant ifa_magickgetimagedelay(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagedelay", count, 1, 1, 1);
  return (f_magickgetimagedelay(a0));
}
Variant i_pi(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pi);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pi", 0, 1);
  return (f_pi());
}
Variant ifa_pi(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("pi", 0, 1);
  return (f_pi());
}
Variant i_mb_substr_count(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_substr_count);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_substr_count", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_substr_count(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_substr_count(arg0, arg1, arg2));
  }
}
Variant ifa_mb_substr_count(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_substr_count", count, 2, 3, 1);
  if (count <= 2) return (f_mb_substr_count(a0, a1));
  return (f_mb_substr_count(a0, a1, a2));
}
Variant i_hphp_splfileinfo_getinode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getinode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getinode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getinode(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getinode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getinode", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getinode(a0));
}
Variant i_magickgettextdescent(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgettextdescent);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgettextdescent", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgettextdescent(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgettextdescent(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickgettextdescent(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgettextdescent", count, 3, 4, 1);
  if (count <= 3) return (f_magickgettextdescent(a0, a1, a2));
  return (f_magickgettextdescent(a0, a1, a2, a3));
}
Variant i_drawsetstrokealpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokealpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokealpha", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokealpha(arg0, arg1), null);
  }
}
Variant ifa_drawsetstrokealpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetstrokealpha", count, 2, 2, 1);
  return (f_drawsetstrokealpha(a0, a1), null);
}
Variant i_apc_delete_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_delete_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apc_delete_file", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_delete_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_delete_file(arg0, arg1));
  }
}
Variant ifa_apc_delete_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("apc_delete_file", count, 1, 2, 1);
  if (count <= 1) return (f_apc_delete_file(a0));
  return (f_apc_delete_file(a0, a1));
}
Variant i_strrpos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strrpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strrpos", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strrpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strrpos(arg0, arg1, arg2));
  }
}
Variant ifa_strrpos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("strrpos", count, 2, 3, 1);
  if (count <= 2) return (f_strrpos(a0, a1));
  return (f_strrpos(a0, a1, a2));
}
Variant i_array_diff_assoc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_diff_assoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff_assoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_diff_assoc(count, arg0, arg1));
    return (f_array_diff_assoc(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_array_diff_assoc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("array_diff_assoc", count+1, 1);
  if (count <= 2) return (f_array_diff_assoc(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_diff_assoc(count,a0, a1, params));
}
Variant i_magickclippathimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickclippathimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickclippathimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickclippathimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickclippathimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magickclippathimage", count, 3, 3, 1);
  return (f_magickclippathimage(a0, a1, a2));
}
Variant i_xmlwriter_write_element(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_element);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("xmlwriter_write_element", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_xmlwriter_write_element(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_element(arg0, arg1, arg2));
  }
}
Variant ifa_xmlwriter_write_element(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("xmlwriter_write_element", count, 2, 3, 1);
  if (count <= 2) return (f_xmlwriter_write_element(a0, a1));
  return (f_xmlwriter_write_element(a0, a1, a2));
}
Variant i_dom_document_schema_validate_xml(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_schema_validate_xml);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_schema_validate_xml", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_schema_validate_xml(arg0, arg1));
  }
}
Variant ifa_dom_document_schema_validate_xml(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_schema_validate_xml", count, 2, 2, 1);
  return (f_dom_document_schema_validate_xml(a0, a1));
}
Variant i_ereg(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ereg);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("ereg", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_ereg(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_ereg(arg0, arg1, arg2));
  }
}
Variant ifa_ereg(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("ereg", count, 2, 3, 1);
  if (count <= 2) return (f_ereg(a0, a1));
  return (f_ereg(a0, a1, ref(a2)));
}
Variant i_curl_multi_info_read(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_multi_info_read);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_multi_info_read", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_curl_multi_info_read(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_curl_multi_info_read(arg0, arg1));
  }
}
Variant ifa_curl_multi_info_read(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_multi_info_read", count, 1, 2, 1);
  if (count <= 1) return (f_curl_multi_info_read(a0));
  return (f_curl_multi_info_read(a0, ref(a1)));
}
Variant i_magickthresholdimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickthresholdimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickthresholdimage", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickthresholdimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickthresholdimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickthresholdimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("magickthresholdimage", count, 2, 3, 1);
  if (count <= 2) return (f_magickthresholdimage(a0, a1));
  return (f_magickthresholdimage(a0, a1, a2));
}
Variant i_msg_remove_queue(void *extra, CArrRef params) {
  FUNCTION_INJECTION(msg_remove_queue);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("msg_remove_queue", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_msg_remove_queue(arg0));
  }
}
Variant ifa_msg_remove_queue(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("msg_remove_queue", count, 1, 1, 1);
  return (f_msg_remove_queue(a0));
}
Variant i_mb_strlen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strlen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strlen", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_strlen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strlen(arg0, arg1));
  }
}
Variant ifa_mb_strlen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strlen", count, 1, 2, 1);
  if (count <= 1) return (f_mb_strlen(a0));
  return (f_mb_strlen(a0, a1));
}
Variant i_drawgetclippath(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetclippath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetclippath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetclippath(arg0));
  }
}
Variant ifa_drawgetclippath(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetclippath", count, 1, 1, 1);
  return (f_drawgetclippath(a0));
}
Variant i_imagecopy(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecopy);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagecopy", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecopy(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant ifa_imagecopy(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 8) return throw_wrong_arguments("imagecopy", count, 8, 8, 1);
  return (f_imagecopy(a0, a1, a2, a3, a4, a5, null, null));
}
Variant i_pixelsetcolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetcolor(arg0, arg1), null);
  }
}
Variant ifa_pixelsetcolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetcolor", count, 2, 2, 1);
  return (f_pixelsetcolor(a0, a1), null);
}
Variant i_time_sleep_until(void *extra, CArrRef params) {
  FUNCTION_INJECTION(time_sleep_until);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("time_sleep_until", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_time_sleep_until(arg0));
  }
}
Variant ifa_time_sleep_until(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("time_sleep_until", count, 1, 1, 1);
  return (f_time_sleep_until(a0));
}
Variant i_session_unset(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_unset);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_unset", 0, 1);
  return (f_session_unset());
}
Variant ifa_session_unset(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("session_unset", 0, 1);
  return (f_session_unset());
}
Variant i_mb_ereg_replace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("mb_ereg_replace", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mb_ereg_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_replace(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_ereg_replace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("mb_ereg_replace", count, 3, 4, 1);
  if (count <= 3) return (f_mb_ereg_replace(a0, a1, a2));
  return (f_mb_ereg_replace(a0, a1, a2, a3));
}
Variant i_openssl_csr_get_public_key(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_get_public_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_csr_get_public_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_csr_get_public_key(arg0));
  }
}
Variant ifa_openssl_csr_get_public_key(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("openssl_csr_get_public_key", count, 1, 1, 1);
  return (f_openssl_csr_get_public_key(a0));
}
Variant i_magickfximage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickfximage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickfximage", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickfximage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickfximage(arg0, arg1, arg2));
  }
}
Variant ifa_magickfximage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("magickfximage", count, 2, 3, 1);
  if (count <= 2) return (f_magickfximage(a0, a1));
  return (f_magickfximage(a0, a1, a2));
}
Variant i_tmpfile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(tmpfile);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("tmpfile", 0, 1);
  return (f_tmpfile());
}
Variant ifa_tmpfile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("tmpfile", 0, 1);
  return (f_tmpfile());
}
Variant i_hash(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hash);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_hash(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash(arg0, arg1, arg2));
  }
}
Variant ifa_hash(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("hash", count, 2, 3, 1);
  if (count <= 2) return (f_hash(a0, a1));
  return (f_hash(a0, a1, a2));
}
Variant i_uasort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(uasort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("uasort", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_uasort(arg0, arg1));
  }
}
Variant ifa_uasort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("uasort", count, 2, 2, 1);
  return (f_uasort(ref(a0), a1));
}
Variant i_pixelgetalpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetalpha", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetalpha(arg0));
  }
}
Variant ifa_pixelgetalpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetalpha", count, 1, 1, 1);
  return (f_pixelgetalpha(a0));
}
Variant i_drawsettextencoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsettextencoding);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextencoding", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsettextencoding(arg0, arg1), null);
  }
}
Variant ifa_drawsettextencoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsettextencoding", count, 2, 2, 1);
  return (f_drawsettextencoding(a0, a1), null);
}
Variant i_apache_request_headers(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apache_request_headers);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_request_headers", 0, 1);
  return (f_apache_request_headers());
}
Variant ifa_apache_request_headers(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("apache_request_headers", 0, 1);
  return (f_apache_request_headers());
}
Variant i_is_subclass_of(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_subclass_of);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("is_subclass_of", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_is_subclass_of(arg0, arg1));
  }
}
Variant ifa_is_subclass_of(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("is_subclass_of", count, 2, 2, 1);
  return (f_is_subclass_of(a0, a1));
}
Variant i_pixelgetmagentaquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetmagentaquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetmagentaquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetmagentaquantum(arg0));
  }
}
Variant ifa_pixelgetmagentaquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetmagentaquantum", count, 1, 1, 1);
  return (f_pixelgetmagentaquantum(a0));
}
Variant i_hphp_get_static_property(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_get_static_property);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_get_static_property", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_get_static_property(arg0, arg1));
  }
}
Variant ifa_hphp_get_static_property(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_get_static_property", count, 2, 2, 1);
  return (f_hphp_get_static_property(a0, a1));
}
Variant i_array_pop(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_pop);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_pop", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_array_pop(arg0));
  }
}
Variant ifa_array_pop(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("array_pop", count, 1, 1, 1);
  return (f_array_pop(ref(a0)));
}
Variant i_magickgetimagecolors(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecolors);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecolors", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagecolors(arg0));
  }
}
Variant ifa_magickgetimagecolors(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagecolors", count, 1, 1, 1);
  return (f_magickgetimagecolors(a0));
}
Variant i_session_regenerate_id(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_regenerate_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_regenerate_id", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_regenerate_id());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_regenerate_id(arg0));
  }
}
Variant ifa_session_regenerate_id(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("session_regenerate_id", 1, 1);
  if (count <= 0) return (f_session_regenerate_id());
  return (f_session_regenerate_id(a0));
}
Variant i_class_exists(void *extra, CArrRef params) {
  FUNCTION_INJECTION(class_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_exists", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_class_exists(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_class_exists(arg0, arg1));
  }
}
Variant ifa_class_exists(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("class_exists", count, 1, 2, 1);
  if (count <= 1) return (f_class_exists(a0));
  return (f_class_exists(a0, a1));
}
Variant i_getallheaders(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getallheaders);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getallheaders", 0, 1);
  return (f_getallheaders());
}
Variant ifa_getallheaders(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("getallheaders", 0, 1);
  return (f_getallheaders());
}
Variant i_get_extension_funcs(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_extension_funcs);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_extension_funcs", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_extension_funcs(arg0));
  }
}
Variant ifa_get_extension_funcs(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("get_extension_funcs", count, 1, 1, 1);
  return (f_get_extension_funcs(a0));
}
Variant i_imagecolordeallocate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolordeallocate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolordeallocate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolordeallocate(arg0, arg1));
  }
}
Variant ifa_imagecolordeallocate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagecolordeallocate", count, 2, 2, 1);
  return (f_imagecolordeallocate(a0, a1));
}
Variant i_closelog(void *extra, CArrRef params) {
  FUNCTION_INJECTION(closelog);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("closelog", 0, 1);
  return (f_closelog());
}
Variant ifa_closelog(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("closelog", 0, 1);
  return (f_closelog());
}
Variant i_drawpathlinetoabsolute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetoabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathlinetoabsolute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetoabsolute(arg0, arg1, arg2), null);
  }
}
Variant ifa_drawpathlinetoabsolute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("drawpathlinetoabsolute", count, 3, 3, 1);
  return (f_drawpathlinetoabsolute(a0, a1, a2), null);
}
Variant i_mcrypt_enc_get_iv_size(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_iv_size);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_iv_size", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_iv_size(arg0));
  }
}
Variant ifa_mcrypt_enc_get_iv_size(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_iv_size", count, 1, 1, 1);
  return (f_mcrypt_enc_get_iv_size(a0));
}
Variant i_json_decode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(json_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("json_decode", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_json_decode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_json_decode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_json_decode(arg0, arg1, arg2));
  }
}
Variant ifa_json_decode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("json_decode", count, 1, 3, 1);
  if (count <= 1) return (f_json_decode(a0));
  if (count == 2) return (f_json_decode(a0, a1));
  return (f_json_decode(a0, a1, a2));
}
Variant i_preg_replace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(preg_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_replace", count, 3, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_preg_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_preg_replace(arg0, arg1, arg2, arg3));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_preg_replace(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_preg_replace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_replace", count, 3, 5, 1);
  if (count <= 3) return (f_preg_replace(a0, a1, a2));
  if (count == 4) return (f_preg_replace(a0, a1, a2, a3));
  return (f_preg_replace(a0, a1, a2, a3, ref(a4)));
}
Variant i_hphp_splfileinfo_getmtime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getmtime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getmtime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getmtime(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getmtime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getmtime", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getmtime(a0));
}
Variant i_fmod(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fmod);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fmod", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fmod(arg0, arg1));
  }
}
Variant ifa_fmod(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("fmod", count, 2, 2, 1);
  return (f_fmod(a0, a1));
}
Variant i_curl_errno(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_errno);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_errno", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_errno(arg0));
  }
}
Variant ifa_curl_errno(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("curl_errno", count, 1, 1, 1);
  return (f_curl_errno(a0));
}
Variant i_pagelet_server_task_start(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pagelet_server_task_start);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pagelet_server_task_start", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pagelet_server_task_start(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_pagelet_server_task_start(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pagelet_server_task_start(arg0, arg1, arg2));
  }
}
Variant ifa_pagelet_server_task_start(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("pagelet_server_task_start", count, 1, 3, 1);
  if (count <= 1) return (f_pagelet_server_task_start(a0));
  if (count == 2) return (f_pagelet_server_task_start(a0, a1));
  return (f_pagelet_server_task_start(a0, a1, a2));
}
Variant i_hash_init(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hash_init);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("hash_init", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_hash_init(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_hash_init(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_init(arg0, arg1, arg2));
  }
}
Variant ifa_hash_init(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("hash_init", count, 1, 3, 1);
  if (count <= 1) return (f_hash_init(a0));
  if (count == 2) return (f_hash_init(a0, a1));
  return (f_hash_init(a0, a1, a2));
}
Variant i_mb_strripos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strripos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strripos", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strripos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strripos(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strripos(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_strripos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strripos", count, 2, 4, 1);
  if (count <= 2) return (f_mb_strripos(a0, a1));
  if (count == 3) return (f_mb_strripos(a0, a1, a2));
  return (f_mb_strripos(a0, a1, a2, a3));
}
Variant i_mysql_fetch_row(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_row);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_row", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_fetch_row(arg0));
  }
}
Variant ifa_mysql_fetch_row(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mysql_fetch_row", count, 1, 1, 1);
  return (f_mysql_fetch_row(a0));
}
Variant i_hphp_splfileobject_setcsvcontrol(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_setcsvcontrol);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_setcsvcontrol", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_setcsvcontrol(arg0, arg1, arg2, arg3), null);
  }
}
Variant ifa_hphp_splfileobject_setcsvcontrol(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_setcsvcontrol", count, 4, 4, 1);
  return (f_hphp_splfileobject_setcsvcontrol(a0, a1, a2, a3), null);
}
Variant i_ob_get_flush(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_get_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_flush", 0, 1);
  return (f_ob_get_flush());
}
Variant ifa_ob_get_flush(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("ob_get_flush", 0, 1);
  return (f_ob_get_flush());
}
Variant i_curl_error(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_error);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_error", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_error(arg0));
  }
}
Variant ifa_curl_error(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("curl_error", count, 1, 1, 1);
  return (f_curl_error(a0));
}
Variant i_set_magic_quotes_runtime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(set_magic_quotes_runtime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_magic_quotes_runtime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_set_magic_quotes_runtime(arg0));
  }
}
Variant ifa_set_magic_quotes_runtime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("set_magic_quotes_runtime", count, 1, 1, 1);
  return (f_set_magic_quotes_runtime(a0));
}
Variant i_magickcharcoalimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickcharcoalimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickcharcoalimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcharcoalimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickcharcoalimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magickcharcoalimage", count, 3, 3, 1);
  return (f_magickcharcoalimage(a0, a1, a2));
}
Variant i_scandir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(scandir);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("scandir", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_scandir(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_scandir(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_scandir(arg0, arg1, arg2));
  }
}
Variant ifa_scandir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("scandir", count, 1, 3, 1);
  if (count <= 1) return (f_scandir(a0));
  if (count == 2) return (f_scandir(a0, a1));
  return (f_scandir(a0, a1, a2));
}
Variant i_magickmosaicimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickmosaicimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickmosaicimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickmosaicimages(arg0));
  }
}
Variant ifa_magickmosaicimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickmosaicimages", count, 1, 1, 1);
  return (f_magickmosaicimages(a0));
}
Variant i_timezone_transitions_get(void *extra, CArrRef params) {
  FUNCTION_INJECTION(timezone_transitions_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_transitions_get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_timezone_transitions_get(arg0));
  }
}
Variant ifa_timezone_transitions_get(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("timezone_transitions_get", count, 1, 1, 1);
  return (f_timezone_transitions_get(a0));
}
Variant i_drawsetfontweight(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetfontweight);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontweight", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfontweight(arg0, arg1), null);
  }
}
Variant ifa_drawsetfontweight(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetfontweight", count, 2, 2, 1);
  return (f_drawsetfontweight(a0, a1), null);
}
Variant i_popdrawingwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(popdrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("popdrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_popdrawingwand(arg0), null);
  }
}
Variant ifa_popdrawingwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("popdrawingwand", count, 1, 1, 1);
  return (f_popdrawingwand(a0), null);
}
Variant i_collator_sort_with_sort_keys(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_sort_with_sort_keys);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_sort_with_sort_keys", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_collator_sort_with_sort_keys(arg0, arg1));
  }
}
Variant ifa_collator_sort_with_sort_keys(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("collator_sort_with_sort_keys", count, 2, 2, 1);
  return (f_collator_sort_with_sort_keys(a0, ref(a1)));
}
Variant i_socket_shutdown(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_shutdown);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_shutdown", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_socket_shutdown(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_shutdown(arg0, arg1));
  }
}
Variant ifa_socket_shutdown(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_shutdown", count, 1, 2, 1);
  if (count <= 1) return (f_socket_shutdown(a0));
  return (f_socket_shutdown(a0, a1));
}
Variant i_mcrypt_create_iv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_create_iv);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_create_iv", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_create_iv(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_create_iv(arg0, arg1));
  }
}
Variant ifa_mcrypt_create_iv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_create_iv", count, 1, 2, 1);
  if (count <= 1) return (f_mcrypt_create_iv(a0));
  return (f_mcrypt_create_iv(a0, a1));
}
Variant i_eval(void *extra, CArrRef params) {
  FUNCTION_INJECTION(eval);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("eval", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_eval(arg0));
  }
}
Variant ifa_eval(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("eval", count, 1, 1, 1);
  return (f_eval(a0));
}
Variant i_bindec(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bindec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bindec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_bindec(arg0));
  }
}
Variant ifa_bindec(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("bindec", count, 1, 1, 1);
  return (f_bindec(a0));
}
Variant i_fileperms(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fileperms);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileperms", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fileperms(arg0));
  }
}
Variant ifa_fileperms(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fileperms", count, 1, 1, 1);
  return (f_fileperms(a0));
}
Variant i_hphp_splfileobject_fstat(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fstat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fstat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_fstat(arg0));
  }
}
Variant ifa_hphp_splfileobject_fstat(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fstat", count, 1, 1, 1);
  return (f_hphp_splfileobject_fstat(a0));
}
Variant i_unserialize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(unserialize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("unserialize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_unserialize(arg0));
  }
}
Variant ifa_unserialize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("unserialize", count, 1, 1, 1);
  return (f_unserialize(a0));
}
Variant i_urldecode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(urldecode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("urldecode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_urldecode(arg0));
  }
}
Variant ifa_urldecode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("urldecode", count, 1, 1, 1);
  return (f_urldecode(a0));
}
Variant i_magickannotateimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickannotateimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickannotateimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickannotateimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_magickannotateimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("magickannotateimage", count, 6, 6, 1);
  return (f_magickannotateimage(a0, a1, a2, a3, a4, a5));
}
Variant i_mailparse_msg_create(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_create);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mailparse_msg_create", 0, 1);
  return (f_mailparse_msg_create());
}
Variant ifa_mailparse_msg_create(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("mailparse_msg_create", 0, 1);
  return (f_mailparse_msg_create());
}
Variant i_session_set_cookie_params(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_set_cookie_params);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("session_set_cookie_params", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_session_set_cookie_params(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_session_set_cookie_params(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_session_set_cookie_params(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_session_set_cookie_params(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_session_set_cookie_params(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant ifa_session_set_cookie_params(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 5) return throw_wrong_arguments("session_set_cookie_params", count, 1, 5, 1);
  if (count <= 1) return (f_session_set_cookie_params(a0), null);
  if (count == 2) return (f_session_set_cookie_params(a0, a1), null);
  if (count == 3) return (f_session_set_cookie_params(a0, a1, a2), null);
  if (count == 4) return (f_session_set_cookie_params(a0, a1, a2, a3), null);
  return (f_session_set_cookie_params(a0, a1, a2, a3, a4), null);
}
Variant i_drawellipse(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawellipse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawellipse", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawellipse(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant ifa_drawellipse(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 7) return throw_wrong_arguments("drawellipse", count, 7, 7, 1);
  return (f_drawellipse(a0, a1, a2, a3, a4, a5, null), null);
}
Variant i_xmlwriter_write_element_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_element_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("xmlwriter_write_element_ns", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_xmlwriter_write_element_ns(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_element_ns(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_xmlwriter_write_element_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("xmlwriter_write_element_ns", count, 4, 5, 1);
  if (count <= 4) return (f_xmlwriter_write_element_ns(a0, a1, a2, a3));
  return (f_xmlwriter_write_element_ns(a0, a1, a2, a3, a4));
}
Variant i_magicksetcompressionquality(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetcompressionquality);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetcompressionquality", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetcompressionquality(arg0, arg1));
  }
}
Variant ifa_magicksetcompressionquality(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetcompressionquality", count, 2, 2, 1);
  return (f_magicksetcompressionquality(a0, a1));
}
Variant i_magickaddnoiseimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickaddnoiseimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaddnoiseimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickaddnoiseimage(arg0, arg1));
  }
}
Variant ifa_magickaddnoiseimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickaddnoiseimage", count, 2, 2, 1);
  return (f_magickaddnoiseimage(a0, a1));
}
Variant i_magickgetimagewhitepoint(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagewhitepoint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagewhitepoint", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagewhitepoint(arg0));
  }
}
Variant ifa_magickgetimagewhitepoint(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagewhitepoint", count, 1, 1, 1);
  return (f_magickgetimagewhitepoint(a0));
}
Variant i_magickseparateimagechannel(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickseparateimagechannel);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickseparateimagechannel", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickseparateimagechannel(arg0, arg1));
  }
}
Variant ifa_magickseparateimagechannel(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickseparateimagechannel", count, 2, 2, 1);
  return (f_magickseparateimagechannel(a0, a1));
}
Variant i_array_push(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_push);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_push", count+1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_push(count, arg0, arg1));
    return (f_array_push(count,ref(arg0), arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_array_push(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("array_push", count+1, 1);
  if (count <= 2) return (f_array_push(count, ref(a0), a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_push(count,ref(a0), a1, params));
}
Variant i_flush(void *extra, CArrRef params) {
  FUNCTION_INJECTION(flush);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("flush", 0, 1);
  return (f_flush(), null);
}
Variant ifa_flush(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("flush", 0, 1);
  return (f_flush(), null);
}
Variant i_connection_aborted(void *extra, CArrRef params) {
  FUNCTION_INJECTION(connection_aborted);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_aborted", 0, 1);
  return (f_connection_aborted());
}
Variant ifa_connection_aborted(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("connection_aborted", 0, 1);
  return (f_connection_aborted());
}
Variant i_uksort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(uksort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("uksort", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_uksort(arg0, arg1));
  }
}
Variant ifa_uksort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("uksort", count, 2, 2, 1);
  return (f_uksort(ref(a0), a1));
}
Variant i_mysql_set_timeout(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_set_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mysql_set_timeout", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_set_timeout());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mysql_set_timeout(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_set_timeout(arg0, arg1));
  }
}
Variant ifa_mysql_set_timeout(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("mysql_set_timeout", 2, 1);
  if (count <= 0) return (f_mysql_set_timeout());
  if (count == 1) return (f_mysql_set_timeout(a0));
  return (f_mysql_set_timeout(a0, a1));
}
Variant i_hash_update_stream(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hash_update_stream);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_update_stream", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_hash_update_stream(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_update_stream(arg0, arg1, arg2));
  }
}
Variant ifa_hash_update_stream(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_update_stream", count, 2, 3, 1);
  if (count <= 2) return (f_hash_update_stream(a0, a1));
  return (f_hash_update_stream(a0, a1, a2));
}
Variant i_ob_start(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_start);
  int count __attribute__((__unused__)) = params.size();
  if (count > 3) return throw_toomany_arguments("ob_start", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ob_start());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_ob_start(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_ob_start(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ob_start(arg0, arg1, arg2));
  }
}
Variant ifa_ob_start(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 3) return throw_toomany_arguments("ob_start", 3, 1);
  if (count <= 0) return (f_ob_start());
  if (count == 1) return (f_ob_start(a0));
  if (count == 2) return (f_ob_start(a0, a1));
  return (f_ob_start(a0, a1, a2));
}
Variant i_mysql_get_host_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_get_host_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_host_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_get_host_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_get_host_info(arg0));
  }
}
Variant ifa_mysql_get_host_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_get_host_info", 1, 1);
  if (count <= 0) return (f_mysql_get_host_info());
  return (f_mysql_get_host_info(a0));
}
Variant i_mb_language(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_language);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_language", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_language());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_language(arg0));
  }
}
Variant ifa_mb_language(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mb_language", 1, 1);
  if (count <= 0) return (f_mb_language());
  return (f_mb_language(a0));
}
Variant i_pixelgetnextiteratorrow(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetnextiteratorrow);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetnextiteratorrow", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetnextiteratorrow(arg0));
  }
}
Variant ifa_pixelgetnextiteratorrow(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetnextiteratorrow", count, 1, 1, 1);
  return (f_pixelgetnextiteratorrow(a0));
}
Variant i_ldap_next_reference(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_next_reference);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_reference", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_next_reference(arg0, arg1));
  }
}
Variant ifa_ldap_next_reference(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_next_reference", count, 2, 2, 1);
  return (f_ldap_next_reference(a0, a1));
}
Variant i_socket_get_status(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_get_status);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_get_status", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_get_status(arg0));
  }
}
Variant ifa_socket_get_status(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("socket_get_status", count, 1, 1, 1);
  return (f_socket_get_status(a0));
}
Variant i_checkdnsrr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(checkdnsrr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("checkdnsrr", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_checkdnsrr(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_checkdnsrr(arg0, arg1));
  }
}
Variant ifa_checkdnsrr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("checkdnsrr", count, 1, 2, 1);
  if (count <= 1) return (f_checkdnsrr(a0));
  return (f_checkdnsrr(a0, a1));
}
Variant i_openssl_verify(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_verify);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_verify", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_verify(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_verify(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_verify(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_verify", count, 3, 4, 1);
  if (count <= 3) return (f_openssl_verify(a0, a1, a2));
  return (f_openssl_verify(a0, a1, a2, a3));
}
Variant i_curl_exec(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_exec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_exec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_exec(arg0));
  }
}
Variant ifa_curl_exec(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("curl_exec", count, 1, 1, 1);
  return (f_curl_exec(a0));
}
Variant i_magickgetexceptiontype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetexceptiontype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexceptiontype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetexceptiontype(arg0));
  }
}
Variant ifa_magickgetexceptiontype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetexceptiontype", count, 1, 1, 1);
  return (f_magickgetexceptiontype(a0));
}
Variant i_array_sum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_sum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_sum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_sum(arg0));
  }
}
Variant ifa_array_sum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("array_sum", count, 1, 1, 1);
  return (f_array_sum(a0));
}
Variant i_unregister_tick_function(void *extra, CArrRef params) {
  FUNCTION_INJECTION(unregister_tick_function);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("unregister_tick_function", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_unregister_tick_function(arg0), null);
  }
}
Variant ifa_unregister_tick_function(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("unregister_tick_function", count, 1, 1, 1);
  return (f_unregister_tick_function(a0), null);
}
Variant i_newpixelwandarray(void *extra, CArrRef params) {
  FUNCTION_INJECTION(newpixelwandarray);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixelwandarray", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_newpixelwandarray(arg0));
  }
}
Variant ifa_newpixelwandarray(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("newpixelwandarray", count, 1, 1, 1);
  return (f_newpixelwandarray(a0));
}
Variant i_magickgetversion(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetversion);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversion", 0, 1);
  return (f_magickgetversion());
}
Variant ifa_magickgetversion(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("magickgetversion", 0, 1);
  return (f_magickgetversion());
}
Variant i_imagelayereffect(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagelayereffect);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagelayereffect", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagelayereffect(arg0, arg1));
  }
}
Variant ifa_imagelayereffect(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagelayereffect", count, 2, 2, 1);
  return (f_imagelayereffect(a0, a1));
}
Variant i_glob(void *extra, CArrRef params) {
  FUNCTION_INJECTION(glob);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("glob", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_glob(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_glob(arg0, arg1));
  }
}
Variant ifa_glob(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("glob", count, 1, 2, 1);
  if (count <= 1) return (f_glob(a0));
  return (f_glob(a0, a1));
}
Variant i_exec(void *extra, CArrRef params) {
  FUNCTION_INJECTION(exec);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("exec", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_exec(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_exec(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_exec(arg0, arg1, arg2));
  }
}
Variant ifa_exec(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("exec", count, 1, 3, 1);
  if (count <= 1) return (f_exec(a0));
  if (count == 2) return (f_exec(a0, ref(a1)));
  return (f_exec(a0, ref(a1), ref(a2)));
}
Variant i_apd_continue(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apd_continue);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_continue", 0, 1);
  return (f_apd_continue());
}
Variant ifa_apd_continue(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("apd_continue", 0, 1);
  return (f_apd_continue());
}
Variant i_magickgetimagedepth(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagedepth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickgetimagedepth", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magickgetimagedepth(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimagedepth(arg0, arg1));
  }
}
Variant ifa_magickgetimagedepth(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("magickgetimagedepth", count, 1, 2, 1);
  if (count <= 1) return (f_magickgetimagedepth(a0));
  return (f_magickgetimagedepth(a0, a1));
}
Variant i_pclose(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pclose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pclose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pclose(arg0));
  }
}
Variant ifa_pclose(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pclose", count, 1, 1, 1);
  return (f_pclose(a0));
}
Variant i_get_parent_class(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_parent_class);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_parent_class", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_parent_class());
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_parent_class(arg0));
  }
}
Variant ifa_get_parent_class(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("get_parent_class", 1, 1);
  if (count <= 0) return (f_get_parent_class());
  return (f_get_parent_class(a0));
}
Variant i_mb_strpos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strpos", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strpos(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strpos(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_strpos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strpos", count, 2, 4, 1);
  if (count <= 2) return (f_mb_strpos(a0, a1));
  if (count == 3) return (f_mb_strpos(a0, a1, a2));
  return (f_mb_strpos(a0, a1, a2, a3));
}
Variant i_xmlwriter_write_dtd_attlist(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_dtd_attlist);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_dtd_attlist", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_dtd_attlist(arg0, arg1, arg2));
  }
}
Variant ifa_xmlwriter_write_dtd_attlist(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_dtd_attlist", count, 3, 3, 1);
  return (f_xmlwriter_write_dtd_attlist(a0, a1, a2));
}
Variant i_xml_set_element_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_set_element_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xml_set_element_handler", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_element_handler(arg0, arg1, arg2));
  }
}
Variant ifa_xml_set_element_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("xml_set_element_handler", count, 3, 3, 1);
  return (f_xml_set_element_handler(a0, a1, a2));
}
Variant i_drawgetstrokeopacity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokeopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokeopacity", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokeopacity(arg0));
  }
}
Variant ifa_drawgetstrokeopacity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetstrokeopacity", count, 1, 1, 1);
  return (f_drawgetstrokeopacity(a0));
}
Variant i_ldap_get_entries(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_get_entries);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_entries", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_get_entries(arg0, arg1));
  }
}
Variant ifa_ldap_get_entries(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_get_entries", count, 2, 2, 1);
  return (f_ldap_get_entries(a0, a1));
}
Variant i_ob_iconv_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_iconv_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ob_iconv_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ob_iconv_handler(arg0, arg1));
  }
}
Variant ifa_ob_iconv_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ob_iconv_handler", count, 2, 2, 1);
  return (f_ob_iconv_handler(a0, a1));
}
Variant i_hphp_throw_fatal_error(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_throw_fatal_error);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_throw_fatal_error", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_throw_fatal_error(arg0), null);
  }
}
Variant ifa_hphp_throw_fatal_error(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_throw_fatal_error", count, 1, 1, 1);
  return (f_hphp_throw_fatal_error(a0), null);
}
Variant i_pathinfo(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pathinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("pathinfo", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pathinfo(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pathinfo(arg0, arg1));
  }
}
Variant ifa_pathinfo(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("pathinfo", count, 1, 2, 1);
  if (count <= 1) return (f_pathinfo(a0));
  return (f_pathinfo(a0, a1));
}
Variant i_magickaffinetransformimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickaffinetransformimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaffinetransformimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickaffinetransformimage(arg0, arg1));
  }
}
Variant ifa_magickaffinetransformimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickaffinetransformimage", count, 2, 2, 1);
  return (f_magickaffinetransformimage(a0, a1));
}
Variant i_fb_stubout_intercept_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_stubout_intercept_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("fb_stubout_intercept_handler", count, 5, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_fb_stubout_intercept_handler(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_fb_stubout_intercept_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("fb_stubout_intercept_handler", count, 5, 5, 1);
  return (f_fb_stubout_intercept_handler(a0, a1, a2, a3, ref(a4)));
}
Variant i_ob_get_status(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_get_status);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ob_get_status", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ob_get_status());
    CVarRef arg0((ad->getValue(pos)));
    return (f_ob_get_status(arg0));
  }
}
Variant ifa_ob_get_status(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("ob_get_status", 1, 1);
  if (count <= 0) return (f_ob_get_status());
  return (f_ob_get_status(a0));
}
Variant i_collator_create(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_create);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_create", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_collator_create(arg0));
  }
}
Variant ifa_collator_create(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("collator_create", count, 1, 1, 1);
  return (f_collator_create(a0));
}
Variant i_exit(void *extra, CArrRef params) {
  FUNCTION_INJECTION(exit);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("exit", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_exit());
    CVarRef arg0((ad->getValue(pos)));
    return (f_exit(arg0));
  }
}
Variant ifa_exit(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("exit", 1, 1);
  if (count <= 0) return (f_exit());
  return (f_exit(a0));
}
Variant i_memcache_debug(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_debug);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_debug", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_memcache_debug(arg0));
  }
}
Variant ifa_memcache_debug(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("memcache_debug", count, 1, 1, 1);
  return (f_memcache_debug(a0));
}
Variant i_apc_sma_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_sma_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("apc_sma_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_apc_sma_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_apc_sma_info(arg0));
  }
}
Variant ifa_apc_sma_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("apc_sma_info", 1, 1);
  if (count <= 0) return (f_apc_sma_info());
  return (f_apc_sma_info(a0));
}
Variant i_ldap_bind(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_bind);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("ldap_bind", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_ldap_bind(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_ldap_bind(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_bind(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_bind(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("ldap_bind", count, 1, 3, 1);
  if (count <= 1) return (f_ldap_bind(a0));
  if (count == 2) return (f_ldap_bind(a0, a1));
  return (f_ldap_bind(a0, a1, a2));
}
Variant i_pixelsetbluequantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetbluequantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetbluequantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetbluequantum(arg0, arg1), null);
  }
}
Variant ifa_pixelsetbluequantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetbluequantum", count, 2, 2, 1);
  return (f_pixelsetbluequantum(a0, a1), null);
}
Variant i_magickreadimagefile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickreadimagefile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimagefile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickreadimagefile(arg0, arg1));
  }
}
Variant ifa_magickreadimagefile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickreadimagefile", count, 2, 2, 1);
  return (f_magickreadimagefile(a0, a1));
}
Variant i_session_is_registered(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_is_registered);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_is_registered", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_is_registered(arg0));
  }
}
Variant ifa_session_is_registered(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("session_is_registered", count, 1, 1, 1);
  return (f_session_is_registered(a0));
}
Variant i_mysql_real_escape_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_real_escape_string);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_real_escape_string", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_real_escape_string(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_real_escape_string(arg0, arg1));
  }
}
Variant ifa_mysql_real_escape_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_real_escape_string", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_real_escape_string(a0));
  return (f_mysql_real_escape_string(a0, a1));
}
Variant i_magickframeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickframeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickframeimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickframeimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_magickframeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("magickframeimage", count, 6, 6, 1);
  return (f_magickframeimage(a0, a1, a2, a3, a4, a5));
}
Variant i_pixelgetblue(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetblue);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblue", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetblue(arg0));
  }
}
Variant ifa_pixelgetblue(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetblue", count, 1, 1, 1);
  return (f_pixelgetblue(a0));
}
Variant i_imagefill(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagefill);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagefill", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefill(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagefill(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("imagefill", count, 4, 4, 1);
  return (f_imagefill(a0, a1, a2, a3));
}
Variant i_hphp_set_property(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_set_property);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_set_property", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_set_property(arg0, arg1, arg2, arg3), null);
  }
}
Variant ifa_hphp_set_property(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("hphp_set_property", count, 4, 4, 1);
  return (f_hphp_set_property(a0, a1, a2, a3), null);
}
Variant i_readgzfile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(readgzfile);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("readgzfile", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_readgzfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_readgzfile(arg0, arg1));
  }
}
Variant ifa_readgzfile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("readgzfile", count, 1, 2, 1);
  if (count <= 1) return (f_readgzfile(a0));
  return (f_readgzfile(a0, a1));
}
Variant i_memcache_set(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_set);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_set", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_memcache_set(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_memcache_set(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_set(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_memcache_set(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_set", count, 3, 5, 1);
  if (count <= 3) return (f_memcache_set(a0, a1, a2));
  if (count == 4) return (f_memcache_set(a0, a1, a2, a3));
  return (f_memcache_set(a0, a1, a2, a3, a4));
}
Variant i_magicksampleimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksampleimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksampleimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksampleimage(arg0, arg1, arg2));
  }
}
Variant ifa_magicksampleimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksampleimage", count, 3, 3, 1);
  return (f_magicksampleimage(a0, a1, a2));
}
Variant i_mysql_escape_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_escape_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_escape_string", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_escape_string(arg0));
  }
}
Variant ifa_mysql_escape_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mysql_escape_string", count, 1, 1, 1);
  return (f_mysql_escape_string(a0));
}
Variant i_idn_to_utf8(void *extra, CArrRef params) {
  FUNCTION_INJECTION(idn_to_utf8);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_utf8", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_idn_to_utf8(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_idn_to_utf8(arg0, arg1));
  }
}
Variant ifa_idn_to_utf8(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_utf8", count, 1, 2, 1);
  if (count <= 1) return (f_idn_to_utf8(a0));
  return (f_idn_to_utf8(a0, ref(a1)));
}
Variant i_sql_regcase(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sql_regcase);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sql_regcase", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sql_regcase(arg0));
  }
}
Variant ifa_sql_regcase(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("sql_regcase", count, 1, 1, 1);
  return (f_sql_regcase(a0));
}
Variant i_in_array(void *extra, CArrRef params) {
  FUNCTION_INJECTION(in_array);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("in_array", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_in_array(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_in_array(arg0, arg1, arg2));
  }
}
Variant ifa_in_array(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("in_array", count, 2, 3, 1);
  if (count <= 2) return (f_in_array(a0, a1));
  return (f_in_array(a0, a1, a2));
}
Variant i_drawpathcurvetoquadraticbezierabsolute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetoquadraticbezierabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetoquadraticbezierabsolute", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetoquadraticbezierabsolute(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant ifa_drawpathcurvetoquadraticbezierabsolute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("drawpathcurvetoquadraticbezierabsolute", count, 5, 5, 1);
  return (f_drawpathcurvetoquadraticbezierabsolute(a0, a1, a2, a3, a4), null);
}
Variant i_socket_set_timeout(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_set_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_set_timeout", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_set_timeout(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_set_timeout(arg0, arg1, arg2));
  }
}
Variant ifa_socket_set_timeout(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_set_timeout", count, 2, 3, 1);
  if (count <= 2) return (f_socket_set_timeout(a0, a1));
  return (f_socket_set_timeout(a0, a1, a2));
}
Variant i_bin2hex(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bin2hex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bin2hex", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_bin2hex(arg0));
  }
}
Variant ifa_bin2hex(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("bin2hex", count, 1, 1, 1);
  return (f_bin2hex(a0));
}
Variant i_error_get_last(void *extra, CArrRef params) {
  FUNCTION_INJECTION(error_get_last);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("error_get_last", 0, 1);
  return (f_error_get_last());
}
Variant ifa_error_get_last(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("error_get_last", 0, 1);
  return (f_error_get_last());
}
Variant i_is_link(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_link);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_link", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_link(arg0));
  }
}
Variant ifa_is_link(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_link", count, 1, 1, 1);
  return (f_is_link(a0));
}
Variant i_set_file_buffer(void *extra, CArrRef params) {
  FUNCTION_INJECTION(set_file_buffer);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("set_file_buffer", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_set_file_buffer(arg0, arg1));
  }
}
Variant ifa_set_file_buffer(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("set_file_buffer", count, 2, 2, 1);
  return (f_set_file_buffer(a0, a1));
}
Variant i_magicksetimageredprimary(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimageredprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageredprimary", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageredprimary(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetimageredprimary(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksetimageredprimary", count, 3, 3, 1);
  return (f_magicksetimageredprimary(a0, a1, a2));
}
Variant i_i18n_loc_set_default(void *extra, CArrRef params) {
  FUNCTION_INJECTION(i18n_loc_set_default);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("i18n_loc_set_default", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_i18n_loc_set_default(arg0));
  }
}
Variant ifa_i18n_loc_set_default(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("i18n_loc_set_default", count, 1, 1, 1);
  return (f_i18n_loc_set_default(a0));
}
Variant i_ftok(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ftok);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ftok", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ftok(arg0, arg1));
  }
}
Variant ifa_ftok(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ftok", count, 2, 2, 1);
  return (f_ftok(a0, a1));
}
Variant i_mysql_list_fields(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_list_fields);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_list_fields", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mysql_list_fields(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_list_fields(arg0, arg1, arg2));
  }
}
Variant ifa_mysql_list_fields(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_list_fields", count, 2, 3, 1);
  if (count <= 2) return (f_mysql_list_fields(a0, a1));
  return (f_mysql_list_fields(a0, a1, a2));
}
Variant i_stream_wrapper_register(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_wrapper_register);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_wrapper_register", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_wrapper_register(arg0, arg1));
  }
}
Variant ifa_stream_wrapper_register(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stream_wrapper_register", count, 2, 2, 1);
  return (f_stream_wrapper_register(a0, a1));
}
Variant i_pixelsetredquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetredquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetredquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetredquantum(arg0, arg1), null);
  }
}
Variant ifa_pixelsetredquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetredquantum", count, 2, 2, 1);
  return (f_pixelsetredquantum(a0, a1), null);
}
Variant i_xhprof_disable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xhprof_disable);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_disable", 0, 1);
  return (f_xhprof_disable());
}
Variant ifa_xhprof_disable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("xhprof_disable", 0, 1);
  return (f_xhprof_disable());
}
Variant i_magickgammaimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgammaimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickgammaimage", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickgammaimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgammaimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickgammaimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("magickgammaimage", count, 2, 3, 1);
  if (count <= 2) return (f_magickgammaimage(a0, a1));
  return (f_magickgammaimage(a0, a1, a2));
}
Variant i_pixelsetcyan(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetcyan);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcyan", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetcyan(arg0, arg1), null);
  }
}
Variant ifa_pixelsetcyan(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetcyan", count, 2, 2, 1);
  return (f_pixelsetcyan(a0, a1), null);
}
Variant i_mb_decode_mimeheader(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_decode_mimeheader);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_decode_mimeheader", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_decode_mimeheader(arg0));
  }
}
Variant ifa_mb_decode_mimeheader(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mb_decode_mimeheader", count, 1, 1, 1);
  return (f_mb_decode_mimeheader(a0));
}
Variant i_key_exists(void *extra, CArrRef params) {
  FUNCTION_INJECTION(key_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("key_exists", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_key_exists(arg0, arg1));
  }
}
Variant ifa_key_exists(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("key_exists", count, 2, 2, 1);
  return (f_key_exists(a0, a1));
}
Variant i_htmlentities(void *extra, CArrRef params) {
  FUNCTION_INJECTION(htmlentities);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("htmlentities", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_htmlentities(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_htmlentities(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_htmlentities(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_htmlentities(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_htmlentities(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("htmlentities", count, 1, 4, 1);
  if (count <= 1) return (f_htmlentities(a0));
  if (count == 2) return (f_htmlentities(a0, a1));
  if (count == 3) return (f_htmlentities(a0, a1, a2));
  return (f_htmlentities(a0, a1, a2, a3));
}
Variant i_rad2deg(void *extra, CArrRef params) {
  FUNCTION_INJECTION(rad2deg);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rad2deg", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_rad2deg(arg0));
  }
}
Variant ifa_rad2deg(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("rad2deg", count, 1, 1, 1);
  return (f_rad2deg(a0));
}
Variant i_xmlwriter_start_dtd(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_dtd);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("xmlwriter_start_dtd", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_xmlwriter_start_dtd(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_xmlwriter_start_dtd(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_dtd(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_xmlwriter_start_dtd(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("xmlwriter_start_dtd", count, 2, 4, 1);
  if (count <= 2) return (f_xmlwriter_start_dtd(a0, a1));
  if (count == 3) return (f_xmlwriter_start_dtd(a0, a1, a2));
  return (f_xmlwriter_start_dtd(a0, a1, a2, a3));
}
Variant i_drawpathstart(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathstart);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathstart", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpathstart(arg0), null);
  }
}
Variant ifa_drawpathstart(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawpathstart", count, 1, 1, 1);
  return (f_drawpathstart(a0), null);
}
Variant i_proc_nice(void *extra, CArrRef params) {
  FUNCTION_INJECTION(proc_nice);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_nice", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_proc_nice(arg0));
  }
}
Variant ifa_proc_nice(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("proc_nice", count, 1, 1, 1);
  return (f_proc_nice(a0));
}
Variant i_hphp_thread_is_warmup_enabled(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_thread_is_warmup_enabled);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_thread_is_warmup_enabled", 0, 1);
  return (f_hphp_thread_is_warmup_enabled());
}
Variant ifa_hphp_thread_is_warmup_enabled(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("hphp_thread_is_warmup_enabled", 0, 1);
  return (f_hphp_thread_is_warmup_enabled());
}
Variant i_mysql_pconnect_with_db(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_pconnect_with_db);
  int count __attribute__((__unused__)) = params.size();
  if (count > 7) return throw_toomany_arguments("mysql_pconnect_with_db", 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_pconnect_with_db());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mysql_pconnect_with_db(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mysql_pconnect_with_db(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mysql_pconnect_with_db(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mysql_pconnect_with_db(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_mysql_pconnect_with_db(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_mysql_pconnect_with_db(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_pconnect_with_db(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant ifa_mysql_pconnect_with_db(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 7) return throw_toomany_arguments("mysql_pconnect_with_db", 7, 1);
  if (count <= 0) return (f_mysql_pconnect_with_db());
  if (count == 1) return (f_mysql_pconnect_with_db(a0));
  if (count == 2) return (f_mysql_pconnect_with_db(a0, a1));
  if (count == 3) return (f_mysql_pconnect_with_db(a0, a1, a2));
  if (count == 4) return (f_mysql_pconnect_with_db(a0, a1, a2, a3));
  if (count == 5) return (f_mysql_pconnect_with_db(a0, a1, a2, a3, a4));
  return (f_mysql_pconnect_with_db(a0, a1, a2, a3, a4, a5));
}
Variant i_imagepsslantfont(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagepsslantfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsslantfont", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepsslantfont(arg0, arg1));
  }
}
Variant ifa_imagepsslantfont(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagepsslantfont", count, 2, 2, 1);
  return (f_imagepsslantfont(a0, a1));
}
Variant i_magickgetimagemattecolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagemattecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagemattecolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagemattecolor(arg0));
  }
}
Variant ifa_magickgetimagemattecolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagemattecolor", count, 1, 1, 1);
  return (f_magickgetimagemattecolor(a0));
}
Variant i_mb_strstr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strstr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strstr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strstr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strstr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strstr(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_strstr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strstr", count, 2, 4, 1);
  if (count <= 2) return (f_mb_strstr(a0, a1));
  if (count == 3) return (f_mb_strstr(a0, a1, a2));
  return (f_mb_strstr(a0, a1, a2, a3));
}
Variant i_pixelgetblack(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetblack);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblack", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetblack(arg0));
  }
}
Variant ifa_pixelgetblack(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetblack", count, 1, 1, 1);
  return (f_pixelgetblack(a0));
}
Variant i_mysql_field_table(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_field_table);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_table", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_table(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_table(arg0, arg1));
  }
}
Variant ifa_mysql_field_table(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_table", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_field_table(a0));
  return (f_mysql_field_table(a0, a1));
}
Variant i_magicksetimagescene(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagescene);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagescene", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagescene(arg0, arg1));
  }
}
Variant ifa_magicksetimagescene(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagescene", count, 2, 2, 1);
  return (f_magicksetimagescene(a0, a1));
}
Variant i_magickgetimagerenderingintent(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagerenderingintent);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagerenderingintent", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagerenderingintent(arg0));
  }
}
Variant ifa_magickgetimagerenderingintent(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagerenderingintent", count, 1, 1, 1);
  return (f_magickgetimagerenderingintent(a0));
}
Variant i_setlocale(void *extra, CArrRef params) {
  FUNCTION_INJECTION(setlocale);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("setlocale", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_setlocale(count, arg0, arg1));
    return (f_setlocale(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_setlocale(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("setlocale", count+1, 1);
  if (count <= 2) return (f_setlocale(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_setlocale(count,a0, a1, params));
}
Variant i_drawpushclippath(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpushclippath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpushclippath", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpushclippath(arg0, arg1), null);
  }
}
Variant ifa_drawpushclippath(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawpushclippath", count, 2, 2, 1);
  return (f_drawpushclippath(a0, a1), null);
}
Variant i_drawpopclippath(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpopclippath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpopclippath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpopclippath(arg0), null);
  }
}
Variant ifa_drawpopclippath(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawpopclippath", count, 1, 1, 1);
  return (f_drawpopclippath(a0), null);
}
Variant i_nl2br(void *extra, CArrRef params) {
  FUNCTION_INJECTION(nl2br);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("nl2br", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_nl2br(arg0));
  }
}
Variant ifa_nl2br(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("nl2br", count, 1, 1, 1);
  return (f_nl2br(a0));
}
Variant i_hphp_splfileinfo_getperms(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getperms);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getperms", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getperms(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getperms(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getperms", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getperms(a0));
}
Variant i_drawsetfillopacity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetfillopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillopacity", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfillopacity(arg0, arg1), null);
  }
}
Variant ifa_drawsetfillopacity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetfillopacity", count, 2, 2, 1);
  return (f_drawsetfillopacity(a0, a1), null);
}
Variant i_mb_substitute_character(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_substitute_character);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_substitute_character", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_substitute_character());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_substitute_character(arg0));
  }
}
Variant ifa_mb_substitute_character(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mb_substitute_character", 1, 1);
  if (count <= 0) return (f_mb_substitute_character());
  return (f_mb_substitute_character(a0));
}
Variant i_setrawcookie(void *extra, CArrRef params) {
  FUNCTION_INJECTION(setrawcookie);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("setrawcookie", count, 1, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_setrawcookie(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_setrawcookie(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_setrawcookie(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_setrawcookie(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_setrawcookie(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_setrawcookie(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_setrawcookie(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant ifa_setrawcookie(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 7) return throw_wrong_arguments("setrawcookie", count, 1, 7, 1);
  if (count <= 1) return (f_setrawcookie(a0));
  if (count == 2) return (f_setrawcookie(a0, a1));
  if (count == 3) return (f_setrawcookie(a0, a1, a2));
  if (count == 4) return (f_setrawcookie(a0, a1, a2, a3));
  if (count == 5) return (f_setrawcookie(a0, a1, a2, a3, a4));
  return (f_setrawcookie(a0, a1, a2, a3, a4, a5));
}
Variant i_evhttp_get(void *extra, CArrRef params) {
  FUNCTION_INJECTION(evhttp_get);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("evhttp_get", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_evhttp_get(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_evhttp_get(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_evhttp_get(arg0, arg1, arg2));
  }
}
Variant ifa_evhttp_get(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("evhttp_get", count, 1, 3, 1);
  if (count <= 1) return (f_evhttp_get(a0));
  if (count == 2) return (f_evhttp_get(a0, a1));
  return (f_evhttp_get(a0, a1, a2));
}
Variant i_getimagesize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getimagesize);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("getimagesize", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_getimagesize(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_getimagesize(arg0, arg1));
  }
}
Variant ifa_getimagesize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("getimagesize", count, 1, 2, 1);
  if (count <= 1) return (f_getimagesize(a0));
  return (f_getimagesize(a0, ref(a1)));
}
Variant i_ldap_modify(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_modify);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_modify", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_modify(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_modify(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ldap_modify", count, 3, 3, 1);
  return (f_ldap_modify(a0, a1, a2));
}
Variant i_ldap_search(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_search);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_search", count, 3, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_ldap_search(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_ldap_search(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_ldap_search(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_ldap_search(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_ldap_search(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_search(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant ifa_ldap_search(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_search", count, 3, 8, 1);
  if (count <= 3) return (f_ldap_search(a0, a1, a2));
  if (count == 4) return (f_ldap_search(a0, a1, a2, a3));
  if (count == 5) return (f_ldap_search(a0, a1, a2, a3, a4));
  return (f_ldap_search(a0, a1, a2, a3, a4, a5));
}
Variant i_strcasecmp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strcasecmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcasecmp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strcasecmp(arg0, arg1));
  }
}
Variant ifa_strcasecmp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("strcasecmp", count, 2, 2, 1);
  return (f_strcasecmp(a0, a1));
}
Variant i_magickgetimagesignature(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagesignature);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesignature", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagesignature(arg0));
  }
}
Variant ifa_magickgetimagesignature(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagesignature", count, 1, 1, 1);
  return (f_magickgetimagesignature(a0));
}
Variant i_get_class_methods(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_class_methods);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_class_methods", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_class_methods(arg0));
  }
}
Variant ifa_get_class_methods(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("get_class_methods", count, 1, 1, 1);
  return (f_get_class_methods(a0));
}
Variant i_fopen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fopen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("fopen", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fopen(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fopen(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fopen(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_fopen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("fopen", count, 2, 4, 1);
  if (count <= 2) return (f_fopen(a0, a1));
  if (count == 3) return (f_fopen(a0, a1, a2));
  return (f_fopen(a0, a1, a2, a3));
}
Variant i_fb_const_fetch(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_const_fetch);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_const_fetch", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_const_fetch(arg0));
  }
}
Variant ifa_fb_const_fetch(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fb_const_fetch", count, 1, 1, 1);
  return (f_fb_const_fetch(a0));
}
Variant i_mcrypt_generic_end(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_generic_end);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_generic_end", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_generic_end(arg0));
  }
}
Variant ifa_mcrypt_generic_end(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_generic_end", count, 1, 1, 1);
  return (f_mcrypt_generic_end(a0));
}
Variant i_openssl_pkey_free(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_free);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_free", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_pkey_free(arg0), null);
  }
}
Variant ifa_openssl_pkey_free(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("openssl_pkey_free", count, 1, 1, 1);
  return (f_openssl_pkey_free(a0), null);
}
Variant i_readlink(void *extra, CArrRef params) {
  FUNCTION_INJECTION(readlink);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("readlink", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_readlink(arg0));
  }
}
Variant ifa_readlink(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("readlink", count, 1, 1, 1);
  return (f_readlink(a0));
}
Variant i_header_remove(void *extra, CArrRef params) {
  FUNCTION_INJECTION(header_remove);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("header_remove", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_header_remove(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_header_remove(arg0), null);
  }
}
Variant ifa_header_remove(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("header_remove", 1, 1);
  if (count <= 0) return (f_header_remove(), null);
  return (f_header_remove(a0), null);
}
Variant i_magickechoimagesblob(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickechoimagesblob);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickechoimagesblob", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickechoimagesblob(arg0));
  }
}
Variant ifa_magickechoimagesblob(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickechoimagesblob", count, 1, 1, 1);
  return (f_magickechoimagesblob(a0));
}
Variant i_mailparse_msg_parse(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_parse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mailparse_msg_parse", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_msg_parse(arg0, arg1));
  }
}
Variant ifa_mailparse_msg_parse(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("mailparse_msg_parse", count, 2, 2, 1);
  return (f_mailparse_msg_parse(a0, a1));
}
Variant i_xmlwriter_text(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_text);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_text", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_text(arg0, arg1));
  }
}
Variant ifa_xmlwriter_text(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xmlwriter_text", count, 2, 2, 1);
  return (f_xmlwriter_text(a0, a1));
}
Variant i_pixelsetindex(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetindex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetindex", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetindex(arg0, arg1), null);
  }
}
Variant ifa_pixelsetindex(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetindex", count, 2, 2, 1);
  return (f_pixelsetindex(a0, a1), null);
}
Variant i_php_sapi_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(php_sapi_name);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_sapi_name", 0, 1);
  return (f_php_sapi_name());
}
Variant ifa_php_sapi_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("php_sapi_name", 0, 1);
  return (f_php_sapi_name());
}
Variant i_mcrypt_enc_get_key_size(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_key_size);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_key_size", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_key_size(arg0));
  }
}
Variant ifa_mcrypt_enc_get_key_size(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_key_size", count, 1, 1, 1);
  return (f_mcrypt_enc_get_key_size(a0));
}
Variant i_mysql_num_fields(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_num_fields);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_num_fields", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_num_fields(arg0));
  }
}
Variant ifa_mysql_num_fields(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mysql_num_fields", count, 1, 1, 1);
  return (f_mysql_num_fields(a0));
}
Variant i_dom_xpath_register_php_functions(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_xpath_register_php_functions);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_xpath_register_php_functions", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dom_xpath_register_php_functions(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_xpath_register_php_functions(arg0, arg1));
  }
}
Variant ifa_dom_xpath_register_php_functions(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_xpath_register_php_functions", count, 1, 2, 1);
  if (count <= 1) return (f_dom_xpath_register_php_functions(a0));
  return (f_dom_xpath_register_php_functions(a0, a1));
}
Variant i_magicksteganoimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksteganoimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksteganoimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksteganoimage(arg0, arg1, arg2));
  }
}
Variant ifa_magicksteganoimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksteganoimage", count, 3, 3, 1);
  return (f_magicksteganoimage(a0, a1, a2));
}
Variant i_magicksetfirstiterator(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetfirstiterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicksetfirstiterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magicksetfirstiterator(arg0), null);
  }
}
Variant ifa_magicksetfirstiterator(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magicksetfirstiterator", count, 1, 1, 1);
  return (f_magicksetfirstiterator(a0), null);
}
Variant i_pixelgetcolorasstring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetcolorasstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcolorasstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetcolorasstring(arg0));
  }
}
Variant ifa_pixelgetcolorasstring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetcolorasstring", count, 1, 1, 1);
  return (f_pixelgetcolorasstring(a0));
}
Variant i_magickremoveimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickremoveimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickremoveimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickremoveimage(arg0));
  }
}
Variant ifa_magickremoveimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickremoveimage", count, 1, 1, 1);
  return (f_magickremoveimage(a0));
}
Variant i_file_exists(void *extra, CArrRef params) {
  FUNCTION_INJECTION(file_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("file_exists", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_file_exists(arg0));
  }
}
Variant ifa_file_exists(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("file_exists", count, 1, 1, 1);
  return (f_file_exists(a0));
}
Variant i_call_user_func_array(void *extra, CArrRef params) {
  FUNCTION_INJECTION(call_user_func_array);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("call_user_func_array", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_call_user_func_array(arg0, arg1));
  }
}
Variant ifa_call_user_func_array(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("call_user_func_array", count, 2, 2, 1);
  return (f_call_user_func_array(a0, a1));
}
Variant i_restore_include_path(void *extra, CArrRef params) {
  FUNCTION_INJECTION(restore_include_path);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_include_path", 0, 1);
  return (f_restore_include_path(), null);
}
Variant ifa_restore_include_path(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("restore_include_path", 0, 1);
  return (f_restore_include_path(), null);
}
Variant i_memcache_set_compress_threshold(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_set_compress_threshold);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_set_compress_threshold", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_set_compress_threshold(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_set_compress_threshold(arg0, arg1, arg2));
  }
}
Variant ifa_memcache_set_compress_threshold(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_set_compress_threshold", count, 2, 3, 1);
  if (count <= 2) return (f_memcache_set_compress_threshold(a0, a1));
  return (f_memcache_set_compress_threshold(a0, a1, a2));
}
Variant i_dom_element_set_id_attribute_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_id_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_element_set_id_attribute_ns", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_id_attribute_ns(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_dom_element_set_id_attribute_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("dom_element_set_id_attribute_ns", count, 4, 4, 1);
  return (f_dom_element_set_id_attribute_ns(a0, a1, a2, a3));
}
Variant i_drawgettextundercolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgettextundercolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextundercolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgettextundercolor(arg0));
  }
}
Variant ifa_drawgettextundercolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgettextundercolor", count, 1, 1, 1);
  return (f_drawgettextundercolor(a0));
}
Variant i_array_shift(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_shift);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_shift", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_array_shift(arg0));
  }
}
Variant ifa_array_shift(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("array_shift", count, 1, 1, 1);
  return (f_array_shift(ref(a0)));
}
Variant i_magicksetimageformat(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimageformat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageformat", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageformat(arg0, arg1));
  }
}
Variant ifa_magicksetimageformat(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimageformat", count, 2, 2, 1);
  return (f_magicksetimageformat(a0, a1));
}
Variant i_xmlwriter_open_memory(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_open_memory);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xmlwriter_open_memory", 0, 1);
  return (f_xmlwriter_open_memory());
}
Variant ifa_xmlwriter_open_memory(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("xmlwriter_open_memory", 0, 1);
  return (f_xmlwriter_open_memory());
}
Variant i_drawsetstrokemiterlimit(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokemiterlimit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokemiterlimit", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokemiterlimit(arg0, arg1), null);
  }
}
Variant ifa_drawsetstrokemiterlimit(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetstrokemiterlimit", count, 2, 2, 1);
  return (f_drawsetstrokemiterlimit(a0, a1), null);
}
Variant i_mb_convert_kana(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_convert_kana);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_convert_kana", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_convert_kana(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mb_convert_kana(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_convert_kana(arg0, arg1, arg2));
  }
}
Variant ifa_mb_convert_kana(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_convert_kana", count, 1, 3, 1);
  if (count <= 1) return (f_mb_convert_kana(a0));
  if (count == 2) return (f_mb_convert_kana(a0, a1));
  return (f_mb_convert_kana(a0, a1, a2));
}
Variant i_token_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(token_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("token_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_token_name(arg0));
  }
}
Variant ifa_token_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("token_name", count, 1, 1, 1);
  return (f_token_name(a0));
}
Variant i_preg_quote(void *extra, CArrRef params) {
  FUNCTION_INJECTION(preg_quote);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("preg_quote", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_preg_quote(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_preg_quote(arg0, arg1));
  }
}
Variant ifa_preg_quote(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("preg_quote", count, 1, 2, 1);
  if (count <= 1) return (f_preg_quote(a0));
  return (f_preg_quote(a0, a1));
}
Variant i_hphp_service_thread_started(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_service_thread_started);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_service_thread_started", 0, 1);
  return (f_hphp_service_thread_started(), null);
}
Variant ifa_hphp_service_thread_started(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("hphp_service_thread_started", 0, 1);
  return (f_hphp_service_thread_started(), null);
}
Variant i_magickconvolveimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickconvolveimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickconvolveimage", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickconvolveimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickconvolveimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickconvolveimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("magickconvolveimage", count, 2, 3, 1);
  if (count <= 2) return (f_magickconvolveimage(a0, a1));
  return (f_magickconvolveimage(a0, a1, a2));
}
Variant i_curl_getinfo(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_getinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_getinfo", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_curl_getinfo(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_getinfo(arg0, arg1));
  }
}
Variant ifa_curl_getinfo(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_getinfo", count, 1, 2, 1);
  if (count <= 1) return (f_curl_getinfo(a0));
  return (f_curl_getinfo(a0, a1));
}
Variant i_pfsockopen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pfsockopen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("pfsockopen", count, 1, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pfsockopen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_pfsockopen(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_pfsockopen(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_pfsockopen(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pfsockopen(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_pfsockopen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 5) return throw_wrong_arguments("pfsockopen", count, 1, 5, 1);
  if (count <= 1) return (f_pfsockopen(a0));
  if (count == 2) return (f_pfsockopen(a0, a1));
  if (count == 3) return (f_pfsockopen(a0, a1, ref(a2)));
  if (count == 4) return (f_pfsockopen(a0, a1, ref(a2), ref(a3)));
  return (f_pfsockopen(a0, a1, ref(a2), ref(a3), a4));
}
Variant i_dom_element_get_elements_by_tag_name_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_elements_by_tag_name_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_elements_by_tag_name_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_elements_by_tag_name_ns(arg0, arg1, arg2));
  }
}
Variant ifa_dom_element_get_elements_by_tag_name_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_element_get_elements_by_tag_name_ns", count, 3, 3, 1);
  return (f_dom_element_get_elements_by_tag_name_ns(a0, a1, a2));
}
Variant i_ucfirst(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ucfirst);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ucfirst", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ucfirst(arg0));
  }
}
Variant ifa_ucfirst(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ucfirst", count, 1, 1, 1);
  return (f_ucfirst(a0));
}
Variant i_hphp_splfileinfo_isreadable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_isreadable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isreadable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_isreadable(arg0));
  }
}
Variant ifa_hphp_splfileinfo_isreadable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isreadable", count, 1, 1, 1);
  return (f_hphp_splfileinfo_isreadable(a0));
}
Variant i_chroot(void *extra, CArrRef params) {
  FUNCTION_INJECTION(chroot);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chroot", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_chroot(arg0));
  }
}
Variant ifa_chroot(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("chroot", count, 1, 1, 1);
  return (f_chroot(a0));
}
Variant i_chdir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(chdir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chdir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_chdir(arg0));
  }
}
Variant ifa_chdir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("chdir", count, 1, 1, 1);
  return (f_chdir(a0));
}
Variant i_socket_write(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_write);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_write", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_write(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_write(arg0, arg1, arg2));
  }
}
Variant ifa_socket_write(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_write", count, 2, 3, 1);
  if (count <= 2) return (f_socket_write(a0, a1));
  return (f_socket_write(a0, a1, a2));
}
Variant i_forward_static_call_array(void *extra, CArrRef params) {
  FUNCTION_INJECTION(forward_static_call_array);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("forward_static_call_array", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_forward_static_call_array(arg0, arg1));
  }
}
Variant ifa_forward_static_call_array(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("forward_static_call_array", count, 2, 2, 1);
  return (f_forward_static_call_array(a0, a1));
}
Variant i_stream_bucket_new(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_bucket_new);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_new", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_bucket_new(arg0, arg1));
  }
}
Variant ifa_stream_bucket_new(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stream_bucket_new", count, 2, 2, 1);
  return (f_stream_bucket_new(a0, a1));
}
Variant i_magickflipimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickflipimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflipimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickflipimage(arg0));
  }
}
Variant ifa_magickflipimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickflipimage", count, 1, 1, 1);
  return (f_magickflipimage(a0));
}
Variant i_timezone_identifiers_list(void *extra, CArrRef params) {
  FUNCTION_INJECTION(timezone_identifiers_list);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("timezone_identifiers_list", 0, 1);
  return (f_timezone_identifiers_list());
}
Variant ifa_timezone_identifiers_list(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("timezone_identifiers_list", 0, 1);
  return (f_timezone_identifiers_list());
}
Variant i_array_diff_key(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_diff_key);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff_key", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_diff_key(count, arg0, arg1));
    return (f_array_diff_key(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_array_diff_key(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("array_diff_key", count+1, 1);
  if (count <= 2) return (f_array_diff_key(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_diff_key(count,a0, a1, params));
}
Variant i_session_encode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_encode", 0, 1);
  return (f_session_encode());
}
Variant ifa_session_encode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("session_encode", 0, 1);
  return (f_session_encode());
}
Variant i_fread(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fread);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fread", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fread(arg0, arg1));
  }
}
Variant ifa_fread(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("fread", count, 2, 2, 1);
  return (f_fread(a0, a1));
}
Variant i_override_function(void *extra, CArrRef params) {
  FUNCTION_INJECTION(override_function);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("override_function", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_override_function(arg0, arg1, arg2));
  }
}
Variant ifa_override_function(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("override_function", count, 3, 3, 1);
  return (f_override_function(a0, a1, a2));
}
Variant i_is_long(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_long);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_long", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_long(arg0));
  }
}
Variant ifa_is_long(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_long", count, 1, 1, 1);
  return (f_is_long(a0));
}
Variant i_pixelsetred(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetred);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetred", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetred(arg0, arg1), null);
  }
}
Variant ifa_pixelsetred(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetred", count, 2, 2, 1);
  return (f_pixelsetred(a0, a1), null);
}
Variant i_mailparse_uudecode_all(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_uudecode_all);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_uudecode_all", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_uudecode_all(arg0));
  }
}
Variant ifa_mailparse_uudecode_all(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mailparse_uudecode_all", count, 1, 1, 1);
  return (f_mailparse_uudecode_all(a0));
}
Variant i_drawsetvectorgraphics(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetvectorgraphics);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetvectorgraphics", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetvectorgraphics(arg0, arg1));
  }
}
Variant ifa_drawsetvectorgraphics(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetvectorgraphics", count, 2, 2, 1);
  return (f_drawsetvectorgraphics(a0, a1));
}
Variant i_ctype_upper(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ctype_upper);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_upper", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_upper(arg0));
  }
}
Variant ifa_ctype_upper(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ctype_upper", count, 1, 1, 1);
  return (f_ctype_upper(a0));
}
Variant i_get_declared_classes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_declared_classes);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_declared_classes", 0, 1);
  return (f_get_declared_classes());
}
Variant ifa_get_declared_classes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("get_declared_classes", 0, 1);
  return (f_get_declared_classes());
}
Variant i_drawgetstrokelinejoin(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokelinejoin);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokelinejoin", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokelinejoin(arg0));
  }
}
Variant ifa_drawgetstrokelinejoin(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetstrokelinejoin", count, 1, 1, 1);
  return (f_drawgetstrokelinejoin(a0));
}
Variant i_popen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(popen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("popen", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_popen(arg0, arg1));
  }
}
Variant ifa_popen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("popen", count, 2, 2, 1);
  return (f_popen(a0, a1));
}
Variant i_ldap_next_entry(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_next_entry);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_entry", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_next_entry(arg0, arg1));
  }
}
Variant ifa_ldap_next_entry(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_next_entry", count, 2, 2, 1);
  return (f_ldap_next_entry(a0, a1));
}
Variant i_mailparse_msg_parse_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_parse_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_parse_file", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_msg_parse_file(arg0));
  }
}
Variant ifa_mailparse_msg_parse_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mailparse_msg_parse_file", count, 1, 1, 1);
  return (f_mailparse_msg_parse_file(a0));
}
Variant i_get_loaded_extensions(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_loaded_extensions);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_loaded_extensions", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_loaded_extensions());
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_loaded_extensions(arg0));
  }
}
Variant ifa_get_loaded_extensions(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("get_loaded_extensions", 1, 1);
  if (count <= 0) return (f_get_loaded_extensions());
  return (f_get_loaded_extensions(a0));
}
Variant i_magickdrawimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickdrawimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickdrawimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickdrawimage(arg0, arg1));
  }
}
Variant ifa_magickdrawimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickdrawimage", count, 2, 2, 1);
  return (f_magickdrawimage(a0, a1));
}
Variant i_mcrypt_cbc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_cbc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_cbc", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_cbc(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_cbc(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_mcrypt_cbc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_cbc", count, 4, 5, 1);
  if (count <= 4) return (f_mcrypt_cbc(a0, a1, a2, a3));
  return (f_mcrypt_cbc(a0, a1, a2, a3, a4));
}
Variant i_session_set_save_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_set_save_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("session_set_save_handler", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_session_set_save_handler(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_session_set_save_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("session_set_save_handler", count, 6, 6, 1);
  return (f_session_set_save_handler(a0, a1, a2, a3, a4, a5));
}
Variant i_dom_element_get_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_attribute(arg0, arg1));
  }
}
Variant ifa_dom_element_get_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_element_get_attribute", count, 2, 2, 1);
  return (f_dom_element_get_attribute(a0, a1));
}
Variant i_imagecreatetruecolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreatetruecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecreatetruecolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecreatetruecolor(arg0, arg1));
  }
}
Variant ifa_imagecreatetruecolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagecreatetruecolor", count, 2, 2, 1);
  return (f_imagecreatetruecolor(a0, a1));
}
Variant i_intl_is_failure(void *extra, CArrRef params) {
  FUNCTION_INJECTION(intl_is_failure);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("intl_is_failure", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_intl_is_failure(arg0));
  }
}
Variant ifa_intl_is_failure(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("intl_is_failure", count, 1, 1, 1);
  return (f_intl_is_failure(a0));
}
Variant i_inet_ntop(void *extra, CArrRef params) {
  FUNCTION_INJECTION(inet_ntop);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("inet_ntop", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_inet_ntop(arg0));
  }
}
Variant ifa_inet_ntop(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("inet_ntop", count, 1, 1, 1);
  return (f_inet_ntop(a0));
}
Variant i_magickreadimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickreadimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickreadimage(arg0, arg1));
  }
}
Variant ifa_magickreadimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickreadimage", count, 2, 2, 1);
  return (f_magickreadimage(a0, a1));
}
Variant i_dom_node_is_default_namespace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_is_default_namespace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_is_default_namespace", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_is_default_namespace(arg0, arg1));
  }
}
Variant ifa_dom_node_is_default_namespace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_node_is_default_namespace", count, 2, 2, 1);
  return (f_dom_node_is_default_namespace(a0, a1));
}
Variant i_curl_init(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_init);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("curl_init", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_curl_init());
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_init(arg0));
  }
}
Variant ifa_curl_init(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("curl_init", 1, 1);
  if (count <= 0) return (f_curl_init());
  return (f_curl_init(a0));
}
Variant i_mcrypt_cfb(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_cfb);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_cfb", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_cfb(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_cfb(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_mcrypt_cfb(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_cfb", count, 4, 5, 1);
  if (count <= 4) return (f_mcrypt_cfb(a0, a1, a2, a3));
  return (f_mcrypt_cfb(a0, a1, a2, a3, a4));
}
Variant i_dom_document_create_document_fragment(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_document_fragment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_create_document_fragment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_document_create_document_fragment(arg0));
  }
}
Variant ifa_dom_document_create_document_fragment(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dom_document_create_document_fragment", count, 1, 1, 1);
  return (f_dom_document_create_document_fragment(a0));
}
Variant i_set_time_limit(void *extra, CArrRef params) {
  FUNCTION_INJECTION(set_time_limit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_time_limit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_set_time_limit(arg0), null);
  }
}
Variant ifa_set_time_limit(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("set_time_limit", count, 1, 1, 1);
  return (f_set_time_limit(a0), null);
}
Variant i_libxml_get_errors(void *extra, CArrRef params) {
  FUNCTION_INJECTION(libxml_get_errors);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_get_errors", 0, 1);
  return (f_libxml_get_errors());
}
Variant ifa_libxml_get_errors(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("libxml_get_errors", 0, 1);
  return (f_libxml_get_errors());
}
Variant i_get_magic_quotes_gpc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_magic_quotes_gpc);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_magic_quotes_gpc", 0, 1);
  return (f_get_magic_quotes_gpc());
}
Variant ifa_get_magic_quotes_gpc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("get_magic_quotes_gpc", 0, 1);
  return (f_get_magic_quotes_gpc());
}
Variant i_proc_get_status(void *extra, CArrRef params) {
  FUNCTION_INJECTION(proc_get_status);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_get_status", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_proc_get_status(arg0));
  }
}
Variant ifa_proc_get_status(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("proc_get_status", count, 1, 1, 1);
  return (f_proc_get_status(a0));
}
Variant i_log10(void *extra, CArrRef params) {
  FUNCTION_INJECTION(log10);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("log10", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_log10(arg0));
  }
}
Variant ifa_log10(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("log10", count, 1, 1, 1);
  return (f_log10(a0));
}
Variant i_hphp_directoryiterator_seek(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_seek);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_directoryiterator_seek", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_directoryiterator_seek(arg0, arg1), null);
  }
}
Variant ifa_hphp_directoryiterator_seek(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_directoryiterator_seek", count, 2, 2, 1);
  return (f_hphp_directoryiterator_seek(a0, a1), null);
}
Variant i_ldap_get_values(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_get_values);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_values", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_get_values(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_get_values(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ldap_get_values", count, 3, 3, 1);
  return (f_ldap_get_values(a0, a1, a2));
}
Variant i_is_soap_fault(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_soap_fault);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_soap_fault", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_soap_fault(arg0));
  }
}
Variant ifa_is_soap_fault(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_soap_fault", count, 1, 1, 1);
  return (f_is_soap_fault(a0));
}
Variant i_magickgetimagechannelmean(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagechannelmean);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimagechannelmean", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimagechannelmean(arg0, arg1));
  }
}
Variant ifa_magickgetimagechannelmean(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickgetimagechannelmean", count, 2, 2, 1);
  return (f_magickgetimagechannelmean(a0, a1));
}
Variant i_disk_total_space(void *extra, CArrRef params) {
  FUNCTION_INJECTION(disk_total_space);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("disk_total_space", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_disk_total_space(arg0));
  }
}
Variant ifa_disk_total_space(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("disk_total_space", count, 1, 1, 1);
  return (f_disk_total_space(a0));
}
Variant i_imagegd(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagegd);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegd", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagegd(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagegd(arg0, arg1));
  }
}
Variant ifa_imagegd(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegd", count, 1, 2, 1);
  if (count <= 1) return (f_imagegd(a0));
  return (f_imagegd(a0, a1));
}
Variant i_socket_set_blocking(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_set_blocking);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("socket_set_blocking", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_set_blocking(arg0, arg1));
  }
}
Variant ifa_socket_set_blocking(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("socket_set_blocking", count, 2, 2, 1);
  return (f_socket_set_blocking(a0, a1));
}
Variant i_dom_element_get_elements_by_tag_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_elements_by_tag_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_elements_by_tag_name", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_elements_by_tag_name(arg0, arg1));
  }
}
Variant ifa_dom_element_get_elements_by_tag_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_element_get_elements_by_tag_name", count, 2, 2, 1);
  return (f_dom_element_get_elements_by_tag_name(a0, a1));
}
Variant i_posix_mknod(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_mknod);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("posix_mknod", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_posix_mknod(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_posix_mknod(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_mknod(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_posix_mknod(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("posix_mknod", count, 2, 4, 1);
  if (count <= 2) return (f_posix_mknod(a0, a1));
  if (count == 3) return (f_posix_mknod(a0, a1, a2));
  return (f_posix_mknod(a0, a1, a2, a3));
}
Variant i_apc_define_constants(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_define_constants);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_define_constants", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_apc_define_constants(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_define_constants(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_define_constants(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_apc_define_constants(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_define_constants", count, 2, 4, 1);
  if (count <= 2) return (f_apc_define_constants(a0, a1));
  if (count == 3) return (f_apc_define_constants(a0, a1, a2));
  return (f_apc_define_constants(a0, a1, a2, a3));
}
Variant i_posix_kill(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_kill);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_kill", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_kill(arg0, arg1));
  }
}
Variant ifa_posix_kill(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("posix_kill", count, 2, 2, 1);
  return (f_posix_kill(a0, a1));
}
Variant i_drawgetstrokealpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokealpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokealpha", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokealpha(arg0));
  }
}
Variant ifa_drawgetstrokealpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetstrokealpha", count, 1, 1, 1);
  return (f_drawgetstrokealpha(a0));
}
Variant i_mcrypt_get_block_size(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_get_block_size);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_get_block_size", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_get_block_size(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_get_block_size(arg0, arg1));
  }
}
Variant ifa_mcrypt_get_block_size(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_get_block_size", count, 1, 2, 1);
  if (count <= 1) return (f_mcrypt_get_block_size(a0));
  return (f_mcrypt_get_block_size(a0, a1));
}
Variant i_magickmorphimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickmorphimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickmorphimages", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmorphimages(arg0, arg1));
  }
}
Variant ifa_magickmorphimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickmorphimages", count, 2, 2, 1);
  return (f_magickmorphimages(a0, a1));
}
Variant i_getlastmod(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getlastmod);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getlastmod", 0, 1);
  return (f_getlastmod());
}
Variant ifa_getlastmod(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("getlastmod", 0, 1);
  return (f_getlastmod());
}
Variant i_magickquantizeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickquantizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickquantizeimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickquantizeimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_magickquantizeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("magickquantizeimage", count, 6, 6, 1);
  return (f_magickquantizeimage(a0, a1, a2, a3, a4, a5));
}
Variant i_imagesavealpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagesavealpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesavealpha", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesavealpha(arg0, arg1));
  }
}
Variant ifa_imagesavealpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagesavealpha", count, 2, 2, 1);
  return (f_imagesavealpha(a0, a1));
}
Variant i_drawsetfontfamily(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetfontfamily);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontfamily", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfontfamily(arg0, arg1));
  }
}
Variant ifa_drawsetfontfamily(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetfontfamily", count, 2, 2, 1);
  return (f_drawsetfontfamily(a0, a1));
}
Variant i_drawsettextantialias(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsettextantialias);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsettextantialias", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_drawsettextantialias(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsettextantialias(arg0, arg1), null);
  }
}
Variant ifa_drawsettextantialias(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsettextantialias", count, 1, 2, 1);
  if (count <= 1) return (f_drawsettextantialias(a0), null);
  return (f_drawsettextantialias(a0, a1), null);
}
Variant i_pixelsetgreenquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetgreenquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetgreenquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetgreenquantum(arg0, arg1), null);
  }
}
Variant ifa_pixelsetgreenquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetgreenquantum", count, 2, 2, 1);
  return (f_pixelsetgreenquantum(a0, a1), null);
}
Variant i_bcsqrt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bcsqrt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("bcsqrt", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_bcsqrt(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcsqrt(arg0, arg1));
  }
}
Variant ifa_bcsqrt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("bcsqrt", count, 1, 2, 1);
  if (count <= 1) return (f_bcsqrt(a0));
  return (f_bcsqrt(a0, a1));
}
Variant i_pcntl_signal(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_signal);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("pcntl_signal", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_pcntl_signal(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_signal(arg0, arg1, arg2));
  }
}
Variant ifa_pcntl_signal(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("pcntl_signal", count, 2, 3, 1);
  if (count <= 2) return (f_pcntl_signal(a0, a1));
  return (f_pcntl_signal(a0, a1, a2));
}
Variant i_mcrypt_ecb(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_ecb);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_ecb", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_ecb(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_ecb(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_mcrypt_ecb(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_ecb", count, 4, 5, 1);
  if (count <= 4) return (f_mcrypt_ecb(a0, a1, a2, a3));
  return (f_mcrypt_ecb(a0, a1, a2, a3, a4));
}
Variant i_pixelsetcyanquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetcyanquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcyanquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetcyanquantum(arg0, arg1), null);
  }
}
Variant ifa_pixelsetcyanquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetcyanquantum", count, 2, 2, 1);
  return (f_pixelsetcyanquantum(a0, a1), null);
}
Variant i_array_walk(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_walk);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_walk", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_walk(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_walk(arg0, arg1, arg2));
  }
}
Variant ifa_array_walk(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("array_walk", count, 2, 3, 1);
  if (count <= 2) return (f_array_walk(ref(a0), a1));
  return (f_array_walk(ref(a0), a1, a2));
}
Variant i_getmxrr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getmxrr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("getmxrr", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_getmxrr(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_getmxrr(arg0, arg1, arg2));
  }
}
Variant ifa_getmxrr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("getmxrr", count, 2, 3, 1);
  if (count <= 2) return (f_getmxrr(a0, ref(a1)));
  return (f_getmxrr(a0, ref(a1), ref(a2)));
}
Variant i_magickqueryfonts(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickqueryfonts);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryfonts", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickqueryfonts(arg0));
  }
}
Variant ifa_magickqueryfonts(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickqueryfonts", count, 1, 1, 1);
  return (f_magickqueryfonts(a0));
}
Variant i_floatval(void *extra, CArrRef params) {
  FUNCTION_INJECTION(floatval);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("floatval", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_floatval(arg0));
  }
}
Variant ifa_floatval(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("floatval", count, 1, 1, 1);
  return (f_floatval(a0));
}
Variant i_dom_element_get_attribute_node_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_attribute_node_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_attribute_node_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_attribute_node_ns(arg0, arg1, arg2));
  }
}
Variant ifa_dom_element_get_attribute_node_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_element_get_attribute_node_ns", count, 3, 3, 1);
  return (f_dom_element_get_attribute_node_ns(a0, a1, a2));
}
Variant i_xml_set_object(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_set_object);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_object", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_xml_set_object(arg0, arg1));
  }
}
Variant ifa_xml_set_object(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xml_set_object", count, 2, 2, 1);
  return (f_xml_set_object(a0, ref(a1)));
}
Variant i_ctype_print(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ctype_print);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_print", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_print(arg0));
  }
}
Variant ifa_ctype_print(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ctype_print", count, 1, 1, 1);
  return (f_ctype_print(a0));
}
Variant i_gzwrite(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzwrite);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzwrite", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_gzwrite(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzwrite(arg0, arg1, arg2));
  }
}
Variant ifa_gzwrite(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("gzwrite", count, 2, 3, 1);
  if (count <= 2) return (f_gzwrite(a0, a1));
  return (f_gzwrite(a0, a1, a2));
}
Variant i_hphp_splfileinfo___tostring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo___tostring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo___tostring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo___tostring(arg0));
  }
}
Variant ifa_hphp_splfileinfo___tostring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo___tostring", count, 1, 1, 1);
  return (f_hphp_splfileinfo___tostring(a0));
}
Variant i_magickaddimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickaddimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaddimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickaddimage(arg0, arg1));
  }
}
Variant ifa_magickaddimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickaddimage", count, 2, 2, 1);
  return (f_magickaddimage(a0, a1));
}
Variant i_clearstatcache(void *extra, CArrRef params) {
  FUNCTION_INJECTION(clearstatcache);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("clearstatcache", 0, 1);
  return (f_clearstatcache(), null);
}
Variant ifa_clearstatcache(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("clearstatcache", 0, 1);
  return (f_clearstatcache(), null);
}
Variant i_chgrp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(chgrp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chgrp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_chgrp(arg0, arg1));
  }
}
Variant ifa_chgrp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("chgrp", count, 2, 2, 1);
  return (f_chgrp(a0, a1));
}
Variant i_virtual(void *extra, CArrRef params) {
  FUNCTION_INJECTION(virtual);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("virtual", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_virtual(arg0));
  }
}
Variant ifa_virtual(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("virtual", count, 1, 1, 1);
  return (f_virtual(a0));
}
Variant i_reset(void *extra, CArrRef params) {
  FUNCTION_INJECTION(reset);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("reset", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_reset(arg0));
  }
}
Variant ifa_reset(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("reset", count, 1, 1, 1);
  return (f_reset(ref(a0)));
}
Variant i_set_include_path(void *extra, CArrRef params) {
  FUNCTION_INJECTION(set_include_path);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_include_path", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_set_include_path(arg0));
  }
}
Variant ifa_set_include_path(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("set_include_path", count, 1, 1, 1);
  return (f_set_include_path(a0));
}
Variant i_hphp_recursivedirectoryiterator_next(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_next);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_next", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_next(arg0), null);
  }
}
Variant ifa_hphp_recursivedirectoryiterator_next(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_next", count, 1, 1, 1);
  return (f_hphp_recursivedirectoryiterator_next(a0), null);
}
Variant i_openssl_x509_export(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_export);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_x509_export", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_x509_export(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_x509_export(arg0, arg1, arg2));
  }
}
Variant ifa_openssl_x509_export(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_x509_export", count, 2, 3, 1);
  if (count <= 2) return (f_openssl_x509_export(a0, ref(a1)));
  return (f_openssl_x509_export(a0, ref(a1), a2));
}
Variant i_magickcolorizeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickcolorizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickcolorizeimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcolorizeimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickcolorizeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magickcolorizeimage", count, 3, 3, 1);
  return (f_magickcolorizeimage(a0, a1, a2));
}
Variant i_imagettftext(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagettftext);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagettftext", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagettftext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant ifa_imagettftext(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 8) return throw_wrong_arguments("imagettftext", count, 8, 8, 1);
  return (f_imagettftext(a0, a1, a2, a3, a4, a5, null, null));
}
Variant i_mb_strrchr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strrchr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrchr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strrchr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strrchr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strrchr(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_strrchr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrchr", count, 2, 4, 1);
  if (count <= 2) return (f_mb_strrchr(a0, a1));
  if (count == 3) return (f_mb_strrchr(a0, a1, a2));
  return (f_mb_strrchr(a0, a1, a2, a3));
}
Variant i_magickgetimageprofile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageprofile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimageprofile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimageprofile(arg0, arg1));
  }
}
Variant ifa_magickgetimageprofile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickgetimageprofile", count, 2, 2, 1);
  return (f_magickgetimageprofile(a0, a1));
}
Variant i_file_put_contents(void *extra, CArrRef params) {
  FUNCTION_INJECTION(file_put_contents);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("file_put_contents", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_file_put_contents(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_file_put_contents(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_file_put_contents(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_file_put_contents(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("file_put_contents", count, 2, 4, 1);
  if (count <= 2) return (f_file_put_contents(a0, a1));
  if (count == 3) return (f_file_put_contents(a0, a1, a2));
  return (f_file_put_contents(a0, a1, a2, a3));
}
Variant i_iconv_mime_encode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iconv_mime_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iconv_mime_encode", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iconv_mime_encode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_mime_encode(arg0, arg1, arg2));
  }
}
Variant ifa_iconv_mime_encode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("iconv_mime_encode", count, 2, 3, 1);
  if (count <= 2) return (f_iconv_mime_encode(a0, a1));
  return (f_iconv_mime_encode(a0, a1, a2));
}
Variant i_log1p(void *extra, CArrRef params) {
  FUNCTION_INJECTION(log1p);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("log1p", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_log1p(arg0));
  }
}
Variant ifa_log1p(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("log1p", count, 1, 1, 1);
  return (f_log1p(a0));
}
Variant i_fwrite(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fwrite);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fwrite", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fwrite(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fwrite(arg0, arg1, arg2));
  }
}
Variant ifa_fwrite(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("fwrite", count, 2, 3, 1);
  if (count <= 2) return (f_fwrite(a0, a1));
  return (f_fwrite(a0, a1, a2));
}
Variant i_atan2(void *extra, CArrRef params) {
  FUNCTION_INJECTION(atan2);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("atan2", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_atan2(arg0, arg1));
  }
}
Variant ifa_atan2(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("atan2", count, 2, 2, 1);
  return (f_atan2(a0, a1));
}
Variant i_is_a(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_a);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("is_a", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_is_a(arg0, arg1));
  }
}
Variant ifa_is_a(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("is_a", count, 2, 2, 1);
  return (f_is_a(a0, a1));
}
Variant i_idate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(idate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_idate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_idate(arg0, arg1));
  }
}
Variant ifa_idate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("idate", count, 1, 2, 1);
  if (count <= 1) return (f_idate(a0));
  return (f_idate(a0, a1));
}
Variant i_posix_initgroups(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_initgroups);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_initgroups", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_initgroups(arg0, arg1));
  }
}
Variant ifa_posix_initgroups(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("posix_initgroups", count, 2, 2, 1);
  return (f_posix_initgroups(a0, a1));
}
Variant i_arsort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(arsort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("arsort", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_arsort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_arsort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_arsort(arg0, arg1, arg2));
  }
}
Variant ifa_arsort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("arsort", count, 1, 3, 1);
  if (count <= 1) return (f_arsort(ref(a0)));
  if (count == 2) return (f_arsort(ref(a0), a1));
  return (f_arsort(ref(a0), a1, a2));
}
Variant i_dom_characterdata_substring_data(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_characterdata_substring_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_substring_data", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_characterdata_substring_data(arg0, arg1, arg2));
  }
}
Variant ifa_dom_characterdata_substring_data(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_characterdata_substring_data", count, 3, 3, 1);
  return (f_dom_characterdata_substring_data(a0, a1, a2));
}
Variant i_gethostbyaddr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gethostbyaddr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbyaddr", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gethostbyaddr(arg0));
  }
}
Variant ifa_gethostbyaddr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("gethostbyaddr", count, 1, 1, 1);
  return (f_gethostbyaddr(a0));
}
Variant i_apc_delete(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_delete);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apc_delete", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_delete(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_delete(arg0, arg1));
  }
}
Variant ifa_apc_delete(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("apc_delete", count, 1, 2, 1);
  if (count <= 1) return (f_apc_delete(a0));
  return (f_apc_delete(a0, a1));
}
Variant i_magicklevelimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicklevelimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("magicklevelimage", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_magicklevelimage(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicklevelimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_magicklevelimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("magicklevelimage", count, 4, 5, 1);
  if (count <= 4) return (f_magicklevelimage(a0, a1, a2, a3));
  return (f_magicklevelimage(a0, a1, a2, a3, a4));
}
Variant i_openssl_x509_parse(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_parse);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_x509_parse", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_openssl_x509_parse(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_x509_parse(arg0, arg1));
  }
}
Variant ifa_openssl_x509_parse(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_x509_parse", count, 1, 2, 1);
  if (count <= 1) return (f_openssl_x509_parse(a0));
  return (f_openssl_x509_parse(a0, a1));
}
Variant i_dom_nodelist_item(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_nodelist_item);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_nodelist_item", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_nodelist_item(arg0, arg1));
  }
}
Variant ifa_dom_nodelist_item(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_nodelist_item", count, 2, 2, 1);
  return (f_dom_nodelist_item(a0, a1));
}
Variant i_magickcommentimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickcommentimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcommentimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcommentimage(arg0, arg1));
  }
}
Variant ifa_magickcommentimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickcommentimage", count, 2, 2, 1);
  return (f_magickcommentimage(a0, a1));
}
Variant i_hphp_splfileinfo_islink(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_islink);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_islink", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_islink(arg0));
  }
}
Variant ifa_hphp_splfileinfo_islink(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_islink", count, 1, 1, 1);
  return (f_hphp_splfileinfo_islink(a0));
}
Variant i_magicksetimagedelay(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagedelay);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagedelay", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagedelay(arg0, arg1));
  }
}
Variant ifa_magicksetimagedelay(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagedelay", count, 2, 2, 1);
  return (f_magicksetimagedelay(a0, a1));
}
Variant i_magickposterizeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickposterizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickposterizeimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickposterizeimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickposterizeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magickposterizeimage", count, 3, 3, 1);
  return (f_magickposterizeimage(a0, a1, a2));
}
Variant i_dom_namednodemap_get_named_item(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_namednodemap_get_named_item);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_namednodemap_get_named_item", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_namednodemap_get_named_item(arg0, arg1));
  }
}
Variant ifa_dom_namednodemap_get_named_item(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_namednodemap_get_named_item", count, 2, 2, 1);
  return (f_dom_namednodemap_get_named_item(a0, a1));
}
Variant i_dom_element_get_attribute_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_attribute_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_attribute_ns(arg0, arg1, arg2));
  }
}
Variant ifa_dom_element_get_attribute_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_element_get_attribute_ns", count, 3, 3, 1);
  return (f_dom_element_get_attribute_ns(a0, a1, a2));
}
Variant i_stream_socket_accept(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_socket_accept);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_socket_accept", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_socket_accept(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_stream_socket_accept(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_stream_socket_accept(arg0, arg1, arg2));
  }
}
Variant ifa_stream_socket_accept(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_socket_accept", count, 1, 3, 1);
  if (count <= 1) return (f_stream_socket_accept(a0));
  if (count == 2) return (f_stream_socket_accept(a0, a1));
  return (f_stream_socket_accept(a0, a1, ref(a2)));
}
Variant i_magickqueryconfigureoption(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickqueryconfigureoption);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryconfigureoption", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickqueryconfigureoption(arg0));
  }
}
Variant ifa_magickqueryconfigureoption(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickqueryconfigureoption", count, 1, 1, 1);
  return (f_magickqueryconfigureoption(a0));
}
Variant i_magickevaluateimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickevaluateimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickevaluateimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickevaluateimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickevaluateimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickevaluateimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickevaluateimage", count, 3, 4, 1);
  if (count <= 3) return (f_magickevaluateimage(a0, a1, a2));
  return (f_magickevaluateimage(a0, a1, a2, a3));
}
Variant i_imagesx(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagesx);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagesx", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagesx(arg0));
  }
}
Variant ifa_imagesx(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagesx", count, 1, 1, 1);
  return (f_imagesx(a0));
}
Variant i_imagesy(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagesy);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagesy", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagesy(arg0));
  }
}
Variant ifa_imagesy(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagesy", count, 1, 1, 1);
  return (f_imagesy(a0));
}
Variant i_mysql_get_client_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_get_client_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mysql_get_client_info", 0, 1);
  return (f_mysql_get_client_info());
}
Variant ifa_mysql_get_client_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("mysql_get_client_info", 0, 1);
  return (f_mysql_get_client_info());
}
Variant i_fb_crossall_query(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_crossall_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("fb_crossall_query", count, 1, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fb_crossall_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_fb_crossall_query(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fb_crossall_query(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_fb_crossall_query(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_fb_crossall_query(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_crossall_query(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_fb_crossall_query(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 6) return throw_wrong_arguments("fb_crossall_query", count, 1, 6, 1);
  if (count <= 1) return (f_fb_crossall_query(a0));
  if (count == 2) return (f_fb_crossall_query(a0, a1));
  if (count == 3) return (f_fb_crossall_query(a0, a1, a2));
  if (count == 4) return (f_fb_crossall_query(a0, a1, a2, a3));
  if (count == 5) return (f_fb_crossall_query(a0, a1, a2, a3, a4));
  return (f_fb_crossall_query(a0, a1, a2, a3, a4, a5));
}
Variant i_fseek(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fseek);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fseek", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fseek(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fseek(arg0, arg1, arg2));
  }
}
Variant ifa_fseek(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("fseek", count, 2, 3, 1);
  if (count <= 2) return (f_fseek(a0, a1));
  return (f_fseek(a0, a1, a2));
}
Variant i_call_user_func_array_async(void *extra, CArrRef params) {
  FUNCTION_INJECTION(call_user_func_array_async);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("call_user_func_array_async", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_call_user_func_array_async(arg0, arg1));
  }
}
Variant ifa_call_user_func_array_async(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("call_user_func_array_async", count, 2, 2, 1);
  return (f_call_user_func_array_async(a0, a1));
}
Variant i_apc_compile_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_compile_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_compile_file", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_compile_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_compile_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_compile_file(arg0, arg1, arg2));
  }
}
Variant ifa_apc_compile_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_compile_file", count, 1, 3, 1);
  if (count <= 1) return (f_apc_compile_file(a0));
  if (count == 2) return (f_apc_compile_file(a0, a1));
  return (f_apc_compile_file(a0, a1, a2));
}
Variant i_memcache_set_server_params(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_set_server_params);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 7) return throw_wrong_arguments("memcache_set_server_params", count, 2, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_set_server_params(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_set_server_params(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_memcache_set_server_params(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_memcache_set_server_params(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_memcache_set_server_params(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_set_server_params(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant ifa_memcache_set_server_params(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 7) return throw_wrong_arguments("memcache_set_server_params", count, 2, 7, 1);
  if (count <= 2) return (f_memcache_set_server_params(a0, a1));
  if (count == 3) return (f_memcache_set_server_params(a0, a1, a2));
  if (count == 4) return (f_memcache_set_server_params(a0, a1, a2, a3));
  if (count == 5) return (f_memcache_set_server_params(a0, a1, a2, a3, a4));
  return (f_memcache_set_server_params(a0, a1, a2, a3, a4, a5));
}
Variant i_magicksetpassphrase(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetpassphrase);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetpassphrase", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetpassphrase(arg0, arg1));
  }
}
Variant ifa_magicksetpassphrase(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetpassphrase", count, 2, 2, 1);
  return (f_magicksetpassphrase(a0, a1));
}
Variant i_mysql_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_info(arg0));
  }
}
Variant ifa_mysql_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_info", 1, 1);
  if (count <= 0) return (f_mysql_info());
  return (f_mysql_info(a0));
}
Variant i_is_writable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_writable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_writable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_writable(arg0));
  }
}
Variant ifa_is_writable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_writable", count, 1, 1, 1);
  return (f_is_writable(a0));
}
Variant i_magickrotateimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickrotateimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickrotateimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickrotateimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickrotateimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magickrotateimage", count, 3, 3, 1);
  return (f_magickrotateimage(a0, a1, a2));
}
Variant i_fgetcsv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fgetcsv);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("fgetcsv", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fgetcsv(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_fgetcsv(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fgetcsv(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fgetcsv(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_fgetcsv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("fgetcsv", count, 1, 4, 1);
  if (count <= 1) return (f_fgetcsv(a0));
  if (count == 2) return (f_fgetcsv(a0, a1));
  if (count == 3) return (f_fgetcsv(a0, a1, a2));
  return (f_fgetcsv(a0, a1, a2, a3));
}
Variant i_magickcolorfloodfillimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickcolorfloodfillimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickcolorfloodfillimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcolorfloodfillimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_magickcolorfloodfillimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("magickcolorfloodfillimage", count, 6, 6, 1);
  return (f_magickcolorfloodfillimage(a0, a1, a2, a3, a4, a5));
}
Variant i_atanh(void *extra, CArrRef params) {
  FUNCTION_INJECTION(atanh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("atanh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_atanh(arg0));
  }
}
Variant ifa_atanh(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("atanh", count, 1, 1, 1);
  return (f_atanh(a0));
}
Variant i_imagecopyresized(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecopyresized);
  int count __attribute__((__unused__)) = params.size();
  if (count != 10) return throw_wrong_arguments("imagecopyresized", count, 10, 10, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg9((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecopyresized(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9));
  }
}
Variant ifa_imagecopyresized(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 10) return throw_wrong_arguments("imagecopyresized", count, 10, 10, 1);
  return (f_imagecopyresized(a0, a1, a2, a3, a4, a5, null, null, null, null));
}
Variant i_fpassthru(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fpassthru);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fpassthru", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fpassthru(arg0));
  }
}
Variant ifa_fpassthru(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fpassthru", count, 1, 1, 1);
  return (f_fpassthru(a0));
}
Variant i_magickblackthresholdimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickblackthresholdimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickblackthresholdimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickblackthresholdimage(arg0, arg1));
  }
}
Variant ifa_magickblackthresholdimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickblackthresholdimage", count, 2, 2, 1);
  return (f_magickblackthresholdimage(a0, a1));
}
Variant i_mcrypt_encrypt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_encrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_encrypt", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_encrypt(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_encrypt(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_mcrypt_encrypt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_encrypt", count, 4, 5, 1);
  if (count <= 4) return (f_mcrypt_encrypt(a0, a1, a2, a3));
  return (f_mcrypt_encrypt(a0, a1, a2, a3, a4));
}
Variant i_magicksetimagegreenprimary(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagegreenprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagegreenprimary", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagegreenprimary(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetimagegreenprimary(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksetimagegreenprimary", count, 3, 3, 1);
  return (f_magicksetimagegreenprimary(a0, a1, a2));
}
Variant i_xmlwriter_start_attribute_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("xmlwriter_start_attribute_ns", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_attribute_ns(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_xmlwriter_start_attribute_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("xmlwriter_start_attribute_ns", count, 4, 4, 1);
  return (f_xmlwriter_start_attribute_ns(a0, a1, a2, a3));
}
Variant i_magickgetimageinterlacescheme(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageinterlacescheme);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageinterlacescheme", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageinterlacescheme(arg0));
  }
}
Variant ifa_magickgetimageinterlacescheme(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimageinterlacescheme", count, 1, 1, 1);
  return (f_magickgetimageinterlacescheme(a0));
}
Variant i_array_merge_recursive(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_merge_recursive);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_merge_recursive", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_merge_recursive(count, arg0));
    return (f_array_merge_recursive(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_array_merge_recursive(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("array_merge_recursive", count+1, 1);
  if (count <= 1) return (f_array_merge_recursive(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_merge_recursive(count,a0, params));
}
Variant i_array_uintersect(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_uintersect);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_uintersect", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_uintersect(count, arg0, arg1, arg2));
    return (f_array_uintersect(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant ifa_array_uintersect(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3) return throw_missing_arguments("array_uintersect", count+1, 1);
  if (count <= 3) return (f_array_uintersect(count, a0, a1, a2));
  Array params;
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_uintersect(count,a0, a1, a2, params));
}
Variant i_xml_set_unparsed_entity_decl_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_set_unparsed_entity_decl_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_unparsed_entity_decl_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_unparsed_entity_decl_handler(arg0, arg1));
  }
}
Variant ifa_xml_set_unparsed_entity_decl_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xml_set_unparsed_entity_decl_handler", count, 2, 2, 1);
  return (f_xml_set_unparsed_entity_decl_handler(a0, a1));
}
Variant i_ob_get_contents(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_get_contents);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_contents", 0, 1);
  return (f_ob_get_contents());
}
Variant ifa_ob_get_contents(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("ob_get_contents", 0, 1);
  return (f_ob_get_contents());
}
Variant i_pixelgetcyan(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetcyan);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcyan", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetcyan(arg0));
  }
}
Variant ifa_pixelgetcyan(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetcyan", count, 1, 1, 1);
  return (f_pixelgetcyan(a0));
}
Variant i_stream_select(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_select);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("stream_select", count, 4, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_stream_select(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_select(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_stream_select(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("stream_select", count, 4, 5, 1);
  if (count <= 4) return (f_stream_select(ref(a0), ref(a1), ref(a2), a3));
  return (f_stream_select(ref(a0), ref(a1), ref(a2), a3, a4));
}
Variant i_get_resource_type(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_resource_type);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_resource_type", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_resource_type(arg0));
  }
}
Variant ifa_get_resource_type(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("get_resource_type", count, 1, 1, 1);
  return (f_get_resource_type(a0));
}
Variant i_dangling_server_proxy_old_request(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dangling_server_proxy_old_request);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("dangling_server_proxy_old_request", 0, 1);
  return (f_dangling_server_proxy_old_request());
}
Variant ifa_dangling_server_proxy_old_request(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("dangling_server_proxy_old_request", 0, 1);
  return (f_dangling_server_proxy_old_request());
}
Variant i_magickgetimagefilename(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagefilename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagefilename", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagefilename(arg0));
  }
}
Variant ifa_magickgetimagefilename(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagefilename", count, 1, 1, 1);
  return (f_magickgetimagefilename(a0));
}
Variant i_exif_tagname(void *extra, CArrRef params) {
  FUNCTION_INJECTION(exif_tagname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exif_tagname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_exif_tagname(arg0));
  }
}
Variant ifa_exif_tagname(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("exif_tagname", count, 1, 1, 1);
  return (f_exif_tagname(a0));
}
Variant i_dom_document_create_attribute_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_document_create_attribute_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_attribute_ns(arg0, arg1, arg2));
  }
}
Variant ifa_dom_document_create_attribute_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_document_create_attribute_ns", count, 3, 3, 1);
  return (f_dom_document_create_attribute_ns(a0, a1, a2));
}
Variant i_drawsetfillalpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetfillalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillalpha", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfillalpha(arg0, arg1), null);
  }
}
Variant ifa_drawsetfillalpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetfillalpha", count, 2, 2, 1);
  return (f_drawsetfillalpha(a0, a1), null);
}
Variant i_mb_convert_encoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_convert_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_convert_encoding", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_convert_encoding(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_convert_encoding(arg0, arg1, arg2));
  }
}
Variant ifa_mb_convert_encoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_convert_encoding", count, 2, 3, 1);
  if (count <= 2) return (f_mb_convert_encoding(a0, a1));
  return (f_mb_convert_encoding(a0, a1, a2));
}
Variant i_wandgetexceptionstring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(wandgetexceptionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexceptionstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_wandgetexceptionstring(arg0));
  }
}
Variant ifa_wandgetexceptionstring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("wandgetexceptionstring", count, 1, 1, 1);
  return (f_wandgetexceptionstring(a0));
}
Variant i_proc_open(void *extra, CArrRef params) {
  FUNCTION_INJECTION(proc_open);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("proc_open", count, 3, 6, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_proc_open(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_proc_open(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_proc_open(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_proc_open(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_proc_open(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 6) return throw_wrong_arguments("proc_open", count, 3, 6, 1);
  if (count <= 3) return (f_proc_open(a0, a1, ref(a2)));
  if (count == 4) return (f_proc_open(a0, a1, ref(a2), a3));
  if (count == 5) return (f_proc_open(a0, a1, ref(a2), a3, a4));
  return (f_proc_open(a0, a1, ref(a2), a3, a4, a5));
}
Variant i_hphp_splfileobject_fgetss(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fgetss);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_fgetss", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_fgetss(arg0, arg1));
  }
}
Variant ifa_hphp_splfileobject_fgetss(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_fgetss", count, 2, 2, 1);
  return (f_hphp_splfileobject_fgetss(a0, a1));
}
Variant i_clearpixeliterator(void *extra, CArrRef params) {
  FUNCTION_INJECTION(clearpixeliterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearpixeliterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_clearpixeliterator(arg0), null);
  }
}
Variant ifa_clearpixeliterator(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("clearpixeliterator", count, 1, 1, 1);
  return (f_clearpixeliterator(a0), null);
}
Variant i_socket_server(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_server);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("socket_server", count, 1, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_socket_server(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_socket_server(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_socket_server(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_socket_server(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_socket_server(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("socket_server", count, 1, 4, 1);
  if (count <= 1) return (f_socket_server(a0));
  if (count == 2) return (f_socket_server(a0, a1));
  if (count == 3) return (f_socket_server(a0, a1, ref(a2)));
  return (f_socket_server(a0, a1, ref(a2), ref(a3)));
}
Variant i_magickremoveimageprofile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickremoveimageprofile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickremoveimageprofile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickremoveimageprofile(arg0, arg1));
  }
}
Variant ifa_magickremoveimageprofile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickremoveimageprofile", count, 2, 2, 1);
  return (f_magickremoveimageprofile(a0, a1));
}
Variant i_xmlwriter_write_dtd_element(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_dtd_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_dtd_element", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_dtd_element(arg0, arg1, arg2));
  }
}
Variant ifa_xmlwriter_write_dtd_element(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_dtd_element", count, 3, 3, 1);
  return (f_xmlwriter_write_dtd_element(a0, a1, a2));
}
Variant i_drawpushdefs(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpushdefs);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpushdefs", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpushdefs(arg0), null);
  }
}
Variant ifa_drawpushdefs(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawpushdefs", count, 1, 1, 1);
  return (f_drawpushdefs(a0), null);
}
Variant i_image2wbmp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(image2wbmp);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("image2wbmp", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_image2wbmp(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_image2wbmp(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_image2wbmp(arg0, arg1, arg2));
  }
}
Variant ifa_image2wbmp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("image2wbmp", count, 1, 3, 1);
  if (count <= 1) return (f_image2wbmp(a0));
  if (count == 2) return (f_image2wbmp(a0, a1));
  return (f_image2wbmp(a0, a1, a2));
}
Variant i_join(void *extra, CArrRef params) {
  FUNCTION_INJECTION(join);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("join", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_join(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_join(arg0, arg1));
  }
}
Variant ifa_join(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("join", count, 1, 2, 1);
  if (count <= 1) return (f_join(a0));
  return (f_join(a0, a1));
}
Variant i_magicksetimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimage(arg0, arg1));
  }
}
Variant ifa_magicksetimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimage", count, 2, 2, 1);
  return (f_magicksetimage(a0, a1));
}
Variant i_openssl_free_key(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_free_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_free_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_free_key(arg0), null);
  }
}
Variant ifa_openssl_free_key(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("openssl_free_key", count, 1, 1, 1);
  return (f_openssl_free_key(a0), null);
}
Variant i_preg_grep(void *extra, CArrRef params) {
  FUNCTION_INJECTION(preg_grep);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("preg_grep", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_preg_grep(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_preg_grep(arg0, arg1, arg2));
  }
}
Variant ifa_preg_grep(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("preg_grep", count, 2, 3, 1);
  if (count <= 2) return (f_preg_grep(a0, a1));
  return (f_preg_grep(a0, a1, a2));
}
Variant i_is_float(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_float);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_float", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_float(arg0));
  }
}
Variant ifa_is_float(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_float", count, 1, 1, 1);
  return (f_is_float(a0));
}
Variant i_stream_socket_pair(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_socket_pair);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("stream_socket_pair", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_pair(arg0, arg1, arg2));
  }
}
Variant ifa_stream_socket_pair(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("stream_socket_pair", count, 3, 3, 1);
  return (f_stream_socket_pair(a0, a1, a2));
}
Variant i_get_required_files(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_required_files);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_required_files", 0, 1);
  return (f_get_required_files());
}
Variant ifa_get_required_files(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("get_required_files", 0, 1);
  return (f_get_required_files());
}
Variant i_mysql_fetch_field(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_field);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_fetch_field", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_fetch_field(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_fetch_field(arg0, arg1));
  }
}
Variant ifa_mysql_fetch_field(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_fetch_field", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_fetch_field(a0));
  return (f_mysql_fetch_field(a0, a1));
}
Variant i_chmod(void *extra, CArrRef params) {
  FUNCTION_INJECTION(chmod);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chmod", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_chmod(arg0, arg1));
  }
}
Variant ifa_chmod(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("chmod", count, 2, 2, 1);
  return (f_chmod(a0, a1));
}
Variant i_magickgettextascent(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgettextascent);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgettextascent", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgettextascent(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgettextascent(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickgettextascent(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgettextascent", count, 3, 4, 1);
  if (count <= 3) return (f_magickgettextascent(a0, a1, a2));
  return (f_magickgettextascent(a0, a1, a2, a3));
}
Variant i_mb_regex_encoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_regex_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_regex_encoding", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_regex_encoding());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_regex_encoding(arg0));
  }
}
Variant ifa_mb_regex_encoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mb_regex_encoding", 1, 1);
  if (count <= 0) return (f_mb_regex_encoding());
  return (f_mb_regex_encoding(a0));
}
Variant i_mail(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mail);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mail", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mail(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mail(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mail(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_mail(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 5) return throw_wrong_arguments("mail", count, 3, 5, 1);
  if (count <= 3) return (f_mail(a0, a1, a2));
  if (count == 4) return (f_mail(a0, a1, a2, a3));
  return (f_mail(a0, a1, a2, a3, a4));
}
Variant i_mcrypt_enc_self_test(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_self_test);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_self_test", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_self_test(arg0));
  }
}
Variant ifa_mcrypt_enc_self_test(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_self_test", count, 1, 1, 1);
  return (f_mcrypt_enc_self_test(a0));
}
Variant i_ignore_user_abort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ignore_user_abort);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ignore_user_abort", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ignore_user_abort());
    CVarRef arg0((ad->getValue(pos)));
    return (f_ignore_user_abort(arg0));
  }
}
Variant ifa_ignore_user_abort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("ignore_user_abort", 1, 1);
  if (count <= 0) return (f_ignore_user_abort());
  return (f_ignore_user_abort(a0));
}
Variant i_imagesetthickness(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagesetthickness);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetthickness", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesetthickness(arg0, arg1));
  }
}
Variant ifa_imagesetthickness(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagesetthickness", count, 2, 2, 1);
  return (f_imagesetthickness(a0, a1));
}
Variant i_str_pad(void *extra, CArrRef params) {
  FUNCTION_INJECTION(str_pad);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("str_pad", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_str_pad(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_str_pad(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_str_pad(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_str_pad(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("str_pad", count, 2, 4, 1);
  if (count <= 2) return (f_str_pad(a0, a1));
  if (count == 3) return (f_str_pad(a0, a1, a2));
  return (f_str_pad(a0, a1, a2, a3));
}
Variant i_openssl_pkcs7_decrypt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs7_decrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_pkcs7_decrypt", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_pkcs7_decrypt(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs7_decrypt(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_pkcs7_decrypt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_pkcs7_decrypt", count, 3, 4, 1);
  if (count <= 3) return (f_openssl_pkcs7_decrypt(a0, a1, a2));
  return (f_openssl_pkcs7_decrypt(a0, a1, a2, a3));
}
Variant i_pagelet_server_task_result(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pagelet_server_task_result);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("pagelet_server_task_result", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_pagelet_server_task_result(arg0, arg1, arg2));
  }
}
Variant ifa_pagelet_server_task_result(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("pagelet_server_task_result", count, 3, 3, 1);
  return (f_pagelet_server_task_result(a0, ref(a1), ref(a2)));
}
Variant i_asinh(void *extra, CArrRef params) {
  FUNCTION_INJECTION(asinh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("asinh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_asinh(arg0));
  }
}
Variant ifa_asinh(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("asinh", count, 1, 1, 1);
  return (f_asinh(a0));
}
Variant i_mailparse_msg_extract_part(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_extract_part);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_part", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mailparse_msg_extract_part(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_msg_extract_part(arg0, arg1, arg2));
  }
}
Variant ifa_mailparse_msg_extract_part(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_part", count, 2, 3, 1);
  if (count <= 2) return (f_mailparse_msg_extract_part(a0, a1));
  return (f_mailparse_msg_extract_part(a0, a1, a2));
}
Variant i_magickgetimagecompose(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecompose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagecompose(arg0));
  }
}
Variant ifa_magickgetimagecompose(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagecompose", count, 1, 1, 1);
  return (f_magickgetimagecompose(a0));
}
Variant i_hphp_splfileinfo_getpath(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getpath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getpath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getpath(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getpath(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getpath", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getpath(a0));
}
Variant i_magickcropimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickcropimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickcropimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcropimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_magickcropimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("magickcropimage", count, 5, 5, 1);
  return (f_magickcropimage(a0, a1, a2, a3, a4));
}
Variant i_ob_gzhandler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_gzhandler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ob_gzhandler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ob_gzhandler(arg0, arg1));
  }
}
Variant ifa_ob_gzhandler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ob_gzhandler", count, 2, 2, 1);
  return (f_ob_gzhandler(a0, a1));
}
Variant i_dom_document_normalize_document(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_normalize_document);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_normalize_document", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_document_normalize_document(arg0));
  }
}
Variant ifa_dom_document_normalize_document(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dom_document_normalize_document", count, 1, 1, 1);
  return (f_dom_document_normalize_document(a0));
}
Variant i_drawcomment(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawcomment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawcomment", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawcomment(arg0, arg1), null);
  }
}
Variant ifa_drawcomment(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawcomment", count, 2, 2, 1);
  return (f_drawcomment(a0, a1), null);
}
Variant i_call_user_method(void *extra, CArrRef params) {
  FUNCTION_INJECTION(call_user_method);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("call_user_method", count+1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_call_user_method(count, arg0, arg1));
    return (f_call_user_method(count,arg0, ref(arg1), params.slice(2, count - 2, false)));
  }
}
Variant ifa_call_user_method(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("call_user_method", count+1, 1);
  if (count <= 2) return (f_call_user_method(count, a0, ref(a1)));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_call_user_method(count,a0, ref(a1), params));
}
Variant i_parse_hdf_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(parse_hdf_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("parse_hdf_file", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_parse_hdf_file(arg0));
  }
}
Variant ifa_parse_hdf_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("parse_hdf_file", count, 1, 1, 1);
  return (f_parse_hdf_file(a0));
}
Variant i_mb_split(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_split);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_split", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_split(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_split(arg0, arg1, arg2));
  }
}
Variant ifa_mb_split(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_split", count, 2, 3, 1);
  if (count <= 2) return (f_mb_split(a0, a1));
  return (f_mb_split(a0, a1, a2));
}
Variant i_imagepolygon(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagepolygon);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagepolygon", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepolygon(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagepolygon(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("imagepolygon", count, 4, 4, 1);
  return (f_imagepolygon(a0, a1, a2, a3));
}
Variant i_mysql_field_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_field_name);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_name", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_name(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_name(arg0, arg1));
  }
}
Variant ifa_mysql_field_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_name", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_field_name(a0));
  return (f_mysql_field_name(a0, a1));
}
Variant i_fputs(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fputs);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fputs", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fputs(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fputs(arg0, arg1, arg2));
  }
}
Variant ifa_fputs(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("fputs", count, 2, 3, 1);
  if (count <= 2) return (f_fputs(a0, a1));
  return (f_fputs(a0, a1, a2));
}
Variant i_imagecolorallocatealpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorallocatealpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorallocatealpha", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorallocatealpha(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_imagecolorallocatealpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("imagecolorallocatealpha", count, 5, 5, 1);
  return (f_imagecolorallocatealpha(a0, a1, a2, a3, a4));
}
Variant i_substr_count(void *extra, CArrRef params) {
  FUNCTION_INJECTION(substr_count);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("substr_count", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_substr_count(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_substr_count(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_substr_count(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_substr_count(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("substr_count", count, 2, 4, 1);
  if (count <= 2) return (f_substr_count(a0, a1));
  if (count == 3) return (f_substr_count(a0, a1, a2));
  return (f_substr_count(a0, a1, a2, a3));
}
Variant i_ldap_first_reference(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_first_reference);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_reference", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_first_reference(arg0, arg1));
  }
}
Variant ifa_ldap_first_reference(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_first_reference", count, 2, 2, 1);
  return (f_ldap_first_reference(a0, a1));
}
Variant i_clock_settime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(clock_settime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_settime", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_clock_settime(arg0, arg1, arg2));
  }
}
Variant ifa_clock_settime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("clock_settime", count, 3, 3, 1);
  return (f_clock_settime(a0, a1, a2));
}
Variant i_dom_namednodemap_get_named_item_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_namednodemap_get_named_item_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_namednodemap_get_named_item_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_namednodemap_get_named_item_ns(arg0, arg1, arg2));
  }
}
Variant ifa_dom_namednodemap_get_named_item_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_namednodemap_get_named_item_ns", count, 3, 3, 1);
  return (f_dom_namednodemap_get_named_item_ns(a0, a1, a2));
}
Variant i_ftruncate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ftruncate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ftruncate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ftruncate(arg0, arg1));
  }
}
Variant ifa_ftruncate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ftruncate", count, 2, 2, 1);
  return (f_ftruncate(a0, a1));
}
Variant i_curl_version(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_version);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("curl_version", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_curl_version());
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_version(arg0));
  }
}
Variant ifa_curl_version(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("curl_version", 1, 1);
  if (count <= 0) return (f_curl_version());
  return (f_curl_version(a0));
}
Variant i_pixelgetbluequantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetbluequantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetbluequantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetbluequantum(arg0));
  }
}
Variant ifa_pixelgetbluequantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetbluequantum", count, 1, 1, 1);
  return (f_pixelgetbluequantum(a0));
}
Variant i_print(void *extra, CArrRef params) {
  FUNCTION_INJECTION(print);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("print", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_print(arg0));
  }
}
Variant ifa_print(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("print", count, 1, 1, 1);
  return (f_print(a0));
}
Variant i_mysql_unbuffered_query(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_unbuffered_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_unbuffered_query", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_unbuffered_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_unbuffered_query(arg0, arg1));
  }
}
Variant ifa_mysql_unbuffered_query(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_unbuffered_query", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_unbuffered_query(a0));
  return (f_mysql_unbuffered_query(a0, a1));
}
Variant i_dom_characterdata_delete_data(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_characterdata_delete_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_delete_data", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_characterdata_delete_data(arg0, arg1, arg2));
  }
}
Variant ifa_dom_characterdata_delete_data(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_characterdata_delete_data", count, 3, 3, 1);
  return (f_dom_characterdata_delete_data(a0, a1, a2));
}
Variant i_hphp_recursiveiteratoriterator___construct(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator___construct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_recursiveiteratoriterator___construct", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_recursiveiteratoriterator___construct(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_hphp_recursiveiteratoriterator___construct(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("hphp_recursiveiteratoriterator___construct", count, 4, 4, 1);
  return (f_hphp_recursiveiteratoriterator___construct(a0, a1, a2, a3));
}
Variant i_hash_final(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hash_final);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hash_final", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_hash_final(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_final(arg0, arg1));
  }
}
Variant ifa_hash_final(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("hash_final", count, 1, 2, 1);
  if (count <= 1) return (f_hash_final(a0));
  return (f_hash_final(a0, a1));
}
Variant i_imagecolorresolve(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorresolve);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorresolve", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorresolve(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagecolorresolve(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("imagecolorresolve", count, 4, 4, 1);
  return (f_imagecolorresolve(a0, a1, a2, a3));
}
Variant i_dom_document_import_node(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_import_node);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_import_node", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_document_import_node(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_import_node(arg0, arg1, arg2));
  }
}
Variant ifa_dom_document_import_node(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_import_node", count, 2, 3, 1);
  if (count <= 2) return (f_dom_document_import_node(a0, a1));
  return (f_dom_document_import_node(a0, a1, a2));
}
Variant i_date_date_set(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_date_set);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("date_date_set", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_date_set(arg0, arg1, arg2, arg3), null);
  }
}
Variant ifa_date_date_set(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("date_date_set", count, 4, 4, 1);
  return (f_date_date_set(a0, a1, a2, a3), null);
}
Variant i_pixelsetyellow(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetyellow);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetyellow", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetyellow(arg0, arg1), null);
  }
}
Variant ifa_pixelsetyellow(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetyellow", count, 2, 2, 1);
  return (f_pixelsetyellow(a0, a1), null);
}
Variant i_furchash_hphp_ext_supported(void *extra, CArrRef params) {
  FUNCTION_INJECTION(furchash_hphp_ext_supported);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("furchash_hphp_ext_supported", 0, 1);
  return (f_furchash_hphp_ext_supported());
}
Variant ifa_furchash_hphp_ext_supported(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("furchash_hphp_ext_supported", 0, 1);
  return (f_furchash_hphp_ext_supported());
}
Variant i_inet_pton(void *extra, CArrRef params) {
  FUNCTION_INJECTION(inet_pton);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("inet_pton", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_inet_pton(arg0));
  }
}
Variant ifa_inet_pton(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("inet_pton", count, 1, 1, 1);
  return (f_inet_pton(a0));
}
Variant i_mcrypt_get_key_size(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_get_key_size);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_get_key_size", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_get_key_size(arg0, arg1));
  }
}
Variant ifa_mcrypt_get_key_size(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("mcrypt_get_key_size", count, 2, 2, 1);
  return (f_mcrypt_get_key_size(a0, a1));
}
Variant i_drawsettextalignment(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsettextalignment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextalignment", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsettextalignment(arg0, arg1), null);
  }
}
Variant ifa_drawsettextalignment(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsettextalignment", count, 2, 2, 1);
  return (f_drawsettextalignment(a0, a1), null);
}
Variant i_magickgetimageredprimary(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageredprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageredprimary", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageredprimary(arg0));
  }
}
Variant ifa_magickgetimageredprimary(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimageredprimary", count, 1, 1, 1);
  return (f_magickgetimageredprimary(a0));
}
Variant i_addslashes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(addslashes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("addslashes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_addslashes(arg0));
  }
}
Variant ifa_addslashes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("addslashes", count, 1, 1, 1);
  return (f_addslashes(a0));
}
Variant i_ldap_count_entries(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_count_entries);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_count_entries", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_count_entries(arg0, arg1));
  }
}
Variant ifa_ldap_count_entries(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_count_entries", count, 2, 2, 1);
  return (f_ldap_count_entries(a0, a1));
}
Variant i_ereg_replace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ereg_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ereg_replace", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ereg_replace(arg0, arg1, arg2));
  }
}
Variant ifa_ereg_replace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ereg_replace", count, 3, 3, 1);
  return (f_ereg_replace(a0, a1, a2));
}
Variant i_hphp_recursivedirectoryiterator_getchildren(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_getchildren);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getchildren", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_getchildren(arg0));
  }
}
Variant ifa_hphp_recursivedirectoryiterator_getchildren(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getchildren", count, 1, 1, 1);
  return (f_hphp_recursivedirectoryiterator_getchildren(a0));
}
Variant i_call_user_func_async(void *extra, CArrRef params) {
  FUNCTION_INJECTION(call_user_func_async);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("call_user_func_async", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_call_user_func_async(count, arg0));
    return (f_call_user_func_async(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_call_user_func_async(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("call_user_func_async", count+1, 1);
  if (count <= 1) return (f_call_user_func_async(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_call_user_func_async(count,a0, params));
}
Variant i_drawrender(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawrender);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawrender", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawrender(arg0));
  }
}
Variant ifa_drawrender(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawrender", count, 1, 1, 1);
  return (f_drawrender(a0));
}
Variant i_fb_rpc_intercept_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_rpc_intercept_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("fb_rpc_intercept_handler", count, 5, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_fb_rpc_intercept_handler(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_fb_rpc_intercept_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("fb_rpc_intercept_handler", count, 5, 5, 1);
  return (f_fb_rpc_intercept_handler(a0, a1, a2, a3, ref(a4)));
}
Variant i_fb_intercept(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_intercept);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_intercept", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fb_intercept(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_intercept(arg0, arg1, arg2));
  }
}
Variant ifa_fb_intercept(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_intercept", count, 2, 3, 1);
  if (count <= 2) return (f_fb_intercept(a0, a1));
  return (f_fb_intercept(a0, a1, a2));
}
Variant i_magickgetversionnumber(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetversionnumber);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversionnumber", 0, 1);
  return (f_magickgetversionnumber());
}
Variant ifa_magickgetversionnumber(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("magickgetversionnumber", 0, 1);
  return (f_magickgetversionnumber());
}
Variant i_array_splice(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_splice);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("array_splice", count, 2, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_splice(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_array_splice(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_splice(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_array_splice(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("array_splice", count, 2, 4, 1);
  if (count <= 2) return (f_array_splice(ref(a0), a1));
  if (count == 3) return (f_array_splice(ref(a0), a1, a2));
  return (f_array_splice(ref(a0), a1, a2, a3));
}
Variant i_ftell(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ftell);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ftell", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ftell(arg0));
  }
}
Variant ifa_ftell(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ftell", count, 1, 1, 1);
  return (f_ftell(a0));
}
Variant i_magicksetimagedepth(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagedepth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magicksetimagedepth", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magicksetimagedepth(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagedepth(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetimagedepth(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("magicksetimagedepth", count, 2, 3, 1);
  if (count <= 2) return (f_magicksetimagedepth(a0, a1));
  return (f_magicksetimagedepth(a0, a1, a2));
}
Variant i_apc_load_constants(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_load_constants);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_load_constants", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_load_constants(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_load_constants(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_load_constants(arg0, arg1, arg2));
  }
}
Variant ifa_apc_load_constants(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_load_constants", count, 1, 3, 1);
  if (count <= 1) return (f_apc_load_constants(a0));
  if (count == 2) return (f_apc_load_constants(a0, a1));
  return (f_apc_load_constants(a0, a1, a2));
}
Variant i___halt_compiler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(__halt_compiler);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("__halt_compiler", 0, 1);
  return (f___halt_compiler(), null);
}
Variant ifa___halt_compiler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("__halt_compiler", 0, 1);
  return (f___halt_compiler(), null);
}
Variant i_magicklabelimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicklabelimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicklabelimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicklabelimage(arg0, arg1));
  }
}
Variant ifa_magicklabelimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicklabelimage", count, 2, 2, 1);
  return (f_magicklabelimage(a0, a1));
}
Variant i_hphp_log(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_log);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_log", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_log(arg0, arg1));
  }
}
Variant ifa_hphp_log(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_log", count, 2, 2, 1);
  return (f_hphp_log(a0, a1));
}
Variant i_stream_get_contents(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_get_contents);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_get_contents", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_get_contents(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_stream_get_contents(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_get_contents(arg0, arg1, arg2));
  }
}
Variant ifa_stream_get_contents(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_get_contents", count, 1, 3, 1);
  if (count <= 1) return (f_stream_get_contents(a0));
  if (count == 2) return (f_stream_get_contents(a0, a1));
  return (f_stream_get_contents(a0, a1, a2));
}
Variant i_imagecreatefromjpeg(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromjpeg);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromjpeg", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromjpeg(arg0));
  }
}
Variant ifa_imagecreatefromjpeg(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagecreatefromjpeg", count, 1, 1, 1);
  return (f_imagecreatefromjpeg(a0));
}
Variant i_chown(void *extra, CArrRef params) {
  FUNCTION_INJECTION(chown);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chown", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_chown(arg0, arg1));
  }
}
Variant ifa_chown(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("chown", count, 2, 2, 1);
  return (f_chown(a0, a1));
}
Variant i_hash_hmac_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hash_hmac_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("hash_hmac_file", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_hash_hmac_file(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_hmac_file(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_hash_hmac_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("hash_hmac_file", count, 3, 4, 1);
  if (count <= 3) return (f_hash_hmac_file(a0, a1, a2));
  return (f_hash_hmac_file(a0, a1, a2, a3));
}
Variant i_magickechoimageblob(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickechoimageblob);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickechoimageblob", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickechoimageblob(arg0));
  }
}
Variant ifa_magickechoimageblob(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickechoimageblob", count, 1, 1, 1);
  return (f_magickechoimageblob(a0));
}
Variant i_link(void *extra, CArrRef params) {
  FUNCTION_INJECTION(link);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("link", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_link(arg0, arg1));
  }
}
Variant ifa_link(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("link", count, 2, 2, 1);
  return (f_link(a0, a1));
}
Variant i_fb_utf8ize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_utf8ize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_utf8ize", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_fb_utf8ize(arg0));
  }
}
Variant ifa_fb_utf8ize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fb_utf8ize", count, 1, 1, 1);
  return (f_fb_utf8ize(ref(a0)));
}
Variant i_drawsetfillpatternurl(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetfillpatternurl);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillpatternurl", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfillpatternurl(arg0, arg1));
  }
}
Variant ifa_drawsetfillpatternurl(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetfillpatternurl", count, 2, 2, 1);
  return (f_drawsetfillpatternurl(a0, a1));
}
Variant i_iconv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iconv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("iconv", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv(arg0, arg1, arg2));
  }
}
Variant ifa_iconv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("iconv", count, 3, 3, 1);
  return (f_iconv(a0, a1, a2));
}
Variant i_highlight_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(highlight_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("highlight_file", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_highlight_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_highlight_file(arg0, arg1));
  }
}
Variant ifa_highlight_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("highlight_file", count, 1, 2, 1);
  if (count <= 1) return (f_highlight_file(a0));
  return (f_highlight_file(a0, a1));
}
Variant i_iconv_mime_decode_headers(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iconv_mime_decode_headers);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("iconv_mime_decode_headers", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_iconv_mime_decode_headers(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_iconv_mime_decode_headers(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_mime_decode_headers(arg0, arg1, arg2));
  }
}
Variant ifa_iconv_mime_decode_headers(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("iconv_mime_decode_headers", count, 1, 3, 1);
  if (count <= 1) return (f_iconv_mime_decode_headers(a0));
  if (count == 2) return (f_iconv_mime_decode_headers(a0, a1));
  return (f_iconv_mime_decode_headers(a0, a1, a2));
}
Variant i_ini_get_all(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ini_get_all);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ini_get_all", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ini_get_all());
    CVarRef arg0((ad->getValue(pos)));
    return (f_ini_get_all(arg0));
  }
}
Variant ifa_ini_get_all(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("ini_get_all", 1, 1);
  if (count <= 0) return (f_ini_get_all());
  return (f_ini_get_all(a0));
}
Variant i_collator_get_strength(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_get_strength);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_strength", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_collator_get_strength(arg0));
  }
}
Variant ifa_collator_get_strength(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("collator_get_strength", count, 1, 1, 1);
  return (f_collator_get_strength(a0));
}
Variant i_ldap_get_values_len(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_get_values_len);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_values_len", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_get_values_len(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_get_values_len(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ldap_get_values_len", count, 3, 3, 1);
  return (f_ldap_get_values_len(a0, a1, a2));
}
Variant i_hphp_splfileinfo_getrealpath(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getrealpath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getrealpath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getrealpath(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getrealpath(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getrealpath", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getrealpath(a0));
}
Variant i_openssl_pkcs7_verify(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs7_verify);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) return throw_wrong_arguments("openssl_pkcs7_verify", count, 2, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_pkcs7_verify(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_openssl_pkcs7_verify(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_openssl_pkcs7_verify(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_openssl_pkcs7_verify(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs7_verify(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_openssl_pkcs7_verify(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 6) return throw_wrong_arguments("openssl_pkcs7_verify", count, 2, 6, 1);
  if (count <= 2) return (f_openssl_pkcs7_verify(a0, a1));
  if (count == 3) return (f_openssl_pkcs7_verify(a0, a1, a2));
  if (count == 4) return (f_openssl_pkcs7_verify(a0, a1, a2, a3));
  if (count == 5) return (f_openssl_pkcs7_verify(a0, a1, a2, a3, a4));
  return (f_openssl_pkcs7_verify(a0, a1, a2, a3, a4, a5));
}
Variant i_hphp_directoryiterator_current(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_current);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_current", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_current(arg0));
  }
}
Variant ifa_hphp_directoryiterator_current(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_current", count, 1, 1, 1);
  return (f_hphp_directoryiterator_current(a0));
}
Variant i_hphp_splfileobject_fgetcsv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fgetcsv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_fgetcsv", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_fgetcsv(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_hphp_splfileobject_fgetcsv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_fgetcsv", count, 4, 4, 1);
  return (f_hphp_splfileobject_fgetcsv(a0, a1, a2, a3));
}
Variant i_furchash_hphp_ext(void *extra, CArrRef params) {
  FUNCTION_INJECTION(furchash_hphp_ext);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("furchash_hphp_ext", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_furchash_hphp_ext(arg0, arg1, arg2));
  }
}
Variant ifa_furchash_hphp_ext(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("furchash_hphp_ext", count, 3, 3, 1);
  return (f_furchash_hphp_ext(a0, a1, a2));
}
Variant i_stream_socket_recvfrom(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_socket_recvfrom);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_recvfrom", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_socket_recvfrom(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_socket_recvfrom(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_recvfrom(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_stream_socket_recvfrom(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_recvfrom", count, 2, 4, 1);
  if (count <= 2) return (f_stream_socket_recvfrom(a0, a1));
  if (count == 3) return (f_stream_socket_recvfrom(a0, a1, a2));
  return (f_stream_socket_recvfrom(a0, a1, a2, a3));
}
Variant i_drawgetcliprule(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetcliprule);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetcliprule", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetcliprule(arg0));
  }
}
Variant ifa_drawgetcliprule(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetcliprule", count, 1, 1, 1);
  return (f_drawgetcliprule(a0));
}
Variant i_apc_filehits(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_filehits);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apc_filehits", 0, 1);
  return (f_apc_filehits());
}
Variant ifa_apc_filehits(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("apc_filehits", 0, 1);
  return (f_apc_filehits());
}
Variant i_pixelgetexceptionstring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetexceptionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexceptionstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetexceptionstring(arg0));
  }
}
Variant ifa_pixelgetexceptionstring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetexceptionstring", count, 1, 1, 1);
  return (f_pixelgetexceptionstring(a0));
}
Variant i_mcrypt_ofb(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_ofb);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_ofb", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_ofb(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_ofb(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_mcrypt_ofb(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_ofb", count, 4, 5, 1);
  if (count <= 4) return (f_mcrypt_ofb(a0, a1, a2, a3));
  return (f_mcrypt_ofb(a0, a1, a2, a3, a4));
}
Variant i_imageantialias(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imageantialias);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imageantialias", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageantialias(arg0, arg1));
  }
}
Variant ifa_imageantialias(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imageantialias", count, 2, 2, 1);
  return (f_imageantialias(a0, a1));
}
Variant i_hphp_splfileinfo_openfile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_openfile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileinfo_openfile", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_openfile(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_hphp_splfileinfo_openfile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("hphp_splfileinfo_openfile", count, 4, 4, 1);
  return (f_hphp_splfileinfo_openfile(a0, a1, a2, a3));
}
Variant i_dom_document_validate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_validate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_validate", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_document_validate(arg0));
  }
}
Variant ifa_dom_document_validate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dom_document_validate", count, 1, 1, 1);
  return (f_dom_document_validate(a0));
}
Variant i_idn_to_ascii(void *extra, CArrRef params) {
  FUNCTION_INJECTION(idn_to_ascii);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_ascii", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_idn_to_ascii(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_idn_to_ascii(arg0, arg1));
  }
}
Variant ifa_idn_to_ascii(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_ascii", count, 1, 2, 1);
  if (count <= 1) return (f_idn_to_ascii(a0));
  return (f_idn_to_ascii(a0, ref(a1)));
}
Variant i_error_log(void *extra, CArrRef params) {
  FUNCTION_INJECTION(error_log);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("error_log", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_error_log(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_error_log(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_error_log(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_error_log(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_error_log(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("error_log", count, 1, 4, 1);
  if (count <= 1) return (f_error_log(a0));
  if (count == 2) return (f_error_log(a0, a1));
  if (count == 3) return (f_error_log(a0, a1, a2));
  return (f_error_log(a0, a1, a2, a3));
}
Variant i_hash_update(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hash_update);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hash_update", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_update(arg0, arg1));
  }
}
Variant ifa_hash_update(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hash_update", count, 2, 2, 1);
  return (f_hash_update(a0, a1));
}
Variant i_ob_flush(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_flush", 0, 1);
  return (f_ob_flush(), null);
}
Variant ifa_ob_flush(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("ob_flush", 0, 1);
  return (f_ob_flush(), null);
}
Variant i_md5_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(md5_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("md5_file", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_md5_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_md5_file(arg0, arg1));
  }
}
Variant ifa_md5_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("md5_file", count, 1, 2, 1);
  if (count <= 1) return (f_md5_file(a0));
  return (f_md5_file(a0, a1));
}
Variant i_drawgetexception(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetexception(arg0));
  }
}
Variant ifa_drawgetexception(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetexception", count, 1, 1, 1);
  return (f_drawgetexception(a0));
}
Variant i_file_get_contents(void *extra, CArrRef params) {
  FUNCTION_INJECTION(file_get_contents);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("file_get_contents", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_file_get_contents(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_file_get_contents(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_file_get_contents(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_file_get_contents(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_file_get_contents(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_file_get_contents(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 5) return throw_wrong_arguments("file_get_contents", count, 1, 5, 1);
  if (count <= 1) return (f_file_get_contents(a0));
  if (count == 2) return (f_file_get_contents(a0, a1));
  if (count == 3) return (f_file_get_contents(a0, a1, a2));
  if (count == 4) return (f_file_get_contents(a0, a1, a2, a3));
  return (f_file_get_contents(a0, a1, a2, a3, a4));
}
Variant i_uniqid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(uniqid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("uniqid", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_uniqid());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_uniqid(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_uniqid(arg0, arg1));
  }
}
Variant ifa_uniqid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("uniqid", 2, 1);
  if (count <= 0) return (f_uniqid());
  if (count == 1) return (f_uniqid(a0));
  return (f_uniqid(a0, a1));
}
Variant i_strncasecmp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strncasecmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("strncasecmp", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strncasecmp(arg0, arg1, arg2));
  }
}
Variant ifa_strncasecmp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("strncasecmp", count, 3, 3, 1);
  return (f_strncasecmp(a0, a1, a2));
}
Variant i_magicksetimagepixels(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagepixels);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("magicksetimagepixels", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagepixels(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant ifa_magicksetimagepixels(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 8) return throw_wrong_arguments("magicksetimagepixels", count, 8, 8, 1);
  return (f_magicksetimagepixels(a0, a1, a2, a3, a4, a5, null, null));
}
Variant i_drawgetfillopacity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetfillopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillopacity", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfillopacity(arg0));
  }
}
Variant ifa_drawgetfillopacity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetfillopacity", count, 1, 1, 1);
  return (f_drawgetfillopacity(a0));
}
Variant i_xml_parser_create_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_parser_create_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("xml_parser_create_ns", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_xml_parser_create_ns());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_xml_parser_create_ns(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_parser_create_ns(arg0, arg1));
  }
}
Variant ifa_xml_parser_create_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("xml_parser_create_ns", 2, 1);
  if (count <= 0) return (f_xml_parser_create_ns());
  if (count == 1) return (f_xml_parser_create_ns(a0));
  return (f_xml_parser_create_ns(a0, a1));
}
Variant i_ldap_delete(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_delete);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_delete", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_delete(arg0, arg1));
  }
}
Variant ifa_ldap_delete(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_delete", count, 2, 2, 1);
  return (f_ldap_delete(a0, a1));
}
Variant i_fnmatch(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fnmatch);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fnmatch", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fnmatch(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fnmatch(arg0, arg1, arg2));
  }
}
Variant ifa_fnmatch(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("fnmatch", count, 2, 3, 1);
  if (count <= 2) return (f_fnmatch(a0, a1));
  return (f_fnmatch(a0, a1, a2));
}
Variant i_hphp_splfileobject_eof(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_eof);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_eof", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_eof(arg0));
  }
}
Variant ifa_hphp_splfileobject_eof(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_eof", count, 1, 1, 1);
  return (f_hphp_splfileobject_eof(a0));
}
Variant i_metaphone(void *extra, CArrRef params) {
  FUNCTION_INJECTION(metaphone);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("metaphone", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_metaphone(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_metaphone(arg0, arg1));
  }
}
Variant ifa_metaphone(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("metaphone", count, 1, 2, 1);
  if (count <= 1) return (f_metaphone(a0));
  return (f_metaphone(a0, a1));
}
Variant i_mysql_errno(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_errno);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_errno", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_errno());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_errno(arg0));
  }
}
Variant ifa_mysql_errno(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_errno", 1, 1);
  if (count <= 0) return (f_mysql_errno());
  return (f_mysql_errno(a0));
}
Variant i_stream_wrapper_unregister(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_wrapper_unregister);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_wrapper_unregister", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_wrapper_unregister(arg0));
  }
}
Variant ifa_stream_wrapper_unregister(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("stream_wrapper_unregister", count, 1, 1, 1);
  return (f_stream_wrapper_unregister(a0));
}
Variant i_magickcyclecolormapimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickcyclecolormapimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcyclecolormapimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcyclecolormapimage(arg0, arg1));
  }
}
Variant ifa_magickcyclecolormapimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickcyclecolormapimage", count, 2, 2, 1);
  return (f_magickcyclecolormapimage(a0, a1));
}
Variant i_hphp_recursiveiteratoriterator_current(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_current);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_current", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_current(arg0));
  }
}
Variant ifa_hphp_recursiveiteratoriterator_current(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_current", count, 1, 1, 1);
  return (f_hphp_recursiveiteratoriterator_current(a0));
}
Variant i_restore_error_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(restore_error_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_error_handler", 0, 1);
  return (f_restore_error_handler());
}
Variant ifa_restore_error_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("restore_error_handler", 0, 1);
  return (f_restore_error_handler());
}
Variant i_hphp_recursivedirectoryiterator___construct(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator___construct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_recursivedirectoryiterator___construct", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_recursivedirectoryiterator___construct(arg0, arg1, arg2));
  }
}
Variant ifa_hphp_recursivedirectoryiterator___construct(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("hphp_recursivedirectoryiterator___construct", count, 3, 3, 1);
  return (f_hphp_recursivedirectoryiterator___construct(a0, a1, a2));
}
Variant i_magicksetimagevirtualpixelmethod(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagevirtualpixelmethod);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagevirtualpixelmethod", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagevirtualpixelmethod(arg0, arg1));
  }
}
Variant ifa_magicksetimagevirtualpixelmethod(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagevirtualpixelmethod", count, 2, 2, 1);
  return (f_magicksetimagevirtualpixelmethod(a0, a1));
}
Variant i_socket_getpeername(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_getpeername);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_getpeername", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_getpeername(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_socket_getpeername(arg0, arg1, arg2));
  }
}
Variant ifa_socket_getpeername(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_getpeername", count, 2, 3, 1);
  if (count <= 2) return (f_socket_getpeername(a0, ref(a1)));
  return (f_socket_getpeername(a0, ref(a1), ref(a2)));
}
Variant i_memcache_close(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_memcache_close(arg0));
  }
}
Variant ifa_memcache_close(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("memcache_close", count, 1, 1, 1);
  return (f_memcache_close(a0));
}
Variant i_mysql_error(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_error", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_error());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_error(arg0));
  }
}
Variant ifa_mysql_error(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_error", 1, 1);
  if (count <= 0) return (f_mysql_error());
  return (f_mysql_error(a0));
}
Variant i_drawtranslate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawtranslate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawtranslate", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawtranslate(arg0, arg1, arg2), null);
  }
}
Variant ifa_drawtranslate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("drawtranslate", count, 3, 3, 1);
  return (f_drawtranslate(a0, a1, a2), null);
}
Variant i_mysql_list_dbs(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_list_dbs);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_list_dbs", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_list_dbs());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_list_dbs(arg0));
  }
}
Variant ifa_mysql_list_dbs(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_list_dbs", 1, 1);
  if (count <= 0) return (f_mysql_list_dbs());
  return (f_mysql_list_dbs(a0));
}
Variant i_imagefilter(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagefilter);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) return throw_wrong_arguments("imagefilter", count, 2, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_imagefilter(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_imagefilter(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_imagefilter(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_imagefilter(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilter(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imagefilter(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 6) return throw_wrong_arguments("imagefilter", count, 2, 6, 1);
  if (count <= 2) return (f_imagefilter(a0, a1));
  if (count == 3) return (f_imagefilter(a0, a1, a2));
  if (count == 4) return (f_imagefilter(a0, a1, a2, a3));
  if (count == 5) return (f_imagefilter(a0, a1, a2, a3, a4));
  return (f_imagefilter(a0, a1, a2, a3, a4, a5));
}
Variant i_base64_encode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(base64_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("base64_encode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_base64_encode(arg0));
  }
}
Variant ifa_base64_encode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("base64_encode", count, 1, 1, 1);
  return (f_base64_encode(a0));
}
Variant i_dom_xpath_query(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_xpath_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_xpath_query", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_xpath_query(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_xpath_query(arg0, arg1, arg2));
  }
}
Variant ifa_dom_xpath_query(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_xpath_query", count, 2, 3, 1);
  if (count <= 2) return (f_dom_xpath_query(a0, a1));
  return (f_dom_xpath_query(a0, a1, a2));
}
Variant i_hphpd_install_user_command(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphpd_install_user_command);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphpd_install_user_command", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphpd_install_user_command(arg0, arg1));
  }
}
Variant ifa_hphpd_install_user_command(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphpd_install_user_command", count, 2, 2, 1);
  return (f_hphpd_install_user_command(a0, a1));
}
Variant i_dom_element_set_id_attribute_node(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_id_attribute_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_id_attribute_node", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_id_attribute_node(arg0, arg1, arg2));
  }
}
Variant ifa_dom_element_set_id_attribute_node(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_element_set_id_attribute_node", count, 3, 3, 1);
  return (f_dom_element_set_id_attribute_node(a0, a1, a2));
}
Variant i_is_null(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_null);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_null", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_null(arg0));
  }
}
Variant ifa_is_null(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_null", count, 1, 1, 1);
  return (f_is_null(a0));
}
Variant i_octdec(void *extra, CArrRef params) {
  FUNCTION_INJECTION(octdec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("octdec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_octdec(arg0));
  }
}
Variant ifa_octdec(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("octdec", count, 1, 1, 1);
  return (f_octdec(a0));
}
Variant i_drawsetclippath(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetclippath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetclippath", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetclippath(arg0, arg1));
  }
}
Variant ifa_drawsetclippath(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetclippath", count, 2, 2, 1);
  return (f_drawsetclippath(a0, a1));
}
Variant i_magickconstituteimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickconstituteimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickconstituteimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickconstituteimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_magickconstituteimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("magickconstituteimage", count, 6, 6, 1);
  return (f_magickconstituteimage(a0, a1, a2, a3, a4, a5));
}
Variant i_pcntl_wexitstatus(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_wexitstatus);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wexitstatus", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wexitstatus(arg0));
  }
}
Variant ifa_pcntl_wexitstatus(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pcntl_wexitstatus", count, 1, 1, 1);
  return (f_pcntl_wexitstatus(a0));
}
Variant i_iterator_apply(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iterator_apply);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iterator_apply", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iterator_apply(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iterator_apply(arg0, arg1, arg2));
  }
}
Variant ifa_iterator_apply(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("iterator_apply", count, 2, 3, 1);
  if (count <= 2) return (f_iterator_apply(a0, a1));
  return (f_iterator_apply(a0, a1, a2));
}
Variant i_apache_setenv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apache_setenv);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("apache_setenv", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_apache_setenv(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apache_setenv(arg0, arg1, arg2));
  }
}
Variant ifa_apache_setenv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("apache_setenv", count, 2, 3, 1);
  if (count <= 2) return (f_apache_setenv(a0, a1));
  return (f_apache_setenv(a0, a1, a2));
}
Variant i_dom_node_is_same_node(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_is_same_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_is_same_node", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_is_same_node(arg0, arg1));
  }
}
Variant ifa_dom_node_is_same_node(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_node_is_same_node", count, 2, 2, 1);
  return (f_dom_node_is_same_node(a0, a1));
}
Variant i_clonedrawingwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(clonedrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clonedrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_clonedrawingwand(arg0));
  }
}
Variant ifa_clonedrawingwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("clonedrawingwand", count, 1, 1, 1);
  return (f_clonedrawingwand(a0));
}
Variant i_ob_get_clean(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_get_clean);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_clean", 0, 1);
  return (f_ob_get_clean());
}
Variant ifa_ob_get_clean(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("ob_get_clean", 0, 1);
  return (f_ob_get_clean());
}
Variant i_expm1(void *extra, CArrRef params) {
  FUNCTION_INJECTION(expm1);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("expm1", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_expm1(arg0));
  }
}
Variant ifa_expm1(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("expm1", count, 1, 1, 1);
  return (f_expm1(a0));
}
Variant i_ldap_first_entry(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_first_entry);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_entry", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_first_entry(arg0, arg1));
  }
}
Variant ifa_ldap_first_entry(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_first_entry", count, 2, 2, 1);
  return (f_ldap_first_entry(a0, a1));
}
Variant i_curl_multi_select(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_multi_select);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_multi_select", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_curl_multi_select(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_multi_select(arg0, arg1));
  }
}
Variant ifa_curl_multi_select(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_multi_select", count, 1, 2, 1);
  if (count <= 1) return (f_curl_multi_select(a0));
  return (f_curl_multi_select(a0, a1));
}
Variant i_magickswirlimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickswirlimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickswirlimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickswirlimage(arg0, arg1));
  }
}
Variant ifa_magickswirlimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickswirlimage", count, 2, 2, 1);
  return (f_magickswirlimage(a0, a1));
}
Variant i_mb_ereg_search_regs(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_regs);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search_regs", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_ereg_search_regs());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mb_ereg_search_regs(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_search_regs(arg0, arg1));
  }
}
Variant ifa_mb_ereg_search_regs(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("mb_ereg_search_regs", 2, 1);
  if (count <= 0) return (f_mb_ereg_search_regs());
  if (count == 1) return (f_mb_ereg_search_regs(a0));
  return (f_mb_ereg_search_regs(a0, a1));
}
Variant i_ldap_errno(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_errno);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_errno", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_errno(arg0));
  }
}
Variant ifa_ldap_errno(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ldap_errno", count, 1, 1, 1);
  return (f_ldap_errno(a0));
}
Variant i_mysql_get_server_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_get_server_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_server_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_get_server_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_get_server_info(arg0));
  }
}
Variant ifa_mysql_get_server_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_get_server_info", 1, 1);
  if (count <= 0) return (f_mysql_get_server_info());
  return (f_mysql_get_server_info(a0));
}
Variant i_mailparse_rfc822_parse_addresses(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_rfc822_parse_addresses);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_rfc822_parse_addresses", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_rfc822_parse_addresses(arg0));
  }
}
Variant ifa_mailparse_rfc822_parse_addresses(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mailparse_rfc822_parse_addresses", count, 1, 1, 1);
  return (f_mailparse_rfc822_parse_addresses(a0));
}
Variant i_magickgetimagemimetype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagemimetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagemimetype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagemimetype(arg0));
  }
}
Variant ifa_magickgetimagemimetype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagemimetype", count, 1, 1, 1);
  return (f_magickgetimagemimetype(a0));
}
Variant i_soundex(void *extra, CArrRef params) {
  FUNCTION_INJECTION(soundex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("soundex", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_soundex(arg0));
  }
}
Variant ifa_soundex(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("soundex", count, 1, 1, 1);
  return (f_soundex(a0));
}
Variant i_magickgetimageformat(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageformat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageformat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageformat(arg0));
  }
}
Variant ifa_magickgetimageformat(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimageformat", count, 1, 1, 1);
  return (f_magickgetimageformat(a0));
}
Variant i_mcrypt_module_get_supported_key_sizes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_get_supported_key_sizes);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_supported_key_sizes", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_get_supported_key_sizes(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_get_supported_key_sizes(arg0, arg1));
  }
}
Variant ifa_mcrypt_module_get_supported_key_sizes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_supported_key_sizes", count, 1, 2, 1);
  if (count <= 1) return (f_mcrypt_module_get_supported_key_sizes(a0));
  return (f_mcrypt_module_get_supported_key_sizes(a0, a1));
}
Variant i_preg_replace_callback(void *extra, CArrRef params) {
  FUNCTION_INJECTION(preg_replace_callback);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_replace_callback", count, 3, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_preg_replace_callback(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_preg_replace_callback(arg0, arg1, arg2, arg3));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_preg_replace_callback(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_preg_replace_callback(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_replace_callback", count, 3, 5, 1);
  if (count <= 3) return (f_preg_replace_callback(a0, a1, a2));
  if (count == 4) return (f_preg_replace_callback(a0, a1, a2, a3));
  return (f_preg_replace_callback(a0, a1, a2, a3, ref(a4)));
}
Variant i_dom_document_create_element(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_element);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_create_element", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_document_create_element(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_element(arg0, arg1, arg2));
  }
}
Variant ifa_dom_document_create_element(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_create_element", count, 2, 3, 1);
  if (count <= 2) return (f_dom_document_create_element(a0, a1));
  return (f_dom_document_create_element(a0, a1, a2));
}
Variant i_ldap_error(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_error);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_error", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_error(arg0));
  }
}
Variant ifa_ldap_error(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ldap_error", count, 1, 1, 1);
  return (f_ldap_error(a0));
}
Variant i_xmlwriter_full_end_element(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_full_end_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_full_end_element", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_full_end_element(arg0));
  }
}
Variant ifa_xmlwriter_full_end_element(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_full_end_element", count, 1, 1, 1);
  return (f_xmlwriter_full_end_element(a0));
}
Variant i_ctype_graph(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ctype_graph);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_graph", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_graph(arg0));
  }
}
Variant ifa_ctype_graph(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ctype_graph", count, 1, 1, 1);
  return (f_ctype_graph(a0));
}
Variant i_session_register(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_register);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("session_register", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_session_register(count, arg0));
    return (f_session_register(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_session_register(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("session_register", count+1, 1);
  if (count <= 1) return (f_session_register(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_session_register(count,a0, params));
}
Variant i_asort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(asort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("asort", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_asort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_asort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_asort(arg0, arg1, arg2));
  }
}
Variant ifa_asort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("asort", count, 1, 3, 1);
  if (count <= 1) return (f_asort(ref(a0)));
  if (count == 2) return (f_asort(ref(a0), a1));
  return (f_asort(ref(a0), a1, a2));
}
Variant i_apd_echo(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apd_echo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("apd_echo", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_apd_echo(arg0));
  }
}
Variant ifa_apd_echo(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("apd_echo", count, 1, 1, 1);
  return (f_apd_echo(a0));
}
Variant i_rewinddir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(rewinddir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rewinddir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_rewinddir(arg0), null);
  }
}
Variant ifa_rewinddir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("rewinddir", count, 1, 1, 1);
  return (f_rewinddir(a0), null);
}
Variant i_ob_implicit_flush(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_implicit_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ob_implicit_flush", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ob_implicit_flush(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_ob_implicit_flush(arg0), null);
  }
}
Variant ifa_ob_implicit_flush(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("ob_implicit_flush", 1, 1);
  if (count <= 0) return (f_ob_implicit_flush(), null);
  return (f_ob_implicit_flush(a0), null);
}
Variant i_pcntl_signal_dispatch(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_signal_dispatch);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pcntl_signal_dispatch", 0, 1);
  return (f_pcntl_signal_dispatch());
}
Variant ifa_pcntl_signal_dispatch(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("pcntl_signal_dispatch", 0, 1);
  return (f_pcntl_signal_dispatch());
}
Variant i_session_get_cookie_params(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_get_cookie_params);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_get_cookie_params", 0, 1);
  return (f_session_get_cookie_params());
}
Variant ifa_session_get_cookie_params(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("session_get_cookie_params", 0, 1);
  return (f_session_get_cookie_params());
}
Variant i_pixelgetiteratorexceptionstring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetiteratorexceptionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexceptionstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetiteratorexceptionstring(arg0));
  }
}
Variant ifa_pixelgetiteratorexceptionstring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexceptionstring", count, 1, 1, 1);
  return (f_pixelgetiteratorexceptionstring(a0));
}
Variant i_stream_socket_client(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_socket_client);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("stream_socket_client", count, 1, 6, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_socket_client(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_stream_socket_client(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_socket_client(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_stream_socket_client(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_stream_socket_client(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_client(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_stream_socket_client(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 6) return throw_wrong_arguments("stream_socket_client", count, 1, 6, 1);
  if (count <= 1) return (f_stream_socket_client(a0));
  if (count == 2) return (f_stream_socket_client(a0, ref(a1)));
  if (count == 3) return (f_stream_socket_client(a0, ref(a1), ref(a2)));
  if (count == 4) return (f_stream_socket_client(a0, ref(a1), ref(a2), a3));
  if (count == 5) return (f_stream_socket_client(a0, ref(a1), ref(a2), a3, a4));
  return (f_stream_socket_client(a0, ref(a1), ref(a2), a3, a4, a5));
}
Variant i_drawsetstrokedasharray(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokedasharray);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsetstrokedasharray", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_drawsetstrokedasharray(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokedasharray(arg0, arg1), null);
  }
}
Variant ifa_drawsetstrokedasharray(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsetstrokedasharray", count, 1, 2, 1);
  if (count <= 1) return (f_drawsetstrokedasharray(a0), null);
  return (f_drawsetstrokedasharray(a0, a1), null);
}
Variant i_mysql_free_result(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_free_result);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_free_result", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_free_result(arg0));
  }
}
Variant ifa_mysql_free_result(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mysql_free_result", count, 1, 1, 1);
  return (f_mysql_free_result(a0));
}
Variant i_is_real(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_real);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_real", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_real(arg0));
  }
}
Variant ifa_is_real(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_real", count, 1, 1, 1);
  return (f_is_real(a0));
}
Variant i_mcrypt_enc_is_block_algorithm_mode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_is_block_algorithm_mode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_algorithm_mode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_is_block_algorithm_mode(arg0));
  }
}
Variant ifa_mcrypt_enc_is_block_algorithm_mode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_algorithm_mode", count, 1, 1, 1);
  return (f_mcrypt_enc_is_block_algorithm_mode(a0));
}
Variant i_array_slice(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_slice);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("array_slice", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_slice(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_array_slice(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_slice(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_array_slice(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("array_slice", count, 2, 4, 1);
  if (count <= 2) return (f_array_slice(a0, a1));
  if (count == 3) return (f_array_slice(a0, a1, a2));
  return (f_array_slice(a0, a1, a2, a3));
}
Variant i_count_chars(void *extra, CArrRef params) {
  FUNCTION_INJECTION(count_chars);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("count_chars", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_count_chars(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_count_chars(arg0, arg1));
  }
}
Variant ifa_count_chars(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("count_chars", count, 1, 2, 1);
  if (count <= 1) return (f_count_chars(a0));
  return (f_count_chars(a0, a1));
}
Variant i_hphp_splfileobject_getmaxlinelen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_getmaxlinelen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getmaxlinelen", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_getmaxlinelen(arg0));
  }
}
Variant ifa_hphp_splfileobject_getmaxlinelen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getmaxlinelen", count, 1, 1, 1);
  return (f_hphp_splfileobject_getmaxlinelen(a0));
}
Variant i_array_uintersect_uassoc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_uintersect_uassoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4) return throw_missing_arguments("array_uintersect_uassoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_array_uintersect_uassoc(count, arg0, arg1, arg2, arg3));
    return (f_array_uintersect_uassoc(count,arg0, arg1, arg2, arg3, params.slice(4, count - 4, false)));
  }
}
Variant ifa_array_uintersect_uassoc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4) return throw_missing_arguments("array_uintersect_uassoc", count+1, 1);
  if (count <= 4) return (f_array_uintersect_uassoc(count, a0, a1, a2, a3));
  Array params;
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_uintersect_uassoc(count,a0, a1, a2, a3, params));
}
Variant i_drawsetstrokewidth(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokewidth);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokewidth", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokewidth(arg0, arg1), null);
  }
}
Variant ifa_drawsetstrokewidth(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetstrokewidth", count, 2, 2, 1);
  return (f_drawsetstrokewidth(a0, a1), null);
}
Variant i_posix_mkfifo(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_mkfifo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_mkfifo", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_mkfifo(arg0, arg1));
  }
}
Variant ifa_posix_mkfifo(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("posix_mkfifo", count, 2, 2, 1);
  return (f_posix_mkfifo(a0, a1));
}
Variant i_array_count_values(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_count_values);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_count_values", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_count_values(arg0));
  }
}
Variant ifa_array_count_values(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("array_count_values", count, 1, 1, 1);
  return (f_array_count_values(a0));
}
Variant i_memcache_connect(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_connect);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_connect", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_memcache_connect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_memcache_connect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_connect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_connect(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_memcache_connect(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_connect", count, 1, 4, 1);
  if (count <= 1) return (f_memcache_connect(a0));
  if (count == 2) return (f_memcache_connect(a0, a1));
  if (count == 3) return (f_memcache_connect(a0, a1, a2));
  return (f_memcache_connect(a0, a1, a2, a3));
}
Variant i_pixelgetexception(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetexception(arg0));
  }
}
Variant ifa_pixelgetexception(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetexception", count, 1, 1, 1);
  return (f_pixelgetexception(a0));
}
Variant i_mkdir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mkdir);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("mkdir", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mkdir(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mkdir(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mkdir(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mkdir(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mkdir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("mkdir", count, 1, 4, 1);
  if (count <= 1) return (f_mkdir(a0));
  if (count == 2) return (f_mkdir(a0, a1));
  if (count == 3) return (f_mkdir(a0, a1, a2));
  return (f_mkdir(a0, a1, a2, a3));
}
Variant i_magicksetsize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetsize", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetsize(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetsize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksetsize", count, 3, 3, 1);
  return (f_magicksetsize(a0, a1, a2));
}
Variant i_debug_zval_dump(void *extra, CArrRef params) {
  FUNCTION_INJECTION(debug_zval_dump);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("debug_zval_dump", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_debug_zval_dump(arg0), null);
  }
}
Variant ifa_debug_zval_dump(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("debug_zval_dump", count, 1, 1, 1);
  return (f_debug_zval_dump(a0), null);
}
Variant i_iconv_substr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iconv_substr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("iconv_substr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iconv_substr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_iconv_substr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_substr(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_iconv_substr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("iconv_substr", count, 2, 4, 1);
  if (count <= 2) return (f_iconv_substr(a0, a1));
  if (count == 3) return (f_iconv_substr(a0, a1, a2));
  return (f_iconv_substr(a0, a1, a2, a3));
}
Variant i_xml_set_external_entity_ref_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_set_external_entity_ref_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_external_entity_ref_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_external_entity_ref_handler(arg0, arg1));
  }
}
Variant ifa_xml_set_external_entity_ref_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xml_set_external_entity_ref_handler", count, 2, 2, 1);
  return (f_xml_set_external_entity_ref_handler(a0, a1));
}
Variant i_mb_decode_numericentity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_decode_numericentity);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_decode_numericentity", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_decode_numericentity(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_decode_numericentity(arg0, arg1, arg2));
  }
}
Variant ifa_mb_decode_numericentity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_decode_numericentity", count, 2, 3, 1);
  if (count <= 2) return (f_mb_decode_numericentity(a0, a1));
  return (f_mb_decode_numericentity(a0, a1, a2));
}
Variant i_ldap_next_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_next_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_next_attribute(arg0, arg1));
  }
}
Variant ifa_ldap_next_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_next_attribute", count, 2, 2, 1);
  return (f_ldap_next_attribute(a0, a1));
}
Variant i_hphp_splfileobject_fflush(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fflush);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fflush", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_fflush(arg0));
  }
}
Variant ifa_hphp_splfileobject_fflush(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fflush", count, 1, 1, 1);
  return (f_hphp_splfileobject_fflush(a0));
}
Variant i_imagejpeg(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagejpeg);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagejpeg", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagejpeg(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_imagejpeg(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagejpeg(arg0, arg1, arg2));
  }
}
Variant ifa_imagejpeg(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("imagejpeg", count, 1, 3, 1);
  if (count <= 1) return (f_imagejpeg(a0));
  if (count == 2) return (f_imagejpeg(a0, a1));
  return (f_imagejpeg(a0, a1, a2));
}
Variant i_imagesetbrush(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagesetbrush);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetbrush", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesetbrush(arg0, arg1));
  }
}
Variant ifa_imagesetbrush(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagesetbrush", count, 2, 2, 1);
  return (f_imagesetbrush(a0, a1));
}
Variant i_mb_strtoupper(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strtoupper);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strtoupper", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_strtoupper(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strtoupper(arg0, arg1));
  }
}
Variant ifa_mb_strtoupper(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strtoupper", count, 1, 2, 1);
  if (count <= 1) return (f_mb_strtoupper(a0));
  return (f_mb_strtoupper(a0, a1));
}
Variant i_usleep(void *extra, CArrRef params) {
  FUNCTION_INJECTION(usleep);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("usleep", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_usleep(arg0), null);
  }
}
Variant ifa_usleep(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("usleep", count, 1, 1, 1);
  return (f_usleep(a0), null);
}
Variant i_mb_strrpos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strrpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrpos", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strrpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strrpos(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strrpos(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_strrpos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrpos", count, 2, 4, 1);
  if (count <= 2) return (f_mb_strrpos(a0, a1));
  if (count == 3) return (f_mb_strrpos(a0, a1, a2));
  return (f_mb_strrpos(a0, a1, a2, a3));
}
Variant i_collator_compare(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_compare);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("collator_compare", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_compare(arg0, arg1, arg2));
  }
}
Variant ifa_collator_compare(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("collator_compare", count, 3, 3, 1);
  return (f_collator_compare(a0, a1, a2));
}
Variant i_extract(void *extra, CArrRef params) {
  FUNCTION_INJECTION(extract);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("extract", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_extract(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_extract(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_extract(arg0, arg1, arg2));
  }
}
Variant ifa_extract(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("extract", count, 1, 3, 1);
  if (count <= 1) return (f_extract(a0));
  if (count == 2) return (f_extract(a0, a1));
  return (f_extract(a0, a1, a2));
}
Variant i_session_decode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_decode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_decode(arg0));
  }
}
Variant ifa_session_decode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("session_decode", count, 1, 1, 1);
  return (f_session_decode(a0));
}
Variant i_get_browser(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_browser);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("get_browser", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_browser());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_get_browser(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_get_browser(arg0, arg1));
  }
}
Variant ifa_get_browser(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("get_browser", 2, 1);
  if (count <= 0) return (f_get_browser());
  if (count == 1) return (f_get_browser(a0));
  return (f_get_browser(a0, a1));
}
Variant i_html_entity_decode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(html_entity_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("html_entity_decode", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_html_entity_decode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_html_entity_decode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_html_entity_decode(arg0, arg1, arg2));
  }
}
Variant ifa_html_entity_decode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("html_entity_decode", count, 1, 3, 1);
  if (count <= 1) return (f_html_entity_decode(a0));
  if (count == 2) return (f_html_entity_decode(a0, a1));
  return (f_html_entity_decode(a0, a1, a2));
}
Variant i_spl_classes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(spl_classes);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("spl_classes", 0, 1);
  return (f_spl_classes());
}
Variant ifa_spl_classes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("spl_classes", 0, 1);
  return (f_spl_classes());
}
Variant i_preg_split(void *extra, CArrRef params) {
  FUNCTION_INJECTION(preg_split);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("preg_split", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_preg_split(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_preg_split(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_preg_split(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_preg_split(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("preg_split", count, 2, 4, 1);
  if (count <= 2) return (f_preg_split(a0, a1));
  if (count == 3) return (f_preg_split(a0, a1, a2));
  return (f_preg_split(a0, a1, a2, a3));
}
Variant i_magickpreviewimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickpreviewimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickpreviewimages", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickpreviewimages(arg0, arg1));
  }
}
Variant ifa_magickpreviewimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickpreviewimages", count, 2, 2, 1);
  return (f_magickpreviewimages(a0, a1));
}
Variant i_zend_logo_guid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(zend_logo_guid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_logo_guid", 0, 1);
  return (f_zend_logo_guid());
}
Variant ifa_zend_logo_guid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("zend_logo_guid", 0, 1);
  return (f_zend_logo_guid());
}
Variant i_magickgetimagesize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagesize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagesize(arg0));
  }
}
Variant ifa_magickgetimagesize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagesize", count, 1, 1, 1);
  return (f_magickgetimagesize(a0));
}
Variant i_apd_set_browser_trace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apd_set_browser_trace);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_set_browser_trace", 0, 1);
  return (f_apd_set_browser_trace(), null);
}
Variant ifa_apd_set_browser_trace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("apd_set_browser_trace", 0, 1);
  return (f_apd_set_browser_trace(), null);
}
Variant i_xhprof_sample_enable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xhprof_sample_enable);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_sample_enable", 0, 1);
  return (f_xhprof_sample_enable(), null);
}
Variant ifa_xhprof_sample_enable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("xhprof_sample_enable", 0, 1);
  return (f_xhprof_sample_enable(), null);
}
Variant i_hphp_splfileobject_key(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_key(arg0));
  }
}
Variant ifa_hphp_splfileobject_key(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_key", count, 1, 1, 1);
  return (f_hphp_splfileobject_key(a0));
}
Variant i_mb_http_input(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_http_input);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_http_input", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_http_input());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_http_input(arg0));
  }
}
Variant ifa_mb_http_input(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mb_http_input", 1, 1);
  if (count <= 0) return (f_mb_http_input());
  return (f_mb_http_input(a0));
}
Variant i_gzinflate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzinflate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzinflate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzinflate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzinflate(arg0, arg1));
  }
}
Variant ifa_gzinflate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("gzinflate", count, 1, 2, 1);
  if (count <= 1) return (f_gzinflate(a0));
  return (f_gzinflate(a0, a1));
}
Variant i_openssl_pkcs7_sign(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs7_sign);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 7) return throw_wrong_arguments("openssl_pkcs7_sign", count, 5, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_openssl_pkcs7_sign(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_openssl_pkcs7_sign(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs7_sign(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant ifa_openssl_pkcs7_sign(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 5 || count > 7) return throw_wrong_arguments("openssl_pkcs7_sign", count, 5, 7, 1);
  if (count <= 5) return (f_openssl_pkcs7_sign(a0, a1, a2, a3, a4));
  return (f_openssl_pkcs7_sign(a0, a1, a2, a3, a4, a5));
}
Variant i_assert(void *extra, CArrRef params) {
  FUNCTION_INJECTION(assert);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("assert", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_assert(arg0));
  }
}
Variant ifa_assert(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("assert", count, 1, 1, 1);
  return (f_assert(a0));
}
Variant i_stream_get_wrappers(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_get_wrappers);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_wrappers", 0, 1);
  return (f_stream_get_wrappers());
}
Variant ifa_stream_get_wrappers(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("stream_get_wrappers", 0, 1);
  return (f_stream_get_wrappers());
}
Variant i_gzfile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzfile);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzfile", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzfile(arg0, arg1));
  }
}
Variant ifa_gzfile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("gzfile", count, 1, 2, 1);
  if (count <= 1) return (f_gzfile(a0));
  return (f_gzfile(a0, a1));
}
Variant i_session_id(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_id", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_id());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_id(arg0));
  }
}
Variant ifa_session_id(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("session_id", 1, 1);
  if (count <= 0) return (f_session_id());
  return (f_session_id(a0));
}
Variant i_stream_socket_sendto(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_socket_sendto);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_sendto", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_socket_sendto(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_socket_sendto(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_sendto(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_stream_socket_sendto(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_sendto", count, 2, 4, 1);
  if (count <= 2) return (f_stream_socket_sendto(a0, a1));
  if (count == 3) return (f_stream_socket_sendto(a0, a1, a2));
  return (f_stream_socket_sendto(a0, a1, a2, a3));
}
Variant i_gzpassthru(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzpassthru);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzpassthru", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzpassthru(arg0));
  }
}
Variant ifa_gzpassthru(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("gzpassthru", count, 1, 1, 1);
  return (f_gzpassthru(a0));
}
Variant i_stream_bucket_make_writeable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_bucket_make_writeable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_bucket_make_writeable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_bucket_make_writeable(arg0));
  }
}
Variant ifa_stream_bucket_make_writeable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("stream_bucket_make_writeable", count, 1, 1, 1);
  return (f_stream_bucket_make_writeable(a0));
}
Variant i_posix_setegid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_setegid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setegid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_setegid(arg0));
  }
}
Variant ifa_posix_setegid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_setegid", count, 1, 1, 1);
  return (f_posix_setegid(a0));
}
Variant i_drawgetexceptionstring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetexceptionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexceptionstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetexceptionstring(arg0));
  }
}
Variant ifa_drawgetexceptionstring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetexceptionstring", count, 1, 1, 1);
  return (f_drawgetexceptionstring(a0));
}
Variant i_hash_algos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hash_algos);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hash_algos", 0, 1);
  return (f_hash_algos());
}
Variant ifa_hash_algos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("hash_algos", 0, 1);
  return (f_hash_algos());
}
Variant i_drawsetstrokeantialias(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokeantialias);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsetstrokeantialias", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_drawsetstrokeantialias(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokeantialias(arg0, arg1), null);
  }
}
Variant ifa_drawsetstrokeantialias(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsetstrokeantialias", count, 1, 2, 1);
  if (count <= 1) return (f_drawsetstrokeantialias(a0), null);
  return (f_drawsetstrokeantialias(a0, a1), null);
}
Variant i_destroypixelwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(destroypixelwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroypixelwand(arg0), null);
  }
}
Variant ifa_destroypixelwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("destroypixelwand", count, 1, 1, 1);
  return (f_destroypixelwand(a0), null);
}
Variant i_fstat(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fstat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fstat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fstat(arg0));
  }
}
Variant ifa_fstat(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fstat", count, 1, 1, 1);
  return (f_fstat(a0));
}
Variant i_magicksetimageresolution(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimageresolution);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageresolution", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageresolution(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetimageresolution(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksetimageresolution", count, 3, 3, 1);
  return (f_magicksetimageresolution(a0, a1, a2));
}
Variant i_mysql_db_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_db_name);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_db_name", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mysql_db_name(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_db_name(arg0, arg1, arg2));
  }
}
Variant ifa_mysql_db_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_db_name", count, 2, 3, 1);
  if (count <= 2) return (f_mysql_db_name(a0, a1));
  return (f_mysql_db_name(a0, a1, a2));
}
Variant i_is_finite(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_finite);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_finite", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_finite(arg0));
  }
}
Variant ifa_is_finite(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_finite", count, 1, 1, 1);
  return (f_is_finite(a0));
}
Variant i_pixelgetyellowquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetyellowquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetyellowquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetyellowquantum(arg0));
  }
}
Variant ifa_pixelgetyellowquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetyellowquantum", count, 1, 1, 1);
  return (f_pixelgetyellowquantum(a0));
}
Variant i_ksort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ksort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("ksort", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_ksort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ksort(arg0, arg1));
  }
}
Variant ifa_ksort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("ksort", count, 1, 2, 1);
  if (count <= 1) return (f_ksort(ref(a0)));
  return (f_ksort(ref(a0), a1));
}
Variant i_thrift_protocol_read_binary(void *extra, CArrRef params) {
  FUNCTION_INJECTION(thrift_protocol_read_binary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("thrift_protocol_read_binary", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_thrift_protocol_read_binary(arg0, arg1, arg2));
  }
}
Variant ifa_thrift_protocol_read_binary(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("thrift_protocol_read_binary", count, 3, 3, 1);
  return (f_thrift_protocol_read_binary(a0, a1, a2));
}
Variant i_get_included_files(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_included_files);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_included_files", 0, 1);
  return (f_get_included_files());
}
Variant ifa_get_included_files(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("get_included_files", 0, 1);
  return (f_get_included_files());
}
Variant i_strip_tags(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strip_tags);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strip_tags", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_strip_tags(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strip_tags(arg0, arg1));
  }
}
Variant ifa_strip_tags(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("strip_tags", count, 1, 2, 1);
  if (count <= 1) return (f_strip_tags(a0));
  return (f_strip_tags(a0, a1));
}
Variant i_mb_ereg_search_getpos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_getpos);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_ereg_search_getpos", 0, 1);
  return (f_mb_ereg_search_getpos());
}
Variant ifa_mb_ereg_search_getpos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("mb_ereg_search_getpos", 0, 1);
  return (f_mb_ereg_search_getpos());
}
Variant i_pixelgetcyanquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetcyanquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcyanquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetcyanquantum(arg0));
  }
}
Variant ifa_pixelgetcyanquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetcyanquantum", count, 1, 1, 1);
  return (f_pixelgetcyanquantum(a0));
}
Variant i_magickgetexception(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetexception(arg0));
  }
}
Variant ifa_magickgetexception(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetexception", count, 1, 1, 1);
  return (f_magickgetexception(a0));
}
Variant i_ctype_punct(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ctype_punct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_punct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_punct(arg0));
  }
}
Variant ifa_ctype_punct(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ctype_punct", count, 1, 1, 1);
  return (f_ctype_punct(a0));
}
Variant i_next(void *extra, CArrRef params) {
  FUNCTION_INJECTION(next);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("next", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_next(arg0));
  }
}
Variant ifa_next(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("next", count, 1, 1, 1);
  return (f_next(ref(a0)));
}
Variant i_shm_detach(void *extra, CArrRef params) {
  FUNCTION_INJECTION(shm_detach);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shm_detach", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_shm_detach(arg0));
  }
}
Variant ifa_shm_detach(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("shm_detach", count, 1, 1, 1);
  return (f_shm_detach(a0));
}
Variant i_shm_attach(void *extra, CArrRef params) {
  FUNCTION_INJECTION(shm_attach);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("shm_attach", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_shm_attach(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_shm_attach(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_shm_attach(arg0, arg1, arg2));
  }
}
Variant ifa_shm_attach(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("shm_attach", count, 1, 3, 1);
  if (count <= 1) return (f_shm_attach(a0));
  if (count == 2) return (f_shm_attach(a0, a1));
  return (f_shm_attach(a0, a1, a2));
}
Variant i_magickflattenimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickflattenimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflattenimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickflattenimages(arg0));
  }
}
Variant ifa_magickflattenimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickflattenimages", count, 1, 1, 1);
  return (f_magickflattenimages(a0));
}
Variant i_dom_document_save_html_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_save_html_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_save_html_file", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_save_html_file(arg0, arg1));
  }
}
Variant ifa_dom_document_save_html_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_save_html_file", count, 2, 2, 1);
  return (f_dom_document_save_html_file(a0, a1));
}
Variant i_similar_text(void *extra, CArrRef params) {
  FUNCTION_INJECTION(similar_text);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("similar_text", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_similar_text(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_similar_text(arg0, arg1, arg2));
  }
}
Variant ifa_similar_text(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("similar_text", count, 2, 3, 1);
  if (count <= 2) return (f_similar_text(a0, a1));
  return (f_similar_text(a0, a1, ref(a2)));
}
Variant i_hphp_get_thread_id(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_get_thread_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_get_thread_id", 0, 1);
  return (f_hphp_get_thread_id());
}
Variant ifa_hphp_get_thread_id(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("hphp_get_thread_id", 0, 1);
  return (f_hphp_get_thread_id());
}
Variant i_imagecreatefromgd2part(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromgd2part);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecreatefromgd2part", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecreatefromgd2part(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_imagecreatefromgd2part(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("imagecreatefromgd2part", count, 5, 5, 1);
  return (f_imagecreatefromgd2part(a0, a1, a2, a3, a4));
}
Variant i_dom_element_set_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_attribute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_attribute(arg0, arg1, arg2));
  }
}
Variant ifa_dom_element_set_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_element_set_attribute", count, 3, 3, 1);
  return (f_dom_element_set_attribute(a0, a1, a2));
}
Variant i_iterator_to_array(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iterator_to_array);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("iterator_to_array", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_iterator_to_array(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iterator_to_array(arg0, arg1));
  }
}
Variant ifa_iterator_to_array(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("iterator_to_array", count, 1, 2, 1);
  if (count <= 1) return (f_iterator_to_array(a0));
  return (f_iterator_to_array(a0, a1));
}
Variant i_iconv_get_encoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iconv_get_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("iconv_get_encoding", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_iconv_get_encoding());
    CVarRef arg0((ad->getValue(pos)));
    return (f_iconv_get_encoding(arg0));
  }
}
Variant ifa_iconv_get_encoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("iconv_get_encoding", 1, 1);
  if (count <= 0) return (f_iconv_get_encoding());
  return (f_iconv_get_encoding(a0));
}
Variant i_getmyinode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getmyinode);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmyinode", 0, 1);
  return (f_getmyinode());
}
Variant ifa_getmyinode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("getmyinode", 0, 1);
  return (f_getmyinode());
}
Variant i_gzgetc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzgetc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzgetc", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzgetc(arg0));
  }
}
Variant ifa_gzgetc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("gzgetc", count, 1, 1, 1);
  return (f_gzgetc(a0));
}
Variant i_hphp_set_static_property(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_set_static_property);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_set_static_property", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_set_static_property(arg0, arg1, arg2), null);
  }
}
Variant ifa_hphp_set_static_property(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("hphp_set_static_property", count, 3, 3, 1);
  return (f_hphp_set_static_property(a0, a1, a2), null);
}
Variant i_unlink(void *extra, CArrRef params) {
  FUNCTION_INJECTION(unlink);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("unlink", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_unlink(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_unlink(arg0, arg1));
  }
}
Variant ifa_unlink(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("unlink", count, 1, 2, 1);
  if (count <= 1) return (f_unlink(a0));
  return (f_unlink(a0, a1));
}
Variant i_mcrypt_module_open(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_open);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("mcrypt_module_open", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_open(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mcrypt_module_open(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("mcrypt_module_open", count, 4, 4, 1);
  return (f_mcrypt_module_open(a0, a1, a2, a3));
}
Variant i_token_get_all(void *extra, CArrRef params) {
  FUNCTION_INJECTION(token_get_all);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("token_get_all", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_token_get_all(arg0));
  }
}
Variant ifa_token_get_all(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("token_get_all", count, 1, 1, 1);
  return (f_token_get_all(a0));
}
Variant i_base_convert(void *extra, CArrRef params) {
  FUNCTION_INJECTION(base_convert);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("base_convert", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_base_convert(arg0, arg1, arg2));
  }
}
Variant ifa_base_convert(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("base_convert", count, 3, 3, 1);
  return (f_base_convert(a0, a1, a2));
}
Variant i_gethostbynamel(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gethostbynamel);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbynamel", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gethostbynamel(arg0));
  }
}
Variant ifa_gethostbynamel(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("gethostbynamel", count, 1, 1, 1);
  return (f_gethostbynamel(a0));
}
Variant i_var_dump(void *extra, CArrRef params) {
  FUNCTION_INJECTION(var_dump);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("var_dump", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_var_dump(count, arg0), null);
    return (f_var_dump(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant ifa_var_dump(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("var_dump", count+1, 1);
  if (count <= 1) return (f_var_dump(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_var_dump(count,a0, params), null);
}
Variant i_xmlwriter_start_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_attribute(arg0, arg1));
  }
}
Variant ifa_xmlwriter_start_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_attribute", count, 2, 2, 1);
  return (f_xmlwriter_start_attribute(a0, a1));
}
Variant i_pack(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pack);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("pack", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pack(count, arg0));
    return (f_pack(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_pack(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("pack", count+1, 1);
  if (count <= 1) return (f_pack(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_pack(count,a0, params));
}
Variant i_gzgets(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzgets);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzgets", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzgets(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzgets(arg0, arg1));
  }
}
Variant ifa_gzgets(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("gzgets", count, 1, 2, 1);
  if (count <= 1) return (f_gzgets(a0));
  return (f_gzgets(a0, a1));
}
Variant i_array_intersect_uassoc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_intersect_uassoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_intersect_uassoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_intersect_uassoc(count, arg0, arg1, arg2));
    return (f_array_intersect_uassoc(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant ifa_array_intersect_uassoc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3) return throw_missing_arguments("array_intersect_uassoc", count+1, 1);
  if (count <= 3) return (f_array_intersect_uassoc(count, a0, a1, a2));
  Array params;
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_intersect_uassoc(count,a0, a1, a2, params));
}
Variant i_basename(void *extra, CArrRef params) {
  FUNCTION_INJECTION(basename);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("basename", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_basename(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_basename(arg0, arg1));
  }
}
Variant ifa_basename(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("basename", count, 1, 2, 1);
  if (count <= 1) return (f_basename(a0));
  return (f_basename(a0, a1));
}
Variant i_krsort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(krsort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("krsort", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_krsort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_krsort(arg0, arg1));
  }
}
Variant ifa_krsort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("krsort", count, 1, 2, 1);
  if (count <= 1) return (f_krsort(ref(a0)));
  return (f_krsort(ref(a0), a1));
}
Variant i_clock_gettime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(clock_gettime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_gettime", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_clock_gettime(arg0, arg1, arg2));
  }
}
Variant ifa_clock_gettime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("clock_gettime", count, 3, 3, 1);
  return (f_clock_gettime(a0, ref(a1), ref(a2)));
}
Variant i_pushdrawingwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pushdrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pushdrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pushdrawingwand(arg0), null);
  }
}
Variant ifa_pushdrawingwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pushdrawingwand", count, 1, 1, 1);
  return (f_pushdrawingwand(a0), null);
}
Variant i_imageline(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imageline);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imageline", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageline(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imageline(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("imageline", count, 6, 6, 1);
  return (f_imageline(a0, a1, a2, a3, a4, a5));
}
Variant i_socket_read(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_read);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_read", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_read(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_read(arg0, arg1, arg2));
  }
}
Variant ifa_socket_read(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_read", count, 2, 3, 1);
  if (count <= 2) return (f_socket_read(a0, a1));
  return (f_socket_read(a0, a1, a2));
}
Variant i_xmlwriter_write_dtd_entity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_dtd_entity);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 7) return throw_wrong_arguments("xmlwriter_write_dtd_entity", count, 3, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_xmlwriter_write_dtd_entity(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_xmlwriter_write_dtd_entity(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_xmlwriter_write_dtd_entity(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_xmlwriter_write_dtd_entity(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_dtd_entity(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant ifa_xmlwriter_write_dtd_entity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 7) return throw_wrong_arguments("xmlwriter_write_dtd_entity", count, 3, 7, 1);
  if (count <= 3) return (f_xmlwriter_write_dtd_entity(a0, a1, a2));
  if (count == 4) return (f_xmlwriter_write_dtd_entity(a0, a1, a2, a3));
  if (count == 5) return (f_xmlwriter_write_dtd_entity(a0, a1, a2, a3, a4));
  return (f_xmlwriter_write_dtd_entity(a0, a1, a2, a3, a4, a5));
}
Variant i_mysql_tablename(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_tablename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mysql_tablename", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_tablename(arg0, arg1));
  }
}
Variant ifa_mysql_tablename(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("mysql_tablename", count, 2, 2, 1);
  return (f_mysql_tablename(a0, a1));
}
Variant i_collator_sort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_sort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("collator_sort", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_collator_sort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_sort(arg0, arg1, arg2));
  }
}
Variant ifa_collator_sort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("collator_sort", count, 2, 3, 1);
  if (count <= 2) return (f_collator_sort(a0, ref(a1)));
  return (f_collator_sort(a0, ref(a1), a2));
}
Variant i_magickwriteimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickwriteimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwriteimage(arg0, arg1));
  }
}
Variant ifa_magickwriteimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickwriteimage", count, 2, 2, 1);
  return (f_magickwriteimage(a0, a1));
}
Variant i_mcrypt_module_get_algo_key_size(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_get_algo_key_size);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_algo_key_size", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_get_algo_key_size(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_get_algo_key_size(arg0, arg1));
  }
}
Variant ifa_mcrypt_module_get_algo_key_size(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_algo_key_size", count, 1, 2, 1);
  if (count <= 1) return (f_mcrypt_module_get_algo_key_size(a0));
  return (f_mcrypt_module_get_algo_key_size(a0, a1));
}
Variant i_hash_update_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hash_update_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_update_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_hash_update_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_update_file(arg0, arg1, arg2));
  }
}
Variant ifa_hash_update_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_update_file", count, 2, 3, 1);
  if (count <= 2) return (f_hash_update_file(a0, a1));
  return (f_hash_update_file(a0, a1, a2));
}
Variant i_magickembossimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickembossimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickembossimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickembossimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickembossimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magickembossimage", count, 3, 3, 1);
  return (f_magickembossimage(a0, a1, a2));
}
Variant i_forward_static_call(void *extra, CArrRef params) {
  FUNCTION_INJECTION(forward_static_call);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("forward_static_call", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_forward_static_call(count, arg0));
    return (f_forward_static_call(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_forward_static_call(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("forward_static_call", count+1, 1);
  if (count <= 1) return (f_forward_static_call(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_forward_static_call(count,a0, params));
}
Variant i_gzencode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzencode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("gzencode", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzencode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_gzencode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzencode(arg0, arg1, arg2));
  }
}
Variant ifa_gzencode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("gzencode", count, 1, 3, 1);
  if (count <= 1) return (f_gzencode(a0));
  if (count == 2) return (f_gzencode(a0, a1));
  return (f_gzencode(a0, a1, a2));
}
Variant i_checkdate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(checkdate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("checkdate", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_checkdate(arg0, arg1, arg2));
  }
}
Variant ifa_checkdate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("checkdate", count, 3, 3, 1);
  return (f_checkdate(a0, a1, a2));
}
Variant i_magickimplodeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickimplodeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickimplodeimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickimplodeimage(arg0, arg1));
  }
}
Variant ifa_magickimplodeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickimplodeimage", count, 2, 2, 1);
  return (f_magickimplodeimage(a0, a1));
}
Variant i_magickgetimageindex(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageindex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageindex", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageindex(arg0));
  }
}
Variant ifa_magickgetimageindex(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimageindex", count, 1, 1, 1);
  return (f_magickgetimageindex(a0));
}
Variant i_ctype_lower(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ctype_lower);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_lower", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_lower(arg0));
  }
}
Variant ifa_ctype_lower(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ctype_lower", count, 1, 1, 1);
  return (f_ctype_lower(a0));
}
Variant i_imagepsloadfont(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagepsloadfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagepsloadfont", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagepsloadfont(arg0));
  }
}
Variant ifa_imagepsloadfont(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagepsloadfont", count, 1, 1, 1);
  return (f_imagepsloadfont(a0));
}
Variant i_iconv_mime_decode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iconv_mime_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("iconv_mime_decode", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_iconv_mime_decode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_iconv_mime_decode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_mime_decode(arg0, arg1, arg2));
  }
}
Variant ifa_iconv_mime_decode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("iconv_mime_decode", count, 1, 3, 1);
  if (count <= 1) return (f_iconv_mime_decode(a0));
  if (count == 2) return (f_iconv_mime_decode(a0, a1));
  return (f_iconv_mime_decode(a0, a1, a2));
}
Variant i_hphp_recursiveiteratoriterator_key(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_key(arg0));
  }
}
Variant ifa_hphp_recursiveiteratoriterator_key(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_key", count, 1, 1, 1);
  return (f_hphp_recursiveiteratoriterator_key(a0));
}
Variant i_mcrypt_module_is_block_algorithm(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_is_block_algorithm);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_algorithm", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_is_block_algorithm(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_is_block_algorithm(arg0, arg1));
  }
}
Variant ifa_mcrypt_module_is_block_algorithm(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_algorithm", count, 1, 2, 1);
  if (count <= 1) return (f_mcrypt_module_is_block_algorithm(a0));
  return (f_mcrypt_module_is_block_algorithm(a0, a1));
}
Variant i_wandgetexception(void *extra, CArrRef params) {
  FUNCTION_INJECTION(wandgetexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_wandgetexception(arg0));
  }
}
Variant ifa_wandgetexception(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("wandgetexception", count, 1, 1, 1);
  return (f_wandgetexception(a0));
}
Variant i_fsockopen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fsockopen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("fsockopen", count, 1, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fsockopen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_fsockopen(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fsockopen(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_fsockopen(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fsockopen(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_fsockopen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 5) return throw_wrong_arguments("fsockopen", count, 1, 5, 1);
  if (count <= 1) return (f_fsockopen(a0));
  if (count == 2) return (f_fsockopen(a0, a1));
  if (count == 3) return (f_fsockopen(a0, a1, ref(a2)));
  if (count == 4) return (f_fsockopen(a0, a1, ref(a2), ref(a3)));
  return (f_fsockopen(a0, a1, ref(a2), ref(a3), a4));
}
Variant i_usort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(usort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("usort", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_usort(arg0, arg1));
  }
}
Variant ifa_usort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("usort", count, 2, 2, 1);
  return (f_usort(ref(a0), a1));
}
Variant i_pixelsetiteratorrow(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetiteratorrow);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetiteratorrow", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetiteratorrow(arg0, arg1));
  }
}
Variant ifa_pixelsetiteratorrow(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetiteratorrow", count, 2, 2, 1);
  return (f_pixelsetiteratorrow(a0, a1));
}
Variant i_call_user_func_serialized(void *extra, CArrRef params) {
  FUNCTION_INJECTION(call_user_func_serialized);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("call_user_func_serialized", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_call_user_func_serialized(arg0));
  }
}
Variant ifa_call_user_func_serialized(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("call_user_func_serialized", count, 1, 1, 1);
  return (f_call_user_func_serialized(a0));
}
Variant i_hphp_splfileinfo_iswritable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_iswritable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_iswritable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_iswritable(arg0));
  }
}
Variant ifa_hphp_splfileinfo_iswritable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_iswritable", count, 1, 1, 1);
  return (f_hphp_splfileinfo_iswritable(a0));
}
Variant i_dom_document_create_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_attribute(arg0, arg1));
  }
}
Variant ifa_dom_document_create_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_create_attribute", count, 2, 2, 1);
  return (f_dom_document_create_attribute(a0, a1));
}
Variant i_ldap_get_option(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_get_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_option", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_ldap_get_option(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_get_option(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ldap_get_option", count, 3, 3, 1);
  return (f_ldap_get_option(a0, a1, ref(a2)));
}
Variant i_socket_recv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_recv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_recv", count, 4, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_recv(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_socket_recv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("socket_recv", count, 4, 4, 1);
  return (f_socket_recv(a0, ref(a1), a2, a3));
}
Variant i_sys_getloadavg(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sys_getloadavg);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("sys_getloadavg", 0, 1);
  return (f_sys_getloadavg());
}
Variant ifa_sys_getloadavg(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("sys_getloadavg", 0, 1);
  return (f_sys_getloadavg());
}
Variant i_evhttp_async_post(void *extra, CArrRef params) {
  FUNCTION_INJECTION(evhttp_async_post);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("evhttp_async_post", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_evhttp_async_post(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_evhttp_async_post(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_evhttp_async_post(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_evhttp_async_post(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("evhttp_async_post", count, 2, 4, 1);
  if (count <= 2) return (f_evhttp_async_post(a0, a1));
  if (count == 3) return (f_evhttp_async_post(a0, a1, a2));
  return (f_evhttp_async_post(a0, a1, a2, a3));
}
Variant i_hphp_recursivedirectoryiterator_seek(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_seek);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_recursivedirectoryiterator_seek", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_recursivedirectoryiterator_seek(arg0, arg1), null);
  }
}
Variant ifa_hphp_recursivedirectoryiterator_seek(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_recursivedirectoryiterator_seek", count, 2, 2, 1);
  return (f_hphp_recursivedirectoryiterator_seek(a0, a1), null);
}
Variant i_array_values(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_values);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_values", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_values(arg0));
  }
}
Variant ifa_array_values(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("array_values", count, 1, 1, 1);
  return (f_array_values(a0));
}
Variant i_ctype_digit(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ctype_digit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_digit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_digit(arg0));
  }
}
Variant ifa_ctype_digit(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ctype_digit", count, 1, 1, 1);
  return (f_ctype_digit(a0));
}
Variant i_ob_get_length(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_get_length);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_length", 0, 1);
  return (f_ob_get_length());
}
Variant ifa_ob_get_length(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("ob_get_length", 0, 1);
  return (f_ob_get_length());
}
Variant i_magicksolarizeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksolarizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksolarizeimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksolarizeimage(arg0, arg1));
  }
}
Variant ifa_magicksolarizeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksolarizeimage", count, 2, 2, 1);
  return (f_magicksolarizeimage(a0, a1));
}
Variant i_ob_list_handlers(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_list_handlers);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_list_handlers", 0, 1);
  return (f_ob_list_handlers());
}
Variant ifa_ob_list_handlers(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("ob_list_handlers", 0, 1);
  return (f_ob_list_handlers());
}
Variant i_array_uintersect_assoc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_uintersect_assoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_uintersect_assoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_uintersect_assoc(count, arg0, arg1, arg2));
    return (f_array_uintersect_assoc(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant ifa_array_uintersect_assoc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3) return throw_missing_arguments("array_uintersect_assoc", count+1, 1);
  if (count <= 3) return (f_array_uintersect_assoc(count, a0, a1, a2));
  Array params;
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_uintersect_assoc(count,a0, a1, a2, params));
}
Variant i_openssl_x509_read(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_read);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_x509_read", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_x509_read(arg0));
  }
}
Variant ifa_openssl_x509_read(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("openssl_x509_read", count, 1, 1, 1);
  return (f_openssl_x509_read(a0));
}
Variant i_magickgetimagecolormapcolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecolormapcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimagecolormapcolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimagecolormapcolor(arg0, arg1));
  }
}
Variant ifa_magickgetimagecolormapcolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickgetimagecolormapcolor", count, 2, 2, 1);
  return (f_magickgetimagecolormapcolor(a0, a1));
}
Variant i_hphp_splfileobject_getcvscontrol(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_getcvscontrol);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getcvscontrol", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_getcvscontrol(arg0));
  }
}
Variant ifa_hphp_splfileobject_getcvscontrol(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getcvscontrol", count, 1, 1, 1);
  return (f_hphp_splfileobject_getcvscontrol(a0));
}
Variant i_settype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(settype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("settype", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_settype(arg0, arg1));
  }
}
Variant ifa_settype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("settype", count, 2, 2, 1);
  return (f_settype(ref(a0), a1));
}
Variant i_posix_access(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_access);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("posix_access", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_posix_access(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_access(arg0, arg1));
  }
}
Variant ifa_posix_access(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("posix_access", count, 1, 2, 1);
  if (count <= 1) return (f_posix_access(a0));
  return (f_posix_access(a0, a1));
}
Variant i_explode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(explode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("explode", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_explode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_explode(arg0, arg1, arg2));
  }
}
Variant ifa_explode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("explode", count, 2, 3, 1);
  if (count <= 2) return (f_explode(a0, a1));
  return (f_explode(a0, a1, a2));
}
Variant i_fb_load_local_databases(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_load_local_databases);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_load_local_databases", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_load_local_databases(arg0), null);
  }
}
Variant ifa_fb_load_local_databases(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fb_load_local_databases", count, 1, 1, 1);
  return (f_fb_load_local_databases(a0), null);
}
Variant i_imagecreatefromgd(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromgd);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgd", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromgd(arg0));
  }
}
Variant ifa_imagecreatefromgd(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagecreatefromgd", count, 1, 1, 1);
  return (f_imagecreatefromgd(a0));
}
Variant i_proc_close(void *extra, CArrRef params) {
  FUNCTION_INJECTION(proc_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_proc_close(arg0));
  }
}
Variant ifa_proc_close(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("proc_close", count, 1, 1, 1);
  return (f_proc_close(a0));
}
Variant i_magickgaussianblurimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgaussianblurimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgaussianblurimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgaussianblurimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgaussianblurimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickgaussianblurimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgaussianblurimage", count, 3, 4, 1);
  if (count <= 3) return (f_magickgaussianblurimage(a0, a1, a2));
  return (f_magickgaussianblurimage(a0, a1, a2, a3));
}
Variant i_apd_set_session_trace_socket(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apd_set_session_trace_socket);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("apd_set_session_trace_socket", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apd_set_session_trace_socket(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_apd_set_session_trace_socket(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("apd_set_session_trace_socket", count, 4, 4, 1);
  return (f_apd_set_session_trace_socket(a0, a1, a2, a3));
}
Variant i_openssl_pkcs12_export_to_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs12_export_to_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("openssl_pkcs12_export_to_file", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_openssl_pkcs12_export_to_file(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs12_export_to_file(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_openssl_pkcs12_export_to_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 5) return throw_wrong_arguments("openssl_pkcs12_export_to_file", count, 4, 5, 1);
  if (count <= 4) return (f_openssl_pkcs12_export_to_file(a0, a1, a2, a3));
  return (f_openssl_pkcs12_export_to_file(a0, a1, a2, a3, a4));
}
Variant i_mailparse_msg_free(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_free);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_free", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_msg_free(arg0));
  }
}
Variant ifa_mailparse_msg_free(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mailparse_msg_free", count, 1, 1, 1);
  return (f_mailparse_msg_free(a0));
}
Variant i_openssl_private_decrypt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_private_decrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_private_decrypt", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_private_decrypt(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_private_decrypt(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_private_decrypt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_private_decrypt", count, 3, 4, 1);
  if (count <= 3) return (f_openssl_private_decrypt(a0, ref(a1), a2));
  return (f_openssl_private_decrypt(a0, ref(a1), a2, a3));
}
Variant i_dom_document_save(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_save);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_save", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_document_save(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_save(arg0, arg1, arg2));
  }
}
Variant ifa_dom_document_save(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_save", count, 2, 3, 1);
  if (count <= 2) return (f_dom_document_save(a0, a1));
  return (f_dom_document_save(a0, a1, a2));
}
Variant i_hphp_get_extension_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_get_extension_info);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_extension_info", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_get_extension_info(arg0));
  }
}
Variant ifa_hphp_get_extension_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_get_extension_info", count, 1, 1, 1);
  return (f_hphp_get_extension_info(a0));
}
Variant i_output_add_rewrite_var(void *extra, CArrRef params) {
  FUNCTION_INJECTION(output_add_rewrite_var);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("output_add_rewrite_var", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_output_add_rewrite_var(arg0, arg1));
  }
}
Variant ifa_output_add_rewrite_var(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("output_add_rewrite_var", count, 2, 2, 1);
  return (f_output_add_rewrite_var(a0, a1));
}
Variant i_xmlwriter_write_cdata(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_cdata);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_cdata", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_cdata(arg0, arg1));
  }
}
Variant ifa_xmlwriter_write_cdata(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_cdata", count, 2, 2, 1);
  return (f_xmlwriter_write_cdata(a0, a1));
}
Variant i_mb_list_mime_names(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_list_mime_names);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_list_mime_names", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_list_mime_names());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_list_mime_names(arg0));
  }
}
Variant ifa_mb_list_mime_names(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mb_list_mime_names", 1, 1);
  if (count <= 0) return (f_mb_list_mime_names());
  return (f_mb_list_mime_names(a0));
}
Variant i_ispixelwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ispixelwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ispixelwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ispixelwand(arg0));
  }
}
Variant ifa_ispixelwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ispixelwand", count, 1, 1, 1);
  return (f_ispixelwand(a0));
}
Variant i_xmlwriter_end_dtd(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_dtd);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_dtd(arg0));
  }
}
Variant ifa_xmlwriter_end_dtd(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd", count, 1, 1, 1);
  return (f_xmlwriter_end_dtd(a0));
}
Variant i_curl_close(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_close(arg0));
  }
}
Variant ifa_curl_close(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("curl_close", count, 1, 1, 1);
  return (f_curl_close(a0));
}
Variant i_array_udiff(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_udiff);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_udiff", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_udiff(count, arg0, arg1, arg2));
    return (f_array_udiff(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant ifa_array_udiff(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3) return throw_missing_arguments("array_udiff", count+1, 1);
  if (count <= 3) return (f_array_udiff(count, a0, a1, a2));
  Array params;
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_udiff(count,a0, a1, a2, params));
}
Variant i_session_cache_limiter(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_cache_limiter);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_cache_limiter", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_cache_limiter());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_cache_limiter(arg0));
  }
}
Variant ifa_session_cache_limiter(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("session_cache_limiter", 1, 1);
  if (count <= 0) return (f_session_cache_limiter());
  return (f_session_cache_limiter(a0));
}
Variant i_stream_context_create(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_context_create);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("stream_context_create", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_stream_context_create());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_stream_context_create(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_context_create(arg0, arg1));
  }
}
Variant ifa_stream_context_create(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("stream_context_create", 2, 1);
  if (count <= 0) return (f_stream_context_create());
  if (count == 1) return (f_stream_context_create(a0));
  return (f_stream_context_create(a0, a1));
}
Variant i_drawgetstrokedashoffset(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokedashoffset);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokedashoffset", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokedashoffset(arg0));
  }
}
Variant ifa_drawgetstrokedashoffset(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetstrokedashoffset", count, 1, 1, 1);
  return (f_drawgetstrokedashoffset(a0));
}
Variant i_openssl_pkey_get_public(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_get_public);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_get_public", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_pkey_get_public(arg0));
  }
}
Variant ifa_openssl_pkey_get_public(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("openssl_pkey_get_public", count, 1, 1, 1);
  return (f_openssl_pkey_get_public(a0));
}
Variant i_interface_exists(void *extra, CArrRef params) {
  FUNCTION_INJECTION(interface_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("interface_exists", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_interface_exists(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_interface_exists(arg0, arg1));
  }
}
Variant ifa_interface_exists(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("interface_exists", count, 1, 2, 1);
  if (count <= 1) return (f_interface_exists(a0));
  return (f_interface_exists(a0, a1));
}
Variant i_hphp_directoryiterator___construct(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator___construct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_directoryiterator___construct", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_directoryiterator___construct(arg0, arg1));
  }
}
Variant ifa_hphp_directoryiterator___construct(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_directoryiterator___construct", count, 2, 2, 1);
  return (f_hphp_directoryiterator___construct(a0, a1));
}
Variant i_drawpathmovetorelative(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathmovetorelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathmovetorelative", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathmovetorelative(arg0, arg1, arg2), null);
  }
}
Variant ifa_drawpathmovetorelative(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("drawpathmovetorelative", count, 3, 3, 1);
  return (f_drawpathmovetorelative(a0, a1, a2), null);
}
Variant i_apache_get_config(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apache_get_config);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_config", 0, 1);
  return (f_apache_get_config());
}
Variant ifa_apache_get_config(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("apache_get_config", 0, 1);
  return (f_apache_get_config());
}
Variant i_curl_copy_handle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_copy_handle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_copy_handle", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_copy_handle(arg0));
  }
}
Variant ifa_curl_copy_handle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("curl_copy_handle", count, 1, 1, 1);
  return (f_curl_copy_handle(a0));
}
Variant i_drawgetvectorgraphics(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetvectorgraphics);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetvectorgraphics", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetvectorgraphics(arg0));
  }
}
Variant ifa_drawgetvectorgraphics(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetvectorgraphics", count, 1, 1, 1);
  return (f_drawgetvectorgraphics(a0));
}
Variant i_drawpathfinish(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathfinish);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathfinish", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpathfinish(arg0), null);
  }
}
Variant ifa_drawpathfinish(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawpathfinish", count, 1, 1, 1);
  return (f_drawpathfinish(a0), null);
}
Variant i_png2wbmp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(png2wbmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("png2wbmp", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_png2wbmp(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_png2wbmp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("png2wbmp", count, 5, 5, 1);
  return (f_png2wbmp(a0, a1, a2, a3, a4));
}
Variant i_drawmatte(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawmatte);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawmatte", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawmatte(arg0, arg1, arg2, arg3), null);
  }
}
Variant ifa_drawmatte(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("drawmatte", count, 4, 4, 1);
  return (f_drawmatte(a0, a1, a2, a3), null);
}
Variant i_imagecolormatch(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolormatch);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolormatch", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolormatch(arg0, arg1));
  }
}
Variant ifa_imagecolormatch(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagecolormatch", count, 2, 2, 1);
  return (f_imagecolormatch(a0, a1));
}
Variant i_drawrectangle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawrectangle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawrectangle", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawrectangle(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant ifa_drawrectangle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("drawrectangle", count, 5, 5, 1);
  return (f_drawrectangle(a0, a1, a2, a3, a4), null);
}
Variant i_fb_parallel_query(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_parallel_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("fb_parallel_query", count, 1, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fb_parallel_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_fb_parallel_query(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fb_parallel_query(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_fb_parallel_query(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_fb_parallel_query(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_fb_parallel_query(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_parallel_query(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant ifa_fb_parallel_query(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 7) return throw_wrong_arguments("fb_parallel_query", count, 1, 7, 1);
  if (count <= 1) return (f_fb_parallel_query(a0));
  if (count == 2) return (f_fb_parallel_query(a0, a1));
  if (count == 3) return (f_fb_parallel_query(a0, a1, a2));
  if (count == 4) return (f_fb_parallel_query(a0, a1, a2, a3));
  if (count == 5) return (f_fb_parallel_query(a0, a1, a2, a3, a4));
  return (f_fb_parallel_query(a0, a1, a2, a3, a4, a5));
}
Variant i_dom_document_create_entity_reference(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_entity_reference);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_entity_reference", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_entity_reference(arg0, arg1));
  }
}
Variant ifa_dom_document_create_entity_reference(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_create_entity_reference", count, 2, 2, 1);
  return (f_dom_document_create_entity_reference(a0, a1));
}
Variant i_mcrypt_enc_get_block_size(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_block_size);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_block_size", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_block_size(arg0));
  }
}
Variant ifa_mcrypt_enc_get_block_size(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_block_size", count, 1, 1, 1);
  return (f_mcrypt_enc_get_block_size(a0));
}
Variant i_stream_context_set_option(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_context_set_option);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_context_set_option", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_context_set_option(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_context_set_option(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_context_set_option(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_stream_context_set_option(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_context_set_option", count, 2, 4, 1);
  if (count <= 2) return (f_stream_context_set_option(a0, a1));
  if (count == 3) return (f_stream_context_set_option(a0, a1, a2));
  return (f_stream_context_set_option(a0, a1, a2, a3));
}
Variant i_drawpathcurvetorelative(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetorelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawpathcurvetorelative", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetorelative(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant ifa_drawpathcurvetorelative(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 7) return throw_wrong_arguments("drawpathcurvetorelative", count, 7, 7, 1);
  return (f_drawpathcurvetorelative(a0, a1, a2, a3, a4, a5, null), null);
}
Variant i_phpcredits(void *extra, CArrRef params) {
  FUNCTION_INJECTION(phpcredits);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpcredits", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_phpcredits());
    CVarRef arg0((ad->getValue(pos)));
    return (f_phpcredits(arg0));
  }
}
Variant ifa_phpcredits(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("phpcredits", 1, 1);
  if (count <= 0) return (f_phpcredits());
  return (f_phpcredits(a0));
}
Variant i_drawgetfillrule(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetfillrule);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillrule", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfillrule(arg0));
  }
}
Variant ifa_drawgetfillrule(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetfillrule", count, 1, 1, 1);
  return (f_drawgetfillrule(a0));
}
Variant i_parse_hdf_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(parse_hdf_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("parse_hdf_string", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_parse_hdf_string(arg0));
  }
}
Variant ifa_parse_hdf_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("parse_hdf_string", count, 1, 1, 1);
  return (f_parse_hdf_string(a0));
}
Variant i_xmlwriter_end_cdata(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_cdata);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_cdata", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_cdata(arg0));
  }
}
Variant ifa_xmlwriter_end_cdata(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_cdata", count, 1, 1, 1);
  return (f_xmlwriter_end_cdata(a0));
}
Variant i_magickgetversionstring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetversionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversionstring", 0, 1);
  return (f_magickgetversionstring());
}
Variant ifa_magickgetversionstring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("magickgetversionstring", 0, 1);
  return (f_magickgetversionstring());
}
Variant i_pcntl_fork(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_fork);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pcntl_fork", 0, 1);
  return (f_pcntl_fork());
}
Variant ifa_pcntl_fork(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("pcntl_fork", 0, 1);
  return (f_pcntl_fork());
}
Variant i_dom_node_normalize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_normalize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_normalize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_node_normalize(arg0));
  }
}
Variant ifa_dom_node_normalize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dom_node_normalize", count, 1, 1, 1);
  return (f_dom_node_normalize(a0));
}
Variant i_doubleval(void *extra, CArrRef params) {
  FUNCTION_INJECTION(doubleval);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("doubleval", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_doubleval(arg0));
  }
}
Variant ifa_doubleval(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("doubleval", count, 1, 1, 1);
  return (f_doubleval(a0));
}
Variant i_assert_options(void *extra, CArrRef params) {
  FUNCTION_INJECTION(assert_options);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("assert_options", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_assert_options(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_assert_options(arg0, arg1));
  }
}
Variant ifa_assert_options(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("assert_options", count, 1, 2, 1);
  if (count <= 1) return (f_assert_options(a0));
  return (f_assert_options(a0, a1));
}
Variant i_magickhasnextimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickhasnextimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickhasnextimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickhasnextimage(arg0));
  }
}
Variant ifa_magickhasnextimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickhasnextimage", count, 1, 1, 1);
  return (f_magickhasnextimage(a0));
}
Variant i_rmdir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(rmdir);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("rmdir", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_rmdir(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rmdir(arg0, arg1));
  }
}
Variant ifa_rmdir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("rmdir", count, 1, 2, 1);
  if (count <= 1) return (f_rmdir(a0));
  return (f_rmdir(a0, a1));
}
Variant i_drawgetstrokelinecap(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokelinecap);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokelinecap", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokelinecap(arg0));
  }
}
Variant ifa_drawgetstrokelinecap(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetstrokelinecap", count, 1, 1, 1);
  return (f_drawgetstrokelinecap(a0));
}
Variant i_hphp_clear_unflushed(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_clear_unflushed);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_clear_unflushed", 0, 1);
  return (f_hphp_clear_unflushed(), null);
}
Variant ifa_hphp_clear_unflushed(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("hphp_clear_unflushed", 0, 1);
  return (f_hphp_clear_unflushed(), null);
}
Variant i_magickscaleimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickscaleimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickscaleimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickscaleimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickscaleimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magickscaleimage", count, 3, 3, 1);
  return (f_magickscaleimage(a0, a1, a2));
}
Variant i_pixelgetblackquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetblackquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblackquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetblackquantum(arg0));
  }
}
Variant ifa_pixelgetblackquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetblackquantum", count, 1, 1, 1);
  return (f_pixelgetblackquantum(a0));
}
Variant i_magicknewimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicknewimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magicknewimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magicknewimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicknewimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magicknewimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magicknewimage", count, 3, 4, 1);
  if (count <= 3) return (f_magicknewimage(a0, a1, a2));
  return (f_magicknewimage(a0, a1, a2, a3));
}
Variant i_destroypixelwands(void *extra, CArrRef params) {
  FUNCTION_INJECTION(destroypixelwands);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwands", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroypixelwands(arg0), null);
  }
}
Variant ifa_destroypixelwands(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("destroypixelwands", count, 1, 1, 1);
  return (f_destroypixelwands(a0), null);
}
Variant i_shm_remove(void *extra, CArrRef params) {
  FUNCTION_INJECTION(shm_remove);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shm_remove", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_shm_remove(arg0));
  }
}
Variant ifa_shm_remove(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("shm_remove", count, 1, 1, 1);
  return (f_shm_remove(a0));
}
Variant i_hphp_splfileobject_setflags(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_setflags);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_setflags", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_setflags(arg0, arg1), null);
  }
}
Variant ifa_hphp_splfileobject_setflags(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_setflags", count, 2, 2, 1);
  return (f_hphp_splfileobject_setflags(a0, a1), null);
}
Variant i_date_sun_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_sun_info);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("date_sun_info", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_sun_info(arg0, arg1, arg2));
  }
}
Variant ifa_date_sun_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("date_sun_info", count, 3, 3, 1);
  return (f_date_sun_info(a0, a1, a2));
}
Variant i_hphp_directoryiterator_valid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_valid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_valid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_valid(arg0));
  }
}
Variant ifa_hphp_directoryiterator_valid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_valid", count, 1, 1, 1);
  return (f_hphp_directoryiterator_valid(a0));
}
Variant i_magickresizeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickresizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickresizeimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickresizeimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_magickresizeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("magickresizeimage", count, 5, 5, 1);
  return (f_magickresizeimage(a0, a1, a2, a3, a4));
}
Variant i_parse_ini_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(parse_ini_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("parse_ini_file", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_parse_ini_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_parse_ini_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_parse_ini_file(arg0, arg1, arg2));
  }
}
Variant ifa_parse_ini_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("parse_ini_file", count, 1, 3, 1);
  if (count <= 1) return (f_parse_ini_file(a0));
  if (count == 2) return (f_parse_ini_file(a0, a1));
  return (f_parse_ini_file(a0, a1, a2));
}
Variant i_stream_get_meta_data(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_get_meta_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_get_meta_data", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_get_meta_data(arg0));
  }
}
Variant ifa_stream_get_meta_data(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("stream_get_meta_data", count, 1, 1, 1);
  return (f_stream_get_meta_data(a0));
}
Variant i_imagepsencodefont(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagepsencodefont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsencodefont", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepsencodefont(arg0, arg1));
  }
}
Variant ifa_imagepsencodefont(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagepsencodefont", count, 2, 2, 1);
  return (f_imagepsencodefont(a0, a1));
}
Variant i_ldap_set_option(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_set_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_set_option", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_set_option(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_set_option(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ldap_set_option", count, 3, 3, 1);
  return (f_ldap_set_option(a0, a1, a2));
}
Variant i_magickgetsize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetsize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetsize(arg0));
  }
}
Variant ifa_magickgetsize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetsize", count, 1, 1, 1);
  return (f_magickgetsize(a0));
}
Variant i_memory_get_peak_usage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memory_get_peak_usage);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("memory_get_peak_usage", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_memory_get_peak_usage());
    CVarRef arg0((ad->getValue(pos)));
    return (f_memory_get_peak_usage(arg0));
  }
}
Variant ifa_memory_get_peak_usage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("memory_get_peak_usage", 1, 1);
  if (count <= 0) return (f_memory_get_peak_usage());
  return (f_memory_get_peak_usage(a0));
}
Variant i_pcntl_exec(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_exec);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pcntl_exec", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pcntl_exec(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_pcntl_exec(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_exec(arg0, arg1, arg2), null);
  }
}
Variant ifa_pcntl_exec(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("pcntl_exec", count, 1, 3, 1);
  if (count <= 1) return (f_pcntl_exec(a0), null);
  if (count == 2) return (f_pcntl_exec(a0, a1), null);
  return (f_pcntl_exec(a0, a1, a2), null);
}
Variant i_xmlwriter_set_indent_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_set_indent_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_set_indent_string", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_set_indent_string(arg0, arg1));
  }
}
Variant ifa_xmlwriter_set_indent_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xmlwriter_set_indent_string", count, 2, 2, 1);
  return (f_xmlwriter_set_indent_string(a0, a1));
}
Variant i_php_strip_whitespace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(php_strip_whitespace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("php_strip_whitespace", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_php_strip_whitespace(arg0));
  }
}
Variant ifa_php_strip_whitespace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("php_strip_whitespace", count, 1, 1, 1);
  return (f_php_strip_whitespace(a0));
}
Variant i_strcoll(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strcoll);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcoll", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strcoll(arg0, arg1));
  }
}
Variant ifa_strcoll(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("strcoll", count, 2, 2, 1);
  return (f_strcoll(a0, a1));
}
Variant i_write_hdf_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(write_hdf_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("write_hdf_file", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_write_hdf_file(arg0, arg1));
  }
}
Variant ifa_write_hdf_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("write_hdf_file", count, 2, 2, 1);
  return (f_write_hdf_file(a0, a1));
}
Variant i_socket_send(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_send);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_send", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_send(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_socket_send(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("socket_send", count, 4, 4, 1);
  return (f_socket_send(a0, a1, a2, a3));
}
Variant i_zlib_get_coding_type(void *extra, CArrRef params) {
  FUNCTION_INJECTION(zlib_get_coding_type);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zlib_get_coding_type", 0, 1);
  return (f_zlib_get_coding_type());
}
Variant ifa_zlib_get_coding_type(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("zlib_get_coding_type", 0, 1);
  return (f_zlib_get_coding_type());
}
Variant i_hphp_splfileobject_fscanf(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fscanf);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_fscanf", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_fscanf(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_hphp_splfileobject_fscanf(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_fscanf", count, 4, 4, 1);
  return (f_hphp_splfileobject_fscanf(a0, a1, a2, a3));
}
Variant i_mb_ereg_search_getregs(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_getregs);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_ereg_search_getregs", 0, 1);
  return (f_mb_ereg_search_getregs());
}
Variant ifa_mb_ereg_search_getregs(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("mb_ereg_search_getregs", 0, 1);
  return (f_mb_ereg_search_getregs());
}
Variant i_mb_eregi(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_eregi);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_eregi", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_eregi(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_mb_eregi(arg0, arg1, arg2));
  }
}
Variant ifa_mb_eregi(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_eregi", count, 2, 3, 1);
  if (count <= 2) return (f_mb_eregi(a0, a1));
  return (f_mb_eregi(a0, a1, ref(a2)));
}
Variant i_pixelgetgreen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetgreen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetgreen", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetgreen(arg0));
  }
}
Variant ifa_pixelgetgreen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetgreen", count, 1, 1, 1);
  return (f_pixelgetgreen(a0));
}
Variant i_mysql_client_encoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_client_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_client_encoding", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_client_encoding());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_client_encoding(arg0));
  }
}
Variant ifa_mysql_client_encoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_client_encoding", 1, 1);
  if (count <= 0) return (f_mysql_client_encoding());
  return (f_mysql_client_encoding(a0));
}
Variant i_zend_thread_id(void *extra, CArrRef params) {
  FUNCTION_INJECTION(zend_thread_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_thread_id", 0, 1);
  return (f_zend_thread_id());
}
Variant ifa_zend_thread_id(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("zend_thread_id", 0, 1);
  return (f_zend_thread_id());
}
Variant i_ldap_mod_replace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_mod_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_replace", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_mod_replace(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_mod_replace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ldap_mod_replace", count, 3, 3, 1);
  return (f_ldap_mod_replace(a0, a1, a2));
}
Variant i_collator_get_error_code(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_get_error_code);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_error_code", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_collator_get_error_code(arg0));
  }
}
Variant ifa_collator_get_error_code(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("collator_get_error_code", count, 1, 1, 1);
  return (f_collator_get_error_code(a0));
}
Variant i_stream_filter_prepend(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_filter_prepend);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_filter_prepend", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_filter_prepend(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_filter_prepend(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_filter_prepend(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_stream_filter_prepend(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_filter_prepend", count, 2, 4, 1);
  if (count <= 2) return (f_stream_filter_prepend(a0, a1));
  if (count == 3) return (f_stream_filter_prepend(a0, a1, a2));
  return (f_stream_filter_prepend(a0, a1, a2, a3));
}
Variant i_substr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(substr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("substr", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_substr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_substr(arg0, arg1, arg2));
  }
}
Variant ifa_substr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("substr", count, 2, 3, 1);
  if (count <= 2) return (f_substr(a0, a1));
  return (f_substr(a0, a1, a2));
}
Variant i_magickcombineimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickcombineimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcombineimages", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcombineimages(arg0, arg1));
  }
}
Variant ifa_magickcombineimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickcombineimages", count, 2, 2, 1);
  return (f_magickcombineimages(a0, a1));
}
Variant i_pixelgetexceptiontype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetexceptiontype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexceptiontype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetexceptiontype(arg0));
  }
}
Variant ifa_pixelgetexceptiontype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetexceptiontype", count, 1, 1, 1);
  return (f_pixelgetexceptiontype(a0));
}
Variant i_unpack(void *extra, CArrRef params) {
  FUNCTION_INJECTION(unpack);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("unpack", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_unpack(arg0, arg1));
  }
}
Variant ifa_unpack(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("unpack", count, 2, 2, 1);
  return (f_unpack(a0, a1));
}
Variant i_hphp_splfileinfo_isdir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_isdir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isdir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_isdir(arg0));
  }
}
Variant ifa_hphp_splfileinfo_isdir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isdir", count, 1, 1, 1);
  return (f_hphp_splfileinfo_isdir(a0));
}
Variant i_magickgetimagepixels(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagepixels);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("magickgetimagepixels", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimagepixels(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant ifa_magickgetimagepixels(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 7) return throw_wrong_arguments("magickgetimagepixels", count, 7, 7, 1);
  return (f_magickgetimagepixels(a0, a1, a2, a3, a4, a5, null));
}
Variant i_array_product(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_product);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_product", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_product(arg0));
  }
}
Variant ifa_array_product(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("array_product", count, 1, 1, 1);
  return (f_array_product(a0));
}
Variant i_substr_replace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(substr_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("substr_replace", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_substr_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_substr_replace(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_substr_replace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("substr_replace", count, 3, 4, 1);
  if (count <= 3) return (f_substr_replace(a0, a1, a2));
  return (f_substr_replace(a0, a1, a2, a3));
}
Variant i_xbox_get_thread_time(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xbox_get_thread_time);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_get_thread_time", 0, 1);
  return (f_xbox_get_thread_time());
}
Variant ifa_xbox_get_thread_time(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("xbox_get_thread_time", 0, 1);
  return (f_xbox_get_thread_time());
}
Variant i_xmlwriter_write_dtd(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_dtd);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("xmlwriter_write_dtd", count, 2, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_xmlwriter_write_dtd(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_xmlwriter_write_dtd(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_xmlwriter_write_dtd(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_dtd(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_xmlwriter_write_dtd(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 5) return throw_wrong_arguments("xmlwriter_write_dtd", count, 2, 5, 1);
  if (count <= 2) return (f_xmlwriter_write_dtd(a0, a1));
  if (count == 3) return (f_xmlwriter_write_dtd(a0, a1, a2));
  if (count == 4) return (f_xmlwriter_write_dtd(a0, a1, a2, a3));
  return (f_xmlwriter_write_dtd(a0, a1, a2, a3, a4));
}
Variant i_mysql_select_db(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_select_db);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_select_db", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_select_db(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_select_db(arg0, arg1));
  }
}
Variant ifa_mysql_select_db(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_select_db", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_select_db(a0));
  return (f_mysql_select_db(a0, a1));
}
Variant i_fb_get_taint(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_get_taint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_get_taint", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_get_taint(arg0));
  }
}
Variant ifa_fb_get_taint(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fb_get_taint", count, 1, 1, 1);
  return (f_fb_get_taint(a0));
}
Variant i_use_soap_error_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(use_soap_error_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("use_soap_error_handler", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_use_soap_error_handler());
    CVarRef arg0((ad->getValue(pos)));
    return (f_use_soap_error_handler(arg0));
  }
}
Variant ifa_use_soap_error_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("use_soap_error_handler", 1, 1);
  if (count <= 0) return (f_use_soap_error_handler());
  return (f_use_soap_error_handler(a0));
}
Variant i_debug_backtrace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(debug_backtrace);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("debug_backtrace", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_debug_backtrace());
    CVarRef arg0((ad->getValue(pos)));
    return (f_debug_backtrace(arg0));
  }
}
Variant ifa_debug_backtrace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("debug_backtrace", 1, 1);
  if (count <= 0) return (f_debug_backtrace());
  return (f_debug_backtrace(a0));
}
Variant i_drawpathcurvetosmoothrelative(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetosmoothrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetosmoothrelative", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetosmoothrelative(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant ifa_drawpathcurvetosmoothrelative(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("drawpathcurvetosmoothrelative", count, 5, 5, 1);
  return (f_drawpathcurvetosmoothrelative(a0, a1, a2, a3, a4), null);
}
Variant i_mailparse_determine_best_xfer_encoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_determine_best_xfer_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_determine_best_xfer_encoding", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_determine_best_xfer_encoding(arg0));
  }
}
Variant ifa_mailparse_determine_best_xfer_encoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mailparse_determine_best_xfer_encoding", count, 1, 1, 1);
  return (f_mailparse_determine_best_xfer_encoding(a0));
}
Variant i_imagettfbbox(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagettfbbox);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagettfbbox", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagettfbbox(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagettfbbox(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("imagettfbbox", count, 4, 4, 1);
  return (f_imagettfbbox(a0, a1, a2, a3));
}
Variant i_mb_internal_encoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_internal_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_internal_encoding", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_internal_encoding());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_internal_encoding(arg0));
  }
}
Variant ifa_mb_internal_encoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mb_internal_encoding", 1, 1);
  if (count <= 0) return (f_mb_internal_encoding());
  return (f_mb_internal_encoding(a0));
}
Variant i_msg_get_queue(void *extra, CArrRef params) {
  FUNCTION_INJECTION(msg_get_queue);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("msg_get_queue", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_msg_get_queue(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_msg_get_queue(arg0, arg1));
  }
}
Variant ifa_msg_get_queue(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("msg_get_queue", count, 1, 2, 1);
  if (count <= 1) return (f_msg_get_queue(a0));
  return (f_msg_get_queue(a0, a1));
}
Variant i_posix_getegid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getegid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getegid", 0, 1);
  return (f_posix_getegid());
}
Variant ifa_posix_getegid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_getegid", 0, 1);
  return (f_posix_getegid());
}
Variant i_magickmedianfilterimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickmedianfilterimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickmedianfilterimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmedianfilterimage(arg0, arg1));
  }
}
Variant ifa_magickmedianfilterimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickmedianfilterimage", count, 2, 2, 1);
  return (f_magickmedianfilterimage(a0, a1));
}
Variant i_xbox_task_result(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xbox_task_result);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xbox_task_result", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_xbox_task_result(arg0, arg1, arg2));
  }
}
Variant ifa_xbox_task_result(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("xbox_task_result", count, 3, 3, 1);
  return (f_xbox_task_result(a0, a1, ref(a2)));
}
Variant i_mcrypt_generic_deinit(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_generic_deinit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_generic_deinit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_generic_deinit(arg0));
  }
}
Variant ifa_mcrypt_generic_deinit(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_generic_deinit", count, 1, 1, 1);
  return (f_mcrypt_generic_deinit(a0));
}
Variant i_method_exists(void *extra, CArrRef params) {
  FUNCTION_INJECTION(method_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("method_exists", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_method_exists(arg0, arg1));
  }
}
Variant ifa_method_exists(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("method_exists", count, 2, 2, 1);
  return (f_method_exists(a0, a1));
}
Variant i_money_format(void *extra, CArrRef params) {
  FUNCTION_INJECTION(money_format);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("money_format", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_money_format(arg0, arg1));
  }
}
Variant ifa_money_format(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("money_format", count, 2, 2, 1);
  return (f_money_format(a0, a1));
}
Variant i_clearmagickwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(clearmagickwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearmagickwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_clearmagickwand(arg0), null);
  }
}
Variant ifa_clearmagickwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("clearmagickwand", count, 1, 1, 1);
  return (f_clearmagickwand(a0), null);
}
Variant i_dom_element_remove_attribute_node(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_remove_attribute_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_remove_attribute_node", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_remove_attribute_node(arg0, arg1));
  }
}
Variant ifa_dom_element_remove_attribute_node(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_element_remove_attribute_node", count, 2, 2, 1);
  return (f_dom_element_remove_attribute_node(a0, a1));
}
Variant i_array_udiff_assoc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_udiff_assoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_udiff_assoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_udiff_assoc(count, arg0, arg1, arg2));
    return (f_array_udiff_assoc(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant ifa_array_udiff_assoc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3) return throw_missing_arguments("array_udiff_assoc", count+1, 1);
  if (count <= 3) return (f_array_udiff_assoc(count, a0, a1, a2));
  Array params;
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_udiff_assoc(count,a0, a1, a2, params));
}
Variant i_xml_parser_free(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_parser_free);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_parser_free", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_parser_free(arg0));
  }
}
Variant ifa_xml_parser_free(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xml_parser_free", count, 1, 1, 1);
  return (f_xml_parser_free(a0));
}
Variant i_is_resource(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_resource);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_resource", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_resource(arg0));
  }
}
Variant ifa_is_resource(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_resource", count, 1, 1, 1);
  return (f_is_resource(a0));
}
Variant i_hphp_splfileinfo_getsize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getsize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getsize(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getsize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getsize", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getsize(a0));
}
Variant i_posix_seteuid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_seteuid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_seteuid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_seteuid(arg0));
  }
}
Variant ifa_posix_seteuid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_seteuid", count, 1, 1, 1);
  return (f_posix_seteuid(a0));
}
Variant i_magicksetinterlacescheme(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetinterlacescheme);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetinterlacescheme", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetinterlacescheme(arg0, arg1));
  }
}
Variant ifa_magicksetinterlacescheme(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetinterlacescheme", count, 2, 2, 1);
  return (f_magicksetinterlacescheme(a0, a1));
}
Variant i_str_shuffle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(str_shuffle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("str_shuffle", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_str_shuffle(arg0));
  }
}
Variant ifa_str_shuffle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("str_shuffle", count, 1, 1, 1);
  return (f_str_shuffle(a0));
}
Variant i_mcrypt_enc_is_block_algorithm(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_is_block_algorithm);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_algorithm", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_is_block_algorithm(arg0));
  }
}
Variant ifa_mcrypt_enc_is_block_algorithm(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_algorithm", count, 1, 1, 1);
  return (f_mcrypt_enc_is_block_algorithm(a0));
}
Variant i_call_user_func_array_rpc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(call_user_func_array_rpc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("call_user_func_array_rpc", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_call_user_func_array_rpc(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_call_user_func_array_rpc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("call_user_func_array_rpc", count, 6, 6, 1);
  return (f_call_user_func_array_rpc(a0, a1, a2, a3, a4, a5));
}
Variant i_fb_serialize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_serialize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_serialize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_serialize(arg0));
  }
}
Variant ifa_fb_serialize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fb_serialize", count, 1, 1, 1);
  return (f_fb_serialize(a0));
}
Variant i_magickgetcopyright(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetcopyright);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetcopyright", 0, 1);
  return (f_magickgetcopyright());
}
Variant ifa_magickgetcopyright(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("magickgetcopyright", 0, 1);
  return (f_magickgetcopyright());
}
Variant i_magickstripimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickstripimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickstripimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickstripimage(arg0));
  }
}
Variant ifa_magickstripimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickstripimage", count, 1, 1, 1);
  return (f_magickstripimage(a0));
}
Variant i_base64_decode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(base64_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("base64_decode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_base64_decode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_base64_decode(arg0, arg1));
  }
}
Variant ifa_base64_decode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("base64_decode", count, 1, 2, 1);
  if (count <= 1) return (f_base64_decode(a0));
  return (f_base64_decode(a0, a1));
}
Variant i_rand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(rand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("rand", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_rand());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_rand(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rand(arg0, arg1));
  }
}
Variant ifa_rand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("rand", 2, 1);
  if (count <= 0) return (f_rand());
  if (count == 1) return (f_rand(a0));
  return (f_rand(a0, a1));
}
Variant i_crc32(void *extra, CArrRef params) {
  FUNCTION_INJECTION(crc32);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("crc32", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_crc32(arg0));
  }
}
Variant ifa_crc32(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("crc32", count, 1, 1, 1);
  return (f_crc32(a0));
}
Variant i_stream_encoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("stream_encoding", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_encoding(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_encoding(arg0, arg1));
  }
}
Variant ifa_stream_encoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("stream_encoding", count, 1, 2, 1);
  if (count <= 1) return (f_stream_encoding(a0));
  return (f_stream_encoding(a0, a1));
}
Variant i_drawgetstrokedasharray(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokedasharray);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokedasharray", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokedasharray(arg0));
  }
}
Variant ifa_drawgetstrokedasharray(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetstrokedasharray", count, 1, 1, 1);
  return (f_drawgetstrokedasharray(a0));
}
Variant i_magickgetimagedispose(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagedispose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagedispose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagedispose(arg0));
  }
}
Variant ifa_magickgetimagedispose(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagedispose", count, 1, 1, 1);
  return (f_magickgetimagedispose(a0));
}
Variant i_drawpopdefs(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpopdefs);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpopdefs", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpopdefs(arg0), null);
  }
}
Variant ifa_drawpopdefs(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawpopdefs", count, 1, 1, 1);
  return (f_drawpopdefs(a0), null);
}
Variant i_xml_parser_create(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_parser_create);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("xml_parser_create", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_xml_parser_create());
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_parser_create(arg0));
  }
}
Variant ifa_xml_parser_create(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("xml_parser_create", 1, 1);
  if (count <= 0) return (f_xml_parser_create());
  return (f_xml_parser_create(a0));
}
Variant i_session_save_path(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_save_path);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_save_path", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_save_path());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_save_path(arg0));
  }
}
Variant ifa_session_save_path(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("session_save_path", 1, 1);
  if (count <= 0) return (f_session_save_path());
  return (f_session_save_path(a0));
}
Variant i_pcntl_wifsignaled(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_wifsignaled);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifsignaled", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wifsignaled(arg0));
  }
}
Variant ifa_pcntl_wifsignaled(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pcntl_wifsignaled", count, 1, 1, 1);
  return (f_pcntl_wifsignaled(a0));
}
Variant i_openssl_pkcs7_encrypt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs7_encrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 6) return throw_wrong_arguments("openssl_pkcs7_encrypt", count, 4, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_openssl_pkcs7_encrypt(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_openssl_pkcs7_encrypt(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs7_encrypt(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_openssl_pkcs7_encrypt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4 || count > 6) return throw_wrong_arguments("openssl_pkcs7_encrypt", count, 4, 6, 1);
  if (count <= 4) return (f_openssl_pkcs7_encrypt(a0, a1, a2, a3));
  if (count == 5) return (f_openssl_pkcs7_encrypt(a0, a1, a2, a3, a4));
  return (f_openssl_pkcs7_encrypt(a0, a1, a2, a3, a4, a5));
}
Variant i_read_exif_data(void *extra, CArrRef params) {
  FUNCTION_INJECTION(read_exif_data);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("read_exif_data", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_read_exif_data(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_read_exif_data(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_read_exif_data(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_read_exif_data(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_read_exif_data(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("read_exif_data", count, 1, 4, 1);
  if (count <= 1) return (f_read_exif_data(a0));
  if (count == 2) return (f_read_exif_data(a0, a1));
  if (count == 3) return (f_read_exif_data(a0, a1, a2));
  return (f_read_exif_data(a0, a1, a2, a3));
}
Variant i_drawsetstrokeopacity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokeopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokeopacity", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokeopacity(arg0, arg1), null);
  }
}
Variant ifa_drawsetstrokeopacity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetstrokeopacity", count, 2, 2, 1);
  return (f_drawsetstrokeopacity(a0, a1), null);
}
Variant i_drawroundrectangle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawroundrectangle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawroundrectangle", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawroundrectangle(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant ifa_drawroundrectangle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 7) return throw_wrong_arguments("drawroundrectangle", count, 7, 7, 1);
  return (f_drawroundrectangle(a0, a1, a2, a3, a4, a5, null), null);
}
Variant i_hphp_directoryiterator_isdot(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_isdot);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_isdot", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_isdot(arg0));
  }
}
Variant ifa_hphp_directoryiterator_isdot(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_isdot", count, 1, 1, 1);
  return (f_hphp_directoryiterator_isdot(a0));
}
Variant i_drawgetstrokewidth(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokewidth);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokewidth", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokewidth(arg0));
  }
}
Variant ifa_drawgetstrokewidth(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetstrokewidth", count, 1, 1, 1);
  return (f_drawgetstrokewidth(a0));
}
Variant i_date_create(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_create);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("date_create", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_date_create());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_date_create(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_create(arg0, arg1));
  }
}
Variant ifa_date_create(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("date_create", 2, 1);
  if (count <= 0) return (f_date_create());
  if (count == 1) return (f_date_create(a0));
  return (f_date_create(a0, a1));
}
Variant i_strcspn(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strcspn);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("strcspn", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strcspn(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_strcspn(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strcspn(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_strcspn(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("strcspn", count, 2, 4, 1);
  if (count <= 2) return (f_strcspn(a0, a1));
  if (count == 3) return (f_strcspn(a0, a1, a2));
  return (f_strcspn(a0, a1, a2, a3));
}
Variant i_drawgetclipunits(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetclipunits);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetclipunits", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetclipunits(arg0));
  }
}
Variant ifa_drawgetclipunits(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetclipunits", count, 1, 1, 1);
  return (f_drawgetclipunits(a0));
}
Variant i_sem_acquire(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sem_acquire);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_acquire", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sem_acquire(arg0));
  }
}
Variant ifa_sem_acquire(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("sem_acquire", count, 1, 1, 1);
  return (f_sem_acquire(a0));
}
Variant i_socket_strerror(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_strerror);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_strerror", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_strerror(arg0));
  }
}
Variant ifa_socket_strerror(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("socket_strerror", count, 1, 1, 1);
  return (f_socket_strerror(a0));
}
Variant i_magickgetstringheight(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetstringheight);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetstringheight", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgetstringheight(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetstringheight(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickgetstringheight(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetstringheight", count, 3, 4, 1);
  if (count <= 3) return (f_magickgetstringheight(a0, a1, a2));
  return (f_magickgetstringheight(a0, a1, a2, a3));
}
Variant i_dom_document_relaxng_validate_xml(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_relaxng_validate_xml);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_relaxng_validate_xml", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_relaxng_validate_xml(arg0, arg1));
  }
}
Variant ifa_dom_document_relaxng_validate_xml(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_relaxng_validate_xml", count, 2, 2, 1);
  return (f_dom_document_relaxng_validate_xml(a0, a1));
}
Variant i_rawurlencode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(rawurlencode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rawurlencode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_rawurlencode(arg0));
  }
}
Variant ifa_rawurlencode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("rawurlencode", count, 1, 1, 1);
  return (f_rawurlencode(a0));
}
Variant i_strtotime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strtotime);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strtotime", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_strtotime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strtotime(arg0, arg1));
  }
}
Variant ifa_strtotime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("strtotime", count, 1, 2, 1);
  if (count <= 1) return (f_strtotime(a0));
  return (f_strtotime(a0, a1));
}
Variant i_dom_element_set_id_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_id_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_id_attribute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_id_attribute(arg0, arg1, arg2));
  }
}
Variant ifa_dom_element_set_id_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_element_set_id_attribute", count, 3, 3, 1);
  return (f_dom_element_set_id_attribute(a0, a1, a2));
}
Variant i_hphp_recursivedirectoryiterator_getsubpath(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_getsubpath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getsubpath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_getsubpath(arg0));
  }
}
Variant ifa_hphp_recursivedirectoryiterator_getsubpath(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getsubpath", count, 1, 1, 1);
  return (f_hphp_recursivedirectoryiterator_getsubpath(a0));
}
Variant i_apc_clear_cache(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_clear_cache);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("apc_clear_cache", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_apc_clear_cache());
    CVarRef arg0((ad->getValue(pos)));
    return (f_apc_clear_cache(arg0));
  }
}
Variant ifa_apc_clear_cache(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("apc_clear_cache", 1, 1);
  if (count <= 0) return (f_apc_clear_cache());
  return (f_apc_clear_cache(a0));
}
Variant i_dirname(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dirname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dirname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dirname(arg0));
  }
}
Variant ifa_dirname(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dirname", count, 1, 1, 1);
  return (f_dirname(a0));
}
Variant i_strnatcasecmp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strnatcasecmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strnatcasecmp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strnatcasecmp(arg0, arg1));
  }
}
Variant ifa_strnatcasecmp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("strnatcasecmp", count, 2, 2, 1);
  return (f_strnatcasecmp(a0, a1));
}
Variant i_magicksetsamplingfactors(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetsamplingfactors);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetsamplingfactors", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetsamplingfactors(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetsamplingfactors(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksetsamplingfactors", count, 3, 3, 1);
  return (f_magicksetsamplingfactors(a0, a1, a2));
}
Variant i_openssl_pkey_get_private(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_get_private);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_pkey_get_private", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_openssl_pkey_get_private(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkey_get_private(arg0, arg1));
  }
}
Variant ifa_openssl_pkey_get_private(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_pkey_get_private", count, 1, 2, 1);
  if (count <= 1) return (f_openssl_pkey_get_private(a0));
  return (f_openssl_pkey_get_private(a0, a1));
}
Variant i_magickaverageimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickaverageimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickaverageimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickaverageimages(arg0));
  }
}
Variant ifa_magickaverageimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickaverageimages", count, 1, 1, 1);
  return (f_magickaverageimages(a0));
}
Variant i_iconv_strrpos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iconv_strrpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iconv_strrpos", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iconv_strrpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_strrpos(arg0, arg1, arg2));
  }
}
Variant ifa_iconv_strrpos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("iconv_strrpos", count, 2, 3, 1);
  if (count <= 2) return (f_iconv_strrpos(a0, a1));
  return (f_iconv_strrpos(a0, a1, a2));
}
Variant i_collator_get_locale(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_get_locale);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("collator_get_locale", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_collator_get_locale(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_get_locale(arg0, arg1));
  }
}
Variant ifa_collator_get_locale(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("collator_get_locale", count, 1, 2, 1);
  if (count <= 1) return (f_collator_get_locale(a0));
  return (f_collator_get_locale(a0, a1));
}
Variant i_drawsetviewbox(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetviewbox);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawsetviewbox", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetviewbox(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant ifa_drawsetviewbox(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("drawsetviewbox", count, 5, 5, 1);
  return (f_drawsetviewbox(a0, a1, a2, a3, a4), null);
}
Variant i_magicksetimagecompressionquality(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagecompressionquality);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompressionquality", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagecompressionquality(arg0, arg1));
  }
}
Variant ifa_magicksetimagecompressionquality(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagecompressionquality", count, 2, 2, 1);
  return (f_magicksetimagecompressionquality(a0, a1));
}
Variant i_mysql_ping(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_ping);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_ping", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_ping());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_ping(arg0));
  }
}
Variant ifa_mysql_ping(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_ping", 1, 1);
  if (count <= 0) return (f_mysql_ping());
  return (f_mysql_ping(a0));
}
Variant i_xml_get_current_byte_index(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_get_current_byte_index);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_byte_index", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_get_current_byte_index(arg0));
  }
}
Variant ifa_xml_get_current_byte_index(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xml_get_current_byte_index", count, 1, 1, 1);
  return (f_xml_get_current_byte_index(a0));
}
Variant i_magicktransformimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicktransformimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicktransformimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicktransformimage(arg0, arg1, arg2));
  }
}
Variant ifa_magicktransformimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicktransformimage", count, 3, 3, 1);
  return (f_magicktransformimage(a0, a1, a2));
}
Variant i_drawgetstrokeantialias(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokeantialias);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokeantialias", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokeantialias(arg0));
  }
}
Variant ifa_drawgetstrokeantialias(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetstrokeantialias", count, 1, 1, 1);
  return (f_drawgetstrokeantialias(a0));
}
Variant i_ini_alter(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ini_alter);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ini_alter", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ini_alter(arg0, arg1));
  }
}
Variant ifa_ini_alter(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ini_alter", count, 2, 2, 1);
  return (f_ini_alter(a0, a1));
}
Variant i_get_class(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_class);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_class", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_class());
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_class(arg0));
  }
}
Variant ifa_get_class(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("get_class", 1, 1);
  if (count <= 0) return (f_get_class());
  return (f_get_class(a0));
}
Variant i_magicksetimageprofile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimageprofile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageprofile", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageprofile(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetimageprofile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksetimageprofile", count, 3, 3, 1);
  return (f_magicksetimageprofile(a0, a1, a2));
}
Variant i_mysql_field_seek(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_field_seek);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_seek", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_seek(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_seek(arg0, arg1));
  }
}
Variant ifa_mysql_field_seek(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_seek", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_field_seek(a0));
  return (f_mysql_field_seek(a0, a1));
}
Variant i_drawgetfontsize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetfontsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontsize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfontsize(arg0));
  }
}
Variant ifa_drawgetfontsize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetfontsize", count, 1, 1, 1);
  return (f_drawgetfontsize(a0));
}
Variant i_mysql_num_rows(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_num_rows);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_num_rows", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_num_rows(arg0));
  }
}
Variant ifa_mysql_num_rows(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mysql_num_rows", count, 1, 1, 1);
  return (f_mysql_num_rows(a0));
}
Variant i_hphp_recursiveiteratoriterator_rewind(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_rewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_rewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_rewind(arg0), null);
  }
}
Variant ifa_hphp_recursiveiteratoriterator_rewind(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_rewind", count, 1, 1, 1);
  return (f_hphp_recursiveiteratoriterator_rewind(a0), null);
}
Variant i_magickgetimageresolution(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageresolution);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageresolution", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageresolution(arg0));
  }
}
Variant ifa_magickgetimageresolution(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimageresolution", count, 1, 1, 1);
  return (f_magickgetimageresolution(a0));
}
Variant i_array_diff(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_diff);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_diff(count, arg0, arg1));
    return (f_array_diff(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_array_diff(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("array_diff", count+1, 1);
  if (count <= 2) return (f_array_diff(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_diff(count,a0, a1, params));
}
Variant i_xmlwriter_open_uri(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_open_uri);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_open_uri", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_open_uri(arg0));
  }
}
Variant ifa_xmlwriter_open_uri(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_open_uri", count, 1, 1, 1);
  return (f_xmlwriter_open_uri(a0));
}
Variant i_magickgetimagetype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagetype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagetype(arg0));
  }
}
Variant ifa_magickgetimagetype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagetype", count, 1, 1, 1);
  return (f_magickgetimagetype(a0));
}
Variant i_simplexml_load_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(simplexml_load_string);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("simplexml_load_string", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_simplexml_load_string(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_simplexml_load_string(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_simplexml_load_string(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_simplexml_load_string(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_simplexml_load_string(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_simplexml_load_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 5) return throw_wrong_arguments("simplexml_load_string", count, 1, 5, 1);
  if (count <= 1) return (f_simplexml_load_string(a0));
  if (count == 2) return (f_simplexml_load_string(a0, a1));
  if (count == 3) return (f_simplexml_load_string(a0, a1, a2));
  if (count == 4) return (f_simplexml_load_string(a0, a1, a2, a3));
  return (f_simplexml_load_string(a0, a1, a2, a3, a4));
}
Variant i_magickunsharpmaskimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickunsharpmaskimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("magickunsharpmaskimage", count, 5, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_magickunsharpmaskimage(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickunsharpmaskimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_magickunsharpmaskimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 5 || count > 6) return throw_wrong_arguments("magickunsharpmaskimage", count, 5, 6, 1);
  if (count <= 5) return (f_magickunsharpmaskimage(a0, a1, a2, a3, a4));
  return (f_magickunsharpmaskimage(a0, a1, a2, a3, a4, a5));
}
Variant i_quoted_printable_encode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(quoted_printable_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quoted_printable_encode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_quoted_printable_encode(arg0));
  }
}
Variant ifa_quoted_printable_encode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("quoted_printable_encode", count, 1, 1, 1);
  return (f_quoted_printable_encode(a0));
}
Variant i_gettype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gettype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gettype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gettype(arg0));
  }
}
Variant ifa_gettype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("gettype", count, 1, 1, 1);
  return (f_gettype(a0));
}
Variant i_magickgetimagebackgroundcolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagebackgroundcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagebackgroundcolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagebackgroundcolor(arg0));
  }
}
Variant ifa_magickgetimagebackgroundcolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagebackgroundcolor", count, 1, 1, 1);
  return (f_magickgetimagebackgroundcolor(a0));
}
Variant i_hphp_splfileobject_setmaxlinelen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_setmaxlinelen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_setmaxlinelen", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_setmaxlinelen(arg0, arg1), null);
  }
}
Variant ifa_hphp_splfileobject_setmaxlinelen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_setmaxlinelen", count, 2, 2, 1);
  return (f_hphp_splfileobject_setmaxlinelen(a0, a1), null);
}
Variant i_array_intersect_key(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_intersect_key);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect_key", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_intersect_key(count, arg0, arg1));
    return (f_array_intersect_key(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_array_intersect_key(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("array_intersect_key", count+1, 1);
  if (count <= 2) return (f_array_intersect_key(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_intersect_key(count,a0, a1, params));
}
Variant i_array_change_key_case(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_change_key_case);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_change_key_case", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_change_key_case(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_change_key_case(arg0, arg1));
  }
}
Variant ifa_array_change_key_case(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("array_change_key_case", count, 1, 2, 1);
  if (count <= 1) return (f_array_change_key_case(a0));
  return (f_array_change_key_case(a0, a1));
}
Variant i_ldap_first_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_first_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_first_attribute(arg0, arg1));
  }
}
Variant ifa_ldap_first_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_first_attribute", count, 2, 2, 1);
  return (f_ldap_first_attribute(a0, a1));
}
Variant i_gettimeofday(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gettimeofday);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("gettimeofday", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_gettimeofday());
    CVarRef arg0((ad->getValue(pos)));
    return (f_gettimeofday(arg0));
  }
}
Variant ifa_gettimeofday(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("gettimeofday", 1, 1);
  if (count <= 0) return (f_gettimeofday());
  return (f_gettimeofday(a0));
}
Variant i_xmlwriter_end_element(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_element", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_element(arg0));
  }
}
Variant ifa_xmlwriter_end_element(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_element", count, 1, 1, 1);
  return (f_xmlwriter_end_element(a0));
}
Variant i_drawpoint(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpoint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpoint", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpoint(arg0, arg1, arg2), null);
  }
}
Variant ifa_drawpoint(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("drawpoint", count, 3, 3, 1);
  return (f_drawpoint(a0, a1, a2), null);
}
Variant i_strnatcmp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strnatcmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strnatcmp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strnatcmp(arg0, arg1));
  }
}
Variant ifa_strnatcmp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("strnatcmp", count, 2, 2, 1);
  return (f_strnatcmp(a0, a1));
}
Variant i_property_exists(void *extra, CArrRef params) {
  FUNCTION_INJECTION(property_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("property_exists", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_property_exists(arg0, arg1));
  }
}
Variant ifa_property_exists(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("property_exists", count, 2, 2, 1);
  return (f_property_exists(a0, a1));
}
Variant i_mysql_affected_rows(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_affected_rows);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_affected_rows", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_affected_rows());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_affected_rows(arg0));
  }
}
Variant ifa_mysql_affected_rows(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_affected_rows", 1, 1);
  if (count <= 0) return (f_mysql_affected_rows());
  return (f_mysql_affected_rows(a0));
}
Variant i_magickdespeckleimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickdespeckleimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdespeckleimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickdespeckleimage(arg0));
  }
}
Variant ifa_magickdespeckleimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickdespeckleimage", count, 1, 1, 1);
  return (f_magickdespeckleimage(a0));
}
Variant i_imagecopymergegray(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecopymergegray);
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagecopymergegray", count, 9, 9, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecopymergegray(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
  }
}
Variant ifa_imagecopymergegray(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 9) return throw_wrong_arguments("imagecopymergegray", count, 9, 9, 1);
  return (f_imagecopymergegray(a0, a1, a2, a3, a4, a5, null, null, null));
}
Variant i_ctype_cntrl(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ctype_cntrl);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_cntrl", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_cntrl(arg0));
  }
}
Variant ifa_ctype_cntrl(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ctype_cntrl", count, 1, 1, 1);
  return (f_ctype_cntrl(a0));
}
Variant i_hphp_splfileobject_next(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_next);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_next", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_next(arg0), null);
  }
}
Variant ifa_hphp_splfileobject_next(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_next", count, 1, 1, 1);
  return (f_hphp_splfileobject_next(a0), null);
}
Variant i_is_array(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_array);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_array", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_array(arg0));
  }
}
Variant ifa_is_array(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_array", count, 1, 1, 1);
  return (f_is_array(a0));
}
Variant i_rename(void *extra, CArrRef params) {
  FUNCTION_INJECTION(rename);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("rename", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_rename(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rename(arg0, arg1, arg2));
  }
}
Variant ifa_rename(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("rename", count, 2, 3, 1);
  if (count <= 2) return (f_rename(a0, a1));
  return (f_rename(a0, a1, a2));
}
Variant i_date_format(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_format);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_format", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_format(arg0, arg1));
  }
}
Variant ifa_date_format(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("date_format", count, 2, 2, 1);
  return (f_date_format(a0, a1));
}
Variant i_hphp_splfileobject_fgetc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fgetc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fgetc", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_fgetc(arg0));
  }
}
Variant ifa_hphp_splfileobject_fgetc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fgetc", count, 1, 1, 1);
  return (f_hphp_splfileobject_fgetc(a0));
}
Variant i_magickshaveimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickshaveimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickshaveimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickshaveimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickshaveimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magickshaveimage", count, 3, 3, 1);
  return (f_magickshaveimage(a0, a1, a2));
}
Variant i_dom_element_set_attribute_node_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_attribute_node_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_set_attribute_node_ns", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_attribute_node_ns(arg0, arg1));
  }
}
Variant ifa_dom_element_set_attribute_node_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_element_set_attribute_node_ns", count, 2, 2, 1);
  return (f_dom_element_set_attribute_node_ns(a0, a1));
}
Variant i_xmlwriter_output_memory(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_output_memory);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xmlwriter_output_memory", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_xmlwriter_output_memory(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_output_memory(arg0, arg1));
  }
}
Variant ifa_xmlwriter_output_memory(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("xmlwriter_output_memory", count, 1, 2, 1);
  if (count <= 1) return (f_xmlwriter_output_memory(a0));
  return (f_xmlwriter_output_memory(a0, a1));
}
Variant i_ob_end_flush(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_end_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_end_flush", 0, 1);
  return (f_ob_end_flush());
}
Variant ifa_ob_end_flush(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("ob_end_flush", 0, 1);
  return (f_ob_end_flush());
}
Variant i_magickwhitethresholdimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickwhitethresholdimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwhitethresholdimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwhitethresholdimage(arg0, arg1));
  }
}
Variant ifa_magickwhitethresholdimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickwhitethresholdimage", count, 2, 2, 1);
  return (f_magickwhitethresholdimage(a0, a1));
}
Variant i_drawpolyline(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpolyline);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpolyline", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpolyline(arg0, arg1), null);
  }
}
Variant ifa_drawpolyline(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawpolyline", count, 2, 2, 1);
  return (f_drawpolyline(a0, a1), null);
}
Variant i_hphp_splfileobject_fgets(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fgets);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fgets", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_fgets(arg0));
  }
}
Variant ifa_hphp_splfileobject_fgets(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fgets", count, 1, 1, 1);
  return (f_hphp_splfileobject_fgets(a0));
}
Variant i_hphp_get_function_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_get_function_info);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_function_info", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_get_function_info(arg0));
  }
}
Variant ifa_hphp_get_function_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_get_function_info", count, 1, 1, 1);
  return (f_hphp_get_function_info(a0));
}
Variant i_prev(void *extra, CArrRef params) {
  FUNCTION_INJECTION(prev);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("prev", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_prev(arg0));
  }
}
Variant ifa_prev(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("prev", count, 1, 1, 1);
  return (f_prev(ref(a0)));
}
Variant i_imagegammacorrect(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagegammacorrect);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagegammacorrect", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagegammacorrect(arg0, arg1, arg2));
  }
}
Variant ifa_imagegammacorrect(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("imagegammacorrect", count, 3, 3, 1);
  return (f_imagegammacorrect(a0, a1, a2));
}
Variant i_str_replace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(str_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("str_replace", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_str_replace(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_str_replace(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_str_replace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("str_replace", count, 3, 4, 1);
  if (count <= 3) return (f_str_replace(a0, a1, a2));
  return (f_str_replace(a0, a1, a2, ref(a3)));
}
Variant i_dom_node_lookup_namespace_uri(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_lookup_namespace_uri);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_lookup_namespace_uri", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_lookup_namespace_uri(arg0, arg1));
  }
}
Variant ifa_dom_node_lookup_namespace_uri(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_node_lookup_namespace_uri", count, 2, 2, 1);
  return (f_dom_node_lookup_namespace_uri(a0, a1));
}
Variant i_fb_unserialize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_unserialize);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_unserialize", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fb_unserialize(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_fb_unserialize(arg0, arg1, arg2));
  }
}
Variant ifa_fb_unserialize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_unserialize", count, 2, 3, 1);
  if (count <= 2) return (f_fb_unserialize(a0, ref(a1)));
  return (f_fb_unserialize(a0, ref(a1), ref(a2)));
}
Variant i_clock_getres(void *extra, CArrRef params) {
  FUNCTION_INJECTION(clock_getres);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_getres", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_clock_getres(arg0, arg1, arg2));
  }
}
Variant ifa_clock_getres(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("clock_getres", count, 3, 3, 1);
  return (f_clock_getres(a0, ref(a1), ref(a2)));
}
Variant i_magicktrimimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicktrimimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicktrimimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicktrimimage(arg0, arg1));
  }
}
Variant ifa_magicktrimimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicktrimimage", count, 2, 2, 1);
  return (f_magicktrimimage(a0, a1));
}
Variant i_hphp_splfileinfo_getpathinfo(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getpathinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getpathinfo", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_getpathinfo(arg0, arg1));
  }
}
Variant ifa_hphp_splfileinfo_getpathinfo(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getpathinfo", count, 2, 2, 1);
  return (f_hphp_splfileinfo_getpathinfo(a0, a1));
}
Variant i_magickgetimagegamma(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagegamma);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagegamma", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagegamma(arg0));
  }
}
Variant ifa_magickgetimagegamma(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagegamma", count, 1, 1, 1);
  return (f_magickgetimagegamma(a0));
}
Variant i_newdrawingwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(newdrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("newdrawingwand", 0, 1);
  return (f_newdrawingwand());
}
Variant ifa_newdrawingwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("newdrawingwand", 0, 1);
  return (f_newdrawingwand());
}
Variant i_gzrewind(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzrewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzrewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzrewind(arg0));
  }
}
Variant ifa_gzrewind(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("gzrewind", count, 1, 1, 1);
  return (f_gzrewind(a0));
}
Variant i_ldap_explode_dn(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_explode_dn);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_explode_dn", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_explode_dn(arg0, arg1));
  }
}
Variant ifa_ldap_explode_dn(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_explode_dn", count, 2, 2, 1);
  return (f_ldap_explode_dn(a0, a1));
}
Variant i_posix_times(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_times);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_times", 0, 1);
  return (f_posix_times());
}
Variant ifa_posix_times(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_times", 0, 1);
  return (f_posix_times());
}
Variant i_drawgetfillcolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetfillcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillcolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfillcolor(arg0));
  }
}
Variant ifa_drawgetfillcolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetfillcolor", count, 1, 1, 1);
  return (f_drawgetfillcolor(a0));
}
Variant i_dom_document_save_html(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_save_html);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_save_html", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_document_save_html(arg0));
  }
}
Variant ifa_dom_document_save_html(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dom_document_save_html", count, 1, 1, 1);
  return (f_dom_document_save_html(a0));
}
Variant i_mb_strtolower(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strtolower);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strtolower", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_strtolower(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strtolower(arg0, arg1));
  }
}
Variant ifa_mb_strtolower(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strtolower", count, 1, 2, 1);
  if (count <= 1) return (f_mb_strtolower(a0));
  return (f_mb_strtolower(a0, a1));
}
Variant i_localtime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(localtime);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("localtime", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_localtime());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_localtime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_localtime(arg0, arg1));
  }
}
Variant ifa_localtime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("localtime", 2, 1);
  if (count <= 0) return (f_localtime());
  if (count == 1) return (f_localtime(a0));
  return (f_localtime(a0, a1));
}
Variant i_fb_thrift_unserialize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_thrift_unserialize);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_thrift_unserialize", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fb_thrift_unserialize(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_fb_thrift_unserialize(arg0, arg1, arg2));
  }
}
Variant ifa_fb_thrift_unserialize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_thrift_unserialize", count, 2, 3, 1);
  if (count <= 2) return (f_fb_thrift_unserialize(a0, ref(a1)));
  return (f_fb_thrift_unserialize(a0, ref(a1), ref(a2)));
}
Variant i_sha1(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sha1);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sha1", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_sha1(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_sha1(arg0, arg1));
  }
}
Variant ifa_sha1(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("sha1", count, 1, 2, 1);
  if (count <= 1) return (f_sha1(a0));
  return (f_sha1(a0, a1));
}
Variant i_collator_set_strength(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_set_strength);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_set_strength", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_set_strength(arg0, arg1));
  }
}
Variant ifa_collator_set_strength(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("collator_set_strength", count, 2, 2, 1);
  return (f_collator_set_strength(a0, a1));
}
Variant i_implode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(implode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("implode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_implode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_implode(arg0, arg1));
  }
}
Variant ifa_implode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("implode", count, 1, 2, 1);
  if (count <= 1) return (f_implode(a0));
  return (f_implode(a0, a1));
}
Variant i_date_isodate_set(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_isodate_set);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("date_isodate_set", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_date_isodate_set(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_isodate_set(arg0, arg1, arg2, arg3), null);
  }
}
Variant ifa_date_isodate_set(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("date_isodate_set", count, 3, 4, 1);
  if (count <= 3) return (f_date_isodate_set(a0, a1, a2), null);
  return (f_date_isodate_set(a0, a1, a2, a3), null);
}
Variant i_magickpaintopaqueimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickpaintopaqueimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickpaintopaqueimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickpaintopaqueimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickpaintopaqueimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickpaintopaqueimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickpaintopaqueimage", count, 3, 4, 1);
  if (count <= 3) return (f_magickpaintopaqueimage(a0, a1, a2));
  return (f_magickpaintopaqueimage(a0, a1, a2, a3));
}
Variant i_mb_strimwidth(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_strimwidth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mb_strimwidth", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mb_strimwidth(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mb_strimwidth(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strimwidth(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_mb_strimwidth(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 5) return throw_wrong_arguments("mb_strimwidth", count, 3, 5, 1);
  if (count <= 3) return (f_mb_strimwidth(a0, a1, a2));
  if (count == 4) return (f_mb_strimwidth(a0, a1, a2, a3));
  return (f_mb_strimwidth(a0, a1, a2, a3, a4));
}
Variant i_drawsetfont(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfont", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfont(arg0, arg1));
  }
}
Variant ifa_drawsetfont(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetfont", count, 2, 2, 1);
  return (f_drawsetfont(a0, a1));
}
Variant i_xml_set_default_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_set_default_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_default_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_default_handler(arg0, arg1));
  }
}
Variant ifa_xml_set_default_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xml_set_default_handler", count, 2, 2, 1);
  return (f_xml_set_default_handler(a0, a1));
}
Variant i_magickchopimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickchopimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickchopimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickchopimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_magickchopimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("magickchopimage", count, 5, 5, 1);
  return (f_magickchopimage(a0, a1, a2, a3, a4));
}
Variant i_wordwrap(void *extra, CArrRef params) {
  FUNCTION_INJECTION(wordwrap);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("wordwrap", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_wordwrap(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_wordwrap(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_wordwrap(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_wordwrap(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_wordwrap(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("wordwrap", count, 1, 4, 1);
  if (count <= 1) return (f_wordwrap(a0));
  if (count == 2) return (f_wordwrap(a0, a1));
  if (count == 3) return (f_wordwrap(a0, a1, a2));
  return (f_wordwrap(a0, a1, a2, a3));
}
Variant i_gzgetss(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzgetss);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("gzgetss", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzgetss(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_gzgetss(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzgetss(arg0, arg1, arg2));
  }
}
Variant ifa_gzgetss(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("gzgetss", count, 1, 3, 1);
  if (count <= 1) return (f_gzgetss(a0));
  if (count == 2) return (f_gzgetss(a0, a1));
  return (f_gzgetss(a0, a1, a2));
}
Variant i_magickgetimagevirtualpixelmethod(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagevirtualpixelmethod);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagevirtualpixelmethod", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagevirtualpixelmethod(arg0));
  }
}
Variant ifa_magickgetimagevirtualpixelmethod(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagevirtualpixelmethod", count, 1, 1, 1);
  return (f_magickgetimagevirtualpixelmethod(a0));
}
Variant i_imagedestroy(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagedestroy);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagedestroy", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagedestroy(arg0));
  }
}
Variant ifa_imagedestroy(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagedestroy", count, 1, 1, 1);
  return (f_imagedestroy(a0));
}
Variant i_timezone_open(void *extra, CArrRef params) {
  FUNCTION_INJECTION(timezone_open);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_open", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_timezone_open(arg0));
  }
}
Variant ifa_timezone_open(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("timezone_open", count, 1, 1, 1);
  return (f_timezone_open(a0));
}
Variant i_ob_clean(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_clean);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_clean", 0, 1);
  return (f_ob_clean(), null);
}
Variant ifa_ob_clean(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("ob_clean", 0, 1);
  return (f_ob_clean(), null);
}
Variant i_mb_ereg_search_pos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_pos);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search_pos", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_ereg_search_pos());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mb_ereg_search_pos(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_search_pos(arg0, arg1));
  }
}
Variant ifa_mb_ereg_search_pos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("mb_ereg_search_pos", 2, 1);
  if (count <= 0) return (f_mb_ereg_search_pos());
  if (count == 1) return (f_mb_ereg_search_pos(a0));
  return (f_mb_ereg_search_pos(a0, a1));
}
Variant i_bccomp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bccomp);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bccomp", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bccomp(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bccomp(arg0, arg1, arg2));
  }
}
Variant ifa_bccomp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("bccomp", count, 2, 3, 1);
  if (count <= 2) return (f_bccomp(a0, a1));
  return (f_bccomp(a0, a1, a2));
}
Variant i_gzdecode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzdecode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzdecode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzdecode(arg0));
  }
}
Variant ifa_gzdecode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("gzdecode", count, 1, 1, 1);
  return (f_gzdecode(a0));
}
Variant i_magicksetimagecompose(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagecompose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompose", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagecompose(arg0, arg1));
  }
}
Variant ifa_magicksetimagecompose(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagecompose", count, 2, 2, 1);
  return (f_magicksetimagecompose(a0, a1));
}
Variant i_apc_bin_dump(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_bin_dump);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apc_bin_dump", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_apc_bin_dump());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_apc_bin_dump(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_bin_dump(arg0, arg1));
  }
}
Variant ifa_apc_bin_dump(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("apc_bin_dump", 2, 1);
  if (count <= 0) return (f_apc_bin_dump());
  if (count == 1) return (f_apc_bin_dump(a0));
  return (f_apc_bin_dump(a0, a1));
}
Variant i_ini_get(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ini_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ini_get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ini_get(arg0));
  }
}
Variant ifa_ini_get(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ini_get", count, 1, 1, 1);
  return (f_ini_get(a0));
}
Variant i_mb_ereg_search_setpos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_setpos);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_ereg_search_setpos", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_ereg_search_setpos(arg0));
  }
}
Variant ifa_mb_ereg_search_setpos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mb_ereg_search_setpos", count, 1, 1, 1);
  return (f_mb_ereg_search_setpos(a0));
}
Variant i_stream_copy_to_stream(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_copy_to_stream);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_copy_to_stream", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_copy_to_stream(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_copy_to_stream(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_copy_to_stream(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_stream_copy_to_stream(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_copy_to_stream", count, 2, 4, 1);
  if (count <= 2) return (f_stream_copy_to_stream(a0, a1));
  if (count == 3) return (f_stream_copy_to_stream(a0, a1, a2));
  return (f_stream_copy_to_stream(a0, a1, a2, a3));
}
Variant i_xml_get_error_code(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_get_error_code);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_error_code", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_get_error_code(arg0));
  }
}
Variant ifa_xml_get_error_code(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xml_get_error_code", count, 1, 1, 1);
  return (f_xml_get_error_code(a0));
}
Variant i_pcntl_alarm(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_alarm);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_alarm", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_alarm(arg0));
  }
}
Variant ifa_pcntl_alarm(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pcntl_alarm", count, 1, 1, 1);
  return (f_pcntl_alarm(a0));
}
Variant i_drawpolygon(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpolygon);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpolygon", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpolygon(arg0, arg1), null);
  }
}
Variant ifa_drawpolygon(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawpolygon", count, 2, 2, 1);
  return (f_drawpolygon(a0, a1), null);
}
Variant i_mysql_connect(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_connect);
  int count __attribute__((__unused__)) = params.size();
  if (count > 7) return throw_toomany_arguments("mysql_connect", 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_connect());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mysql_connect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mysql_connect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mysql_connect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mysql_connect(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_mysql_connect(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_mysql_connect(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_connect(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant ifa_mysql_connect(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 7) return throw_toomany_arguments("mysql_connect", 7, 1);
  if (count <= 0) return (f_mysql_connect());
  if (count == 1) return (f_mysql_connect(a0));
  if (count == 2) return (f_mysql_connect(a0, a1));
  if (count == 3) return (f_mysql_connect(a0, a1, a2));
  if (count == 4) return (f_mysql_connect(a0, a1, a2, a3));
  if (count == 5) return (f_mysql_connect(a0, a1, a2, a3, a4));
  return (f_mysql_connect(a0, a1, a2, a3, a4, a5));
}
Variant i_xmlwriter_write_raw(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_raw);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_raw", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_raw(arg0, arg1));
  }
}
Variant ifa_xmlwriter_write_raw(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_raw", count, 2, 2, 1);
  return (f_xmlwriter_write_raw(a0, a1));
}
Variant i_fgetss(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fgetss);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("fgetss", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fgetss(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_fgetss(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fgetss(arg0, arg1, arg2));
  }
}
Variant ifa_fgetss(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("fgetss", count, 1, 3, 1);
  if (count <= 1) return (f_fgetss(a0));
  if (count == 2) return (f_fgetss(a0, a1));
  return (f_fgetss(a0, a1, a2));
}
Variant i_drawarc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawarc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawarc", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawarc(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant ifa_drawarc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 7) return throw_wrong_arguments("drawarc", count, 7, 7, 1);
  return (f_drawarc(a0, a1, a2, a3, a4, a5, null), null);
}
Variant i_set_error_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(set_error_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("set_error_handler", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_set_error_handler(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_set_error_handler(arg0, arg1));
  }
}
Variant ifa_set_error_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("set_error_handler", count, 1, 2, 1);
  if (count <= 1) return (f_set_error_handler(a0));
  return (f_set_error_handler(a0, a1));
}
Variant i_str_word_count(void *extra, CArrRef params) {
  FUNCTION_INJECTION(str_word_count);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("str_word_count", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_str_word_count(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_str_word_count(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_str_word_count(arg0, arg1, arg2));
  }
}
Variant ifa_str_word_count(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("str_word_count", count, 1, 3, 1);
  if (count <= 1) return (f_str_word_count(a0));
  if (count == 2) return (f_str_word_count(a0, a1));
  return (f_str_word_count(a0, a1, a2));
}
Variant i_drawsetcliprule(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetcliprule);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetcliprule", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetcliprule(arg0, arg1), null);
  }
}
Variant ifa_drawsetcliprule(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetcliprule", count, 2, 2, 1);
  return (f_drawsetcliprule(a0, a1), null);
}
Variant i_openssl_pkcs12_read(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs12_read);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("openssl_pkcs12_read", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs12_read(arg0, arg1, arg2));
  }
}
Variant ifa_openssl_pkcs12_read(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("openssl_pkcs12_read", count, 3, 3, 1);
  return (f_openssl_pkcs12_read(a0, ref(a1), a2));
}
Variant i_ldap_list(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_list);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_list", count, 3, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_ldap_list(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_ldap_list(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_ldap_list(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_ldap_list(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_ldap_list(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_list(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant ifa_ldap_list(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_list", count, 3, 8, 1);
  if (count <= 3) return (f_ldap_list(a0, a1, a2));
  if (count == 4) return (f_ldap_list(a0, a1, a2, a3));
  if (count == 5) return (f_ldap_list(a0, a1, a2, a3, a4));
  return (f_ldap_list(a0, a1, a2, a3, a4, a5));
}
Variant i_func_num_args(void *extra, CArrRef params) {
  FUNCTION_INJECTION(func_num_args);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("func_num_args", 0, 1);
  return (f_func_num_args());
}
Variant ifa_func_num_args(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("func_num_args", 0, 1);
  return (f_func_num_args());
}
Variant i_drawsettextdecoration(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsettextdecoration);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextdecoration", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsettextdecoration(arg0, arg1), null);
  }
}
Variant ifa_drawsettextdecoration(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsettextdecoration", count, 2, 2, 1);
  return (f_drawsettextdecoration(a0, a1), null);
}
Variant i_str_rot13(void *extra, CArrRef params) {
  FUNCTION_INJECTION(str_rot13);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("str_rot13", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_str_rot13(arg0));
  }
}
Variant ifa_str_rot13(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("str_rot13", count, 1, 1, 1);
  return (f_str_rot13(a0));
}
Variant i_openssl_pkey_new(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_new);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("openssl_pkey_new", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_openssl_pkey_new());
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_pkey_new(arg0));
  }
}
Variant ifa_openssl_pkey_new(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("openssl_pkey_new", 1, 1);
  if (count <= 0) return (f_openssl_pkey_new());
  return (f_openssl_pkey_new(a0));
}
Variant i_magicksetimageindex(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimageindex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageindex", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageindex(arg0, arg1));
  }
}
Variant ifa_magicksetimageindex(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimageindex", count, 2, 2, 1);
  return (f_magicksetimageindex(a0, a1));
}
Variant i_ldap_rename(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_rename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("ldap_rename", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_rename(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_ldap_rename(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("ldap_rename", count, 5, 5, 1);
  return (f_ldap_rename(a0, a1, a2, a3, a4));
}
Variant i_ldap_start_tls(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_start_tls);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_start_tls", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_start_tls(arg0));
  }
}
Variant ifa_ldap_start_tls(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ldap_start_tls", count, 1, 1, 1);
  return (f_ldap_start_tls(a0));
}
Variant i_tanh(void *extra, CArrRef params) {
  FUNCTION_INJECTION(tanh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("tanh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_tanh(arg0));
  }
}
Variant ifa_tanh(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("tanh", count, 1, 1, 1);
  return (f_tanh(a0));
}
Variant i_drawscale(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawscale);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawscale", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawscale(arg0, arg1, arg2), null);
  }
}
Variant ifa_drawscale(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("drawscale", count, 3, 3, 1);
  return (f_drawscale(a0, a1, a2), null);
}
Variant i_drawrotate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawrotate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawrotate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawrotate(arg0, arg1), null);
  }
}
Variant ifa_drawrotate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawrotate", count, 2, 2, 1);
  return (f_drawrotate(a0, a1), null);
}
Variant i_getservbyname(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getservbyname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("getservbyname", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_getservbyname(arg0, arg1));
  }
}
Variant ifa_getservbyname(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("getservbyname", count, 2, 2, 1);
  return (f_getservbyname(a0, a1));
}
Variant i_compact(void *extra, CArrRef params) {
  FUNCTION_INJECTION(compact);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("compact", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_compact(count, arg0));
    return (f_compact(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_compact(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("compact", count+1, 1);
  if (count <= 1) return (f_compact(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_compact(count,a0, params));
}
Variant i_hphp_splfileobject_valid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_valid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_valid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_valid(arg0));
  }
}
Variant ifa_hphp_splfileobject_valid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_valid", count, 1, 1, 1);
  return (f_hphp_splfileobject_valid(a0));
}
Variant i_imagecolorclosest(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorclosest);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorclosest", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorclosest(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagecolorclosest(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("imagecolorclosest", count, 4, 4, 1);
  return (f_imagecolorclosest(a0, a1, a2, a3));
}
Variant i_magickwriteimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickwriteimages);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("magickwriteimages", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magickwriteimages(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_magickwriteimages(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwriteimages(arg0, arg1, arg2));
  }
}
Variant ifa_magickwriteimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("magickwriteimages", count, 1, 3, 1);
  if (count <= 1) return (f_magickwriteimages(a0));
  if (count == 2) return (f_magickwriteimages(a0, a1));
  return (f_magickwriteimages(a0, a1, a2));
}
Variant i_pixelsetalpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetalpha", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetalpha(arg0, arg1), null);
  }
}
Variant ifa_pixelsetalpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetalpha", count, 2, 2, 1);
  return (f_pixelsetalpha(a0, a1), null);
}
Variant i_magicksetimageiterations(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimageiterations);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageiterations", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageiterations(arg0, arg1));
  }
}
Variant ifa_magicksetimageiterations(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimageiterations", count, 2, 2, 1);
  return (f_magicksetimageiterations(a0, a1));
}
Variant i_drawpathmovetoabsolute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathmovetoabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathmovetoabsolute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathmovetoabsolute(arg0, arg1, arg2), null);
  }
}
Variant ifa_drawpathmovetoabsolute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("drawpathmovetoabsolute", count, 3, 3, 1);
  return (f_drawpathmovetoabsolute(a0, a1, a2), null);
}
Variant i_quotemeta(void *extra, CArrRef params) {
  FUNCTION_INJECTION(quotemeta);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quotemeta", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_quotemeta(arg0));
  }
}
Variant ifa_quotemeta(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("quotemeta", count, 1, 1, 1);
  return (f_quotemeta(a0));
}
Variant i_parse_ini_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(parse_ini_string);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("parse_ini_string", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_parse_ini_string(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_parse_ini_string(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_parse_ini_string(arg0, arg1, arg2));
  }
}
Variant ifa_parse_ini_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("parse_ini_string", count, 1, 3, 1);
  if (count <= 1) return (f_parse_ini_string(a0));
  if (count == 2) return (f_parse_ini_string(a0, a1));
  return (f_parse_ini_string(a0, a1, a2));
}
Variant i_imagefilltoborder(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagefilltoborder);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagefilltoborder", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilltoborder(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_imagefilltoborder(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("imagefilltoborder", count, 5, 5, 1);
  return (f_imagefilltoborder(a0, a1, a2, a3, a4));
}
Variant i_xml_set_notation_decl_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_set_notation_decl_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_notation_decl_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_notation_decl_handler(arg0, arg1));
  }
}
Variant ifa_xml_set_notation_decl_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xml_set_notation_decl_handler", count, 2, 2, 1);
  return (f_xml_set_notation_decl_handler(a0, a1));
}
Variant i_is_writeable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_writeable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_writeable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_writeable(arg0));
  }
}
Variant ifa_is_writeable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_writeable", count, 1, 1, 1);
  return (f_is_writeable(a0));
}
Variant i_magickgetwandsize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetwandsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetwandsize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetwandsize(arg0));
  }
}
Variant ifa_magickgetwandsize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetwandsize", count, 1, 1, 1);
  return (f_magickgetwandsize(a0));
}
Variant i_hphp_directoryiterator___tostring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator___tostring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator___tostring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator___tostring(arg0));
  }
}
Variant ifa_hphp_directoryiterator___tostring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator___tostring", count, 1, 1, 1);
  return (f_hphp_directoryiterator___tostring(a0));
}
Variant i_memcache_add_server(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_add_server);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 10) return throw_wrong_arguments("memcache_add_server", count, 2, 10, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_add_server(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_add_server(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_memcache_add_server(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 8) return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 9) return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
    CVarRef arg9((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9));
  }
}
Variant ifa_memcache_add_server(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 10) return throw_wrong_arguments("memcache_add_server", count, 2, 10, 1);
  if (count <= 2) return (f_memcache_add_server(a0, a1));
  if (count == 3) return (f_memcache_add_server(a0, a1, a2));
  if (count == 4) return (f_memcache_add_server(a0, a1, a2, a3));
  if (count == 5) return (f_memcache_add_server(a0, a1, a2, a3, a4));
  return (f_memcache_add_server(a0, a1, a2, a3, a4, a5));
}
Variant i_dom_node_remove_child(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_remove_child);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_remove_child", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_remove_child(arg0, arg1));
  }
}
Variant ifa_dom_node_remove_child(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_node_remove_child", count, 2, 2, 1);
  return (f_dom_node_remove_child(a0, a1));
}
Variant i_imageinterlace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imageinterlace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imageinterlace", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imageinterlace(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageinterlace(arg0, arg1));
  }
}
Variant ifa_imageinterlace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("imageinterlace", count, 1, 2, 1);
  if (count <= 1) return (f_imageinterlace(a0));
  return (f_imageinterlace(a0, a1));
}
Variant i_preg_match_all(void *extra, CArrRef params) {
  FUNCTION_INJECTION(preg_match_all);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_match_all", count, 3, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_preg_match_all(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_preg_match_all(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_preg_match_all(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_preg_match_all(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_match_all", count, 3, 5, 1);
  if (count <= 3) return (f_preg_match_all(a0, a1, ref(a2)));
  if (count == 4) return (f_preg_match_all(a0, a1, ref(a2), a3));
  return (f_preg_match_all(a0, a1, ref(a2), a3, a4));
}
Variant i_proc_terminate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(proc_terminate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("proc_terminate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_proc_terminate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_proc_terminate(arg0, arg1));
  }
}
Variant ifa_proc_terminate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("proc_terminate", count, 1, 2, 1);
  if (count <= 1) return (f_proc_terminate(a0));
  return (f_proc_terminate(a0, a1));
}
Variant i_apc_bin_loadfile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_bin_loadfile);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_bin_loadfile", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_bin_loadfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_bin_loadfile(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_bin_loadfile(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_bin_loadfile(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_apc_bin_loadfile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_bin_loadfile", count, 1, 4, 1);
  if (count <= 1) return (f_apc_bin_loadfile(a0));
  if (count == 2) return (f_apc_bin_loadfile(a0, a1));
  if (count == 3) return (f_apc_bin_loadfile(a0, a1, a2));
  return (f_apc_bin_loadfile(a0, a1, a2, a3));
}
Variant i_posix_getcwd(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getcwd);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getcwd", 0, 1);
  return (f_posix_getcwd());
}
Variant ifa_posix_getcwd(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_getcwd", 0, 1);
  return (f_posix_getcwd());
}
Variant i_drawpathcurvetoabsolute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetoabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawpathcurvetoabsolute", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetoabsolute(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant ifa_drawpathcurvetoabsolute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 7) return throw_wrong_arguments("drawpathcurvetoabsolute", count, 7, 7, 1);
  return (f_drawpathcurvetoabsolute(a0, a1, a2, a3, a4, a5, null), null);
}
Variant i_hphp_set_error_page(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_set_error_page);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_set_error_page", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_set_error_page(arg0), null);
  }
}
Variant ifa_hphp_set_error_page(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_set_error_page", count, 1, 1, 1);
  return (f_hphp_set_error_page(a0), null);
}
Variant i_preg_match(void *extra, CArrRef params) {
  FUNCTION_INJECTION(preg_match);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("preg_match", count, 2, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_preg_match(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_preg_match(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_preg_match(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_preg_match(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_preg_match(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 5) return throw_wrong_arguments("preg_match", count, 2, 5, 1);
  if (count <= 2) return (f_preg_match(a0, a1));
  if (count == 3) return (f_preg_match(a0, a1, ref(a2)));
  if (count == 4) return (f_preg_match(a0, a1, ref(a2), a3));
  return (f_preg_match(a0, a1, ref(a2), a3, a4));
}
Variant i_timezone_abbreviations_list(void *extra, CArrRef params) {
  FUNCTION_INJECTION(timezone_abbreviations_list);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("timezone_abbreviations_list", 0, 1);
  return (f_timezone_abbreviations_list());
}
Variant ifa_timezone_abbreviations_list(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("timezone_abbreviations_list", 0, 1);
  return (f_timezone_abbreviations_list());
}
Variant i_magickradialblurimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickradialblurimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickradialblurimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickradialblurimage(arg0, arg1));
  }
}
Variant ifa_magickradialblurimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickradialblurimage", count, 2, 2, 1);
  return (f_magickradialblurimage(a0, a1));
}
Variant i_posix_geteuid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_geteuid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_geteuid", 0, 1);
  return (f_posix_geteuid());
}
Variant ifa_posix_geteuid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_geteuid", 0, 1);
  return (f_posix_geteuid());
}
Variant i_mysql_fetch_lengths(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_lengths);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_lengths", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_fetch_lengths(arg0));
  }
}
Variant ifa_mysql_fetch_lengths(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mysql_fetch_lengths", count, 1, 1, 1);
  return (f_mysql_fetch_lengths(a0));
}
Variant i_magickwriteimagefile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickwriteimagefile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimagefile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwriteimagefile(arg0, arg1));
  }
}
Variant ifa_magickwriteimagefile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickwriteimagefile", count, 2, 2, 1);
  return (f_magickwriteimagefile(a0, a1));
}
Variant i_serialize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(serialize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("serialize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_serialize(arg0));
  }
}
Variant ifa_serialize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("serialize", count, 1, 1, 1);
  return (f_serialize(a0));
}
Variant i_exif_read_data(void *extra, CArrRef params) {
  FUNCTION_INJECTION(exif_read_data);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("exif_read_data", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_exif_read_data(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_exif_read_data(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_exif_read_data(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_exif_read_data(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_exif_read_data(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("exif_read_data", count, 1, 4, 1);
  if (count <= 1) return (f_exif_read_data(a0));
  if (count == 2) return (f_exif_read_data(a0, a1));
  if (count == 3) return (f_exif_read_data(a0, a1, a2));
  return (f_exif_read_data(a0, a1, a2, a3));
}
Variant i_pixelgetiteratorexceptiontype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetiteratorexceptiontype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexceptiontype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetiteratorexceptiontype(arg0));
  }
}
Variant ifa_pixelgetiteratorexceptiontype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexceptiontype", count, 1, 1, 1);
  return (f_pixelgetiteratorexceptiontype(a0));
}
Variant i_destroydrawingwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(destroydrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroydrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroydrawingwand(arg0), null);
  }
}
Variant ifa_destroydrawingwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("destroydrawingwand", count, 1, 1, 1);
  return (f_destroydrawingwand(a0), null);
}
Variant i_lstat(void *extra, CArrRef params) {
  FUNCTION_INJECTION(lstat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("lstat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_lstat(arg0));
  }
}
Variant ifa_lstat(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("lstat", count, 1, 1, 1);
  return (f_lstat(a0));
}
Variant i_apache_note(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apache_note);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apache_note", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apache_note(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apache_note(arg0, arg1));
  }
}
Variant ifa_apache_note(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("apache_note", count, 1, 2, 1);
  if (count <= 1) return (f_apache_note(a0));
  return (f_apache_note(a0, a1));
}
Variant i_drawgetexceptiontype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetexceptiontype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexceptiontype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetexceptiontype(arg0));
  }
}
Variant ifa_drawgetexceptiontype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetexceptiontype", count, 1, 1, 1);
  return (f_drawgetexceptiontype(a0));
}
Variant i_drawbezier(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawbezier);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawbezier", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawbezier(arg0, arg1), null);
  }
}
Variant ifa_drawbezier(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawbezier", count, 2, 2, 1);
  return (f_drawbezier(a0, a1), null);
}
Variant i_xmlwriter_start_comment(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_comment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_start_comment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_start_comment(arg0));
  }
}
Variant ifa_xmlwriter_start_comment(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_start_comment", count, 1, 1, 1);
  return (f_xmlwriter_start_comment(a0));
}
Variant i_ldap_set_rebind_proc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_set_rebind_proc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_set_rebind_proc", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_set_rebind_proc(arg0, arg1));
  }
}
Variant ifa_ldap_set_rebind_proc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_set_rebind_proc", count, 2, 2, 1);
  return (f_ldap_set_rebind_proc(a0, a1));
}
Variant i_drawsetstrokecolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokecolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokecolor(arg0, arg1), null);
  }
}
Variant ifa_drawsetstrokecolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetstrokecolor", count, 2, 2, 1);
  return (f_drawsetstrokecolor(a0, a1), null);
}
Variant i_drawpathlinetohorizontalrelative(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetohorizontalrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetohorizontalrelative", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetohorizontalrelative(arg0, arg1), null);
  }
}
Variant ifa_drawpathlinetohorizontalrelative(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawpathlinetohorizontalrelative", count, 2, 2, 1);
  return (f_drawpathlinetohorizontalrelative(a0, a1), null);
}
Variant i_gmmktime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gmmktime);
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("gmmktime", 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_gmmktime());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_gmmktime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_gmmktime(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_gmmktime(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_gmmktime(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_gmmktime(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gmmktime(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_gmmktime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 6) return throw_toomany_arguments("gmmktime", 6, 1);
  if (count <= 0) return (f_gmmktime());
  if (count == 1) return (f_gmmktime(a0));
  if (count == 2) return (f_gmmktime(a0, a1));
  if (count == 3) return (f_gmmktime(a0, a1, a2));
  if (count == 4) return (f_gmmktime(a0, a1, a2, a3));
  if (count == 5) return (f_gmmktime(a0, a1, a2, a3, a4));
  return (f_gmmktime(a0, a1, a2, a3, a4, a5));
}
Variant i_gmdate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gmdate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gmdate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gmdate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gmdate(arg0, arg1));
  }
}
Variant ifa_gmdate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("gmdate", count, 1, 2, 1);
  if (count <= 1) return (f_gmdate(a0));
  return (f_gmdate(a0, a1));
}
Variant i_posix_getgid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getgid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getgid", 0, 1);
  return (f_posix_getgid());
}
Variant ifa_posix_getgid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_getgid", 0, 1);
  return (f_posix_getgid());
}
Variant i_sinh(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sinh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sinh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sinh(arg0));
  }
}
Variant ifa_sinh(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("sinh", count, 1, 1, 1);
  return (f_sinh(a0));
}
Variant i_apc_fetch(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_fetch);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_fetch", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_fetch(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_fetch(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_fetch(arg0, arg1, arg2));
  }
}
Variant ifa_apc_fetch(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_fetch", count, 1, 3, 1);
  if (count <= 1) return (f_apc_fetch(a0));
  if (count == 2) return (f_apc_fetch(a0, ref(a1)));
  return (f_apc_fetch(a0, ref(a1), a2));
}
Variant i_fileowner(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fileowner);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileowner", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fileowner(arg0));
  }
}
Variant ifa_fileowner(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fileowner", count, 1, 1, 1);
  return (f_fileowner(a0));
}
Variant i_imagecopymerge(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecopymerge);
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagecopymerge", count, 9, 9, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecopymerge(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
  }
}
Variant ifa_imagecopymerge(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 9) return throw_wrong_arguments("imagecopymerge", count, 9, 9, 1);
  return (f_imagecopymerge(a0, a1, a2, a3, a4, a5, null, null, null));
}
Variant i_magickclipimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickclipimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickclipimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickclipimage(arg0));
  }
}
Variant ifa_magickclipimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickclipimage", count, 1, 1, 1);
  return (f_magickclipimage(a0));
}
Variant i_intl_get_error_code(void *extra, CArrRef params) {
  FUNCTION_INJECTION(intl_get_error_code);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("intl_get_error_code", 0, 1);
  return (f_intl_get_error_code());
}
Variant ifa_intl_get_error_code(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("intl_get_error_code", 0, 1);
  return (f_intl_get_error_code());
}
Variant i_imagestringup(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagestringup);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagestringup", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagestringup(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imagestringup(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("imagestringup", count, 6, 6, 1);
  return (f_imagestringup(a0, a1, a2, a3, a4, a5));
}
Variant i_mt_getrandmax(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mt_getrandmax);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mt_getrandmax", 0, 1);
  return (f_mt_getrandmax());
}
Variant ifa_mt_getrandmax(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("mt_getrandmax", 0, 1);
  return (f_mt_getrandmax());
}
Variant i_magickgetresourcelimit(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetresourcelimit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetresourcelimit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetresourcelimit(arg0));
  }
}
Variant ifa_magickgetresourcelimit(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetresourcelimit", count, 1, 1, 1);
  return (f_magickgetresourcelimit(a0));
}
Variant i_hphp_splfileinfo_getlinktarget(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getlinktarget);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getlinktarget", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getlinktarget(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getlinktarget(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getlinktarget", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getlinktarget(a0));
}
Variant i_imagecolorexact(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorexact);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorexact", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorexact(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagecolorexact(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("imagecolorexact", count, 4, 4, 1);
  return (f_imagecolorexact(a0, a1, a2, a3));
}
Variant i_hphp_recursivedirectoryiterator_current(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_current);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_current", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_current(arg0));
  }
}
Variant ifa_hphp_recursivedirectoryiterator_current(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_current", count, 1, 1, 1);
  return (f_hphp_recursivedirectoryiterator_current(a0));
}
Variant i_setcookie(void *extra, CArrRef params) {
  FUNCTION_INJECTION(setcookie);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("setcookie", count, 1, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_setcookie(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_setcookie(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_setcookie(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_setcookie(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_setcookie(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_setcookie(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_setcookie(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant ifa_setcookie(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 7) return throw_wrong_arguments("setcookie", count, 1, 7, 1);
  if (count <= 1) return (f_setcookie(a0));
  if (count == 2) return (f_setcookie(a0, a1));
  if (count == 3) return (f_setcookie(a0, a1, a2));
  if (count == 4) return (f_setcookie(a0, a1, a2, a3));
  if (count == 5) return (f_setcookie(a0, a1, a2, a3, a4));
  return (f_setcookie(a0, a1, a2, a3, a4, a5));
}
Variant i_fileatime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fileatime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileatime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fileatime(arg0));
  }
}
Variant ifa_fileatime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fileatime", count, 1, 1, 1);
  return (f_fileatime(a0));
}
Variant i_apd_stop_trace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apd_stop_trace);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_stop_trace", 0, 1);
  return (f_apd_stop_trace(), null);
}
Variant ifa_apd_stop_trace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("apd_stop_trace", 0, 1);
  return (f_apd_stop_trace(), null);
}
Variant i_hphpd_break(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphpd_break);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("hphpd_break", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_hphpd_break(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphpd_break(arg0), null);
  }
}
Variant ifa_hphpd_break(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("hphpd_break", 1, 1);
  if (count <= 0) return (f_hphpd_break(), null);
  return (f_hphpd_break(a0), null);
}
Variant i_addcslashes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(addcslashes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("addcslashes", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_addcslashes(arg0, arg1));
  }
}
Variant ifa_addcslashes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("addcslashes", count, 2, 2, 1);
  return (f_addcslashes(a0, a1));
}
Variant i_magicksetimageoption(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimageoption);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magicksetimageoption", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageoption(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magicksetimageoption(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("magicksetimageoption", count, 4, 4, 1);
  return (f_magicksetimageoption(a0, a1, a2, a3));
}
Variant i_xmlwriter_write_comment(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_comment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_comment", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_comment(arg0, arg1));
  }
}
Variant ifa_xmlwriter_write_comment(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_comment", count, 2, 2, 1);
  return (f_xmlwriter_write_comment(a0, a1));
}
Variant i_drawgetfontstyle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetfontstyle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontstyle", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfontstyle(arg0));
  }
}
Variant ifa_drawgetfontstyle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetfontstyle", count, 1, 1, 1);
  return (f_drawgetfontstyle(a0));
}
Variant i_dom_element_set_attribute_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_element_set_attribute_ns", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_attribute_ns(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_dom_element_set_attribute_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("dom_element_set_attribute_ns", count, 4, 4, 1);
  return (f_dom_element_set_attribute_ns(a0, a1, a2, a3));
}
Variant i_dom_xpath_evaluate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_xpath_evaluate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_xpath_evaluate", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_xpath_evaluate(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_xpath_evaluate(arg0, arg1, arg2));
  }
}
Variant ifa_dom_xpath_evaluate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_xpath_evaluate", count, 2, 3, 1);
  if (count <= 2) return (f_dom_xpath_evaluate(a0, a1));
  return (f_dom_xpath_evaluate(a0, a1, a2));
}
Variant i_strtoupper(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strtoupper);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strtoupper", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_strtoupper(arg0));
  }
}
Variant ifa_strtoupper(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("strtoupper", count, 1, 1, 1);
  return (f_strtoupper(a0));
}
Variant i_xml_set_processing_instruction_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_set_processing_instruction_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_processing_instruction_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_processing_instruction_handler(arg0, arg1));
  }
}
Variant ifa_xml_set_processing_instruction_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xml_set_processing_instruction_handler", count, 2, 2, 1);
  return (f_xml_set_processing_instruction_handler(a0, a1));
}
Variant i_apd_breakpoint(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apd_breakpoint);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_breakpoint", 0, 1);
  return (f_apd_breakpoint());
}
Variant ifa_apd_breakpoint(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("apd_breakpoint", 0, 1);
  return (f_apd_breakpoint());
}
Variant i_memcache_delete(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_delete);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_delete", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_delete(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_delete(arg0, arg1, arg2));
  }
}
Variant ifa_memcache_delete(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_delete", count, 2, 3, 1);
  if (count <= 2) return (f_memcache_delete(a0, a1));
  return (f_memcache_delete(a0, a1, a2));
}
Variant i_magickgetimageblueprimary(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageblueprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageblueprimary", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageblueprimary(arg0));
  }
}
Variant ifa_magickgetimageblueprimary(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimageblueprimary", count, 1, 1, 1);
  return (f_magickgetimageblueprimary(a0));
}
Variant i_magickspreadimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickspreadimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickspreadimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickspreadimage(arg0, arg1));
  }
}
Variant ifa_magickspreadimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickspreadimage", count, 2, 2, 1);
  return (f_magickspreadimage(a0, a1));
}
Variant i_array_fill(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_fill);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("array_fill", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_fill(arg0, arg1, arg2));
  }
}
Variant ifa_array_fill(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("array_fill", count, 3, 3, 1);
  return (f_array_fill(a0, a1, a2));
}
Variant i_dom_element_set_attribute_node(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_attribute_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_set_attribute_node", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_attribute_node(arg0, arg1));
  }
}
Variant ifa_dom_element_set_attribute_node(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_element_set_attribute_node", count, 2, 2, 1);
  return (f_dom_element_set_attribute_node(a0, a1));
}
Variant i_memcache_replace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_replace", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_memcache_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_memcache_replace(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_replace(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_memcache_replace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_replace", count, 3, 5, 1);
  if (count <= 3) return (f_memcache_replace(a0, a1, a2));
  if (count == 4) return (f_memcache_replace(a0, a1, a2, a3));
  return (f_memcache_replace(a0, a1, a2, a3, a4));
}
Variant i_stream_set_write_buffer(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_set_write_buffer);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_set_write_buffer", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_set_write_buffer(arg0, arg1));
  }
}
Variant ifa_stream_set_write_buffer(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stream_set_write_buffer", count, 2, 2, 1);
  return (f_stream_set_write_buffer(a0, a1));
}
Variant i_mb_list_encodings(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_list_encodings);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_list_encodings", 0, 1);
  return (f_mb_list_encodings());
}
Variant ifa_mb_list_encodings(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("mb_list_encodings", 0, 1);
  return (f_mb_list_encodings());
}
Variant i_sleep(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sleep);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sleep", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sleep(arg0));
  }
}
Variant ifa_sleep(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("sleep", count, 1, 1, 1);
  return (f_sleep(a0));
}
Variant i_cleardrawingwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(cleardrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cleardrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_cleardrawingwand(arg0), null);
  }
}
Variant ifa_cleardrawingwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("cleardrawingwand", count, 1, 1, 1);
  return (f_cleardrawingwand(a0), null);
}
Variant i_imagecolorset(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorset);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorset", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorset(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_imagecolorset(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("imagecolorset", count, 5, 5, 1);
  return (f_imagecolorset(a0, a1, a2, a3, a4));
}
Variant i_openssl_x509_checkpurpose(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_checkpurpose);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_x509_checkpurpose", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_x509_checkpurpose(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_openssl_x509_checkpurpose(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_x509_checkpurpose(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_x509_checkpurpose(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_x509_checkpurpose", count, 2, 4, 1);
  if (count <= 2) return (f_openssl_x509_checkpurpose(a0, a1));
  if (count == 3) return (f_openssl_x509_checkpurpose(a0, a1, a2));
  return (f_openssl_x509_checkpurpose(a0, a1, a2, a3));
}
Variant i_drawpathcurvetosmoothabsolute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetosmoothabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetosmoothabsolute", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetosmoothabsolute(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant ifa_drawpathcurvetosmoothabsolute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("drawpathcurvetosmoothabsolute", count, 5, 5, 1);
  return (f_drawpathcurvetosmoothabsolute(a0, a1, a2, a3, a4), null);
}
Variant i_array_intersect_ukey(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_intersect_ukey);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_intersect_ukey", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_intersect_ukey(count, arg0, arg1, arg2));
    return (f_array_intersect_ukey(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant ifa_array_intersect_ukey(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3) return throw_missing_arguments("array_intersect_ukey", count+1, 1);
  if (count <= 3) return (f_array_intersect_ukey(count, a0, a1, a2));
  Array params;
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_intersect_ukey(count,a0, a1, a2, params));
}
Variant i_timezone_name_from_abbr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(timezone_name_from_abbr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("timezone_name_from_abbr", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_timezone_name_from_abbr(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_timezone_name_from_abbr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_timezone_name_from_abbr(arg0, arg1, arg2));
  }
}
Variant ifa_timezone_name_from_abbr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("timezone_name_from_abbr", count, 1, 3, 1);
  if (count <= 1) return (f_timezone_name_from_abbr(a0));
  if (count == 2) return (f_timezone_name_from_abbr(a0, a1));
  return (f_timezone_name_from_abbr(a0, a1, a2));
}
Variant i_imagefilledellipse(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagefilledellipse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagefilledellipse", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilledellipse(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imagefilledellipse(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("imagefilledellipse", count, 6, 6, 1);
  return (f_imagefilledellipse(a0, a1, a2, a3, a4, a5));
}
Variant i_pcntl_wstopsig(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_wstopsig);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wstopsig", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wstopsig(arg0));
  }
}
Variant ifa_pcntl_wstopsig(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pcntl_wstopsig", count, 1, 1, 1);
  return (f_pcntl_wstopsig(a0));
}
Variant i_get_defined_vars(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_defined_vars);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_defined_vars", 0, 1);
  return (f_get_defined_vars());
}
Variant ifa_get_defined_vars(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("get_defined_vars", 0, 1);
  return (f_get_defined_vars());
}
Variant i_memory_get_usage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memory_get_usage);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("memory_get_usage", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_memory_get_usage());
    CVarRef arg0((ad->getValue(pos)));
    return (f_memory_get_usage(arg0));
  }
}
Variant ifa_memory_get_usage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("memory_get_usage", 1, 1);
  if (count <= 0) return (f_memory_get_usage());
  return (f_memory_get_usage(a0));
}
Variant i_intval(void *extra, CArrRef params) {
  FUNCTION_INJECTION(intval);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("intval", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_intval(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_intval(arg0, arg1));
  }
}
Variant ifa_intval(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("intval", count, 1, 2, 1);
  if (count <= 1) return (f_intval(a0));
  return (f_intval(a0, a1));
}
Variant i_pagelet_server_task_status(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pagelet_server_task_status);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pagelet_server_task_status", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pagelet_server_task_status(arg0));
  }
}
Variant ifa_pagelet_server_task_status(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pagelet_server_task_status", count, 1, 1, 1);
  return (f_pagelet_server_task_status(a0));
}
Variant i_dom_document_get_elements_by_tag_name_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_get_elements_by_tag_name_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_document_get_elements_by_tag_name_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_get_elements_by_tag_name_ns(arg0, arg1, arg2));
  }
}
Variant ifa_dom_document_get_elements_by_tag_name_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_document_get_elements_by_tag_name_ns", count, 3, 3, 1);
  return (f_dom_document_get_elements_by_tag_name_ns(a0, a1, a2));
}
Variant i_iconv_set_encoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iconv_set_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("iconv_set_encoding", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_set_encoding(arg0, arg1));
  }
}
Variant ifa_iconv_set_encoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("iconv_set_encoding", count, 2, 2, 1);
  return (f_iconv_set_encoding(a0, a1));
}
Variant i_magickmattefloodfillimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickmattefloodfillimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickmattefloodfillimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmattefloodfillimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_magickmattefloodfillimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("magickmattefloodfillimage", count, 6, 6, 1);
  return (f_magickmattefloodfillimage(a0, a1, a2, a3, a4, a5));
}
Variant i_mailparse_msg_get_part(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_get_part);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mailparse_msg_get_part", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_msg_get_part(arg0, arg1));
  }
}
Variant ifa_mailparse_msg_get_part(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("mailparse_msg_get_part", count, 2, 2, 1);
  return (f_mailparse_msg_get_part(a0, a1));
}
Variant i_mb_check_encoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_check_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_check_encoding", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_check_encoding());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mb_check_encoding(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_check_encoding(arg0, arg1));
  }
}
Variant ifa_mb_check_encoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("mb_check_encoding", 2, 1);
  if (count <= 0) return (f_mb_check_encoding());
  if (count == 1) return (f_mb_check_encoding(a0));
  return (f_mb_check_encoding(a0, a1));
}
Variant i_ldap_get_dn(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_get_dn);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_dn", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_get_dn(arg0, arg1));
  }
}
Variant ifa_ldap_get_dn(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ldap_get_dn", count, 2, 2, 1);
  return (f_ldap_get_dn(a0, a1));
}
Variant i_newpixeliterator(void *extra, CArrRef params) {
  FUNCTION_INJECTION(newpixeliterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixeliterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_newpixeliterator(arg0));
  }
}
Variant ifa_newpixeliterator(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("newpixeliterator", count, 1, 1, 1);
  return (f_newpixeliterator(a0));
}
Variant i_magicksetimagefilename(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagefilename);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magicksetimagefilename", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magicksetimagefilename(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagefilename(arg0, arg1));
  }
}
Variant ifa_magicksetimagefilename(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("magicksetimagefilename", count, 1, 2, 1);
  if (count <= 1) return (f_magicksetimagefilename(a0));
  return (f_magicksetimagefilename(a0, a1));
}
Variant i_call_user_func(void *extra, CArrRef params) {
  FUNCTION_INJECTION(call_user_func);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("call_user_func", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_call_user_func(count, arg0));
    return (f_call_user_func(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_call_user_func(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("call_user_func", count+1, 1);
  if (count <= 1) return (f_call_user_func(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_call_user_func(count,a0, params));
}
Variant i_mysql_list_tables(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_list_tables);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_list_tables", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_list_tables(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_list_tables(arg0, arg1));
  }
}
Variant ifa_mysql_list_tables(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_list_tables", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_list_tables(a0));
  return (f_mysql_list_tables(a0, a1));
}
Variant i_magickgetinterlacescheme(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetinterlacescheme);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetinterlacescheme", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetinterlacescheme(arg0));
  }
}
Variant ifa_magickgetinterlacescheme(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetinterlacescheme", count, 1, 1, 1);
  return (f_magickgetinterlacescheme(a0));
}
Variant i_ltrim(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ltrim);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("ltrim", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_ltrim(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ltrim(arg0, arg1));
  }
}
Variant ifa_ltrim(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("ltrim", count, 1, 2, 1);
  if (count <= 1) return (f_ltrim(a0));
  return (f_ltrim(a0, a1));
}
Variant i_magicktextureimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicktextureimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicktextureimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicktextureimage(arg0, arg1));
  }
}
Variant ifa_magicktextureimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicktextureimage", count, 2, 2, 1);
  return (f_magicktextureimage(a0, a1));
}
Variant i_mb_ereg_match(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_match);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_ereg_match", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_ereg_match(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_match(arg0, arg1, arg2));
  }
}
Variant ifa_mb_ereg_match(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_ereg_match", count, 2, 3, 1);
  if (count <= 2) return (f_mb_ereg_match(a0, a1));
  return (f_mb_ereg_match(a0, a1, a2));
}
Variant i_mt_srand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mt_srand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mt_srand", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mt_srand(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_mt_srand(arg0), null);
  }
}
Variant ifa_mt_srand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mt_srand", 1, 1);
  if (count <= 0) return (f_mt_srand(), null);
  return (f_mt_srand(a0), null);
}
Variant i_imagecolorallocate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorallocate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorallocate", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorallocate(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagecolorallocate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("imagecolorallocate", count, 4, 4, 1);
  return (f_imagecolorallocate(a0, a1, a2, a3));
}
Variant i_define_syslog_variables(void *extra, CArrRef params) {
  FUNCTION_INJECTION(define_syslog_variables);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("define_syslog_variables", 0, 1);
  return (f_define_syslog_variables(), null);
}
Variant ifa_define_syslog_variables(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("define_syslog_variables", 0, 1);
  return (f_define_syslog_variables(), null);
}
Variant i_fb_get_code_coverage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_get_code_coverage);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("fb_get_code_coverage", 0, 1);
  return (f_fb_get_code_coverage());
}
Variant ifa_fb_get_code_coverage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("fb_get_code_coverage", 0, 1);
  return (f_fb_get_code_coverage());
}
Variant i_mcrypt_enc_get_modes_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_modes_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_modes_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_modes_name(arg0));
  }
}
Variant ifa_mcrypt_enc_get_modes_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_modes_name", count, 1, 1, 1);
  return (f_mcrypt_enc_get_modes_name(a0));
}
Variant i_array_flip(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_flip);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_flip", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_flip(arg0));
  }
}
Variant ifa_array_flip(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("array_flip", count, 1, 1, 1);
  return (f_array_flip(a0));
}
Variant i_count(void *extra, CArrRef params) {
  FUNCTION_INJECTION(count);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("count", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_count(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_count(arg0, arg1));
  }
}
Variant ifa_count(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("count", count, 1, 2, 1);
  if (count <= 1) return (f_count(a0));
  return (f_count(a0, a1));
}
Variant i_lcg_value(void *extra, CArrRef params) {
  FUNCTION_INJECTION(lcg_value);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("lcg_value", 0, 1);
  return (f_lcg_value());
}
Variant ifa_lcg_value(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("lcg_value", 0, 1);
  return (f_lcg_value());
}
Variant i_php_logo_guid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(php_logo_guid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_logo_guid", 0, 1);
  return (f_php_logo_guid());
}
Variant ifa_php_logo_guid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("php_logo_guid", 0, 1);
  return (f_php_logo_guid());
}
Variant i_time(void *extra, CArrRef params) {
  FUNCTION_INJECTION(time);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("time", 0, 1);
  return (f_time());
}
Variant ifa_time(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("time", 0, 1);
  return (f_time());
}
Variant i_magickcoalesceimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickcoalesceimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickcoalesceimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickcoalesceimages(arg0));
  }
}
Variant ifa_magickcoalesceimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickcoalesceimages", count, 1, 1, 1);
  return (f_magickcoalesceimages(a0));
}
Variant i_pixelgetquantumcolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetquantumcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetquantumcolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetquantumcolor(arg0));
  }
}
Variant ifa_pixelgetquantumcolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetquantumcolor", count, 1, 1, 1);
  return (f_pixelgetquantumcolor(a0));
}
Variant i_openssl_private_encrypt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_private_encrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_private_encrypt", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_private_encrypt(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_private_encrypt(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_private_encrypt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_private_encrypt", count, 3, 4, 1);
  if (count <= 3) return (f_openssl_private_encrypt(a0, ref(a1), a2));
  return (f_openssl_private_encrypt(a0, ref(a1), a2, a3));
}
Variant i_xhprof_enable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xhprof_enable);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xhprof_enable", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_xhprof_enable(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xhprof_enable(arg0, arg1), null);
  }
}
Variant ifa_xhprof_enable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("xhprof_enable", count, 1, 2, 1);
  if (count <= 1) return (f_xhprof_enable(a0), null);
  return (f_xhprof_enable(a0, a1), null);
}
Variant i_hphp_splfileinfo_gettype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_gettype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_gettype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_gettype(arg0));
  }
}
Variant ifa_hphp_splfileinfo_gettype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_gettype", count, 1, 1, 1);
  return (f_hphp_splfileinfo_gettype(a0));
}
Variant i_xhprof_run_trace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xhprof_run_trace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xhprof_run_trace", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xhprof_run_trace(arg0, arg1));
  }
}
Variant ifa_xhprof_run_trace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xhprof_run_trace", count, 2, 2, 1);
  return (f_xhprof_run_trace(a0, a1));
}
Variant i_xmlwriter_start_document(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_document);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("xmlwriter_start_document", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_xmlwriter_start_document(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_xmlwriter_start_document(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_xmlwriter_start_document(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_document(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_xmlwriter_start_document(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("xmlwriter_start_document", count, 1, 4, 1);
  if (count <= 1) return (f_xmlwriter_start_document(a0));
  if (count == 2) return (f_xmlwriter_start_document(a0, a1));
  if (count == 3) return (f_xmlwriter_start_document(a0, a1, a2));
  return (f_xmlwriter_start_document(a0, a1, a2, a3));
}
Variant i_libxml_clear_errors(void *extra, CArrRef params) {
  FUNCTION_INJECTION(libxml_clear_errors);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_clear_errors", 0, 1);
  return (f_libxml_clear_errors(), null);
}
Variant ifa_libxml_clear_errors(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("libxml_clear_errors", 0, 1);
  return (f_libxml_clear_errors(), null);
}
Variant i_magicknormalizeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicknormalizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicknormalizeimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magicknormalizeimage(arg0));
  }
}
Variant ifa_magicknormalizeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magicknormalizeimage", count, 1, 1, 1);
  return (f_magicknormalizeimage(a0));
}
Variant i_magickgetformat(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetformat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetformat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetformat(arg0));
  }
}
Variant ifa_magickgetformat(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetformat", count, 1, 1, 1);
  return (f_magickgetformat(a0));
}
Variant i_hphp_get_class_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_get_class_info);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_class_info", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_get_class_info(arg0));
  }
}
Variant ifa_hphp_get_class_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_get_class_info", count, 1, 1, 1);
  return (f_hphp_get_class_info(a0));
}
Variant i_dom_element_remove_attribute_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_remove_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_remove_attribute_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_remove_attribute_ns(arg0, arg1, arg2));
  }
}
Variant ifa_dom_element_remove_attribute_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_element_remove_attribute_ns", count, 3, 3, 1);
  return (f_dom_element_remove_attribute_ns(a0, a1, a2));
}
Variant i_mailparse_msg_get_part_data(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_get_part_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_get_part_data", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_msg_get_part_data(arg0));
  }
}
Variant ifa_mailparse_msg_get_part_data(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mailparse_msg_get_part_data", count, 1, 1, 1);
  return (f_mailparse_msg_get_part_data(a0));
}
Variant i_openssl_csr_new(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_new);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_csr_new", count, 2, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_csr_new(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_openssl_csr_new(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_csr_new(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_csr_new(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_csr_new", count, 2, 4, 1);
  if (count <= 2) return (f_openssl_csr_new(a0, ref(a1)));
  if (count == 3) return (f_openssl_csr_new(a0, ref(a1), a2));
  return (f_openssl_csr_new(a0, ref(a1), a2, a3));
}
Variant i_xbox_task_start(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xbox_task_start);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_task_start", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xbox_task_start(arg0));
  }
}
Variant ifa_xbox_task_start(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xbox_task_start", count, 1, 1, 1);
  return (f_xbox_task_start(a0));
}
Variant i_getcwd(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getcwd);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getcwd", 0, 1);
  return (f_getcwd());
}
Variant ifa_getcwd(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("getcwd", 0, 1);
  return (f_getcwd());
}
Variant i_posix_getrlimit(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getrlimit);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getrlimit", 0, 1);
  return (f_posix_getrlimit());
}
Variant ifa_posix_getrlimit(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_getrlimit", 0, 1);
  return (f_posix_getrlimit());
}
Variant i_mb_get_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_get_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_get_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_get_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_get_info(arg0));
  }
}
Variant ifa_mb_get_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mb_get_info", 1, 1);
  if (count <= 0) return (f_mb_get_info());
  return (f_mb_get_info(a0));
}
Variant i_newpixelwands(void *extra, CArrRef params) {
  FUNCTION_INJECTION(newpixelwands);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixelwands", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_newpixelwands(arg0));
  }
}
Variant ifa_newpixelwands(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("newpixelwands", count, 1, 1, 1);
  return (f_newpixelwands(a0));
}
Variant i_fputcsv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fputcsv);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("fputcsv", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fputcsv(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fputcsv(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fputcsv(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_fputcsv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("fputcsv", count, 2, 4, 1);
  if (count <= 2) return (f_fputcsv(a0, a1));
  if (count == 3) return (f_fputcsv(a0, a1, a2));
  return (f_fputcsv(a0, a1, a2, a3));
}
Variant i_stream_bucket_prepend(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_bucket_prepend);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_prepend", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_bucket_prepend(arg0, arg1), null);
  }
}
Variant ifa_stream_bucket_prepend(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stream_bucket_prepend", count, 2, 2, 1);
  return (f_stream_bucket_prepend(a0, a1), null);
}
Variant i_apache_get_scoreboard(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apache_get_scoreboard);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_scoreboard", 0, 1);
  return (f_apache_get_scoreboard());
}
Variant ifa_apache_get_scoreboard(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("apache_get_scoreboard", 0, 1);
  return (f_apache_get_scoreboard());
}
Variant i_sprintf(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sprintf);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("sprintf", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_sprintf(count, arg0));
    return (f_sprintf(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_sprintf(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("sprintf", count+1, 1);
  if (count <= 1) return (f_sprintf(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_sprintf(count,a0, params));
}
Variant i_ldap_err2str(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_err2str);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_err2str", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_err2str(arg0));
  }
}
Variant ifa_ldap_err2str(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ldap_err2str", count, 1, 1, 1);
  return (f_ldap_err2str(a0));
}
Variant i_memcache_get_stats(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_get_stats);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_get_stats", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_memcache_get_stats(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_memcache_get_stats(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_get_stats(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_get_stats(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_memcache_get_stats(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_get_stats", count, 1, 4, 1);
  if (count <= 1) return (f_memcache_get_stats(a0));
  if (count == 2) return (f_memcache_get_stats(a0, a1));
  if (count == 3) return (f_memcache_get_stats(a0, a1, a2));
  return (f_memcache_get_stats(a0, a1, a2, a3));
}
Variant i_xmlwriter_end_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_attribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_attribute(arg0));
  }
}
Variant ifa_xmlwriter_end_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_attribute", count, 1, 1, 1);
  return (f_xmlwriter_end_attribute(a0));
}
Variant i_imagecharup(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecharup);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagecharup", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecharup(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imagecharup(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("imagecharup", count, 6, 6, 1);
  return (f_imagecharup(a0, a1, a2, a3, a4, a5));
}
Variant i_fflush(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fflush);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fflush", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fflush(arg0));
  }
}
Variant ifa_fflush(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fflush", count, 1, 1, 1);
  return (f_fflush(a0));
}
Variant i_magickwaveimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickwaveimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickwaveimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwaveimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickwaveimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magickwaveimage", count, 3, 3, 1);
  return (f_magickwaveimage(a0, a1, a2));
}
Variant i_imagepsfreefont(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagepsfreefont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagepsfreefont", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagepsfreefont(arg0));
  }
}
Variant ifa_imagepsfreefont(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagepsfreefont", count, 1, 1, 1);
  return (f_imagepsfreefont(a0));
}
Variant i_dom_node_is_supported(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_is_supported);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_node_is_supported", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_is_supported(arg0, arg1, arg2));
  }
}
Variant ifa_dom_node_is_supported(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_node_is_supported", count, 3, 3, 1);
  return (f_dom_node_is_supported(a0, a1, a2));
}
Variant i_magickgetsamplingfactors(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetsamplingfactors);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetsamplingfactors", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetsamplingfactors(arg0));
  }
}
Variant ifa_magickgetsamplingfactors(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetsamplingfactors", count, 1, 1, 1);
  return (f_magickgetsamplingfactors(a0));
}
Variant i_mt_rand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mt_rand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mt_rand", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mt_rand());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mt_rand(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mt_rand(arg0, arg1));
  }
}
Variant ifa_mt_rand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("mt_rand", 2, 1);
  if (count <= 0) return (f_mt_rand());
  if (count == 1) return (f_mt_rand(a0));
  return (f_mt_rand(a0, a1));
}
Variant i_hphp_splfileinfo_getpathname(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getpathname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getpathname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getpathname(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getpathname(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getpathname", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getpathname(a0));
}
Variant i_magickflopimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickflopimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflopimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickflopimage(arg0));
  }
}
Variant ifa_magickflopimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickflopimage", count, 1, 1, 1);
  return (f_magickflopimage(a0));
}
Variant i_register_cleanup_function(void *extra, CArrRef params) {
  FUNCTION_INJECTION(register_cleanup_function);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_cleanup_function", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_register_cleanup_function(count, arg0), null);
    return (f_register_cleanup_function(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant ifa_register_cleanup_function(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("register_cleanup_function", count+1, 1);
  if (count <= 1) return (f_register_cleanup_function(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_register_cleanup_function(count,a0, params), null);
}
Variant i_getenv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getenv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getenv", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_getenv(arg0));
  }
}
Variant ifa_getenv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("getenv", count, 1, 1, 1);
  return (f_getenv(a0));
}
Variant i_is_dir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_dir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_dir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_dir(arg0));
  }
}
Variant ifa_is_dir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_dir", count, 1, 1, 1);
  return (f_is_dir(a0));
}
Variant i_get_defined_functions(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_defined_functions);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_defined_functions", 0, 1);
  return (f_get_defined_functions());
}
Variant ifa_get_defined_functions(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("get_defined_functions", 0, 1);
  return (f_get_defined_functions());
}
Variant i_stream_set_timeout(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_set_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("stream_set_timeout", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_set_timeout(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_set_timeout(arg0, arg1, arg2));
  }
}
Variant ifa_stream_set_timeout(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("stream_set_timeout", count, 2, 3, 1);
  if (count <= 2) return (f_stream_set_timeout(a0, a1));
  return (f_stream_set_timeout(a0, a1, a2));
}
Variant i_magickenhanceimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickenhanceimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickenhanceimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickenhanceimage(arg0));
  }
}
Variant ifa_magickenhanceimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickenhanceimage", count, 1, 1, 1);
  return (f_magickenhanceimage(a0));
}
Variant i_memcache_increment(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_increment);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_increment", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_increment(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_increment(arg0, arg1, arg2));
  }
}
Variant ifa_memcache_increment(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_increment", count, 2, 3, 1);
  if (count <= 2) return (f_memcache_increment(a0, a1));
  return (f_memcache_increment(a0, a1, a2));
}
Variant i_pixelsetblack(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetblack);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblack", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetblack(arg0, arg1), null);
  }
}
Variant ifa_pixelsetblack(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetblack", count, 2, 2, 1);
  return (f_pixelsetblack(a0, a1), null);
}
Variant i_magickgetcharwidth(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetcharwidth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetcharwidth", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgetcharwidth(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetcharwidth(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickgetcharwidth(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetcharwidth", count, 3, 4, 1);
  if (count <= 3) return (f_magickgetcharwidth(a0, a1, a2));
  return (f_magickgetcharwidth(a0, a1, a2, a3));
}
Variant i_magickshearimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickshearimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickshearimage", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickshearimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickshearimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("magickshearimage", count, 4, 4, 1);
  return (f_magickshearimage(a0, a1, a2, a3));
}
Variant i_stream_socket_enable_crypto(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_socket_enable_crypto);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_enable_crypto", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_socket_enable_crypto(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_socket_enable_crypto(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_enable_crypto(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_stream_socket_enable_crypto(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_enable_crypto", count, 2, 4, 1);
  if (count <= 2) return (f_stream_socket_enable_crypto(a0, a1));
  if (count == 3) return (f_stream_socket_enable_crypto(a0, a1, a2));
  return (f_stream_socket_enable_crypto(a0, a1, a2, a3));
}
Variant i_stream_socket_server(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_socket_server);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("stream_socket_server", count, 1, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_socket_server(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_stream_socket_server(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_socket_server(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_stream_socket_server(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_server(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_stream_socket_server(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 5) return throw_wrong_arguments("stream_socket_server", count, 1, 5, 1);
  if (count <= 1) return (f_stream_socket_server(a0));
  if (count == 2) return (f_stream_socket_server(a0, ref(a1)));
  if (count == 3) return (f_stream_socket_server(a0, ref(a1), ref(a2)));
  if (count == 4) return (f_stream_socket_server(a0, ref(a1), ref(a2), a3));
  return (f_stream_socket_server(a0, ref(a1), ref(a2), a3, a4));
}
Variant i_apd_set_pprof_trace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apd_set_pprof_trace);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apd_set_pprof_trace", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_apd_set_pprof_trace());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_apd_set_pprof_trace(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apd_set_pprof_trace(arg0, arg1));
  }
}
Variant ifa_apd_set_pprof_trace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("apd_set_pprof_trace", 2, 1);
  if (count <= 0) return (f_apd_set_pprof_trace());
  if (count == 1) return (f_apd_set_pprof_trace(a0));
  return (f_apd_set_pprof_trace(a0, a1));
}
Variant i_ini_set(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ini_set);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ini_set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ini_set(arg0, arg1));
  }
}
Variant ifa_ini_set(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("ini_set", count, 2, 2, 1);
  return (f_ini_set(a0, a1));
}
Variant i_sort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("sort", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_sort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_sort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_sort(arg0, arg1, arg2));
  }
}
Variant ifa_sort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("sort", count, 1, 3, 1);
  if (count <= 1) return (f_sort(ref(a0)));
  if (count == 2) return (f_sort(ref(a0), a1));
  return (f_sort(ref(a0), a1, a2));
}
Variant i_drawgetfont(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfont", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfont(arg0));
  }
}
Variant ifa_drawgetfont(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetfont", count, 1, 1, 1);
  return (f_drawgetfont(a0));
}
Variant i_readdir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(readdir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("readdir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_readdir(arg0));
  }
}
Variant ifa_readdir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("readdir", count, 1, 1, 1);
  return (f_readdir(a0));
}
Variant i_mysql_close(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_close);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_close", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_close());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_close(arg0));
  }
}
Variant ifa_mysql_close(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_close", 1, 1);
  if (count <= 0) return (f_mysql_close());
  return (f_mysql_close(a0));
}
Variant i_magicksetimagerenderingintent(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagerenderingintent);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagerenderingintent", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagerenderingintent(arg0, arg1));
  }
}
Variant ifa_magicksetimagerenderingintent(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagerenderingintent", count, 2, 2, 1);
  return (f_magicksetimagerenderingintent(a0, a1));
}
Variant i_magickreducenoiseimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickreducenoiseimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreducenoiseimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickreducenoiseimage(arg0, arg1));
  }
}
Variant ifa_magickreducenoiseimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickreducenoiseimage", count, 2, 2, 1);
  return (f_magickreducenoiseimage(a0, a1));
}
Variant i_magickblurimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickblurimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickblurimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickblurimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickblurimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickblurimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickblurimage", count, 3, 4, 1);
  if (count <= 3) return (f_magickblurimage(a0, a1, a2));
  return (f_magickblurimage(a0, a1, a2, a3));
}
Variant i_hphpd_get_user_commands(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphpd_get_user_commands);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphpd_get_user_commands", 0, 1);
  return (f_hphpd_get_user_commands());
}
Variant ifa_hphpd_get_user_commands(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("hphpd_get_user_commands", 0, 1);
  return (f_hphpd_get_user_commands());
}
Variant i_magicktintimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicktintimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicktintimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicktintimage(arg0, arg1, arg2));
  }
}
Variant ifa_magicktintimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicktintimage", count, 3, 3, 1);
  return (f_magicktintimage(a0, a1, a2));
}
Variant i_rawurldecode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(rawurldecode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rawurldecode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_rawurldecode(arg0));
  }
}
Variant ifa_rawurldecode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("rawurldecode", count, 1, 1, 1);
  return (f_rawurldecode(a0));
}
Variant i_strftime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strftime);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strftime", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_strftime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strftime(arg0, arg1));
  }
}
Variant ifa_strftime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("strftime", count, 1, 2, 1);
  if (count <= 1) return (f_strftime(a0));
  return (f_strftime(a0, a1));
}
Variant i_xmlwriter_start_element_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_element_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("xmlwriter_start_element_ns", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_element_ns(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_xmlwriter_start_element_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("xmlwriter_start_element_ns", count, 4, 4, 1);
  return (f_xmlwriter_start_element_ns(a0, a1, a2, a3));
}
Variant i_imagecolorstotal(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorstotal);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecolorstotal", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecolorstotal(arg0));
  }
}
Variant ifa_imagecolorstotal(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagecolorstotal", count, 1, 1, 1);
  return (f_imagecolorstotal(a0));
}
Variant i_hphp_splfileinfo_getowner(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getowner);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getowner", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getowner(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getowner(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getowner", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getowner(a0));
}
Variant i_write_hdf_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(write_hdf_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("write_hdf_string", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_write_hdf_string(arg0));
  }
}
Variant ifa_write_hdf_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("write_hdf_string", count, 1, 1, 1);
  return (f_write_hdf_string(a0));
}
Variant i_dom_node_has_child_nodes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_node_has_child_nodes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_has_child_nodes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_node_has_child_nodes(arg0));
  }
}
Variant ifa_dom_node_has_child_nodes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dom_node_has_child_nodes", count, 1, 1, 1);
  return (f_dom_node_has_child_nodes(a0));
}
Variant i_apc_bin_dumpfile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_bin_dumpfile);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("apc_bin_dumpfile", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_apc_bin_dumpfile(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_apc_bin_dumpfile(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_bin_dumpfile(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_apc_bin_dumpfile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 5) return throw_wrong_arguments("apc_bin_dumpfile", count, 3, 5, 1);
  if (count <= 3) return (f_apc_bin_dumpfile(a0, a1, a2));
  if (count == 4) return (f_apc_bin_dumpfile(a0, a1, a2, a3));
  return (f_apc_bin_dumpfile(a0, a1, a2, a3, a4));
}
Variant i_xml_parse_into_struct(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_parse_into_struct);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("xml_parse_into_struct", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_xml_parse_into_struct(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_xml_parse_into_struct(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_xml_parse_into_struct(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("xml_parse_into_struct", count, 3, 4, 1);
  if (count <= 3) return (f_xml_parse_into_struct(a0, a1, ref(a2)));
  return (f_xml_parse_into_struct(a0, a1, ref(a2), ref(a3)));
}
Variant i_icu_transliterate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(icu_transliterate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("icu_transliterate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_icu_transliterate(arg0, arg1));
  }
}
Variant ifa_icu_transliterate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("icu_transliterate", count, 2, 2, 1);
  return (f_icu_transliterate(a0, a1));
}
Variant i_mb_eregi_replace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_eregi_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("mb_eregi_replace", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mb_eregi_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_eregi_replace(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_eregi_replace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("mb_eregi_replace", count, 3, 4, 1);
  if (count <= 3) return (f_mb_eregi_replace(a0, a1, a2));
  return (f_mb_eregi_replace(a0, a1, a2, a3));
}
Variant i_hphp_splfileinfo_getatime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getatime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getatime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getatime(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getatime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getatime", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getatime(a0));
}
Variant i_array_unshift(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_unshift);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_unshift", count+1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_unshift(count, arg0, arg1));
    return (f_array_unshift(count,ref(arg0), arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_array_unshift(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("array_unshift", count+1, 1);
  if (count <= 2) return (f_array_unshift(count, ref(a0), a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_unshift(count,ref(a0), a1, params));
}
Variant i_stat(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stat(arg0));
  }
}
Variant ifa_stat(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("stat", count, 1, 1, 1);
  return (f_stat(a0));
}
Variant i_posix_getpid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getpid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getpid", 0, 1);
  return (f_posix_getpid());
}
Variant ifa_posix_getpid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_getpid", 0, 1);
  return (f_posix_getpid());
}
Variant i_hphp_directoryiterator_key(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_key(arg0));
  }
}
Variant ifa_hphp_directoryiterator_key(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_key", count, 1, 1, 1);
  return (f_hphp_directoryiterator_key(a0));
}
Variant i_get_current_user(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_current_user);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_current_user", 0, 1);
  return (f_get_current_user());
}
Variant ifa_get_current_user(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("get_current_user", 0, 1);
  return (f_get_current_user());
}
Variant i_filesize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(filesize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filesize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_filesize(arg0));
  }
}
Variant ifa_filesize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("filesize", count, 1, 1, 1);
  return (f_filesize(a0));
}
Variant i_round(void *extra, CArrRef params) {
  FUNCTION_INJECTION(round);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("round", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_round(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_round(arg0, arg1));
  }
}
Variant ifa_round(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("round", count, 1, 2, 1);
  if (count <= 1) return (f_round(a0));
  return (f_round(a0, a1));
}
Variant i_pdo_drivers(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pdo_drivers);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pdo_drivers", 0, 1);
  return (f_pdo_drivers());
}
Variant ifa_pdo_drivers(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("pdo_drivers", 0, 1);
  return (f_pdo_drivers());
}
Variant i_sqrt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sqrt);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sqrt", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sqrt(arg0));
  }
}
Variant ifa_sqrt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("sqrt", count, 1, 1, 1);
  return (f_sqrt(a0));
}
Variant i_ldap_close(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_close(arg0));
  }
}
Variant ifa_ldap_close(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ldap_close", count, 1, 1, 1);
  return (f_ldap_close(a0));
}
Variant i_memcache_pconnect(void *extra, CArrRef params) {
  FUNCTION_INJECTION(memcache_pconnect);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_pconnect", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_memcache_pconnect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_memcache_pconnect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_pconnect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_pconnect(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_memcache_pconnect(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_pconnect", count, 1, 4, 1);
  if (count <= 1) return (f_memcache_pconnect(a0));
  if (count == 2) return (f_memcache_pconnect(a0, a1));
  if (count == 3) return (f_memcache_pconnect(a0, a1, a2));
  return (f_memcache_pconnect(a0, a1, a2, a3));
}
Variant i_mcrypt_enc_get_algorithms_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_algorithms_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_algorithms_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_algorithms_name(arg0));
  }
}
Variant ifa_mcrypt_enc_get_algorithms_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_algorithms_name", count, 1, 1, 1);
  return (f_mcrypt_enc_get_algorithms_name(a0));
}
Variant i_hphp_splfileobject_rewind(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_rewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_rewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_rewind(arg0), null);
  }
}
Variant ifa_hphp_splfileobject_rewind(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_rewind", count, 1, 1, 1);
  return (f_hphp_splfileobject_rewind(a0), null);
}
Variant i_fprintf(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fprintf);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fprintf", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fprintf(count, arg0, arg1));
    return (f_fprintf(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_fprintf(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("fprintf", count+1, 1);
  if (count <= 2) return (f_fprintf(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_fprintf(count,a0, a1, params));
}
Variant i_extension_loaded(void *extra, CArrRef params) {
  FUNCTION_INJECTION(extension_loaded);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("extension_loaded", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_extension_loaded(arg0));
  }
}
Variant ifa_extension_loaded(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("extension_loaded", count, 1, 1, 1);
  return (f_extension_loaded(a0));
}
Variant i_mb_detect_order(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_detect_order);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_detect_order", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_detect_order());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_detect_order(arg0));
  }
}
Variant ifa_mb_detect_order(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mb_detect_order", 1, 1);
  if (count <= 0) return (f_mb_detect_order());
  return (f_mb_detect_order(a0));
}
Variant i_magickmapimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickmapimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickmapimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmapimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickmapimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magickmapimage", count, 3, 3, 1);
  return (f_magickmapimage(a0, a1, a2));
}
Variant i_get_magic_quotes_runtime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_magic_quotes_runtime);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_magic_quotes_runtime", 0, 1);
  return (f_get_magic_quotes_runtime());
}
Variant ifa_get_magic_quotes_runtime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("get_magic_quotes_runtime", 0, 1);
  return (f_get_magic_quotes_runtime());
}
Variant i_pixelsetopacityquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetopacityquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetopacityquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetopacityquantum(arg0, arg1), null);
  }
}
Variant ifa_pixelsetopacityquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetopacityquantum", count, 2, 2, 1);
  return (f_pixelsetopacityquantum(a0, a1), null);
}
Variant i_ctype_space(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ctype_space);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_space", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_space(arg0));
  }
}
Variant ifa_ctype_space(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ctype_space", count, 1, 1, 1);
  return (f_ctype_space(a0));
}
Variant i_destroymagickwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(destroymagickwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroymagickwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroymagickwand(arg0), null);
  }
}
Variant ifa_destroymagickwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("destroymagickwand", count, 1, 1, 1);
  return (f_destroymagickwand(a0), null);
}
Variant i_mcrypt_generic_init(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_generic_init);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("mcrypt_generic_init", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_generic_init(arg0, arg1, arg2));
  }
}
Variant ifa_mcrypt_generic_init(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("mcrypt_generic_init", count, 3, 3, 1);
  return (f_mcrypt_generic_init(a0, a1, a2));
}
Variant i_quoted_printable_decode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(quoted_printable_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quoted_printable_decode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_quoted_printable_decode(arg0));
  }
}
Variant ifa_quoted_printable_decode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("quoted_printable_decode", count, 1, 1, 1);
  return (f_quoted_printable_decode(a0));
}
Variant i_hphp_splfileinfo_getfileinfo(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getfileinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getfileinfo", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_getfileinfo(arg0, arg1));
  }
}
Variant ifa_hphp_splfileinfo_getfileinfo(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getfileinfo", count, 2, 2, 1);
  return (f_hphp_splfileinfo_getfileinfo(a0, a1));
}
Variant i_get_cfg_var(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_cfg_var);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_cfg_var", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_cfg_var(arg0));
  }
}
Variant ifa_get_cfg_var(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("get_cfg_var", count, 1, 1, 1);
  return (f_get_cfg_var(a0));
}
Variant i_imagerectangle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagerectangle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagerectangle", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagerectangle(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imagerectangle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("imagerectangle", count, 6, 6, 1);
  return (f_imagerectangle(a0, a1, a2, a3, a4, a5));
}
Variant i_call_user_func_rpc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(call_user_func_rpc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5) return throw_missing_arguments("call_user_func_rpc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_call_user_func_rpc(count, arg0, arg1, arg2, arg3, arg4));
    return (f_call_user_func_rpc(count,arg0, arg1, arg2, arg3, arg4, params.slice(5, count - 5, false)));
  }
}
Variant ifa_call_user_func_rpc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 5) return throw_missing_arguments("call_user_func_rpc", count+1, 1);
  if (count <= 5) return (f_call_user_func_rpc(count, a0, a1, a2, a3, a4));
  Array params;
  if (count >= 6) params.append(a5);
  return (f_call_user_func_rpc(count,a0, a1, a2, a3, a4, params));
}
Variant i_pixelgetalphaquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetalphaquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetalphaquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetalphaquantum(arg0));
  }
}
Variant ifa_pixelgetalphaquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetalphaquantum", count, 1, 1, 1);
  return (f_pixelgetalphaquantum(a0));
}
Variant i_fb_renamed_functions(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_renamed_functions);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_renamed_functions", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_renamed_functions(arg0), null);
  }
}
Variant ifa_fb_renamed_functions(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fb_renamed_functions", count, 1, 1, 1);
  return (f_fb_renamed_functions(a0), null);
}
Variant i_imagepsextendfont(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagepsextendfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsextendfont", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepsextendfont(arg0, arg1));
  }
}
Variant ifa_imagepsextendfont(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagepsextendfont", count, 2, 2, 1);
  return (f_imagepsextendfont(a0, a1));
}
Variant i_magickgetimageblob(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageblob);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageblob", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageblob(arg0));
  }
}
Variant ifa_magickgetimageblob(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimageblob", count, 1, 1, 1);
  return (f_magickgetimageblob(a0));
}
Variant i_stream_get_filters(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_get_filters);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_filters", 0, 1);
  return (f_stream_get_filters());
}
Variant ifa_stream_get_filters(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("stream_get_filters", 0, 1);
  return (f_stream_get_filters());
}
Variant i_magickqueryfontmetrics(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickqueryfontmetrics);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickqueryfontmetrics", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickqueryfontmetrics(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickqueryfontmetrics(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickqueryfontmetrics(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickqueryfontmetrics", count, 3, 4, 1);
  if (count <= 3) return (f_magickqueryfontmetrics(a0, a1, a2));
  return (f_magickqueryfontmetrics(a0, a1, a2, a3));
}
Variant i_ispixeliterator(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ispixeliterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ispixeliterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ispixeliterator(arg0));
  }
}
Variant ifa_ispixeliterator(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ispixeliterator", count, 1, 1, 1);
  return (f_ispixeliterator(a0));
}
Variant i_imagefilledarc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagefilledarc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagefilledarc", count, 9, 9, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilledarc(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
  }
}
Variant ifa_imagefilledarc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 9) return throw_wrong_arguments("imagefilledarc", count, 9, 9, 1);
  return (f_imagefilledarc(a0, a1, a2, a3, a4, a5, null, null, null));
}
Variant i_getdate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getdate);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("getdate", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_getdate());
    CVarRef arg0((ad->getValue(pos)));
    return (f_getdate(arg0));
  }
}
Variant ifa_getdate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("getdate", 1, 1);
  if (count <= 0) return (f_getdate());
  return (f_getdate(a0));
}
Variant i_hphp_debug_caller_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_debug_caller_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_debug_caller_info", 0, 1);
  return (f_hphp_debug_caller_info());
}
Variant ifa_hphp_debug_caller_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("hphp_debug_caller_info", 0, 1);
  return (f_hphp_debug_caller_info());
}
Variant i_xmlwriter_write_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_attribute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_attribute(arg0, arg1, arg2));
  }
}
Variant ifa_xmlwriter_write_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_attribute", count, 3, 3, 1);
  return (f_xmlwriter_write_attribute(a0, a1, a2));
}
Variant i_imagearc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagearc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagearc", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagearc(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant ifa_imagearc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 8) return throw_wrong_arguments("imagearc", count, 8, 8, 1);
  return (f_imagearc(a0, a1, a2, a3, a4, a5, null, null));
}
Variant i_magickreadimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickreadimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimages", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickreadimages(arg0, arg1));
  }
}
Variant ifa_magickreadimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickreadimages", count, 2, 2, 1);
  return (f_magickreadimages(a0, a1));
}
Variant i_drawgetgravity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetgravity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetgravity", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetgravity(arg0));
  }
}
Variant ifa_drawgetgravity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetgravity", count, 1, 1, 1);
  return (f_drawgetgravity(a0));
}
Variant i_connection_status(void *extra, CArrRef params) {
  FUNCTION_INJECTION(connection_status);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_status", 0, 1);
  return (f_connection_status());
}
Variant ifa_connection_status(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("connection_status", 0, 1);
  return (f_connection_status());
}
Variant i_imagecreatefromgd2(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromgd2);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgd2", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromgd2(arg0));
  }
}
Variant ifa_imagecreatefromgd2(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagecreatefromgd2", count, 1, 1, 1);
  return (f_imagecreatefromgd2(a0));
}
Variant i_stream_socket_shutdown(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_socket_shutdown);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_socket_shutdown", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_shutdown(arg0, arg1));
  }
}
Variant ifa_stream_socket_shutdown(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stream_socket_shutdown", count, 2, 2, 1);
  return (f_stream_socket_shutdown(a0, a1));
}
Variant i_pixelresetiterator(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelresetiterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelresetiterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelresetiterator(arg0), null);
  }
}
Variant ifa_pixelresetiterator(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelresetiterator", count, 1, 1, 1);
  return (f_pixelresetiterator(a0), null);
}
Variant i_msg_send(void *extra, CArrRef params) {
  FUNCTION_INJECTION(msg_send);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("msg_send", count, 3, 6, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_msg_send(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_msg_send(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_msg_send(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_msg_send(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_msg_send(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 6) return throw_wrong_arguments("msg_send", count, 3, 6, 1);
  if (count <= 3) return (f_msg_send(a0, a1, a2));
  if (count == 4) return (f_msg_send(a0, a1, a2, a3));
  if (count == 5) return (f_msg_send(a0, a1, a2, a3, a4));
  return (f_msg_send(a0, a1, a2, a3, a4, ref(a5)));
}
Variant i_getmygid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getmygid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmygid", 0, 1);
  return (f_getmygid());
}
Variant ifa_getmygid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("getmygid", 0, 1);
  return (f_getmygid());
}
Variant i_dom_document_get_element_by_id(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_get_element_by_id);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_get_element_by_id", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_get_element_by_id(arg0, arg1));
  }
}
Variant ifa_dom_document_get_element_by_id(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_get_element_by_id", count, 2, 2, 1);
  return (f_dom_document_get_element_by_id(a0, a1));
}
Variant i_array_udiff_uassoc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_udiff_uassoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4) return throw_missing_arguments("array_udiff_uassoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_array_udiff_uassoc(count, arg0, arg1, arg2, arg3));
    return (f_array_udiff_uassoc(count,arg0, arg1, arg2, arg3, params.slice(4, count - 4, false)));
  }
}
Variant ifa_array_udiff_uassoc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 4) return throw_missing_arguments("array_udiff_uassoc", count+1, 1);
  if (count <= 4) return (f_array_udiff_uassoc(count, a0, a1, a2, a3));
  Array params;
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_udiff_uassoc(count,a0, a1, a2, a3, params));
}
Variant i_strptime(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strptime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strptime", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strptime(arg0, arg1));
  }
}
Variant ifa_strptime(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("strptime", count, 2, 2, 1);
  return (f_strptime(a0, a1));
}
Variant i_array_diff_uassoc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_diff_uassoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_diff_uassoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_diff_uassoc(count, arg0, arg1, arg2));
    return (f_array_diff_uassoc(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant ifa_array_diff_uassoc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3) return throw_missing_arguments("array_diff_uassoc", count+1, 1);
  if (count <= 3) return (f_array_diff_uassoc(count, a0, a1, a2));
  Array params;
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_diff_uassoc(count,a0, a1, a2, params));
}
Variant i_xml_set_character_data_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_set_character_data_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_character_data_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_character_data_handler(arg0, arg1));
  }
}
Variant ifa_xml_set_character_data_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xml_set_character_data_handler", count, 2, 2, 1);
  return (f_xml_set_character_data_handler(a0, a1));
}
Variant i_pcntl_waitpid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_waitpid);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("pcntl_waitpid", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_pcntl_waitpid(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_waitpid(arg0, arg1, arg2));
  }
}
Variant ifa_pcntl_waitpid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("pcntl_waitpid", count, 2, 3, 1);
  if (count <= 2) return (f_pcntl_waitpid(a0, ref(a1)));
  return (f_pcntl_waitpid(a0, ref(a1), a2));
}
Variant i_array_replace_recursive(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_replace_recursive);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_replace_recursive", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_replace_recursive(count, arg0));
    return (f_array_replace_recursive(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_array_replace_recursive(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("array_replace_recursive", count+1, 1);
  if (count <= 1) return (f_array_replace_recursive(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_replace_recursive(count,a0, params));
}
Variant i_gd_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gd_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("gd_info", 0, 1);
  return (f_gd_info());
}
Variant ifa_gd_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("gd_info", 0, 1);
  return (f_gd_info());
}
Variant i_stream_get_transports(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_get_transports);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_transports", 0, 1);
  return (f_stream_get_transports());
}
Variant ifa_stream_get_transports(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("stream_get_transports", 0, 1);
  return (f_stream_get_transports());
}
Variant i_drawsetstrokepatternurl(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokepatternurl);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokepatternurl", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokepatternurl(arg0, arg1));
  }
}
Variant ifa_drawsetstrokepatternurl(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetstrokepatternurl", count, 2, 2, 1);
  return (f_drawsetstrokepatternurl(a0, a1));
}
Variant i_ldap_add(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_add);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_add", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_add(arg0, arg1, arg2));
  }
}
Variant ifa_ldap_add(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("ldap_add", count, 3, 3, 1);
  return (f_ldap_add(a0, a1, a2));
}
Variant i_acosh(void *extra, CArrRef params) {
  FUNCTION_INJECTION(acosh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("acosh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_acosh(arg0));
  }
}
Variant ifa_acosh(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("acosh", count, 1, 1, 1);
  return (f_acosh(a0));
}
Variant i_drawsetfillrule(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetfillrule);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillrule", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfillrule(arg0, arg1), null);
  }
}
Variant ifa_drawsetfillrule(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetfillrule", count, 2, 2, 1);
  return (f_drawsetfillrule(a0, a1), null);
}
Variant i_posix_getlogin(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getlogin);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getlogin", 0, 1);
  return (f_posix_getlogin());
}
Variant ifa_posix_getlogin(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_getlogin", 0, 1);
  return (f_posix_getlogin());
}
Variant i_posix_getsid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getsid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getsid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getsid(arg0));
  }
}
Variant ifa_posix_getsid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_getsid", count, 1, 1, 1);
  return (f_posix_getsid(a0));
}
Variant i_imagegd2(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagegd2);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("imagegd2", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagegd2(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_imagegd2(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_imagegd2(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagegd2(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagegd2(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("imagegd2", count, 1, 4, 1);
  if (count <= 1) return (f_imagegd2(a0));
  if (count == 2) return (f_imagegd2(a0, a1));
  if (count == 3) return (f_imagegd2(a0, a1, a2));
  return (f_imagegd2(a0, a1, a2, a3));
}
Variant i_imagecreate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecreate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecreate(arg0, arg1));
  }
}
Variant ifa_imagecreate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagecreate", count, 2, 2, 1);
  return (f_imagecreate(a0, a1));
}
Variant i_socket_create_pair(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_create_pair);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_create_pair", count, 4, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_socket_create_pair(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_socket_create_pair(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("socket_create_pair", count, 4, 4, 1);
  return (f_socket_create_pair(a0, a1, a2, ref(a3)));
}
Variant i_openssl_x509_check_private_key(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_check_private_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("openssl_x509_check_private_key", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_x509_check_private_key(arg0, arg1));
  }
}
Variant ifa_openssl_x509_check_private_key(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("openssl_x509_check_private_key", count, 2, 2, 1);
  return (f_openssl_x509_check_private_key(a0, a1));
}
Variant i_collator_get_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(collator_get_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_get_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_get_attribute(arg0, arg1));
  }
}
Variant ifa_collator_get_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("collator_get_attribute", count, 2, 2, 1);
  return (f_collator_get_attribute(a0, a1));
}
Variant i_shm_put_var(void *extra, CArrRef params) {
  FUNCTION_INJECTION(shm_put_var);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("shm_put_var", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_shm_put_var(arg0, arg1, arg2));
  }
}
Variant ifa_shm_put_var(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("shm_put_var", count, 3, 3, 1);
  return (f_shm_put_var(a0, a1, a2));
}
Variant i_debug_print_backtrace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(debug_print_backtrace);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("debug_print_backtrace", 0, 1);
  return (f_debug_print_backtrace(), null);
}
Variant ifa_debug_print_backtrace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("debug_print_backtrace", 0, 1);
  return (f_debug_print_backtrace(), null);
}
Variant i_hphp_splfileobject_seek(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_seek);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_seek", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_seek(arg0, arg1), null);
  }
}
Variant ifa_hphp_splfileobject_seek(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_seek", count, 2, 2, 1);
  return (f_hphp_splfileobject_seek(a0, a1), null);
}
Variant i_stream_set_blocking(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_set_blocking);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_set_blocking", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_set_blocking(arg0, arg1));
  }
}
Variant ifa_stream_set_blocking(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stream_set_blocking", count, 2, 2, 1);
  return (f_stream_set_blocking(a0, a1));
}
Variant i_ezmlm_hash(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ezmlm_hash);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ezmlm_hash", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ezmlm_hash(arg0));
  }
}
Variant ifa_ezmlm_hash(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ezmlm_hash", count, 1, 1, 1);
  return (f_ezmlm_hash(a0));
}
Variant i_xml_parser_get_option(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_parser_get_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_parser_get_option", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_parser_get_option(arg0, arg1));
  }
}
Variant ifa_xml_parser_get_option(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xml_parser_get_option", count, 2, 2, 1);
  return (f_xml_parser_get_option(a0, a1));
}
Variant i_array_search(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_search);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_search", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_search(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_search(arg0, arg1, arg2));
  }
}
Variant ifa_array_search(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("array_search", count, 2, 3, 1);
  if (count <= 2) return (f_array_search(a0, a1));
  return (f_array_search(a0, a1, a2));
}
Variant i_is_int(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_int);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_int", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_int(arg0));
  }
}
Variant ifa_is_int(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_int", count, 1, 1, 1);
  return (f_is_int(a0));
}
Variant i_dangling_server_proxy_new_request(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dangling_server_proxy_new_request);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dangling_server_proxy_new_request", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dangling_server_proxy_new_request(arg0));
  }
}
Variant ifa_dangling_server_proxy_new_request(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dangling_server_proxy_new_request", count, 1, 1, 1);
  return (f_dangling_server_proxy_new_request(a0));
}
Variant i_xmlwriter_end_dtd_entity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_dtd_entity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_entity", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_dtd_entity(arg0));
  }
}
Variant ifa_xmlwriter_end_dtd_entity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_entity", count, 1, 1, 1);
  return (f_xmlwriter_end_dtd_entity(a0));
}
Variant i_trim(void *extra, CArrRef params) {
  FUNCTION_INJECTION(trim);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("trim", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_trim(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_trim(arg0, arg1));
  }
}
Variant ifa_trim(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("trim", count, 1, 2, 1);
  if (count <= 1) return (f_trim(a0));
  return (f_trim(a0, a1));
}
Variant i_drawpathclose(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathclose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathclose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpathclose(arg0), null);
  }
}
Variant ifa_drawpathclose(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawpathclose", count, 1, 1, 1);
  return (f_drawpathclose(a0), null);
}
Variant i_magickprofileimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickprofileimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickprofileimage", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickprofileimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickprofileimage(arg0, arg1, arg2));
  }
}
Variant ifa_magickprofileimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("magickprofileimage", count, 2, 3, 1);
  if (count <= 2) return (f_magickprofileimage(a0, a1));
  return (f_magickprofileimage(a0, a1, a2));
}
Variant i_connection_timeout(void *extra, CArrRef params) {
  FUNCTION_INJECTION(connection_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_timeout", 0, 1);
  return (f_connection_timeout());
}
Variant ifa_connection_timeout(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("connection_timeout", 0, 1);
  return (f_connection_timeout());
}
Variant i_mysql_data_seek(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_data_seek);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mysql_data_seek", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_data_seek(arg0, arg1));
  }
}
Variant ifa_mysql_data_seek(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("mysql_data_seek", count, 2, 2, 1);
  return (f_mysql_data_seek(a0, a1));
}
Variant i_pixelgetindex(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetindex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetindex", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetindex(arg0));
  }
}
Variant ifa_pixelgetindex(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetindex", count, 1, 1, 1);
  return (f_pixelgetindex(a0));
}
Variant i_class_implements(void *extra, CArrRef params) {
  FUNCTION_INJECTION(class_implements);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_implements", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_class_implements(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_class_implements(arg0, arg1));
  }
}
Variant ifa_class_implements(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("class_implements", count, 1, 2, 1);
  if (count <= 1) return (f_class_implements(a0));
  return (f_class_implements(a0, a1));
}
Variant i_hebrevc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hebrevc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hebrevc", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_hebrevc(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hebrevc(arg0, arg1));
  }
}
Variant ifa_hebrevc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("hebrevc", count, 1, 2, 1);
  if (count <= 1) return (f_hebrevc(a0));
  return (f_hebrevc(a0, a1));
}
Variant i_get_meta_tags(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_meta_tags);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("get_meta_tags", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_get_meta_tags(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_get_meta_tags(arg0, arg1));
  }
}
Variant ifa_get_meta_tags(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("get_meta_tags", count, 1, 2, 1);
  if (count <= 1) return (f_get_meta_tags(a0));
  return (f_get_meta_tags(a0, a1));
}
Variant i_magicknextimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicknextimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicknextimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magicknextimage(arg0));
  }
}
Variant ifa_magicknextimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magicknextimage", count, 1, 1, 1);
  return (f_magicknextimage(a0));
}
Variant i_hphp_recursivedirectoryiterator_key(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_key(arg0));
  }
}
Variant ifa_hphp_recursivedirectoryiterator_key(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_key", count, 1, 1, 1);
  return (f_hphp_recursivedirectoryiterator_key(a0));
}
Variant i_mysql_create_db(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_create_db);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_create_db", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_create_db(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_create_db(arg0, arg1));
  }
}
Variant ifa_mysql_create_db(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_create_db", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_create_db(a0));
  return (f_mysql_create_db(a0, a1));
}
Variant i_mysql_stat(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_stat);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_stat", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_stat());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_stat(arg0));
  }
}
Variant ifa_mysql_stat(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_stat", 1, 1);
  if (count <= 0) return (f_mysql_stat());
  return (f_mysql_stat(a0));
}
Variant i_get_object_vars(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_object_vars);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_object_vars", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_object_vars(arg0));
  }
}
Variant ifa_get_object_vars(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("get_object_vars", count, 1, 1, 1);
  return (f_get_object_vars(a0));
}
Variant i_msg_receive(void *extra, CArrRef params) {
  FUNCTION_INJECTION(msg_receive);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 8) return throw_wrong_arguments("msg_receive", count, 5, 8, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_msg_receive(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_msg_receive(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_msg_receive(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_msg_receive(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant ifa_msg_receive(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 5 || count > 8) return throw_wrong_arguments("msg_receive", count, 5, 8, 1);
  if (count <= 5) return (f_msg_receive(a0, a1, ref(a2), a3, ref(a4)));
  return (f_msg_receive(a0, a1, ref(a2), a3, ref(a4), a5));
}
Variant i_is_integer(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_integer);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_integer", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_integer(arg0));
  }
}
Variant ifa_is_integer(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_integer", count, 1, 1, 1);
  return (f_is_integer(a0));
}
Variant i_posix_getuid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getuid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getuid", 0, 1);
  return (f_posix_getuid());
}
Variant ifa_posix_getuid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_getuid", 0, 1);
  return (f_posix_getuid());
}
Variant i_imagecreatefromgif(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromgif);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgif", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromgif(arg0));
  }
}
Variant ifa_imagecreatefromgif(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagecreatefromgif", count, 1, 1, 1);
  return (f_imagecreatefromgif(a0));
}
Variant i_mb_send_mail(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_send_mail);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mb_send_mail", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mb_send_mail(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mb_send_mail(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_send_mail(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_mb_send_mail(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 5) return throw_wrong_arguments("mb_send_mail", count, 3, 5, 1);
  if (count <= 3) return (f_mb_send_mail(a0, a1, a2));
  if (count == 4) return (f_mb_send_mail(a0, a1, a2, a3));
  return (f_mb_send_mail(a0, a1, a2, a3, a4));
}
Variant i_hphp_splfileinfo___construct(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo___construct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo___construct", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo___construct(arg0, arg1));
  }
}
Variant ifa_hphp_splfileinfo___construct(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo___construct", count, 2, 2, 1);
  return (f_hphp_splfileinfo___construct(a0, a1));
}
Variant i_register_postsend_function(void *extra, CArrRef params) {
  FUNCTION_INJECTION(register_postsend_function);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_postsend_function", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_register_postsend_function(count, arg0), null);
    return (f_register_postsend_function(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant ifa_register_postsend_function(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("register_postsend_function", count+1, 1);
  if (count <= 1) return (f_register_postsend_function(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_register_postsend_function(count,a0, params), null);
}
Variant i_getrusage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getrusage);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("getrusage", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_getrusage());
    CVarRef arg0((ad->getValue(pos)));
    return (f_getrusage(arg0));
  }
}
Variant ifa_getrusage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("getrusage", 1, 1);
  if (count <= 0) return (f_getrusage());
  return (f_getrusage(a0));
}
Variant i_long2ip(void *extra, CArrRef params) {
  FUNCTION_INJECTION(long2ip);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("long2ip", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_long2ip(arg0));
  }
}
Variant ifa_long2ip(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("long2ip", count, 1, 1, 1);
  return (f_long2ip(a0));
}
Variant i_evhttp_set_cache(void *extra, CArrRef params) {
  FUNCTION_INJECTION(evhttp_set_cache);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("evhttp_set_cache", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_evhttp_set_cache(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_evhttp_set_cache(arg0, arg1, arg2), null);
  }
}
Variant ifa_evhttp_set_cache(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("evhttp_set_cache", count, 2, 3, 1);
  if (count <= 2) return (f_evhttp_set_cache(a0, a1), null);
  return (f_evhttp_set_cache(a0, a1, a2), null);
}
Variant i_magickoilpaintimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickoilpaintimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickoilpaintimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickoilpaintimage(arg0, arg1));
  }
}
Variant ifa_magickoilpaintimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magickoilpaintimage", count, 2, 2, 1);
  return (f_magickoilpaintimage(a0, a1));
}
Variant i_strripos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strripos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strripos", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strripos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strripos(arg0, arg1, arg2));
  }
}
Variant ifa_strripos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("strripos", count, 2, 3, 1);
  if (count <= 2) return (f_strripos(a0, a1));
  return (f_strripos(a0, a1, a2));
}
Variant i_magicksetimagecolormapcolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagecolormapcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagecolormapcolor", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagecolormapcolor(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetimagecolormapcolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksetimagecolormapcolor", count, 3, 3, 1);
  return (f_magicksetimagecolormapcolor(a0, a1, a2));
}
Variant i_magickgetfilename(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetfilename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetfilename", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetfilename(arg0));
  }
}
Variant ifa_magickgetfilename(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetfilename", count, 1, 1, 1);
  return (f_magickgetfilename(a0));
}
Variant i_magicksetimagegamma(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagegamma);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagegamma", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagegamma(arg0, arg1));
  }
}
Variant ifa_magicksetimagegamma(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagegamma", count, 2, 2, 1);
  return (f_magicksetimagegamma(a0, a1));
}
Variant i_mysql_pconnect(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_pconnect);
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("mysql_pconnect", 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_pconnect());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mysql_pconnect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mysql_pconnect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mysql_pconnect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mysql_pconnect(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_mysql_pconnect(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_pconnect(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_mysql_pconnect(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 6) return throw_toomany_arguments("mysql_pconnect", 6, 1);
  if (count <= 0) return (f_mysql_pconnect());
  if (count == 1) return (f_mysql_pconnect(a0));
  if (count == 2) return (f_mysql_pconnect(a0, a1));
  if (count == 3) return (f_mysql_pconnect(a0, a1, a2));
  if (count == 4) return (f_mysql_pconnect(a0, a1, a2, a3));
  if (count == 5) return (f_mysql_pconnect(a0, a1, a2, a3, a4));
  return (f_mysql_pconnect(a0, a1, a2, a3, a4, a5));
}
Variant i_stripos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stripos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("stripos", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stripos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stripos(arg0, arg1, arg2));
  }
}
Variant ifa_stripos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("stripos", count, 2, 3, 1);
  if (count <= 2) return (f_stripos(a0, a1));
  return (f_stripos(a0, a1, a2));
}
Variant i_http_build_query(void *extra, CArrRef params) {
  FUNCTION_INJECTION(http_build_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("http_build_query", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_http_build_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_http_build_query(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_http_build_query(arg0, arg1, arg2));
  }
}
Variant ifa_http_build_query(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("http_build_query", count, 1, 3, 1);
  if (count <= 1) return (f_http_build_query(a0));
  if (count == 2) return (f_http_build_query(a0, a1));
  return (f_http_build_query(a0, a1, a2));
}
Variant i_apc_add(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_add);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_add", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_apc_add(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_add(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_add(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_apc_add(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_add", count, 2, 4, 1);
  if (count <= 2) return (f_apc_add(a0, a1));
  if (count == 3) return (f_apc_add(a0, a1, a2));
  return (f_apc_add(a0, a1, a2, a3));
}
Variant i_iconv_strlen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iconv_strlen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("iconv_strlen", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_iconv_strlen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_strlen(arg0, arg1));
  }
}
Variant ifa_iconv_strlen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("iconv_strlen", count, 1, 2, 1);
  if (count <= 1) return (f_iconv_strlen(a0));
  return (f_iconv_strlen(a0, a1));
}
Variant i_vsprintf(void *extra, CArrRef params) {
  FUNCTION_INJECTION(vsprintf);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("vsprintf", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_vsprintf(arg0, arg1));
  }
}
Variant ifa_vsprintf(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("vsprintf", count, 2, 2, 1);
  return (f_vsprintf(a0, a1));
}
Variant i_imageistruecolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imageistruecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imageistruecolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imageistruecolor(arg0));
  }
}
Variant ifa_imageistruecolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imageistruecolor", count, 1, 1, 1);
  return (f_imageistruecolor(a0));
}
Variant i_mailparse_msg_extract_part_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_extract_part_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_part_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mailparse_msg_extract_part_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_msg_extract_part_file(arg0, arg1, arg2));
  }
}
Variant ifa_mailparse_msg_extract_part_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_part_file", count, 2, 3, 1);
  if (count <= 2) return (f_mailparse_msg_extract_part_file(a0, a1));
  return (f_mailparse_msg_extract_part_file(a0, a1, a2));
}
Variant i_dom_xpath_register_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_xpath_register_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_xpath_register_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_xpath_register_ns(arg0, arg1, arg2));
  }
}
Variant ifa_dom_xpath_register_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("dom_xpath_register_ns", count, 3, 3, 1);
  return (f_dom_xpath_register_ns(a0, a1, a2));
}
Variant i_is_nan(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_nan);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_nan", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_nan(arg0));
  }
}
Variant ifa_is_nan(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_nan", count, 1, 1, 1);
  return (f_is_nan(a0));
}
Variant i_imagegif(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagegif);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegif", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagegif(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagegif(arg0, arg1));
  }
}
Variant ifa_imagegif(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegif", count, 1, 2, 1);
  if (count <= 1) return (f_imagegif(a0));
  return (f_imagegif(a0, a1));
}
Variant i_eregi_replace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(eregi_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("eregi_replace", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_eregi_replace(arg0, arg1, arg2));
  }
}
Variant ifa_eregi_replace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("eregi_replace", count, 3, 3, 1);
  return (f_eregi_replace(a0, a1, a2));
}
Variant i_magickgetimageiterations(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimageiterations);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageiterations", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageiterations(arg0));
  }
}
Variant ifa_magickgetimageiterations(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimageiterations", count, 1, 1, 1);
  return (f_magickgetimageiterations(a0));
}
Variant i_register_tick_function(void *extra, CArrRef params) {
  FUNCTION_INJECTION(register_tick_function);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_tick_function", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_register_tick_function(count, arg0));
    return (f_register_tick_function(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_register_tick_function(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("register_tick_function", count+1, 1);
  if (count <= 1) return (f_register_tick_function(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_register_tick_function(count,a0, params));
}
Variant i_pixelsetblackquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetblackquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblackquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetblackquantum(arg0, arg1), null);
  }
}
Variant ifa_pixelsetblackquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetblackquantum", count, 2, 2, 1);
  return (f_pixelsetblackquantum(a0, a1), null);
}
Variant i_jpeg2wbmp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(jpeg2wbmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("jpeg2wbmp", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_jpeg2wbmp(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_jpeg2wbmp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("jpeg2wbmp", count, 5, 5, 1);
  return (f_jpeg2wbmp(a0, a1, a2, a3, a4));
}
Variant i_mcrypt_get_iv_size(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_get_iv_size);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_get_iv_size", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_get_iv_size(arg0, arg1));
  }
}
Variant ifa_mcrypt_get_iv_size(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("mcrypt_get_iv_size", count, 2, 2, 1);
  return (f_mcrypt_get_iv_size(a0, a1));
}
Variant i_mysql_fetch_array(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_array);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_fetch_array", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_fetch_array(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_fetch_array(arg0, arg1));
  }
}
Variant ifa_mysql_fetch_array(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_fetch_array", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_fetch_array(a0));
  return (f_mysql_fetch_array(a0, a1));
}
Variant i_magickpreviousimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickpreviousimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickpreviousimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickpreviousimage(arg0));
  }
}
Variant ifa_magickpreviousimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickpreviousimage", count, 1, 1, 1);
  return (f_magickpreviousimage(a0));
}
Variant i_magickborderimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickborderimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickborderimage", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickborderimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickborderimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("magickborderimage", count, 4, 4, 1);
  return (f_magickborderimage(a0, a1, a2, a3));
}
Variant i_mcrypt_module_is_block_mode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_is_block_mode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_mode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_is_block_mode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_is_block_mode(arg0, arg1));
  }
}
Variant ifa_mcrypt_module_is_block_mode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_mode", count, 1, 2, 1);
  if (count <= 1) return (f_mcrypt_module_is_block_mode(a0));
  return (f_mcrypt_module_is_block_mode(a0, a1));
}
Variant i_mb_substr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_substr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_substr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_substr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_substr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_substr(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_mb_substr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_substr", count, 2, 4, 1);
  if (count <= 2) return (f_mb_substr(a0, a1));
  if (count == 3) return (f_mb_substr(a0, a1, a2));
  return (f_mb_substr(a0, a1, a2, a3));
}
Variant i_get_defined_constants(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_defined_constants);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_defined_constants", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_defined_constants());
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_defined_constants(arg0));
  }
}
Variant ifa_get_defined_constants(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("get_defined_constants", 1, 1);
  if (count <= 0) return (f_get_defined_constants());
  return (f_get_defined_constants(a0));
}
Variant i_mcrypt_enc_is_block_mode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_is_block_mode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_mode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_is_block_mode(arg0));
  }
}
Variant ifa_mcrypt_enc_is_block_mode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_mode", count, 1, 1, 1);
  return (f_mcrypt_enc_is_block_mode(a0));
}
Variant i_mailparse_stream_encode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mailparse_stream_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("mailparse_stream_encode", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_stream_encode(arg0, arg1, arg2));
  }
}
Variant ifa_mailparse_stream_encode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("mailparse_stream_encode", count, 3, 3, 1);
  return (f_mailparse_stream_encode(a0, a1, a2));
}
Variant i_drawsetstrokedashoffset(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokedashoffset);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokedashoffset", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokedashoffset(arg0, arg1), null);
  }
}
Variant ifa_drawsetstrokedashoffset(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetstrokedashoffset", count, 2, 2, 1);
  return (f_drawsetstrokedashoffset(a0, a1), null);
}
Variant i_php_ini_scanned_files(void *extra, CArrRef params) {
  FUNCTION_INJECTION(php_ini_scanned_files);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_ini_scanned_files", 0, 1);
  return (f_php_ini_scanned_files());
}
Variant ifa_php_ini_scanned_files(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("php_ini_scanned_files", 0, 1);
  return (f_php_ini_scanned_files());
}
Variant i_disk_free_space(void *extra, CArrRef params) {
  FUNCTION_INJECTION(disk_free_space);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("disk_free_space", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_disk_free_space(arg0));
  }
}
Variant ifa_disk_free_space(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("disk_free_space", count, 1, 1, 1);
  return (f_disk_free_space(a0));
}
Variant i_pixelsetyellowquantum(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetyellowquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetyellowquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetyellowquantum(arg0, arg1), null);
  }
}
Variant ifa_pixelsetyellowquantum(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetyellowquantum", count, 2, 2, 1);
  return (f_pixelsetyellowquantum(a0, a1), null);
}
Variant i_dom_document_create_element_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_element_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("dom_document_create_element_ns", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_dom_document_create_element_ns(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_element_ns(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_dom_document_create_element_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("dom_document_create_element_ns", count, 3, 4, 1);
  if (count <= 3) return (f_dom_document_create_element_ns(a0, a1, a2));
  return (f_dom_document_create_element_ns(a0, a1, a2, a3));
}
Variant i_openssl_public_decrypt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_public_decrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_public_decrypt", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_public_decrypt(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_public_decrypt(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_public_decrypt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_public_decrypt", count, 3, 4, 1);
  if (count <= 3) return (f_openssl_public_decrypt(a0, ref(a1), a2));
  return (f_openssl_public_decrypt(a0, ref(a1), a2, a3));
}
Variant i_convert_uuencode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(convert_uuencode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("convert_uuencode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_convert_uuencode(arg0));
  }
}
Variant ifa_convert_uuencode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("convert_uuencode", count, 1, 1, 1);
  return (f_convert_uuencode(a0));
}
Variant i_magickequalizeimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickequalizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickequalizeimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickequalizeimage(arg0));
  }
}
Variant ifa_magickequalizeimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickequalizeimage", count, 1, 1, 1);
  return (f_magickequalizeimage(a0));
}
Variant i_mysql_field_len(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_field_len);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_len", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_len(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_len(arg0, arg1));
  }
}
Variant ifa_mysql_field_len(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_len", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_field_len(a0));
  return (f_mysql_field_len(a0, a1));
}
Variant i_drawsetclipunits(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetclipunits);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetclipunits", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetclipunits(arg0, arg1), null);
  }
}
Variant ifa_drawsetclipunits(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetclipunits", count, 2, 2, 1);
  return (f_drawsetclipunits(a0, a1), null);
}
Variant i_mdecrypt_generic(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mdecrypt_generic);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mdecrypt_generic", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mdecrypt_generic(arg0, arg1));
  }
}
Variant ifa_mdecrypt_generic(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("mdecrypt_generic", count, 2, 2, 1);
  return (f_mdecrypt_generic(a0, a1));
}
Variant i_getprotobyname(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getprotobyname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getprotobyname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_getprotobyname(arg0));
  }
}
Variant ifa_getprotobyname(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("getprotobyname", count, 1, 1, 1);
  return (f_getprotobyname(a0));
}
Variant i_xmlwriter_start_pi(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_pi);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_pi", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_pi(arg0, arg1));
  }
}
Variant ifa_xmlwriter_start_pi(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_pi", count, 2, 2, 1);
  return (f_xmlwriter_start_pi(a0, a1));
}
Variant i_mysql_field_type(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_field_type);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_type", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_type(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_type(arg0, arg1));
  }
}
Variant ifa_mysql_field_type(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_type", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_field_type(a0));
  return (f_mysql_field_type(a0, a1));
}
Variant i_apc_cas(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_cas);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("apc_cas", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_apc_cas(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_cas(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_apc_cas(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("apc_cas", count, 3, 4, 1);
  if (count <= 3) return (f_apc_cas(a0, a1, a2));
  return (f_apc_cas(a0, a1, a2, a3));
}
Variant i_getopt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getopt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("getopt", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_getopt(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_getopt(arg0, arg1));
  }
}
Variant ifa_getopt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("getopt", count, 1, 2, 1);
  if (count <= 1) return (f_getopt(a0));
  return (f_getopt(a0, a1));
}
Variant i_clearpixelwand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(clearpixelwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearpixelwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_clearpixelwand(arg0), null);
  }
}
Variant ifa_clearpixelwand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("clearpixelwand", count, 1, 1, 1);
  return (f_clearpixelwand(a0), null);
}
Variant i_drawsetgravity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetgravity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetgravity", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetgravity(arg0, arg1), null);
  }
}
Variant ifa_drawsetgravity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetgravity", count, 2, 2, 1);
  return (f_drawsetgravity(a0, a1), null);
}
Variant i_magickgetimagecompressionquality(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecompressionquality);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompressionquality", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagecompressionquality(arg0));
  }
}
Variant ifa_magickgetimagecompressionquality(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagecompressionquality", count, 1, 1, 1);
  return (f_magickgetimagecompressionquality(a0));
}
Variant i_magickquantizeimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickquantizeimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickquantizeimages", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickquantizeimages(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_magickquantizeimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("magickquantizeimages", count, 6, 6, 1);
  return (f_magickquantizeimages(a0, a1, a2, a3, a4, a5));
}
Variant i_mysql_insert_id(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_insert_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_insert_id", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_insert_id());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_insert_id(arg0));
  }
}
Variant ifa_mysql_insert_id(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_insert_id", 1, 1);
  if (count <= 0) return (f_mysql_insert_id());
  return (f_mysql_insert_id(a0));
}
Variant i_hphp_thread_set_warmup_enabled(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_thread_set_warmup_enabled);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_thread_set_warmup_enabled", 0, 1);
  return (f_hphp_thread_set_warmup_enabled(), null);
}
Variant ifa_hphp_thread_set_warmup_enabled(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("hphp_thread_set_warmup_enabled", 0, 1);
  return (f_hphp_thread_set_warmup_enabled(), null);
}
Variant i_stream_context_set_param(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_context_set_param);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_context_set_param", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_context_set_param(arg0, arg1));
  }
}
Variant ifa_stream_context_set_param(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stream_context_set_param", count, 2, 2, 1);
  return (f_stream_context_set_param(a0, a1));
}
Variant i_drawpathlinetohorizontalabsolute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetohorizontalabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetohorizontalabsolute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetohorizontalabsolute(arg0, arg1), null);
  }
}
Variant ifa_drawpathlinetohorizontalabsolute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawpathlinetohorizontalabsolute", count, 2, 2, 1);
  return (f_drawpathlinetohorizontalabsolute(a0, a1), null);
}
Variant i_openssl_csr_export(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_export);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_csr_export", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_csr_export(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_csr_export(arg0, arg1, arg2));
  }
}
Variant ifa_openssl_csr_export(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_csr_export", count, 2, 3, 1);
  if (count <= 2) return (f_openssl_csr_export(a0, ref(a1)));
  return (f_openssl_csr_export(a0, ref(a1), a2));
}
Variant i_socket_connect(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_connect);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_connect", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_connect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_connect(arg0, arg1, arg2));
  }
}
Variant ifa_socket_connect(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_connect", count, 2, 3, 1);
  if (count <= 2) return (f_socket_connect(a0, a1));
  return (f_socket_connect(a0, a1, a2));
}
Variant i_stripslashes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stripslashes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stripslashes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stripslashes(arg0));
  }
}
Variant ifa_stripslashes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("stripslashes", count, 1, 1, 1);
  return (f_stripslashes(a0));
}
Variant i_magickhaspreviousimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickhaspreviousimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickhaspreviousimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickhaspreviousimage(arg0));
  }
}
Variant ifa_magickhaspreviousimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickhaspreviousimage", count, 1, 1, 1);
  return (f_magickhaspreviousimage(a0));
}
Variant i_drawgetstrokecolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokecolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokecolor(arg0));
  }
}
Variant ifa_drawgetstrokecolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgetstrokecolor", count, 1, 1, 1);
  return (f_drawgetstrokecolor(a0));
}
Variant i_imagecreatefromwbmp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromwbmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromwbmp", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromwbmp(arg0));
  }
}
Variant ifa_imagecreatefromwbmp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagecreatefromwbmp", count, 1, 1, 1);
  return (f_imagecreatefromwbmp(a0));
}
Variant i_str_repeat(void *extra, CArrRef params) {
  FUNCTION_INJECTION(str_repeat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("str_repeat", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_str_repeat(arg0, arg1));
  }
}
Variant ifa_str_repeat(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("str_repeat", count, 2, 2, 1);
  return (f_str_repeat(a0, a1));
}
Variant i_stream_resolve_include_path(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_resolve_include_path);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("stream_resolve_include_path", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_resolve_include_path(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_resolve_include_path(arg0, arg1));
  }
}
Variant ifa_stream_resolve_include_path(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("stream_resolve_include_path", count, 1, 2, 1);
  if (count <= 1) return (f_stream_resolve_include_path(a0));
  return (f_stream_resolve_include_path(a0, a1));
}
Variant i_ldap_read(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_read);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_read", count, 3, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_ldap_read(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_ldap_read(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_ldap_read(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_ldap_read(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_ldap_read(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_read(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant ifa_ldap_read(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_read", count, 3, 8, 1);
  if (count <= 3) return (f_ldap_read(a0, a1, a2));
  if (count == 4) return (f_ldap_read(a0, a1, a2, a3));
  if (count == 5) return (f_ldap_read(a0, a1, a2, a3, a4));
  return (f_ldap_read(a0, a1, a2, a3, a4, a5));
}
Variant i_apc_dec(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_dec);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_dec", count, 1, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_dec(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_dec(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_dec(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_dec(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_apc_dec(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_dec", count, 1, 4, 1);
  if (count <= 1) return (f_apc_dec(a0));
  if (count == 2) return (f_apc_dec(a0, a1));
  if (count == 3) return (f_apc_dec(a0, a1, ref(a2)));
  return (f_apc_dec(a0, a1, ref(a2), a3));
}
Variant i_posix_get_last_error(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_get_last_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_get_last_error", 0, 1);
  return (f_posix_get_last_error());
}
Variant ifa_posix_get_last_error(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("posix_get_last_error", 0, 1);
  return (f_posix_get_last_error());
}
Variant i_iptcparse(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iptcparse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("iptcparse", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_iptcparse(arg0));
  }
}
Variant ifa_iptcparse(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("iptcparse", count, 1, 1, 1);
  return (f_iptcparse(a0));
}
Variant i_iterator_count(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iterator_count);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("iterator_count", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_iterator_count(arg0));
  }
}
Variant ifa_iterator_count(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("iterator_count", count, 1, 1, 1);
  return (f_iterator_count(a0));
}
Variant i_curl_setopt_array(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_setopt_array);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_setopt_array", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_setopt_array(arg0, arg1));
  }
}
Variant ifa_curl_setopt_array(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("curl_setopt_array", count, 2, 2, 1);
  return (f_curl_setopt_array(a0, a1));
}
Variant i_socket_recvfrom(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_recvfrom);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("socket_recvfrom", count, 5, 6, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_socket_recvfrom(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_socket_recvfrom(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_socket_recvfrom(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 5 || count > 6) return throw_wrong_arguments("socket_recvfrom", count, 5, 6, 1);
  if (count <= 5) return (f_socket_recvfrom(a0, ref(a1), a2, a3, ref(a4)));
  return (f_socket_recvfrom(a0, ref(a1), a2, a3, ref(a4), ref(a5)));
}
Variant i_imagepstext(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagepstext);
  int count __attribute__((__unused__)) = params.size();
  if (count < 8 || count > 12) return throw_wrong_arguments("imagepstext", count, 8, 12, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 8) return (f_imagepstext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 9) return (f_imagepstext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
    CVarRef arg9((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 10) return (f_imagepstext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9));
    CVarRef arg10((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 11) return (f_imagepstext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10));
    CVarRef arg11((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepstext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11));
  }
}
Variant ifa_imagepstext(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 8 || count > 12) return throw_wrong_arguments("imagepstext", count, 8, 12, 1);
  return (f_imagepstext(a0, a1, a2, a3, a4, a5, null, null));
}
Variant i_mb_encode_mimeheader(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_encode_mimeheader);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("mb_encode_mimeheader", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_encode_mimeheader(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mb_encode_mimeheader(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_encode_mimeheader(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mb_encode_mimeheader(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_encode_mimeheader(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_mb_encode_mimeheader(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 5) return throw_wrong_arguments("mb_encode_mimeheader", count, 1, 5, 1);
  if (count <= 1) return (f_mb_encode_mimeheader(a0));
  if (count == 2) return (f_mb_encode_mimeheader(a0, a1));
  if (count == 3) return (f_mb_encode_mimeheader(a0, a1, a2));
  if (count == 4) return (f_mb_encode_mimeheader(a0, a1, a2, a3));
  return (f_mb_encode_mimeheader(a0, a1, a2, a3, a4));
}
Variant i_socket_getsockname(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_getsockname);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_getsockname", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_getsockname(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_socket_getsockname(arg0, arg1, arg2));
  }
}
Variant ifa_socket_getsockname(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_getsockname", count, 2, 3, 1);
  if (count <= 2) return (f_socket_getsockname(a0, ref(a1)));
  return (f_socket_getsockname(a0, ref(a1), ref(a2)));
}
Variant i_imagecreatefromstring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromstring(arg0));
  }
}
Variant ifa_imagecreatefromstring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagecreatefromstring", count, 1, 1, 1);
  return (f_imagecreatefromstring(a0));
}
Variant i_vfprintf(void *extra, CArrRef params) {
  FUNCTION_INJECTION(vfprintf);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("vfprintf", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_vfprintf(arg0, arg1, arg2));
  }
}
Variant ifa_vfprintf(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("vfprintf", count, 3, 3, 1);
  return (f_vfprintf(a0, a1, a2));
}
Variant i_magickcompareimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickcompareimages);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickcompareimages", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickcompareimages(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcompareimages(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickcompareimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickcompareimages", count, 3, 4, 1);
  if (count <= 3) return (f_magickcompareimages(a0, a1, a2));
  return (f_magickcompareimages(a0, a1, a2, a3));
}
Variant i_fscanf(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fscanf);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fscanf", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fscanf(count, arg0, arg1));
    return (f_fscanf(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant ifa_fscanf(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2) return throw_missing_arguments("fscanf", count+1, 1);
  if (count <= 2) return (f_fscanf(count, a0, a1));
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_fscanf(count,a0, a1, params));
}
Variant i_stristr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stristr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stristr", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stristr(arg0, arg1));
  }
}
Variant ifa_stristr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stristr", count, 2, 2, 1);
  return (f_stristr(a0, a1));
}
Variant i_xml_parser_set_option(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xml_parser_set_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xml_parser_set_option", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_parser_set_option(arg0, arg1, arg2));
  }
}
Variant ifa_xml_parser_set_option(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("xml_parser_set_option", count, 3, 3, 1);
  return (f_xml_parser_set_option(a0, a1, a2));
}
Variant i_dom_document_schema_validate_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_schema_validate_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_schema_validate_file", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_schema_validate_file(arg0, arg1));
  }
}
Variant ifa_dom_document_schema_validate_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_schema_validate_file", count, 2, 2, 1);
  return (f_dom_document_schema_validate_file(a0, a1));
}
Variant i_magicksetimageinterlacescheme(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimageinterlacescheme);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageinterlacescheme", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageinterlacescheme(arg0, arg1));
  }
}
Variant ifa_magicksetimageinterlacescheme(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimageinterlacescheme", count, 2, 2, 1);
  return (f_magicksetimageinterlacescheme(a0, a1));
}
Variant i_dom_element_get_attribute_node(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_attribute_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_attribute_node", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_attribute_node(arg0, arg1));
  }
}
Variant ifa_dom_element_get_attribute_node(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_element_get_attribute_node", count, 2, 2, 1);
  return (f_dom_element_get_attribute_node(a0, a1));
}
Variant i_dom_document_create_cdatasection(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_cdatasection);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_cdatasection", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_cdatasection(arg0, arg1));
  }
}
Variant ifa_dom_document_create_cdatasection(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_create_cdatasection", count, 2, 2, 1);
  return (f_dom_document_create_cdatasection(a0, a1));
}
Variant i_destroypixeliterator(void *extra, CArrRef params) {
  FUNCTION_INJECTION(destroypixeliterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixeliterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroypixeliterator(arg0), null);
  }
}
Variant ifa_destroypixeliterator(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("destroypixeliterator", count, 1, 1, 1);
  return (f_destroypixeliterator(a0), null);
}
Variant i_magicksetimagetype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagetype", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagetype(arg0, arg1));
  }
}
Variant ifa_magicksetimagetype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagetype", count, 2, 2, 1);
  return (f_magicksetimagetype(a0, a1));
}
Variant i_hphp_recursiveiteratoriterator_getinneriterator(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_getinneriterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_getinneriterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_getinneriterator(arg0));
  }
}
Variant ifa_hphp_recursiveiteratoriterator_getinneriterator(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_getinneriterator", count, 1, 1, 1);
  return (f_hphp_recursiveiteratoriterator_getinneriterator(a0));
}
Variant i_date_sunrise(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_sunrise);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("date_sunrise", count, 1, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_date_sunrise(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_date_sunrise(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_date_sunrise(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_date_sunrise(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_date_sunrise(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_sunrise(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_date_sunrise(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 6) return throw_wrong_arguments("date_sunrise", count, 1, 6, 1);
  if (count <= 1) return (f_date_sunrise(a0));
  if (count == 2) return (f_date_sunrise(a0, a1));
  if (count == 3) return (f_date_sunrise(a0, a1, a2));
  if (count == 4) return (f_date_sunrise(a0, a1, a2, a3));
  if (count == 5) return (f_date_sunrise(a0, a1, a2, a3, a4));
  return (f_date_sunrise(a0, a1, a2, a3, a4, a5));
}
Variant i_magickgethomeurl(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgethomeurl);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgethomeurl", 0, 1);
  return (f_magickgethomeurl());
}
Variant ifa_magickgethomeurl(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("magickgethomeurl", 0, 1);
  return (f_magickgethomeurl());
}
Variant i_mb_detect_encoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_detect_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_detect_encoding", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_detect_encoding(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mb_detect_encoding(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_detect_encoding(arg0, arg1, arg2));
  }
}
Variant ifa_mb_detect_encoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_detect_encoding", count, 1, 3, 1);
  if (count <= 1) return (f_mb_detect_encoding(a0));
  if (count == 2) return (f_mb_detect_encoding(a0, a1));
  return (f_mb_detect_encoding(a0, a1, a2));
}
Variant i_wandhasexception(void *extra, CArrRef params) {
  FUNCTION_INJECTION(wandhasexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandhasexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_wandhasexception(arg0));
  }
}
Variant ifa_wandhasexception(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("wandhasexception", count, 1, 1, 1);
  return (f_wandhasexception(a0));
}
Variant i_error_reporting(void *extra, CArrRef params) {
  FUNCTION_INJECTION(error_reporting);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("error_reporting", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_error_reporting());
    CVarRef arg0((ad->getValue(pos)));
    return (f_error_reporting(arg0));
  }
}
Variant ifa_error_reporting(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("error_reporting", 1, 1);
  if (count <= 0) return (f_error_reporting());
  return (f_error_reporting(a0));
}
Variant i_imagepalettecopy(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagepalettecopy);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepalettecopy", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepalettecopy(arg0, arg1), null);
  }
}
Variant ifa_imagepalettecopy(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagepalettecopy", count, 2, 2, 1);
  return (f_imagepalettecopy(a0, a1), null);
}
Variant i_hphp_splfileinfo_isexecutable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_isexecutable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isexecutable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_isexecutable(arg0));
  }
}
Variant ifa_hphp_splfileinfo_isexecutable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isexecutable", count, 1, 1, 1);
  return (f_hphp_splfileinfo_isexecutable(a0));
}
Variant i_rename_function(void *extra, CArrRef params) {
  FUNCTION_INJECTION(rename_function);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("rename_function", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rename_function(arg0, arg1));
  }
}
Variant ifa_rename_function(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("rename_function", count, 2, 2, 1);
  return (f_rename_function(a0, a1));
}
Variant i_gzcompress(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzcompress);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzcompress", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzcompress(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzcompress(arg0, arg1));
  }
}
Variant ifa_gzcompress(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("gzcompress", count, 1, 2, 1);
  if (count <= 1) return (f_gzcompress(a0));
  return (f_gzcompress(a0, a1));
}
Variant i_gzeof(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzeof);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzeof", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzeof(arg0));
  }
}
Variant ifa_gzeof(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("gzeof", count, 1, 1, 1);
  return (f_gzeof(a0));
}
Variant i_bcadd(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bcadd);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcadd", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bcadd(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcadd(arg0, arg1, arg2));
  }
}
Variant ifa_bcadd(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("bcadd", count, 2, 3, 1);
  if (count <= 2) return (f_bcadd(a0, a1));
  return (f_bcadd(a0, a1, a2));
}
Variant i_curl_setopt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_setopt);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("curl_setopt", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_setopt(arg0, arg1, arg2));
  }
}
Variant ifa_curl_setopt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("curl_setopt", count, 3, 3, 1);
  return (f_curl_setopt(a0, a1, a2));
}
Variant i_imagealphablending(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagealphablending);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagealphablending", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagealphablending(arg0, arg1));
  }
}
Variant ifa_imagealphablending(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagealphablending", count, 2, 2, 1);
  return (f_imagealphablending(a0, a1));
}
Variant i_pixelgetmagenta(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetmagenta);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetmagenta", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetmagenta(arg0));
  }
}
Variant ifa_pixelgetmagenta(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetmagenta", count, 1, 1, 1);
  return (f_pixelgetmagenta(a0));
}
Variant i_drawannotation(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawannotation);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawannotation", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawannotation(arg0, arg1, arg2, arg3), null);
  }
}
Variant ifa_drawannotation(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("drawannotation", count, 4, 4, 1);
  return (f_drawannotation(a0, a1, a2, a3), null);
}
Variant i_getmypid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getmypid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmypid", 0, 1);
  return (f_getmypid());
}
Variant ifa_getmypid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("getmypid", 0, 1);
  return (f_getmypid());
}
Variant i_magicksetimagedispose(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagedispose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagedispose", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagedispose(arg0, arg1));
  }
}
Variant ifa_magicksetimagedispose(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagedispose", count, 2, 2, 1);
  return (f_magicksetimagedispose(a0, a1));
}
Variant i_drawsetfontsize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetfontsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontsize", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfontsize(arg0, arg1), null);
  }
}
Variant ifa_drawsetfontsize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetfontsize", count, 2, 2, 1);
  return (f_drawsetfontsize(a0, a1), null);
}
Variant i_gethostbyname(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gethostbyname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbyname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gethostbyname(arg0));
  }
}
Variant ifa_gethostbyname(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("gethostbyname", count, 1, 1, 1);
  return (f_gethostbyname(a0));
}
Variant i_stream_wrapper_restore(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_wrapper_restore);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_wrapper_restore", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_wrapper_restore(arg0));
  }
}
Variant ifa_stream_wrapper_restore(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("stream_wrapper_restore", count, 1, 1, 1);
  return (f_stream_wrapper_restore(a0));
}
Variant i_magickgetimagecompression(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecompression);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompression", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagecompression(arg0));
  }
}
Variant ifa_magickgetimagecompression(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagecompression", count, 1, 1, 1);
  return (f_magickgetimagecompression(a0));
}
Variant i_hphp_invoke_method(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_invoke_method);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_invoke_method", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_invoke_method(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_hphp_invoke_method(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("hphp_invoke_method", count, 4, 4, 1);
  return (f_hphp_invoke_method(a0, a1, a2, a3));
}
Variant i_xbox_schedule_thread_reset(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xbox_schedule_thread_reset);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_schedule_thread_reset", 0, 1);
  return (f_xbox_schedule_thread_reset(), null);
}
Variant ifa_xbox_schedule_thread_reset(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("xbox_schedule_thread_reset", 0, 1);
  return (f_xbox_schedule_thread_reset(), null);
}
Variant i_date_offset_get(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_offset_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_offset_get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_date_offset_get(arg0));
  }
}
Variant ifa_date_offset_get(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("date_offset_get", count, 1, 1, 1);
  return (f_date_offset_get(a0));
}
Variant i_pixelgetiteratorexception(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetiteratorexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetiteratorexception(arg0));
  }
}
Variant ifa_pixelgetiteratorexception(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexception", count, 1, 1, 1);
  return (f_pixelgetiteratorexception(a0));
}
Variant i_mysql_field_flags(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_field_flags);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_flags", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_flags(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_flags(arg0, arg1));
  }
}
Variant ifa_mysql_field_flags(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_flags", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_field_flags(a0));
  return (f_mysql_field_flags(a0, a1));
}
Variant i_linkinfo(void *extra, CArrRef params) {
  FUNCTION_INJECTION(linkinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("linkinfo", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_linkinfo(arg0));
  }
}
Variant ifa_linkinfo(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("linkinfo", count, 1, 1, 1);
  return (f_linkinfo(a0));
}
Variant i_strchr(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strchr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strchr", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strchr(arg0, arg1));
  }
}
Variant ifa_strchr(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("strchr", count, 2, 2, 1);
  return (f_strchr(a0, a1));
}
Variant i_magickqueryformats(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickqueryformats);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryformats", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickqueryformats(arg0));
  }
}
Variant ifa_magickqueryformats(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickqueryformats", count, 1, 1, 1);
  return (f_magickqueryformats(a0));
}
Variant i_class_parents(void *extra, CArrRef params) {
  FUNCTION_INJECTION(class_parents);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_parents", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_class_parents(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_class_parents(arg0, arg1));
  }
}
Variant ifa_class_parents(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("class_parents", count, 1, 2, 1);
  if (count <= 1) return (f_class_parents(a0));
  return (f_class_parents(a0, a1));
}
Variant i_date_time_set(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_time_set);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("date_time_set", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_date_time_set(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_time_set(arg0, arg1, arg2, arg3), null);
  }
}
Variant ifa_date_time_set(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("date_time_set", count, 3, 4, 1);
  if (count <= 3) return (f_date_time_set(a0, a1, a2), null);
  return (f_date_time_set(a0, a1, a2, a3), null);
}
Variant i_iconv_strpos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iconv_strpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("iconv_strpos", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iconv_strpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_iconv_strpos(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_strpos(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_iconv_strpos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("iconv_strpos", count, 2, 4, 1);
  if (count <= 2) return (f_iconv_strpos(a0, a1));
  if (count == 3) return (f_iconv_strpos(a0, a1, a2));
  return (f_iconv_strpos(a0, a1, a2, a3));
}
Variant i_i18n_loc_set_strength(void *extra, CArrRef params) {
  FUNCTION_INJECTION(i18n_loc_set_strength);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("i18n_loc_set_strength", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_i18n_loc_set_strength(arg0));
  }
}
Variant ifa_i18n_loc_set_strength(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("i18n_loc_set_strength", count, 1, 1, 1);
  return (f_i18n_loc_set_strength(a0));
}
Variant i_magickgetimagebordercolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagebordercolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagebordercolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagebordercolor(arg0));
  }
}
Variant ifa_magickgetimagebordercolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagebordercolor", count, 1, 1, 1);
  return (f_magickgetimagebordercolor(a0));
}
Variant i_ob_end_clean(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ob_end_clean);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_end_clean", 0, 1);
  return (f_ob_end_clean());
}
Variant ifa_ob_end_clean(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("ob_end_clean", 0, 1);
  return (f_ob_end_clean());
}
Variant i_dom_document_savexml(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_savexml);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("dom_document_savexml", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dom_document_savexml(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_dom_document_savexml(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_savexml(arg0, arg1, arg2));
  }
}
Variant ifa_dom_document_savexml(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("dom_document_savexml", count, 1, 3, 1);
  if (count <= 1) return (f_dom_document_savexml(a0));
  if (count == 2) return (f_dom_document_savexml(a0, a1));
  return (f_dom_document_savexml(a0, a1, a2));
}
Variant i_trigger_error(void *extra, CArrRef params) {
  FUNCTION_INJECTION(trigger_error);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("trigger_error", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_trigger_error(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_trigger_error(arg0, arg1));
  }
}
Variant ifa_trigger_error(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("trigger_error", count, 1, 2, 1);
  if (count <= 1) return (f_trigger_error(a0));
  return (f_trigger_error(a0, a1));
}
Variant i_pcntl_getpriority(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pcntl_getpriority);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("pcntl_getpriority", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_pcntl_getpriority());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_pcntl_getpriority(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_getpriority(arg0, arg1));
  }
}
Variant ifa_pcntl_getpriority(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("pcntl_getpriority", 2, 1);
  if (count <= 0) return (f_pcntl_getpriority());
  if (count == 1) return (f_pcntl_getpriority(a0));
  return (f_pcntl_getpriority(a0, a1));
}
Variant i_date_default_timezone_get(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_default_timezone_get);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("date_default_timezone_get", 0, 1);
  return (f_date_default_timezone_get());
}
Variant ifa_date_default_timezone_get(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("date_default_timezone_get", 0, 1);
  return (f_date_default_timezone_get());
}
Variant i_strcmp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strcmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcmp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strcmp(arg0, arg1));
  }
}
Variant ifa_strcmp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("strcmp", count, 2, 2, 1);
  return (f_strcmp(a0, a1));
}
Variant i_hphp_recursivedirectoryiterator_haschildren(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_haschildren);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_haschildren", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_haschildren(arg0));
  }
}
Variant ifa_hphp_recursivedirectoryiterator_haschildren(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_haschildren", count, 1, 1, 1);
  return (f_hphp_recursivedirectoryiterator_haschildren(a0));
}
Variant i_hphp_instanceof(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_instanceof);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_instanceof", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_instanceof(arg0, arg1));
  }
}
Variant ifa_hphp_instanceof(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_instanceof", count, 2, 2, 1);
  return (f_hphp_instanceof(a0, a1));
}
Variant i_import_request_variables(void *extra, CArrRef params) {
  FUNCTION_INJECTION(import_request_variables);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("import_request_variables", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_import_request_variables(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_import_request_variables(arg0, arg1));
  }
}
Variant ifa_import_request_variables(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("import_request_variables", count, 1, 2, 1);
  if (count <= 1) return (f_import_request_variables(a0));
  return (f_import_request_variables(a0, a1));
}
Variant i_magickgetpackagename(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetpackagename);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetpackagename", 0, 1);
  return (f_magickgetpackagename());
}
Variant ifa_magickgetpackagename(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("magickgetpackagename", 0, 1);
  return (f_magickgetpackagename());
}
Variant i_destroypixelwandarray(void *extra, CArrRef params) {
  FUNCTION_INJECTION(destroypixelwandarray);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwandarray", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroypixelwandarray(arg0), null);
  }
}
Variant ifa_destroypixelwandarray(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("destroypixelwandarray", count, 1, 1, 1);
  return (f_destroypixelwandarray(a0), null);
}
Variant i_spliti(void *extra, CArrRef params) {
  FUNCTION_INJECTION(spliti);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("spliti", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_spliti(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_spliti(arg0, arg1, arg2));
  }
}
Variant ifa_spliti(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("spliti", count, 2, 3, 1);
  if (count <= 2) return (f_spliti(a0, a1));
  return (f_spliti(a0, a1, a2));
}
Variant i_posix_setgid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_setgid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setgid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_setgid(arg0));
  }
}
Variant ifa_posix_setgid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_setgid", count, 1, 1, 1);
  return (f_posix_setgid(a0));
}
Variant i_is_double(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_double);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_double", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_double(arg0));
  }
}
Variant ifa_is_double(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_double", count, 1, 1, 1);
  return (f_is_double(a0));
}
Variant i_output_reset_rewrite_vars(void *extra, CArrRef params) {
  FUNCTION_INJECTION(output_reset_rewrite_vars);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("output_reset_rewrite_vars", 0, 1);
  return (f_output_reset_rewrite_vars());
}
Variant ifa_output_reset_rewrite_vars(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("output_reset_rewrite_vars", 0, 1);
  return (f_output_reset_rewrite_vars());
}
Variant i_get_declared_interfaces(void *extra, CArrRef params) {
  FUNCTION_INJECTION(get_declared_interfaces);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_declared_interfaces", 0, 1);
  return (f_get_declared_interfaces());
}
Variant ifa_get_declared_interfaces(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("get_declared_interfaces", 0, 1);
  return (f_get_declared_interfaces());
}
Variant i_passthru(void *extra, CArrRef params) {
  FUNCTION_INJECTION(passthru);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("passthru", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_passthru(arg0), null);
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_passthru(arg0, arg1), null);
  }
}
Variant ifa_passthru(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("passthru", count, 1, 2, 1);
  if (count <= 1) return (f_passthru(a0), null);
  return (f_passthru(a0, ref(a1)), null);
}
Variant i_magickmontageimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickmontageimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickmontageimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmontageimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_magickmontageimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("magickmontageimage", count, 6, 6, 1);
  return (f_magickmontageimage(a0, a1, a2, a3, a4, a5));
}
Variant i_session_commit(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_commit);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_commit", 0, 1);
  return (f_session_commit(), null);
}
Variant ifa_session_commit(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("session_commit", 0, 1);
  return (f_session_commit(), null);
}
Variant i_apc_cache_info(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_cache_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apc_cache_info", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_apc_cache_info());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_apc_cache_info(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_cache_info(arg0, arg1));
  }
}
Variant ifa_apc_cache_info(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 2) return throw_toomany_arguments("apc_cache_info", 2, 1);
  if (count <= 0) return (f_apc_cache_info());
  if (count == 1) return (f_apc_cache_info(a0));
  return (f_apc_cache_info(a0, a1));
}
Variant i_convert_cyr_string(void *extra, CArrRef params) {
  FUNCTION_INJECTION(convert_cyr_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("convert_cyr_string", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_convert_cyr_string(arg0, arg1, arg2));
  }
}
Variant ifa_convert_cyr_string(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("convert_cyr_string", count, 3, 3, 1);
  return (f_convert_cyr_string(a0, a1, a2));
}
Variant i_sys_get_temp_dir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sys_get_temp_dir);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("sys_get_temp_dir", 0, 1);
  return (f_sys_get_temp_dir());
}
Variant ifa_sys_get_temp_dir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("sys_get_temp_dir", 0, 1);
  return (f_sys_get_temp_dir());
}
Variant i_libxml_get_last_error(void *extra, CArrRef params) {
  FUNCTION_INJECTION(libxml_get_last_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_get_last_error", 0, 1);
  return (f_libxml_get_last_error());
}
Variant ifa_libxml_get_last_error(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("libxml_get_last_error", 0, 1);
  return (f_libxml_get_last_error());
}
Variant i_drawline(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawline);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawline", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawline(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant ifa_drawline(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("drawline", count, 5, 5, 1);
  return (f_drawline(a0, a1, a2, a3, a4), null);
}
Variant i_drawsetfillcolor(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetfillcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillcolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfillcolor(arg0, arg1), null);
  }
}
Variant ifa_drawsetfillcolor(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetfillcolor", count, 2, 2, 1);
  return (f_drawsetfillcolor(a0, a1), null);
}
Variant i_gzopen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzopen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzopen", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_gzopen(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzopen(arg0, arg1, arg2));
  }
}
Variant ifa_gzopen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("gzopen", count, 2, 3, 1);
  if (count <= 2) return (f_gzopen(a0, a1));
  return (f_gzopen(a0, a1, a2));
}
Variant i_getservbyport(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getservbyport);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("getservbyport", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_getservbyport(arg0, arg1));
  }
}
Variant ifa_getservbyport(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("getservbyport", count, 2, 2, 1);
  return (f_getservbyport(a0, a1));
}
Variant i_hphp_splfileinfo_getfilename(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getfilename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getfilename", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getfilename(arg0));
  }
}
Variant ifa_hphp_splfileinfo_getfilename(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getfilename", count, 1, 1, 1);
  return (f_hphp_splfileinfo_getfilename(a0));
}
Variant i_stripcslashes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stripcslashes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stripcslashes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stripcslashes(arg0));
  }
}
Variant ifa_stripcslashes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("stripcslashes", count, 1, 1, 1);
  return (f_stripcslashes(a0));
}
Variant i_curl_multi_add_handle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_multi_add_handle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_add_handle", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_multi_add_handle(arg0, arg1));
  }
}
Variant ifa_curl_multi_add_handle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("curl_multi_add_handle", count, 2, 2, 1);
  return (f_curl_multi_add_handle(a0, a1));
}
Variant i_ldap_free_result(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_free_result);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_free_result", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_free_result(arg0));
  }
}
Variant ifa_ldap_free_result(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("ldap_free_result", count, 1, 1, 1);
  return (f_ldap_free_result(a0));
}
Variant i_array_replace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_replace", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_replace(count, arg0));
    return (f_array_replace(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant ifa_array_replace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1) return throw_missing_arguments("array_replace", count+1, 1);
  if (count <= 1) return (f_array_replace(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (f_array_replace(count,a0, params));
}
Variant i_xmlwriter_end_pi(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_pi);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_pi", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_pi(arg0));
  }
}
Variant ifa_xmlwriter_end_pi(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_pi", count, 1, 1, 1);
  return (f_xmlwriter_end_pi(a0));
}
Variant i_imagewbmp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagewbmp);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagewbmp", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagewbmp(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_imagewbmp(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagewbmp(arg0, arg1, arg2));
  }
}
Variant ifa_imagewbmp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("imagewbmp", count, 1, 3, 1);
  if (count <= 1) return (f_imagewbmp(a0));
  if (count == 2) return (f_imagewbmp(a0, a1));
  return (f_imagewbmp(a0, a1, a2));
}
Variant i_shm_get_var(void *extra, CArrRef params) {
  FUNCTION_INJECTION(shm_get_var);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("shm_get_var", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_shm_get_var(arg0, arg1));
  }
}
Variant ifa_shm_get_var(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("shm_get_var", count, 2, 2, 1);
  return (f_shm_get_var(a0, a1));
}
Variant i_magickgetmimetype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetmimetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetmimetype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetmimetype(arg0));
  }
}
Variant ifa_magickgetmimetype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetmimetype", count, 1, 1, 1);
  return (f_magickgetmimetype(a0));
}
Variant i_mysql_fetch_assoc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_assoc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_assoc", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_fetch_assoc(arg0));
  }
}
Variant ifa_mysql_fetch_assoc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("mysql_fetch_assoc", count, 1, 1, 1);
  return (f_mysql_fetch_assoc(a0));
}
Variant i_socket_set_nonblock(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_set_nonblock);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_set_nonblock", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_set_nonblock(arg0));
  }
}
Variant ifa_socket_set_nonblock(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("socket_set_nonblock", count, 1, 1, 1);
  return (f_socket_set_nonblock(a0));
}
Variant i_array_filter(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_filter);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_filter", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_filter(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_filter(arg0, arg1));
  }
}
Variant ifa_array_filter(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("array_filter", count, 1, 2, 1);
  if (count <= 1) return (f_array_filter(a0));
  return (f_array_filter(a0, a1));
}
Variant i_mysql_query(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_query", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_query(arg0, arg1));
  }
}
Variant ifa_mysql_query(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_query", count, 1, 2, 1);
  if (count <= 1) return (f_mysql_query(a0));
  return (f_mysql_query(a0, a1));
}
Variant i_crypt(void *extra, CArrRef params) {
  FUNCTION_INJECTION(crypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("crypt", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_crypt(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_crypt(arg0, arg1));
  }
}
Variant ifa_crypt(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("crypt", count, 1, 2, 1);
  if (count <= 1) return (f_crypt(a0));
  return (f_crypt(a0, a1));
}
Variant i_xmlwriter_start_cdata(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_cdata);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_start_cdata", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_start_cdata(arg0));
  }
}
Variant ifa_xmlwriter_start_cdata(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xmlwriter_start_cdata", count, 1, 1, 1);
  return (f_xmlwriter_start_cdata(a0));
}
Variant i_fgetc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fgetc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fgetc", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fgetc(arg0));
  }
}
Variant ifa_fgetc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("fgetc", count, 1, 1, 1);
  return (f_fgetc(a0));
}
Variant i_move_uploaded_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(move_uploaded_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("move_uploaded_file", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_move_uploaded_file(arg0, arg1));
  }
}
Variant ifa_move_uploaded_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("move_uploaded_file", count, 2, 2, 1);
  return (f_move_uploaded_file(a0, a1));
}
Variant i_hphp_splfileobject_flock(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_flock);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_flock", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_flock(arg0, arg1));
  }
}
Variant ifa_hphp_splfileobject_flock(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_flock", count, 2, 2, 1);
  return (f_hphp_splfileobject_flock(a0, ref(a1)));
}
Variant i_imagecopyresampled(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecopyresampled);
  int count __attribute__((__unused__)) = params.size();
  if (count != 10) return throw_wrong_arguments("imagecopyresampled", count, 10, 10, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg9((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecopyresampled(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9));
  }
}
Variant ifa_imagecopyresampled(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 10) return throw_wrong_arguments("imagecopyresampled", count, 10, 10, 1);
  return (f_imagecopyresampled(a0, a1, a2, a3, a4, a5, null, null, null, null));
}
Variant i_imagecreatefrompng(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreatefrompng);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefrompng", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefrompng(arg0));
  }
}
Variant ifa_imagecreatefrompng(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagecreatefrompng", count, 1, 1, 1);
  return (f_imagecreatefrompng(a0));
}
Variant i_magickgetimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimage(arg0));
  }
}
Variant ifa_magickgetimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimage", count, 1, 1, 1);
  return (f_magickgetimage(a0));
}
Variant i_imagesettile(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagesettile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesettile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesettile(arg0, arg1));
  }
}
Variant ifa_imagesettile(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("imagesettile", count, 2, 2, 1);
  return (f_imagesettile(a0, a1));
}
Variant i_hphp_recursiveiteratoriterator_valid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_valid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_valid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_valid(arg0));
  }
}
Variant ifa_hphp_recursiveiteratoriterator_valid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_valid", count, 1, 1, 1);
  return (f_hphp_recursiveiteratoriterator_valid(a0));
}
Variant i_fgets(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fgets);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("fgets", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fgets(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fgets(arg0, arg1));
  }
}
Variant ifa_fgets(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("fgets", count, 1, 2, 1);
  if (count <= 1) return (f_fgets(a0));
  return (f_fgets(a0, a1));
}
Variant i_tempnam(void *extra, CArrRef params) {
  FUNCTION_INJECTION(tempnam);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("tempnam", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_tempnam(arg0, arg1));
  }
}
Variant ifa_tempnam(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("tempnam", count, 2, 2, 1);
  return (f_tempnam(a0, a1));
}
Variant i_bcdiv(void *extra, CArrRef params) {
  FUNCTION_INJECTION(bcdiv);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcdiv", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bcdiv(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcdiv(arg0, arg1, arg2));
  }
}
Variant ifa_bcdiv(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("bcdiv", count, 2, 3, 1);
  if (count <= 2) return (f_bcdiv(a0, a1));
  return (f_bcdiv(a0, a1, a2));
}
Variant i_hphp_splfileinfo_getbasename(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getbasename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getbasename", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_getbasename(arg0, arg1));
  }
}
Variant ifa_hphp_splfileinfo_getbasename(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getbasename", count, 2, 2, 1);
  return (f_hphp_splfileinfo_getbasename(a0, a1));
}
Variant i_rsort(void *extra, CArrRef params) {
  FUNCTION_INJECTION(rsort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("rsort", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_rsort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_rsort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rsort(arg0, arg1, arg2));
  }
}
Variant ifa_rsort(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("rsort", count, 1, 3, 1);
  if (count <= 1) return (f_rsort(ref(a0)));
  if (count == 2) return (f_rsort(ref(a0), a1));
  return (f_rsort(ref(a0), a1, a2));
}
Variant i_drawgettextdecoration(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgettextdecoration);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextdecoration", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgettextdecoration(arg0));
  }
}
Variant ifa_drawgettextdecoration(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgettextdecoration", count, 1, 1, 1);
  return (f_drawgettextdecoration(a0));
}
Variant i_strtolower(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strtolower);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strtolower", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_strtolower(arg0));
  }
}
Variant ifa_strtolower(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("strtolower", count, 1, 1, 1);
  return (f_strtolower(a0));
}
Variant i_posix_getgrgid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getgrgid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getgrgid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getgrgid(arg0));
  }
}
Variant ifa_posix_getgrgid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_getgrgid", count, 1, 1, 1);
  return (f_posix_getgrgid(a0));
}
Variant i_apc_inc(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_inc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_inc", count, 1, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_inc(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_inc(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_inc(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_inc(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_apc_inc(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_inc", count, 1, 4, 1);
  if (count <= 1) return (f_apc_inc(a0));
  if (count == 2) return (f_apc_inc(a0, a1));
  if (count == 3) return (f_apc_inc(a0, a1, ref(a2)));
  return (f_apc_inc(a0, a1, ref(a2), a3));
}
Variant i_hphp_create_object(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_create_object);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_create_object", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_create_object(arg0, arg1));
  }
}
Variant ifa_hphp_create_object(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_create_object", count, 2, 2, 1);
  return (f_hphp_create_object(a0, a1));
}
Variant i_hexdec(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hexdec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hexdec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hexdec(arg0));
  }
}
Variant ifa_hexdec(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hexdec", count, 1, 1, 1);
  return (f_hexdec(a0));
}
Variant i_imagefttext(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagefttext);
  int count __attribute__((__unused__)) = params.size();
  if (count < 8 || count > 9) return throw_wrong_arguments("imagefttext", count, 8, 9, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 8) return (f_imagefttext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefttext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
  }
}
Variant ifa_imagefttext(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 8 || count > 9) return throw_wrong_arguments("imagefttext", count, 8, 9, 1);
  return (f_imagefttext(a0, a1, a2, a3, a4, a5, null, null));
}
Variant i_xhprof_sample_disable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xhprof_sample_disable);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_sample_disable", 0, 1);
  return (f_xhprof_sample_disable());
}
Variant ifa_xhprof_sample_disable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("xhprof_sample_disable", 0, 1);
  return (f_xhprof_sample_disable());
}
Variant i_ldap_compare(void *extra, CArrRef params) {
  FUNCTION_INJECTION(ldap_compare);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("ldap_compare", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_compare(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_ldap_compare(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("ldap_compare", count, 4, 4, 1);
  return (f_ldap_compare(a0, a1, a2, a3));
}
Variant i_dns_get_record(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dns_get_record);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("dns_get_record", count, 1, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dns_get_record(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_dns_get_record(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_dns_get_record(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_dns_get_record(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_dns_get_record(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("dns_get_record", count, 1, 4, 1);
  if (count <= 1) return (f_dns_get_record(a0));
  if (count == 2) return (f_dns_get_record(a0, a1));
  if (count == 3) return (f_dns_get_record(a0, a1, ref(a2)));
  return (f_dns_get_record(a0, a1, ref(a2), ref(a3)));
}
Variant i_openssl_get_privatekey(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_get_privatekey);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_get_privatekey", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_openssl_get_privatekey(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_get_privatekey(arg0, arg1));
  }
}
Variant ifa_openssl_get_privatekey(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_get_privatekey", count, 1, 2, 1);
  if (count <= 1) return (f_openssl_get_privatekey(a0));
  return (f_openssl_get_privatekey(a0, a1));
}
Variant i_imagepng(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagepng);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("imagepng", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagepng(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_imagepng(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_imagepng(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepng(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagepng(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("imagepng", count, 1, 4, 1);
  if (count <= 1) return (f_imagepng(a0));
  if (count == 2) return (f_imagepng(a0, a1));
  if (count == 3) return (f_imagepng(a0, a1, a2));
  return (f_imagepng(a0, a1, a2, a3));
}
Variant i_socket_bind(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_bind);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_bind", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_bind(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_bind(arg0, arg1, arg2));
  }
}
Variant ifa_socket_bind(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_bind", count, 2, 3, 1);
  if (count <= 2) return (f_socket_bind(a0, a1));
  return (f_socket_bind(a0, a1, a2));
}
Variant i_getmyuid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getmyuid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmyuid", 0, 1);
  return (f_getmyuid());
}
Variant ifa_getmyuid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("getmyuid", 0, 1);
  return (f_getmyuid());
}
Variant i_pixelgetopacity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetopacity", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetopacity(arg0));
  }
}
Variant ifa_pixelgetopacity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetopacity", count, 1, 1, 1);
  return (f_pixelgetopacity(a0));
}
Variant i_drawsetstrokelinecap(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokelinecap);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokelinecap", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokelinecap(arg0, arg1), null);
  }
}
Variant ifa_drawsetstrokelinecap(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetstrokelinecap", count, 2, 2, 1);
  return (f_drawsetstrokelinecap(a0, a1), null);
}
Variant i_xmlwriter_write_attribute_ns(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("xmlwriter_write_attribute_ns", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_attribute_ns(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_xmlwriter_write_attribute_ns(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("xmlwriter_write_attribute_ns", count, 5, 5, 1);
  return (f_xmlwriter_write_attribute_ns(a0, a1, a2, a3, a4));
}
Variant i_array_keys(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_keys);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("array_keys", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_keys(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_array_keys(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_keys(arg0, arg1, arg2));
  }
}
Variant ifa_array_keys(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("array_keys", count, 1, 3, 1);
  if (count <= 1) return (f_array_keys(a0));
  if (count == 2) return (f_array_keys(a0, a1));
  return (f_array_keys(a0, a1, a2));
}
Variant i_call_user_method_array(void *extra, CArrRef params) {
  FUNCTION_INJECTION(call_user_method_array);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("call_user_method_array", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_call_user_method_array(arg0, arg1, arg2));
  }
}
Variant ifa_call_user_method_array(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("call_user_method_array", count, 3, 3, 1);
  return (f_call_user_method_array(a0, ref(a1), a2));
}
Variant i_magickmagnifyimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickmagnifyimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickmagnifyimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickmagnifyimage(arg0));
  }
}
Variant ifa_magickmagnifyimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickmagnifyimage", count, 1, 1, 1);
  return (f_magickmagnifyimage(a0));
}
Variant i_is_bool(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_bool);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_bool", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_bool(arg0));
  }
}
Variant ifa_is_bool(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_bool", count, 1, 1, 1);
  return (f_is_bool(a0));
}
Variant i_magickgetimagegreenprimary(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetimagegreenprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagegreenprimary", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagegreenprimary(arg0));
  }
}
Variant ifa_magickgetimagegreenprimary(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetimagegreenprimary", count, 1, 1, 1);
  return (f_magickgetimagegreenprimary(a0));
}
Variant i_session_start(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_start);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_start", 0, 1);
  return (f_session_start());
}
Variant ifa_session_start(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("session_start", 0, 1);
  return (f_session_start());
}
Variant i_filegroup(void *extra, CArrRef params) {
  FUNCTION_INJECTION(filegroup);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filegroup", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_filegroup(arg0));
  }
}
Variant ifa_filegroup(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("filegroup", count, 1, 1, 1);
  return (f_filegroup(a0));
}
Variant i_dom_attr_is_id(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_attr_is_id);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_attr_is_id", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_attr_is_id(arg0));
  }
}
Variant ifa_dom_attr_is_id(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("dom_attr_is_id", count, 1, 1, 1);
  return (f_dom_attr_is_id(a0));
}
Variant i_gzread(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzread);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzread", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzread(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzread(arg0, arg1));
  }
}
Variant ifa_gzread(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("gzread", count, 1, 2, 1);
  if (count <= 1) return (f_gzread(a0));
  return (f_gzread(a0, a1));
}
Variant i_drawpathellipticarcrelative(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathellipticarcrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("drawpathellipticarcrelative", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathellipticarcrelative(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7), null);
  }
}
Variant ifa_drawpathellipticarcrelative(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 8) return throw_wrong_arguments("drawpathellipticarcrelative", count, 8, 8, 1);
  return (f_drawpathellipticarcrelative(a0, a1, a2, a3, a4, a5, null, null), null);
}
Variant i_openssl_csr_export_to_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_export_to_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_csr_export_to_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_csr_export_to_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_csr_export_to_file(arg0, arg1, arg2));
  }
}
Variant ifa_openssl_csr_export_to_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_csr_export_to_file", count, 2, 3, 1);
  if (count <= 2) return (f_openssl_csr_export_to_file(a0, a1));
  return (f_openssl_csr_export_to_file(a0, a1, a2));
}
Variant i_magicksetimagecolorspace(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetimagecolorspace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecolorspace", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagecolorspace(arg0, arg1));
  }
}
Variant ifa_magicksetimagecolorspace(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("magicksetimagecolorspace", count, 2, 2, 1);
  return (f_magicksetimagecolorspace(a0, a1));
}
Variant i_nl_langinfo(void *extra, CArrRef params) {
  FUNCTION_INJECTION(nl_langinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("nl_langinfo", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_nl_langinfo(arg0));
  }
}
Variant ifa_nl_langinfo(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("nl_langinfo", count, 1, 1, 1);
  return (f_nl_langinfo(a0));
}
Variant i_hphp_get_stats(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_get_stats);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_stats", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_get_stats(arg0));
  }
}
Variant ifa_hphp_get_stats(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("hphp_get_stats", count, 1, 1, 1);
  return (f_hphp_get_stats(a0));
}
Variant i_strncmp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strncmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("strncmp", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strncmp(arg0, arg1, arg2));
  }
}
Variant ifa_strncmp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("strncmp", count, 3, 3, 1);
  return (f_strncmp(a0, a1, a2));
}
Variant i_mb_regex_set_options(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_regex_set_options);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_regex_set_options", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_regex_set_options());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_regex_set_options(arg0));
  }
}
Variant ifa_mb_regex_set_options(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mb_regex_set_options", 1, 1);
  if (count <= 0) return (f_mb_regex_set_options());
  return (f_mb_regex_set_options(a0));
}
Variant i_pixelsetmagenta(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetmagenta);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetmagenta", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetmagenta(arg0, arg1), null);
  }
}
Variant ifa_pixelsetmagenta(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetmagenta", count, 2, 2, 1);
  return (f_pixelsetmagenta(a0, a1), null);
}
Variant i_dom_element_remove_attribute(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_element_remove_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_remove_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_remove_attribute(arg0, arg1));
  }
}
Variant ifa_dom_element_remove_attribute(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_element_remove_attribute", count, 2, 2, 1);
  return (f_dom_element_remove_attribute(a0, a1));
}
Variant i_magickdeconstructimages(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickdeconstructimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdeconstructimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickdeconstructimages(arg0));
  }
}
Variant ifa_magickdeconstructimages(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickdeconstructimages", count, 1, 1, 1);
  return (f_magickdeconstructimages(a0));
}
Variant i_xbox_task_status(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xbox_task_status);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_task_status", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xbox_task_status(arg0));
  }
}
Variant ifa_xbox_task_status(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xbox_task_status", count, 1, 1, 1);
  return (f_xbox_task_status(a0));
}
Variant i_openssl_open(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_open);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("openssl_open", count, 4, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_open(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_open(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("openssl_open", count, 4, 4, 1);
  return (f_openssl_open(a0, ref(a1), a2, a3));
}
Variant i_apc_bin_load(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_bin_load);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_bin_load", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_bin_load(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_bin_load(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_bin_load(arg0, arg1, arg2));
  }
}
Variant ifa_apc_bin_load(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_bin_load", count, 1, 3, 1);
  if (count <= 1) return (f_apc_bin_load(a0));
  if (count == 2) return (f_apc_bin_load(a0, a1));
  return (f_apc_bin_load(a0, a1, a2));
}
Variant i_current(void *extra, CArrRef params) {
  FUNCTION_INJECTION(current);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("current", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_current(arg0));
  }
}
Variant ifa_current(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("current", count, 1, 1, 1);
  return (f_current(ref(a0)));
}
Variant i_stream_register_wrapper(void *extra, CArrRef params) {
  FUNCTION_INJECTION(stream_register_wrapper);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_register_wrapper", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_register_wrapper(arg0, arg1));
  }
}
Variant ifa_stream_register_wrapper(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("stream_register_wrapper", count, 2, 2, 1);
  return (f_stream_register_wrapper(a0, a1));
}
Variant i_hphp_stats(void *extra, CArrRef params) {
  FUNCTION_INJECTION(hphp_stats);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_stats", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_stats(arg0, arg1), null);
  }
}
Variant ifa_hphp_stats(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("hphp_stats", count, 2, 2, 1);
  return (f_hphp_stats(a0, a1), null);
}
Variant i_opendir(void *extra, CArrRef params) {
  FUNCTION_INJECTION(opendir);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("opendir", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_opendir(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_opendir(arg0, arg1));
  }
}
Variant ifa_opendir(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("opendir", count, 1, 2, 1);
  if (count <= 1) return (f_opendir(a0));
  return (f_opendir(a0, a1));
}
Variant i_magickgetexceptionstring(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetexceptionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexceptionstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetexceptionstring(arg0));
  }
}
Variant ifa_magickgetexceptionstring(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickgetexceptionstring", count, 1, 1, 1);
  return (f_magickgetexceptionstring(a0));
}
Variant i_mcrypt_module_is_block_algorithm_mode(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_is_block_algorithm_mode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_algorithm_mode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_is_block_algorithm_mode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_is_block_algorithm_mode(arg0, arg1));
  }
}
Variant ifa_mcrypt_module_is_block_algorithm_mode(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_algorithm_mode", count, 1, 2, 1);
  if (count <= 1) return (f_mcrypt_module_is_block_algorithm_mode(a0));
  return (f_mcrypt_module_is_block_algorithm_mode(a0, a1));
}
Variant i_posix_setpgid(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_setpgid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_setpgid", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_setpgid(arg0, arg1));
  }
}
Variant ifa_posix_setpgid(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("posix_setpgid", count, 2, 2, 1);
  return (f_posix_setpgid(a0, a1));
}
Variant i_dns_get_mx(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dns_get_mx);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dns_get_mx", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dns_get_mx(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_dns_get_mx(arg0, arg1, arg2));
  }
}
Variant ifa_dns_get_mx(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("dns_get_mx", count, 2, 3, 1);
  if (count <= 2) return (f_dns_get_mx(a0, ref(a1)));
  return (f_dns_get_mx(a0, ref(a1), ref(a2)));
}
Variant i_headers_list(void *extra, CArrRef params) {
  FUNCTION_INJECTION(headers_list);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("headers_list", 0, 1);
  return (f_headers_list());
}
Variant ifa_headers_list(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("headers_list", 0, 1);
  return (f_headers_list());
}
Variant i_escapeshellarg(void *extra, CArrRef params) {
  FUNCTION_INJECTION(escapeshellarg);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("escapeshellarg", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_escapeshellarg(arg0));
  }
}
Variant ifa_escapeshellarg(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("escapeshellarg", count, 1, 1, 1);
  return (f_escapeshellarg(a0));
}
Variant i_is_scalar(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_scalar);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_scalar", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_scalar(arg0));
  }
}
Variant ifa_is_scalar(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_scalar", count, 1, 1, 1);
  return (f_is_scalar(a0));
}
Variant i_acos(void *extra, CArrRef params) {
  FUNCTION_INJECTION(acos);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("acos", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_acos(arg0));
  }
}
Variant ifa_acos(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("acos", count, 1, 1, 1);
  return (f_acos(a0));
}
Variant i_drawgettextencoding(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawgettextencoding);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextencoding", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgettextencoding(arg0));
  }
}
Variant ifa_drawgettextencoding(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("drawgettextencoding", count, 1, 1, 1);
  return (f_drawgettextencoding(a0));
}
Variant i_filetype(void *extra, CArrRef params) {
  FUNCTION_INJECTION(filetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filetype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_filetype(arg0));
  }
}
Variant ifa_filetype(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("filetype", count, 1, 1, 1);
  return (f_filetype(a0));
}
Variant i_magicksetresolution(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetresolution);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetresolution", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetresolution(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetresolution(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksetresolution", count, 3, 3, 1);
  return (f_magicksetresolution(a0, a1, a2));
}
Variant i_posix_isatty(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_isatty);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_isatty", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_isatty(arg0));
  }
}
Variant ifa_posix_isatty(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_isatty", count, 1, 1, 1);
  return (f_posix_isatty(a0));
}
Variant i_dom_document_relaxng_validate_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dom_document_relaxng_validate_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_relaxng_validate_file", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_relaxng_validate_file(arg0, arg1));
  }
}
Variant ifa_dom_document_relaxng_validate_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("dom_document_relaxng_validate_file", count, 2, 2, 1);
  return (f_dom_document_relaxng_validate_file(a0, a1));
}
Variant i_escapeshellcmd(void *extra, CArrRef params) {
  FUNCTION_INJECTION(escapeshellcmd);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("escapeshellcmd", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_escapeshellcmd(arg0));
  }
}
Variant ifa_escapeshellcmd(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("escapeshellcmd", count, 1, 1, 1);
  return (f_escapeshellcmd(a0));
}
Variant i_apc_store(void *extra, CArrRef params) {
  FUNCTION_INJECTION(apc_store);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_store", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_apc_store(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_store(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_store(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_apc_store(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_store", count, 2, 4, 1);
  if (count <= 2) return (f_apc_store(a0, a1));
  if (count == 3) return (f_apc_store(a0, a1, a2));
  return (f_apc_store(a0, a1, a2, a3));
}
Variant i_magickresetiterator(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickresetiterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickresetiterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickresetiterator(arg0), null);
  }
}
Variant ifa_magickresetiterator(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickresetiterator", count, 1, 1, 1);
  return (f_magickresetiterator(a0), null);
}
Variant i_libxml_disable_entity_loader(void *extra, CArrRef params) {
  FUNCTION_INJECTION(libxml_disable_entity_loader);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("libxml_disable_entity_loader", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_libxml_disable_entity_loader());
    CVarRef arg0((ad->getValue(pos)));
    return (f_libxml_disable_entity_loader(arg0));
  }
}
Variant ifa_libxml_disable_entity_loader(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("libxml_disable_entity_loader", 1, 1);
  if (count <= 0) return (f_libxml_disable_entity_loader());
  return (f_libxml_disable_entity_loader(a0));
}
Variant i_magickmotionblurimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickmotionblurimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickmotionblurimage", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmotionblurimage(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickmotionblurimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("magickmotionblurimage", count, 4, 4, 1);
  return (f_magickmotionblurimage(a0, a1, a2, a3));
}
Variant i_session_cache_expire(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_cache_expire);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_cache_expire", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_cache_expire());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_cache_expire(arg0));
  }
}
Variant ifa_session_cache_expire(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("session_cache_expire", 1, 1);
  if (count <= 0) return (f_session_cache_expire());
  return (f_session_cache_expire(a0));
}
Variant i_magicksetwandsize(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicksetwandsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetwandsize", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetwandsize(arg0, arg1, arg2));
  }
}
Variant ifa_magicksetwandsize(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("magicksetwandsize", count, 3, 3, 1);
  return (f_magicksetwandsize(a0, a1, a2));
}
Variant i_number_format(void *extra, CArrRef params) {
  FUNCTION_INJECTION(number_format);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("number_format", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_number_format(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_number_format(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_number_format(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_number_format(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_number_format(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("number_format", count, 1, 4, 1);
  if (count <= 1) return (f_number_format(a0));
  if (count == 2) return (f_number_format(a0, a1));
  if (count == 3) return (f_number_format(a0, a1, a2));
  return (f_number_format(a0, a1, a2, a3));
}
Variant i_array_reduce(void *extra, CArrRef params) {
  FUNCTION_INJECTION(array_reduce);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_reduce", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_reduce(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_reduce(arg0, arg1, arg2));
  }
}
Variant ifa_array_reduce(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("array_reduce", count, 2, 3, 1);
  if (count <= 2) return (f_array_reduce(a0, a1));
  return (f_array_reduce(a0, a1, a2));
}
Variant i_xmlwriter_start_dtd_attlist(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_dtd_attlist);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_dtd_attlist", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_dtd_attlist(arg0, arg1));
  }
}
Variant ifa_xmlwriter_start_dtd_attlist(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_dtd_attlist", count, 2, 2, 1);
  return (f_xmlwriter_start_dtd_attlist(a0, a1));
}
Variant i_constant(void *extra, CArrRef params) {
  FUNCTION_INJECTION(constant);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("constant", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_constant(arg0));
  }
}
Variant ifa_constant(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("constant", count, 1, 1, 1);
  return (f_constant(a0));
}
Variant i_strlen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(strlen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strlen", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_strlen(arg0));
  }
}
Variant ifa_strlen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("strlen", count, 1, 1, 1);
  return (f_strlen(a0));
}
Variant i_srand(void *extra, CArrRef params) {
  FUNCTION_INJECTION(srand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("srand", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_srand(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_srand(arg0), null);
  }
}
Variant ifa_srand(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("srand", 1, 1);
  if (count <= 0) return (f_srand(), null);
  return (f_srand(a0), null);
}
Variant i_mysql_fetch_object(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_object);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mysql_fetch_object", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_fetch_object(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mysql_fetch_object(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_fetch_object(arg0, arg1, arg2));
  }
}
Variant ifa_mysql_fetch_object(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("mysql_fetch_object", count, 1, 3, 1);
  if (count <= 1) return (f_mysql_fetch_object(a0));
  if (count == 2) return (f_mysql_fetch_object(a0, a1));
  return (f_mysql_fetch_object(a0, a1, a2));
}
Variant i_drawpathlinetoverticalrelative(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetoverticalrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetoverticalrelative", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetoverticalrelative(arg0, arg1), null);
  }
}
Variant ifa_drawpathlinetoverticalrelative(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawpathlinetoverticalrelative", count, 2, 2, 1);
  return (f_drawpathlinetoverticalrelative(a0, a1), null);
}
Variant i_magickminifyimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickminifyimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickminifyimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickminifyimage(arg0));
  }
}
Variant ifa_magickminifyimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickminifyimage", count, 1, 1, 1);
  return (f_magickminifyimage(a0));
}
Variant i_date_sunset(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_sunset);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("date_sunset", count, 1, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_date_sunset(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_date_sunset(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_date_sunset(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_date_sunset(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_date_sunset(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_sunset(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_date_sunset(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 6) return throw_wrong_arguments("date_sunset", count, 1, 6, 1);
  if (count <= 1) return (f_date_sunset(a0));
  if (count == 2) return (f_date_sunset(a0, a1));
  if (count == 3) return (f_date_sunset(a0, a1, a2));
  if (count == 4) return (f_date_sunset(a0, a1, a2, a3));
  if (count == 5) return (f_date_sunset(a0, a1, a2, a3, a4));
  return (f_date_sunset(a0, a1, a2, a3, a4, a5));
}
Variant i_symlink(void *extra, CArrRef params) {
  FUNCTION_INJECTION(symlink);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("symlink", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_symlink(arg0, arg1));
  }
}
Variant ifa_symlink(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("symlink", count, 2, 2, 1);
  return (f_symlink(a0, a1));
}
Variant i_imagesetpixel(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagesetpixel);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagesetpixel", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesetpixel(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_imagesetpixel(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 4) return throw_wrong_arguments("imagesetpixel", count, 4, 4, 1);
  return (f_imagesetpixel(a0, a1, a2, a3));
}
Variant i_session_module_name(void *extra, CArrRef params) {
  FUNCTION_INJECTION(session_module_name);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_module_name", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_module_name());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_module_name(arg0));
  }
}
Variant ifa_session_module_name(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("session_module_name", 1, 1);
  if (count <= 0) return (f_session_module_name());
  return (f_session_module_name(a0));
}
Variant i_split(void *extra, CArrRef params) {
  FUNCTION_INJECTION(split);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("split", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_split(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_split(arg0, arg1, arg2));
  }
}
Variant ifa_split(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("split", count, 2, 3, 1);
  if (count <= 2) return (f_split(a0, a1));
  return (f_split(a0, a1, a2));
}
Variant i_drawsetfontstyle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawsetfontstyle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontstyle", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfontstyle(arg0, arg1), null);
  }
}
Variant ifa_drawsetfontstyle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("drawsetfontstyle", count, 2, 2, 1);
  return (f_drawsetfontstyle(a0, a1), null);
}
Variant i_imagecreatefromxbm(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromxbm);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromxbm", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromxbm(arg0));
  }
}
Variant ifa_imagecreatefromxbm(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagecreatefromxbm", count, 1, 1, 1);
  return (f_imagecreatefromxbm(a0));
}
Variant i_mysql_db_query(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_db_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_db_query", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mysql_db_query(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_db_query(arg0, arg1, arg2));
  }
}
Variant ifa_mysql_db_query(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_db_query", count, 2, 3, 1);
  if (count <= 2) return (f_mysql_db_query(a0, a1));
  return (f_mysql_db_query(a0, a1, a2));
}
Variant i_imagecolorclosestalpha(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecolorclosestalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorclosestalpha", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorclosestalpha(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_imagecolorclosestalpha(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 5) return throw_wrong_arguments("imagecolorclosestalpha", count, 5, 5, 1);
  return (f_imagecolorclosestalpha(a0, a1, a2, a3, a4));
}
Variant i_gzuncompress(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzuncompress);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzuncompress", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzuncompress(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzuncompress(arg0, arg1));
  }
}
Variant ifa_gzuncompress(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("gzuncompress", count, 1, 2, 1);
  if (count <= 1) return (f_gzuncompress(a0));
  return (f_gzuncompress(a0, a1));
}
Variant i_is_executable(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_executable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_executable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_executable(arg0));
  }
}
Variant ifa_is_executable(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_executable", count, 1, 1, 1);
  return (f_is_executable(a0));
}
Variant i_socket_create_listen(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_create_listen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_create_listen", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_socket_create_listen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_create_listen(arg0, arg1));
  }
}
Variant ifa_socket_create_listen(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_create_listen", count, 1, 2, 1);
  if (count <= 1) return (f_socket_create_listen(a0));
  return (f_socket_create_listen(a0, a1));
}
Variant i_pixelgetcolorcount(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelgetcolorcount);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcolorcount", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetcolorcount(arg0));
  }
}
Variant ifa_pixelgetcolorcount(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("pixelgetcolorcount", count, 1, 1, 1);
  return (f_pixelgetcolorcount(a0));
}
Variant i_magickqueryconfigureoptions(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickqueryconfigureoptions);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryconfigureoptions", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickqueryconfigureoptions(arg0));
  }
}
Variant ifa_magickqueryconfigureoptions(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("magickqueryconfigureoptions", count, 1, 1, 1);
  return (f_magickqueryconfigureoptions(a0));
}
Variant i_iptcembed(void *extra, CArrRef params) {
  FUNCTION_INJECTION(iptcembed);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iptcembed", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iptcembed(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iptcembed(arg0, arg1, arg2));
  }
}
Variant ifa_iptcembed(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("iptcembed", count, 2, 3, 1);
  if (count <= 2) return (f_iptcembed(a0, a1));
  return (f_iptcembed(a0, a1, a2));
}
Variant i_posix_getgrnam(void *extra, CArrRef params) {
  FUNCTION_INJECTION(posix_getgrnam);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getgrnam", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getgrnam(arg0));
  }
}
Variant ifa_posix_getgrnam(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("posix_getgrnam", count, 1, 1, 1);
  return (f_posix_getgrnam(a0));
}
Variant i_rtrim(void *extra, CArrRef params) {
  FUNCTION_INJECTION(rtrim);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("rtrim", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_rtrim(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rtrim(arg0, arg1));
  }
}
Variant ifa_rtrim(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("rtrim", count, 1, 2, 1);
  if (count <= 1) return (f_rtrim(a0));
  return (f_rtrim(a0, a1));
}
Variant i_print_r(void *extra, CArrRef params) {
  FUNCTION_INJECTION(print_r);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("print_r", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_print_r(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_print_r(arg0, arg1));
  }
}
Variant ifa_print_r(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("print_r", count, 1, 2, 1);
  if (count <= 1) return (f_print_r(a0));
  return (f_print_r(a0, a1));
}
Variant i_drawpathcurvetoquadraticbeziersmoothrelative(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetoquadraticbeziersmoothrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathcurvetoquadraticbeziersmoothrelative", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetoquadraticbeziersmoothrelative(arg0, arg1, arg2), null);
  }
}
Variant ifa_drawpathcurvetoquadraticbeziersmoothrelative(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 3) return throw_wrong_arguments("drawpathcurvetoquadraticbeziersmoothrelative", count, 3, 3, 1);
  return (f_drawpathcurvetoquadraticbeziersmoothrelative(a0, a1, a2), null);
}
Variant i_openssl_pkey_export(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_export);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_pkey_export", count, 2, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_pkey_export(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_openssl_pkey_export(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkey_export(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_openssl_pkey_export(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_pkey_export", count, 2, 4, 1);
  if (count <= 2) return (f_openssl_pkey_export(a0, ref(a1)));
  if (count == 3) return (f_openssl_pkey_export(a0, ref(a1), a2));
  return (f_openssl_pkey_export(a0, ref(a1), a2, a3));
}
Variant i_abs(void *extra, CArrRef params) {
  FUNCTION_INJECTION(abs);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("abs", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_abs(arg0));
  }
}
Variant ifa_abs(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("abs", count, 1, 1, 1);
  return (f_abs(a0));
}
Variant i_restore_exception_handler(void *extra, CArrRef params) {
  FUNCTION_INJECTION(restore_exception_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_exception_handler", 0, 1);
  return (f_restore_exception_handler());
}
Variant ifa_restore_exception_handler(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("restore_exception_handler", 0, 1);
  return (f_restore_exception_handler());
}
Variant i_shell_exec(void *extra, CArrRef params) {
  FUNCTION_INJECTION(shell_exec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shell_exec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_shell_exec(arg0));
  }
}
Variant ifa_shell_exec(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("shell_exec", count, 1, 1, 1);
  return (f_shell_exec(a0));
}
Variant i_curl_multi_exec(void *extra, CArrRef params) {
  FUNCTION_INJECTION(curl_multi_exec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_exec", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_curl_multi_exec(arg0, arg1));
  }
}
Variant ifa_curl_multi_exec(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("curl_multi_exec", count, 2, 2, 1);
  return (f_curl_multi_exec(a0, ref(a1)));
}
Variant i_htmlspecialchars(void *extra, CArrRef params) {
  FUNCTION_INJECTION(htmlspecialchars);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("htmlspecialchars", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_htmlspecialchars(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_htmlspecialchars(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_htmlspecialchars(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_htmlspecialchars(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_htmlspecialchars(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 4) return throw_wrong_arguments("htmlspecialchars", count, 1, 4, 1);
  if (count <= 1) return (f_htmlspecialchars(a0));
  if (count == 2) return (f_htmlspecialchars(a0, a1));
  if (count == 3) return (f_htmlspecialchars(a0, a1, a2));
  return (f_htmlspecialchars(a0, a1, a2, a3));
}
Variant i_imagexbm(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagexbm);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagexbm", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagexbm(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_imagexbm(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagexbm(arg0, arg1, arg2));
  }
}
Variant ifa_imagexbm(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("imagexbm", count, 1, 3, 1);
  if (count <= 1) return (f_imagexbm(a0));
  if (count == 2) return (f_imagexbm(a0, a1));
  return (f_imagexbm(a0, a1, a2));
}
Variant i_magickgetreleasedate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetreleasedate);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetreleasedate", 0, 1);
  return (f_magickgetreleasedate());
}
Variant ifa_magickgetreleasedate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("magickgetreleasedate", 0, 1);
  return (f_magickgetreleasedate());
}
Variant i_xbox_set_thread_timeout(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xbox_set_thread_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_set_thread_timeout", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xbox_set_thread_timeout(arg0), null);
  }
}
Variant ifa_xbox_set_thread_timeout(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("xbox_set_thread_timeout", count, 1, 1, 1);
  return (f_xbox_set_thread_timeout(a0), null);
}
Variant i_sem_remove(void *extra, CArrRef params) {
  FUNCTION_INJECTION(sem_remove);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_remove", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sem_remove(arg0));
  }
}
Variant ifa_sem_remove(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("sem_remove", count, 1, 1, 1);
  return (f_sem_remove(a0));
}
Variant i_imageellipse(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imageellipse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imageellipse", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageellipse(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imageellipse(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("imageellipse", count, 6, 6, 1);
  return (f_imageellipse(a0, a1, a2, a3, a4, a5));
}
Variant i_getprotobynumber(void *extra, CArrRef params) {
  FUNCTION_INJECTION(getprotobynumber);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getprotobynumber", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_getprotobynumber(arg0));
  }
}
Variant ifa_getprotobynumber(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("getprotobynumber", count, 1, 1, 1);
  return (f_getprotobynumber(a0));
}
Variant i_pixelsetopacity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(pixelsetopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetopacity", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetopacity(arg0, arg1), null);
  }
}
Variant ifa_pixelsetopacity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("pixelsetopacity", count, 2, 2, 1);
  return (f_pixelsetopacity(a0, a1), null);
}
Variant i_lchgrp(void *extra, CArrRef params) {
  FUNCTION_INJECTION(lchgrp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("lchgrp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_lchgrp(arg0, arg1));
  }
}
Variant ifa_lchgrp(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("lchgrp", count, 2, 2, 1);
  return (f_lchgrp(a0, a1));
}
Variant i_simplexml_load_file(void *extra, CArrRef params) {
  FUNCTION_INJECTION(simplexml_load_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("simplexml_load_file", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_simplexml_load_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_simplexml_load_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_simplexml_load_file(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_simplexml_load_file(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_simplexml_load_file(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant ifa_simplexml_load_file(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 5) return throw_wrong_arguments("simplexml_load_file", count, 1, 5, 1);
  if (count <= 1) return (f_simplexml_load_file(a0));
  if (count == 2) return (f_simplexml_load_file(a0, a1));
  if (count == 3) return (f_simplexml_load_file(a0, a1, a2));
  if (count == 4) return (f_simplexml_load_file(a0, a1, a2, a3));
  return (f_simplexml_load_file(a0, a1, a2, a3, a4));
}
Variant i_openssl_pkey_get_details(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_get_details);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_get_details", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_pkey_get_details(arg0));
  }
}
Variant ifa_openssl_pkey_get_details(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("openssl_pkey_get_details", count, 1, 1, 1);
  return (f_openssl_pkey_get_details(a0));
}
Variant i_imagetypes(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagetypes);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("imagetypes", 0, 1);
  return (f_imagetypes());
}
Variant ifa_imagetypes(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 0) return throw_toomany_arguments("imagetypes", 0, 1);
  return (f_imagetypes());
}
Variant i_gzseek(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzseek);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzseek", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_gzseek(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzseek(arg0, arg1, arg2));
  }
}
Variant ifa_gzseek(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("gzseek", count, 2, 3, 1);
  if (count <= 2) return (f_gzseek(a0, a1));
  return (f_gzseek(a0, a1, a2));
}
Variant i_magickgetmaxtextadvance(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magickgetmaxtextadvance);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetmaxtextadvance", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgetmaxtextadvance(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetmaxtextadvance(arg0, arg1, arg2, arg3));
  }
}
Variant ifa_magickgetmaxtextadvance(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetmaxtextadvance", count, 3, 4, 1);
  if (count <= 3) return (f_magickgetmaxtextadvance(a0, a1, a2));
  return (f_magickgetmaxtextadvance(a0, a1, a2, a3));
}
Variant i_func_get_arg(void *extra, CArrRef params) {
  FUNCTION_INJECTION(func_get_arg);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("func_get_arg", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_func_get_arg(arg0));
  }
}
Variant ifa_func_get_arg(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("func_get_arg", count, 1, 1, 1);
  return (f_func_get_arg(a0));
}
Variant i_imagefilledrectangle(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagefilledrectangle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagefilledrectangle", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilledrectangle(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant ifa_imagefilledrectangle(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("imagefilledrectangle", count, 6, 6, 1);
  return (f_imagefilledrectangle(a0, a1, a2, a3, a4, a5));
}
Variant i_drawpushpattern(void *extra, CArrRef params) {
  FUNCTION_INJECTION(drawpushpattern);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("drawpushpattern", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpushpattern(arg0, arg1, arg2, arg3, arg4, arg5), null);
  }
}
Variant ifa_drawpushpattern(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 6) return throw_wrong_arguments("drawpushpattern", count, 6, 6, 1);
  return (f_drawpushpattern(a0, a1, a2, a3, a4, a5), null);
}
Variant i_xmlwriter_set_indent(void *extra, CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_set_indent);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_set_indent", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_set_indent(arg0, arg1));
  }
}
Variant ifa_xmlwriter_set_indent(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("xmlwriter_set_indent", count, 2, 2, 1);
  return (f_xmlwriter_set_indent(a0, a1));
}
Variant i_openssl_csr_get_subject(void *extra, CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_get_subject);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_csr_get_subject", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_openssl_csr_get_subject(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_csr_get_subject(arg0, arg1));
  }
}
Variant ifa_openssl_csr_get_subject(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_csr_get_subject", count, 1, 2, 1);
  if (count <= 1) return (f_openssl_csr_get_subject(a0));
  return (f_openssl_csr_get_subject(a0, a1));
}
Variant i_is_numeric(void *extra, CArrRef params) {
  FUNCTION_INJECTION(is_numeric);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_numeric", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_numeric(arg0));
  }
}
Variant ifa_is_numeric(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("is_numeric", count, 1, 1, 1);
  return (f_is_numeric(a0));
}
Variant i_gzdeflate(void *extra, CArrRef params) {
  FUNCTION_INJECTION(gzdeflate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzdeflate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzdeflate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzdeflate(arg0, arg1));
  }
}
Variant ifa_gzdeflate(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("gzdeflate", count, 1, 2, 1);
  if (count <= 1) return (f_gzdeflate(a0));
  return (f_gzdeflate(a0, a1));
}
Variant i_dns_check_record(void *extra, CArrRef params) {
  FUNCTION_INJECTION(dns_check_record);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dns_check_record", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dns_check_record(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dns_check_record(arg0, arg1));
  }
}
Variant ifa_dns_check_record(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("dns_check_record", count, 1, 2, 1);
  if (count <= 1) return (f_dns_check_record(a0));
  return (f_dns_check_record(a0, a1));
}
Variant i_magicknegateimage(void *extra, CArrRef params) {
  FUNCTION_INJECTION(magicknegateimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("magicknegateimage", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magicknegateimage(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_magicknegateimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicknegateimage(arg0, arg1, arg2));
  }
}
Variant ifa_magicknegateimage(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 3) return throw_wrong_arguments("magicknegateimage", count, 1, 3, 1);
  if (count <= 1) return (f_magicknegateimage(a0));
  if (count == 2) return (f_magicknegateimage(a0, a1));
  return (f_magicknegateimage(a0, a1, a2));
}
Variant i_socket_last_error(void *extra, CArrRef params) {
  FUNCTION_INJECTION(socket_last_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("socket_last_error", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_socket_last_error());
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_last_error(arg0));
  }
}
Variant ifa_socket_last_error(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("socket_last_error", 1, 1);
  if (count <= 0) return (f_socket_last_error());
  return (f_socket_last_error(a0));
}
Variant i_create_function(void *extra, CArrRef params) {
  FUNCTION_INJECTION(create_function);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("create_function", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_create_function(arg0, arg1));
  }
}
Variant ifa_create_function(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("create_function", count, 2, 2, 1);
  return (f_create_function(a0, a1));
}
Variant i_str_split(void *extra, CArrRef params) {
  FUNCTION_INJECTION(str_split);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("str_split", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_str_split(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_str_split(arg0, arg1));
  }
}
Variant ifa_str_split(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 1 || count > 2) return throw_wrong_arguments("str_split", count, 1, 2, 1);
  if (count <= 1) return (f_str_split(a0));
  return (f_str_split(a0, a1));
}
Variant i_date_parse(void *extra, CArrRef params) {
  FUNCTION_INJECTION(date_parse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_parse", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_date_parse(arg0));
  }
}
Variant ifa_date_parse(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("date_parse", count, 1, 1, 1);
  return (f_date_parse(a0));
}
Variant i_imagecreatefromxpm(void *extra, CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromxpm);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromxpm", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromxpm(arg0));
  }
}
Variant ifa_imagecreatefromxpm(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 1) return throw_wrong_arguments("imagecreatefromxpm", count, 1, 1, 1);
  return (f_imagecreatefromxpm(a0));
}
Variant i_mysql_thread_id(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mysql_thread_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_thread_id", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_thread_id());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_thread_id(arg0));
  }
}
Variant ifa_mysql_thread_id(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count > 1) return throw_toomany_arguments("mysql_thread_id", 1, 1);
  if (count <= 0) return (f_mysql_thread_id());
  return (f_mysql_thread_id(a0));
}
Variant i_mb_encode_numericentity(void *extra, CArrRef params) {
  FUNCTION_INJECTION(mb_encode_numericentity);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_encode_numericentity", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_encode_numericentity(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_encode_numericentity(arg0, arg1, arg2));
  }
}
Variant ifa_mb_encode_numericentity(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_encode_numericentity", count, 2, 3, 1);
  if (count <= 2) return (f_mb_encode_numericentity(a0, a1));
  return (f_mb_encode_numericentity(a0, a1, a2));
}
Variant i_fb_call_user_func_array_safe(void *extra, CArrRef params) {
  FUNCTION_INJECTION(fb_call_user_func_array_safe);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_call_user_func_array_safe", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_call_user_func_array_safe(arg0, arg1));
  }
}
Variant ifa_fb_call_user_func_array_safe(void *extra, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  if (count != 2) return throw_wrong_arguments("fb_call_user_func_array_safe", count, 2, 2, 1);
  return (f_fb_call_user_func_array_safe(a0, a1));
}
Variant ei_utf8_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("utf8_encode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_utf8_encode(a0));
}
Variant ei_hphp_splfileobject___construct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("hphp_splfileobject___construct", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject___construct(a0, a1, a2, a3, a4));
}
Variant ei_dom_document_create_comment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_comment", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_comment(a0, a1));
}
Variant ei_func_get_args(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("func_get_args", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_func_get_args());
}
Variant ei_php_uname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("php_uname", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_php_uname());
  else return (x_php_uname(a0));
}
Variant ei_posix_uname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_uname", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_uname());
}
Variant ei_curl_multi_remove_handle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_remove_handle", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_remove_handle(a0, a1));
}
Variant ei_memcache_get_server_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_get_server_status", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_get_server_status(a0, a1));
  else return (x_memcache_get_server_status(a0, a1, a2));
}
Variant ei_mysql_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_result", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mysql_result(a0, a1));
  else return (x_mysql_result(a0, a1, a2));
}
Variant ei_hphp_splfileobject_current(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_current", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_current(a0));
}
Variant ei_hphp_splfileinfo_getgroup(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getgroup", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getgroup(a0));
}
Variant ei_register_shutdown_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_shutdown_function", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_register_shutdown_function(count, a0), null);
  return (x_register_shutdown_function(count, a0,vargs), null);
}
Variant ei_pixelsetmagentaquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetmagentaquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetmagentaquantum(a0, a1), null);
}
Variant ei_newmagickwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("newmagickwand", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newmagickwand());
}
Variant ei_natsort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("natsort", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_natsort(ref(a0)));
}
Variant ei_socket_accept(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_accept", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_accept(a0));
}
Variant ei_vprintf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("vprintf", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_vprintf(a0, a1));
}
Variant ei_collator_set_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("collator_set_attribute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_set_attribute(a0, a1, a2));
}
Variant ei_ucwords(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ucwords", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ucwords(a0));
}
Variant ei_header(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("header", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_header(a0), null);
  else if (count == 2) return (x_header(a0, a1), null);
  else return (x_header(a0, a1, a2), null);
}
Variant ei_dom_element_has_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_has_attribute_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_has_attribute_ns(a0, a1, a2));
}
Variant ei_date_default_timezone_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_default_timezone_set", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_default_timezone_set(a0));
}
Variant ei_is_object(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_object", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_object(a0));
}
Variant ei_magicksetimagebias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebias", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagebias(a0, a1));
}
Variant ei_exif_imagetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exif_imagetype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_exif_imagetype(a0));
}
Variant ei_imagegrabscreen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("imagegrabscreen", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagegrabscreen());
}
Variant ei_bcmod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("bcmod", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_bcmod(a0, a1));
}
Variant ei_chr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chr", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chr(a0));
}
Variant ei_drawsetfontstretch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontstretch", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfontstretch(a0, a1), null);
}
Variant ei_posix_setsid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_setsid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_setsid());
}
Variant ei_hphp_splfileinfo_setfileclass(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_setfileclass", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_setfileclass(a0, a1), null);
}
Variant ei_posix_getpwnam(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpwnam", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getpwnam(a0));
}
Variant ei_mcrypt_enc_get_supported_key_sizes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_supported_key_sizes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_supported_key_sizes(a0));
}
Variant ei_phpinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpinfo", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_phpinfo());
  else return (x_phpinfo(a0));
}
Variant ei_evhttp_async_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("evhttp_async_get", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_evhttp_async_get(a0));
  else if (count == 2) return (x_evhttp_async_get(a0, a1));
  else return (x_evhttp_async_get(a0, a1, a2));
}
Variant ei_ldap_parse_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("ldap_parse_result", count, 3, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a5 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_ldap_parse_result(a0, a1, ref(a2)));
  else if (count == 4) return (x_ldap_parse_result(a0, a1, ref(a2), ref(a3)));
  else if (count == 5) return (x_ldap_parse_result(a0, a1, ref(a2), ref(a3), ref(a4)));
  else return (x_ldap_parse_result(a0, a1, ref(a2), ref(a3), ref(a4), ref(a5)));
}
Variant ei_drawgettextantialias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextantialias", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgettextantialias(a0));
}
Variant ei_array_fill_keys(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_fill_keys", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_fill_keys(a0, a1));
}
Variant ei_openssl_seal(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("openssl_seal", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_seal(a0, ref(a1), ref(a2), a3));
}
Variant ei_socket_clear_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("socket_clear_error", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_socket_clear_error(), null);
  else return (x_socket_clear_error(a0), null);
}
Variant ei_die(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("die", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_die());
  else return (x_die(a0));
}
Variant ei_diskfreespace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("diskfreespace", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_diskfreespace(a0));
}
Variant ei_xml_set_start_namespace_decl_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_start_namespace_decl_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_start_namespace_decl_handler(a0, a1));
}
Variant ei_decbin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("decbin", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_decbin(a0));
}
Variant ei_sizeof(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sizeof", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_sizeof(a0));
  else return (x_sizeof(a0, a1));
}
Variant ei_mb_convert_case(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_convert_case", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_convert_case(a0, a1));
  else return (x_mb_convert_case(a0, a1, a2));
}
Variant ei_fb_set_taint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_set_taint", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_set_taint(ref(a0), a1), null);
}
Variant ei_dir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dir(a0));
}
Variant ei_array_combine(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_combine", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_combine(a0, a1));
}
Variant ei_strpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strpos", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strpos(a0, a1));
  else return (x_strpos(a0, a1, a2));
}
Variant ei_array_reverse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_reverse", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_array_reverse(a0));
  else return (x_array_reverse(a0, a1));
}
Variant ei_strrev(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strrev", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strrev(a0));
}
Variant ei_msg_set_queue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("msg_set_queue", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_msg_set_queue(a0, a1));
}
Variant ei_cos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cos", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_cos(a0));
}
Variant ei_hphp_recursivedirectoryiterator_valid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_valid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_valid(a0));
}
Variant ei_bcmul(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcmul", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bcmul(a0, a1));
  else return (x_bcmul(a0, a1, a2));
}
Variant ei_openlog(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("openlog", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openlog(a0, a1, a2));
}
Variant ei_get_include_path(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_include_path", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_include_path());
}
Variant ei_socket_select(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("socket_select", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_socket_select(ref(a0), ref(a1), ref(a2), a3));
  else return (x_socket_select(ref(a0), ref(a1), ref(a2), a3, a4));
}
Variant ei_magickraiseimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickraiseimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickraiseimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_gzputs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzputs", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_gzputs(a0, a1));
  else return (x_gzputs(a0, a1, a2));
}
Variant ei_strpbrk(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strpbrk", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strpbrk(a0, a1));
}
Variant ei_shm_remove_var(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("shm_remove_var", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shm_remove_var(a0, a1));
}
Variant ei_posix_setuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setuid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_setuid(a0));
}
Variant ei_pixelgetyellow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetyellow", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetyellow(a0));
}
Variant ei_convert_uudecode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("convert_uudecode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_convert_uudecode(a0));
}
Variant ei_htmlspecialchars_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("htmlspecialchars_decode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_htmlspecialchars_decode(a0));
  else return (x_htmlspecialchars_decode(a0, a1));
}
Variant ei_xmlwriter_end_document(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_document", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_document(a0));
}
Variant ei_magickgetimagehistogram(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagehistogram", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagehistogram(a0));
}
Variant ei_preg_last_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("preg_last_error", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_preg_last_error());
}
Variant ei_end(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("end", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_end(ref(a0)));
}
Variant ei_stream_get_line(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_get_line", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_get_line(a0));
  else if (count == 2) return (x_stream_get_line(a0, a1));
  else return (x_stream_get_line(a0, a1, a2));
}
Variant ei_deg2rad(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("deg2rad", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_deg2rad(a0));
}
Variant ei_magickrollimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickrollimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickrollimage(a0, a1, a2));
}
Variant ei_ldap_sort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_sort", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_sort(a0, a1, a2));
}
Variant ei_imagetruecolortopalette(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagetruecolortopalette", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagetruecolortopalette(a0, a1, a2));
}
Variant ei_defined(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("defined", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_defined(a0));
}
Variant ei_magickgetimageunits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageunits", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageunits(a0));
}
Variant ei_magicksetimageblueprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageblueprimary", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageblueprimary(a0, a1, a2));
}
Variant ei_session_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_name", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_name());
  else return (x_session_name(a0));
}
Variant ei_get_class_vars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_class_vars", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_class_vars(a0));
}
Variant ei_syslog(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("syslog", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_syslog(a0, a1));
}
Variant ei_array_unique(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_unique", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_unique(a0));
}
Variant ei_bcpow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcpow", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bcpow(a0, a1));
  else return (x_bcpow(a0, a1, a2));
}
Variant ei_pixelgetopacityquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetopacityquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetopacityquantum(a0));
}
Variant ei_php_check_syntax(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("php_check_syntax", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_php_check_syntax(a0));
  else return (x_php_check_syntax(a0, ref(a1)));
}
Variant ei_mysql_connect_with_db(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 8) return throw_toomany_arguments("mysql_connect_with_db", 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_connect_with_db());
  else if (count == 1) return (x_mysql_connect_with_db(a0));
  else if (count == 2) return (x_mysql_connect_with_db(a0, a1));
  else if (count == 3) return (x_mysql_connect_with_db(a0, a1, a2));
  else if (count == 4) return (x_mysql_connect_with_db(a0, a1, a2, a3));
  else if (count == 5) return (x_mysql_connect_with_db(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_mysql_connect_with_db(a0, a1, a2, a3, a4, a5));
  else if (count == 7) return (x_mysql_connect_with_db(a0, a1, a2, a3, a4, a5, a6));
  else return (x_mysql_connect_with_db(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_drawgetstrokemiterlimit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokemiterlimit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokemiterlimit(a0));
}
Variant ei_hphp_splfileobject_fpassthru(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fpassthru", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fpassthru(a0));
}
Variant ei_intl_error_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("intl_error_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_intl_error_name(a0));
}
Variant ei_pixelsetquantumcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("pixelsetquantumcolor", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_pixelsetquantumcolor(a0, a1, a2, a3), null);
  else return (x_pixelsetquantumcolor(a0, a1, a2, a3, a4), null);
}
Variant ei_gztell(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gztell", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gztell(a0));
}
Variant ei_strval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strval", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strval(a0));
}
Variant ei_evhttp_recv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("evhttp_recv", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_evhttp_recv(a0));
}
Variant ei_dom_node_replace_child(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_node_replace_child", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_replace_child(a0, a1, a2));
}
Variant ei_strspn(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("strspn", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strspn(a0, a1));
  else if (count == 3) return (x_strspn(a0, a1, a2));
  else return (x_strspn(a0, a1, a2, a3));
}
Variant ei_ini_restore(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ini_restore", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ini_restore(a0), null);
}
Variant ei_ldap_dn2ufn(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_dn2ufn", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_dn2ufn(a0));
}
Variant ei_ceil(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ceil", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ceil(a0));
}
Variant ei_xmlwriter_end_dtd_attlist(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_attlist", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_dtd_attlist(a0));
}
Variant ei_phpversion(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpversion", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_phpversion());
  else return (x_phpversion(a0));
}
Variant ei_stream_filter_remove(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_filter_remove", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_filter_remove(a0));
}
Variant ei_mcrypt_generic(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_generic", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_generic(a0, a1));
}
Variant ei_is_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_file", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_file(a0));
}
Variant ei_xml_set_end_namespace_decl_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_end_namespace_decl_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_end_namespace_decl_handler(a0, a1));
}
Variant ei_openssl_x509_export_to_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_x509_export_to_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_x509_export_to_file(a0, a1));
  else return (x_openssl_x509_export_to_file(a0, a1, a2));
}
Variant ei_imagesetstyle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetstyle", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesetstyle(a0, a1));
}
Variant ei_drawcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawcolor", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawcolor(a0, a1, a2, a3), null);
}
Variant ei_get_headers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("get_headers", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_get_headers(a0));
  else return (x_get_headers(a0, a1));
}
Variant ei_mysql_drop_db(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_drop_db", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_drop_db(a0));
  else return (x_mysql_drop_db(a0, a1));
}
Variant ei_spl_object_hash(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("spl_object_hash", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_spl_object_hash(a0));
}
Variant ei_magickresampleimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickresampleimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickresampleimage(a0, a1, a2, a3, a4));
}
Variant ei_i18n_loc_get_default(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("i18n_loc_get_default", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_i18n_loc_get_default());
}
Variant ei_strtok(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strtok", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_strtok(a0));
  else return (x_strtok(a0, a1));
}
Variant ei_array_key_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_key_exists", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_key_exists(a0, a1));
}
Variant ei_exp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exp", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_exp(a0));
}
Variant ei_strstr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strstr", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strstr(a0, a1));
}
Variant ei_realpath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("realpath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_realpath(a0));
}
Variant ei_memcache_setoptimeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("memcache_setoptimeout", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_memcache_setoptimeout(a0, a1));
}
Variant ei_stream_filter_append(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_filter_append", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_filter_append(a0, a1));
  else if (count == 3) return (x_stream_filter_append(a0, a1, a2));
  else return (x_stream_filter_append(a0, a1, a2, a3));
}
Variant ei_dom_characterdata_insert_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_insert_data", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_characterdata_insert_data(a0, a1, a2));
}
Variant ei_hphp_get_property(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_get_property", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_property(a0, a1, a2));
}
Variant ei_dom_characterdata_replace_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_characterdata_replace_data", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_characterdata_replace_data(a0, a1, a2, a3));
}
Variant ei_magickgetcharheight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetcharheight", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgetcharheight(a0, a1, a2));
  else return (x_magickgetcharheight(a0, a1, a2, a3));
}
Variant ei_imagerotate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("imagerotate", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_imagerotate(a0, a1, a2));
  else return (x_imagerotate(a0, a1, a2, a3));
}
Variant ei_magickcompositeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickcompositeimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcompositeimage(a0, a1, a2, a3, a4));
}
Variant ei_openssl_sign(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_sign", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_sign(a0, ref(a1), a2));
  else return (x_openssl_sign(a0, ref(a1), a2, a3));
}
Variant ei_version_compare(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("version_compare", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_version_compare(a0, a1));
  else return (x_version_compare(a0, a1, a2));
}
Variant ei_timezone_name_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_name_get", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_name_get(a0));
}
Variant ei_posix_getpgid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpgid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getpgid(a0));
}
Variant ei_dom_node_has_attributes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_has_attributes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_has_attributes(a0));
}
Variant ei_dom_text_is_whitespace_in_element_content(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_text_is_whitespace_in_element_content", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_text_is_whitespace_in_element_content(a0));
}
Variant ei_imagestring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagestring", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagestring(a0, a1, a2, a3, a4, a5));
}
Variant ei_mcrypt_list_modes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mcrypt_list_modes", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mcrypt_list_modes());
  else return (x_mcrypt_list_modes(a0));
}
Variant ei_session_unregister(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_unregister", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_unregister(a0));
}
Variant ei_mcrypt_list_algorithms(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mcrypt_list_algorithms", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mcrypt_list_algorithms());
  else return (x_mcrypt_list_algorithms(a0));
}
Variant ei_mcrypt_get_cipher_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_get_cipher_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_get_cipher_name(a0));
}
Variant ei_idn_to_unicode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_unicode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_idn_to_unicode(a0));
  else return (x_idn_to_unicode(a0, ref(a1)));
}
Variant ei_lchown(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("lchown", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_lchown(a0, a1));
}
Variant ei_drawcomposite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawcomposite", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawcomposite(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_dechex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dechex", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dechex(a0));
}
Variant ei_imagecolortransparent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagecolortransparent", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagecolortransparent(a0));
  else return (x_imagecolortransparent(a0, a1));
}
Variant ei_socket_get_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("socket_get_option", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_get_option(a0, a1, a2));
}
Variant ei_stream_filter_register(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_filter_register", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_filter_register(a0, a1));
}
Variant ei_apache_response_headers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_response_headers", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_response_headers());
}
Variant ei_array_merge(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_merge", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_array_merge(count, a0));
  return (x_array_merge(count, a0,vargs));
}
Variant ei_md5(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("md5", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_md5(a0));
  else return (x_md5(a0, a1));
}
Variant ei_session_write_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_write_close", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_write_close(), null);
}
Variant ei_dom_namednodemap_item(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_namednodemap_item", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_namednodemap_item(a0, a1));
}
Variant ei_bcsub(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcsub", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bcsub(a0, a1));
  else return (x_bcsub(a0, a1, a2));
}
Variant ei_xmlwriter_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xmlwriter_flush", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_xmlwriter_flush(a0));
  else return (x_xmlwriter_flush(a0, a1));
}
Variant ei_sha1_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sha1_file", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_sha1_file(a0));
  else return (x_sha1_file(a0, a1));
}
Variant ei_posix_ctermid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_ctermid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_ctermid());
}
Variant ei_date(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("date", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_date(a0));
  else return (x_date(a0, a1));
}
Variant ei_evhttp_post(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("evhttp_post", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_evhttp_post(a0, a1));
  else if (count == 3) return (x_evhttp_post(a0, a1, a2));
  else return (x_evhttp_post(a0, a1, a2, a3));
}
Variant ei_ldap_connect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("ldap_connect", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ldap_connect());
  else if (count == 1) return (x_ldap_connect(a0));
  else return (x_ldap_connect(a0, a1));
}
Variant ei_shuffle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shuffle", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shuffle(ref(a0)));
}
Variant ei_mcrypt_module_get_algo_block_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_algo_block_size", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_get_algo_block_size(a0));
  else return (x_mcrypt_module_get_algo_block_size(a0, a1));
}
Variant ei_hphp_splfileobject_ftruncate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_ftruncate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_ftruncate(a0, a1));
}
Variant ei_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_key(ref(a0)));
}
Variant ei_xmlwriter_start_dtd_entity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_start_dtd_entity", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_dtd_entity(a0, a1, a2));
}
Variant ei_readfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("readfile", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_readfile(a0));
  else if (count == 2) return (x_readfile(a0, a1));
  else return (x_readfile(a0, a1, a2));
}
Variant ei_atan(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("atan", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_atan(a0));
}
Variant ei_magickmodulateimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickmodulateimage", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmodulateimage(a0, a1, a2, a3));
}
Variant ei_mysql_set_charset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_set_charset", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_set_charset(a0));
  else return (x_mysql_set_charset(a0, a1));
}
Variant ei_fb_unset_taint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_unset_taint", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_unset_taint(ref(a0), a1), null);
}
Variant ei_dom_document_xinclude(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_document_xinclude", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dom_document_xinclude(a0));
  else return (x_dom_document_xinclude(a0, a1));
}
Variant ei_drawgetfontweight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontweight", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfontweight(a0));
}
Variant ei_magickgetimageheight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageheight", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageheight(a0));
}
Variant ei_posix_getpgrp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getpgrp", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getpgrp());
}
Variant ei_i18n_loc_get_error_code(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("i18n_loc_get_error_code", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_i18n_loc_get_error_code());
}
Variant ei_hash_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_hash_file(a0, a1));
  else return (x_hash_file(a0, a1, a2));
}
Variant ei_is_callable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("is_callable", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_is_callable(a0));
  else if (count == 2) return (x_is_callable(a0, a1));
  else return (x_is_callable(a0, a1, ref(a2)));
}
Variant ei_asin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("asin", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_asin(a0));
}
Variant ei_openssl_public_encrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_public_encrypt", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_public_encrypt(a0, ref(a1), a2));
  else return (x_openssl_public_encrypt(a0, ref(a1), a2, a3));
}
Variant ei_curl_multi_init(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("curl_multi_init", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_init());
}
Variant ei_posix_getpwuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpwuid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getpwuid(a0));
}
Variant ei_json_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("json_encode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_json_encode(a0));
  else return (x_json_encode(a0, a1));
}
Variant ei_show_source(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("show_source", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_show_source(a0));
  else return (x_show_source(a0, a1));
}
Variant ei_mcrypt_module_self_test(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_self_test", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_self_test(a0));
  else return (x_mcrypt_module_self_test(a0, a1));
}
Variant ei_sscanf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("sscanf", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 2) return (x_sscanf(count, a0, a1));
  return (x_sscanf(count, a0, a1,vargs));
}
Variant ei_chop(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("chop", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_chop(a0));
  else return (x_chop(a0, a1));
}
Variant ei_mb_convert_variables(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("mb_convert_variables", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_mb_convert_variables(count, a0, a1, ref(a2)));
  return (x_mb_convert_variables(count, a0, a1, ref(a2),vargs));
}
Variant ei_hphp_recursivedirectoryiterator_getsubpathname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getsubpathname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_getsubpathname(a0));
}
Variant ei_socket_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_close(a0), null);
}
Variant ei_max(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("max", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_max(count, a0));
  return (x_max(count, a0,vargs));
}
Variant ei_magickadaptivethresholdimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickadaptivethresholdimage", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickadaptivethresholdimage(a0, a1, a2, a3));
}
Variant ei_each(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("each", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_each(ref(a0)));
}
Variant ei_magickremoveimageprofiles(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickremoveimageprofiles", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickremoveimageprofiles(a0));
}
Variant ei_drawgettextalignment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextalignment", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgettextalignment(a0));
}
Variant ei_xbox_send_message(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("xbox_send_message", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_xbox_send_message(a0, ref(a1), a2));
  else return (x_xbox_send_message(a0, ref(a1), a2, a3));
}
Variant ei_thrift_protocol_write_binary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("thrift_protocol_write_binary", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_thrift_protocol_write_binary(a0, a1, a2, a3, a4, a5), null);
}
Variant ei_wandgetexceptiontype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexceptiontype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_wandgetexceptiontype(a0));
}
Variant ei_drawpathellipticarcabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("drawpathellipticarcabsolute", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathellipticarcabsolute(a0, a1, a2, a3, a4, a5, a6, a7), null);
}
Variant ei_pixelsetgreen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetgreen", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetgreen(a0, a1), null);
}
Variant ei_magickgetimagecolorspace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecolorspace", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecolorspace(a0));
}
Variant ei_pixelsetalphaquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetalphaquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetalphaquantum(a0, a1), null);
}
Variant ei_stream_bucket_append(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_append", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_bucket_append(a0, a1), null);
}
Variant ei_msg_stat_queue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("msg_stat_queue", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_msg_stat_queue(a0));
}
Variant ei_system(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("system", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_system(a0));
  else return (x_system(a0, ref(a1)));
}
Variant ei_mb_parse_str(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_parse_str", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_parse_str(a0));
  else return (x_mb_parse_str(a0, ref(a1)));
}
Variant ei_dom_characterdata_append_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_characterdata_append_data", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_characterdata_append_data(a0, a1));
}
Variant ei_log(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("log", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_log(a0));
  else return (x_log(a0, a1));
}
Variant ei_memcache_decrement(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_decrement", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_decrement(a0, a1));
  else return (x_memcache_decrement(a0, a1, a2));
}
Variant ei_drawskewx(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawskewx", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawskewx(a0, a1), null);
}
Variant ei_min(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("min", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_min(count, a0));
  return (x_min(count, a0,vargs));
}
Variant ei_curl_multi_getcontent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_multi_getcontent", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_getcontent(a0));
}
Variant ei_drawskewy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawskewy", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawskewy(a0, a1), null);
}
Variant ei_is_uploaded_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_uploaded_file", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_uploaded_file(a0));
}
Variant ei_magicksetresourcelimit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetresourcelimit", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetresourcelimit(a0, a1));
}
Variant ei_date_timezone_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_timezone_get", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_timezone_get(a0));
}
Variant ei_hphp_splfileobject_fwrite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_splfileobject_fwrite", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fwrite(a0, a1, a2));
}
Variant ei_apache_get_rewrite_rules(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_rewrite_rules", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_get_rewrite_rules());
}
Variant ei_is_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_string", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_string(a0));
}
Variant ei_pcntl_wtermsig(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wtermsig", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wtermsig(a0));
}
Variant ei_stream_context_get_default(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("stream_context_get_default", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_stream_context_get_default());
  else return (x_stream_context_get_default(a0));
}
Variant ei_drawpathlinetorelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathlinetorelative", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetorelative(a0, a1, a2), null);
}
Variant ei_urlencode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("urlencode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_urlencode(a0));
}
Variant ei_mb_preferred_mime_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_preferred_mime_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_preferred_mime_name(a0));
}
Variant ei_pixelgetgreenquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetgreenquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetgreenquantum(a0));
}
Variant ei_magicksetfilename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magicksetfilename", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magicksetfilename(a0));
  else return (x_magicksetfilename(a0, a1));
}
Variant ei_magickappendimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickappendimages", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magickappendimages(a0));
  else return (x_magickappendimages(a0, a1));
}
Variant ei_pcntl_wifstopped(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifstopped", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wifstopped(a0));
}
Variant ei_mb_ereg_search(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_ereg_search());
  else if (count == 1) return (x_mb_ereg_search(a0));
  else return (x_mb_ereg_search(a0, a1));
}
Variant ei_rewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rewind(a0));
}
Variant ei_chunk_split(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("chunk_split", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_chunk_split(a0));
  else if (count == 2) return (x_chunk_split(a0, a1));
  else return (x_chunk_split(a0, a1, a2));
}
Variant ei_mb_list_encodings_alias_names(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_list_encodings_alias_names", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_list_encodings_alias_names());
  else return (x_mb_list_encodings_alias_names(a0));
}
Variant ei_i18n_loc_set_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("i18n_loc_set_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_i18n_loc_set_attribute(a0, a1));
}
Variant ei_pixelsynciterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelsynciterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsynciterator(a0));
}
Variant ei_openssl_error_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("openssl_error_string", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_error_string());
}
Variant ei_ismagickwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ismagickwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ismagickwand(a0));
}
Variant ei_dom_element_has_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_has_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_has_attribute(a0, a1));
}
Variant ei_strrchr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strrchr", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strrchr(a0, a1));
}
Variant ei_xmlwriter_start_dtd_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_dtd_element", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_dtd_element(a0, a1));
}
Variant ei_str_ireplace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("str_ireplace", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_str_ireplace(a0, a1, a2));
  else return (x_str_ireplace(a0, a1, a2, ref(a3)));
}
Variant ei_magickpainttransparentimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("magickpainttransparentimage", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickpainttransparentimage(a0, a1));
  else if (count == 3) return (x_magickpainttransparentimage(a0, a1, a2));
  else return (x_magickpainttransparentimage(a0, a1, a2, a3));
}
Variant ei_drawsettextundercolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextundercolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsettextundercolor(a0, a1), null);
}
Variant ei_memcache_get_version(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_get_version", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_memcache_get_version(a0));
}
Variant ei_hphp_splfileobject_getflags(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getflags", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_getflags(a0));
}
Variant ei_hphp_recursivedirectoryiterator_rewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_rewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_rewind(a0), null);
}
Variant ei_magickgetstringwidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetstringwidth", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgetstringwidth(a0, a1, a2));
  else return (x_magickgetstringwidth(a0, a1, a2, a3));
}
Variant ei_echo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("echo", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_echo(count, a0), null);
  return (x_echo(count, a0,vargs), null);
}
Variant ei_ldap_parse_reference(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_parse_reference", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_parse_reference(a0, a1, ref(a2)));
}
Variant ei_ctype_xdigit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_xdigit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_xdigit(a0));
}
Variant ei_gmstrftime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gmstrftime", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gmstrftime(a0));
  else return (x_gmstrftime(a0, a1));
}
Variant ei_hphp_recursiveiteratoriterator_next(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_next", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_next(a0), null);
}
Variant ei_stream_socket_get_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_socket_get_name", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_socket_get_name(a0, a1));
}
Variant ei_socket_set_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_set_option", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_set_option(a0, a1, a2, a3));
}
Variant ei_array_multisort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_multisort", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 1) return (x_array_multisort(count, ref(a0)));
  return (x_array_multisort(count, ref(a0),vargs));
}
Variant ei_imagepsbbox(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("imagepsbbox", count, 3, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_imagepsbbox(a0, a1, a2));
  else if (count == 4) return (x_imagepsbbox(a0, a1, a2, a3));
  else if (count == 5) return (x_imagepsbbox(a0, a1, a2, a3, a4));
  else return (x_imagepsbbox(a0, a1, a2, a3, a4, a5));
}
Variant ei_drawpathlinetoverticalabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetoverticalabsolute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetoverticalabsolute(a0, a1), null);
}
Variant ei_mailparse_msg_get_structure(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_get_structure", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_get_structure(a0));
}
Variant ei_mb_ereg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_ereg", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_ereg(a0, a1));
  else return (x_mb_ereg(a0, a1, ref(a2)));
}
Variant ei_decoct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("decoct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_decoct(a0));
}
Variant ei_xml_parse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("xml_parse", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_xml_parse(a0, a1));
  else return (x_xml_parse(a0, a1, a2));
}
Variant ei_xml_get_current_line_number(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_line_number", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_get_current_line_number(a0));
}
Variant ei_drawaffine(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawaffine", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawaffine(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_session_destroy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_destroy", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_destroy());
}
Variant ei_magicksetimagewhitepoint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagewhitepoint", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagewhitepoint(a0, a1, a2));
}
Variant ei_dom_document_get_elements_by_tag_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_get_elements_by_tag_name", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_get_elements_by_tag_name(a0, a1));
}
Variant ei_gzclose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzclose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzclose(a0));
}
Variant ei_imagecolorat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagecolorat", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorat(a0, a1, a2));
}
Variant ei_magickgetimageextrema(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickgetimageextrema", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magickgetimageextrema(a0));
  else return (x_magickgetimageextrema(a0, a1));
}
Variant ei_dom_node_insert_before(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_node_insert_before", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_node_insert_before(a0, a1));
  else return (x_dom_node_insert_before(a0, a1, a2));
}
Variant ei_ord(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ord", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ord(a0));
}
Variant ei_mktime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("mktime", 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mktime());
  else if (count == 1) return (x_mktime(a0));
  else if (count == 2) return (x_mktime(a0, a1));
  else if (count == 3) return (x_mktime(a0, a1, a2));
  else if (count == 4) return (x_mktime(a0, a1, a2, a3));
  else if (count == 5) return (x_mktime(a0, a1, a2, a3, a4));
  else return (x_mktime(a0, a1, a2, a3, a4, a5));
}
Variant ei_sem_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("sem_get", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_sem_get(a0));
  else if (count == 2) return (x_sem_get(a0, a1));
  else if (count == 3) return (x_sem_get(a0, a1, a2));
  else return (x_sem_get(a0, a1, a2, a3));
}
Variant ei_drawsetstrokelinejoin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokelinejoin", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokelinejoin(a0, a1), null);
}
Variant ei_array_intersect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_intersect(count, a0, a1));
  return (x_array_intersect(count, a0, a1,vargs));
}
Variant ei_mailparse_msg_extract_whole_part_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_whole_part_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mailparse_msg_extract_whole_part_file(a0, a1));
  else return (x_mailparse_msg_extract_whole_part_file(a0, a1, a2));
}
Variant ei_mb_strrichr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrichr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strrichr(a0, a1));
  else if (count == 3) return (x_mb_strrichr(a0, a1, a2));
  else return (x_mb_strrichr(a0, a1, a2, a3));
}
Variant ei_socket_sendto(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("socket_sendto", count, 5, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 5) return (x_socket_sendto(a0, a1, a2, a3, a4));
  else return (x_socket_sendto(a0, a1, a2, a3, a4, a5));
}
Variant ei_memcache_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("memcache_flush", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_memcache_flush(a0));
  else return (x_memcache_flush(a0, a1));
}
Variant ei_mb_output_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mb_output_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_output_handler(a0, a1));
}
Variant ei_fclose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fclose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fclose(a0));
}
Variant ei_drawpathcurvetoquadraticbeziersmoothabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathcurvetoquadraticbeziersmoothabsolute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetoquadraticbeziersmoothabsolute(a0, a1, a2), null);
}
Variant ei_function_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("function_exists", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_function_exists(a0));
}
Variant ei_ctype_alpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_alpha", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_alpha(a0));
}
Variant ei_pos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pos", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pos(ref(a0)));
}
Variant ei_pagelet_server_is_enabled(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pagelet_server_is_enabled", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pagelet_server_is_enabled());
}
Variant ei_xbox_get_thread_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_get_thread_timeout", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_get_thread_timeout());
}
Variant ei_imagecolorexactalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorexactalpha", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorexactalpha(a0, a1, a2, a3, a4));
}
Variant ei_pow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pow", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pow(a0, a1));
}
Variant ei_pixelgetredquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetredquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetredquantum(a0));
}
Variant ei_imagecolorsforindex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolorsforindex", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorsforindex(a0, a1));
}
Variant ei_libxml_set_streams_context(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("libxml_set_streams_context", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_libxml_set_streams_context(a0), null);
}
Variant ei_dom_node_clone_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_node_clone_node", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dom_node_clone_node(a0));
  else return (x_dom_node_clone_node(a0, a1));
}
Variant ei_image_type_to_mime_type(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("image_type_to_mime_type", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_image_type_to_mime_type(a0));
}
Variant ei_socket_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("socket_create", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_create(a0, a1, a2));
}
Variant ei_xmlwriter_write_pi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_pi", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_pi(a0, a1, a2));
}
Variant ei_posix_getppid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getppid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getppid());
}
Variant ei_mb_stripos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_stripos", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_stripos(a0, a1));
  else if (count == 3) return (x_mb_stripos(a0, a1, a2));
  else return (x_mb_stripos(a0, a1, a2, a3));
}
Variant ei_magickpingimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickpingimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickpingimage(a0, a1));
}
Variant ei_bcpowmod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("bcpowmod", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_bcpowmod(a0, a1, a2));
  else return (x_bcpowmod(a0, a1, a2, a3));
}
Variant ei_timezone_offset_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("timezone_offset_get", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_offset_get(a0, a1));
}
Variant ei_dom_document_create_text_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_text_node", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_text_node(a0, a1));
}
Variant ei_getrandmax(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getrandmax", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getrandmax());
}
Variant ei_hphp_splfileobject_fseek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_splfileobject_fseek", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fseek(a0, a1, a2));
}
Variant ei_ctype_alnum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_alnum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_alnum(a0));
}
Variant ei_tan(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("tan", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_tan(a0));
}
Variant ei_set_exception_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_exception_handler", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_set_exception_handler(a0));
}
Variant ei_imagegrabwindow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegrabwindow", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagegrabwindow(a0));
  else return (x_imagegrabwindow(a0, a1));
}
Variant ei_memcache_add(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_add", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_memcache_add(a0, a1, a2));
  else if (count == 4) return (x_memcache_add(a0, a1, a2, a3));
  else return (x_memcache_add(a0, a1, a2, a3, a4));
}
Variant ei_magickstereoimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickstereoimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickstereoimage(a0, a1));
}
Variant ei_magickgetimagescene(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagescene", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagescene(a0));
}
Variant ei_hphp_splfileinfo_isfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isfile", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_isfile(a0));
}
Variant ei_openssl_csr_sign(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 6) return throw_wrong_arguments("openssl_csr_sign", count, 4, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_openssl_csr_sign(a0, a1, a2, a3));
  else if (count == 5) return (x_openssl_csr_sign(a0, a1, a2, a3, a4));
  else return (x_openssl_csr_sign(a0, a1, a2, a3, a4, a5));
}
Variant ei_openssl_pkcs12_export(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("openssl_pkcs12_export", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_openssl_pkcs12_export(a0, ref(a1), a2, a3));
  else return (x_openssl_pkcs12_export(a0, ref(a1), a2, a3, a4));
}
Variant ei_magickgetquantumdepth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetquantumdepth", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetquantumdepth());
}
Variant ei_socket_listen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_listen", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_socket_listen(a0));
  else return (x_socket_listen(a0, a1));
}
Variant ei_parse_str(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("parse_str", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_parse_str(a0), null);
  else return (x_parse_str(a0, ref(a1)), null);
}
Variant ei_sin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sin", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sin(a0));
}
Variant ei_dom_node_append_child(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_append_child", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_append_child(a0, a1));
}
Variant ei_cosh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cosh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_cosh(a0));
}
Variant ei_copy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("copy", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_copy(a0, a1));
  else return (x_copy(a0, a1, a2));
}
Variant ei_imagechar(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagechar", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagechar(a0, a1, a2, a3, a4, a5));
}
Variant ei_magicksetimagebackgroundcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebackgroundcolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagebackgroundcolor(a0, a1));
}
Variant ei_ldap_mod_add(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_add", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_mod_add(a0, a1, a2));
}
Variant ei_fb_thrift_serialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_thrift_serialize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_thrift_serialize(a0));
}
Variant ei_posix_ttyname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_ttyname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_ttyname(a0));
}
Variant ei_filectime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filectime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_filectime(a0));
}
Variant ei_newpixelwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("newpixelwand", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_newpixelwand());
  else return (x_newpixelwand(a0));
}
Variant ei_pcntl_wait(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("pcntl_wait", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pcntl_wait(ref(a0)));
  else return (x_pcntl_wait(ref(a0), a1));
}
Variant ei_hypot(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hypot", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hypot(a0, a1));
}
Variant ei_parse_url(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("parse_url", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_parse_url(a0));
  else return (x_parse_url(a0, a1));
}
Variant ei_magickreadimageblob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimageblob", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickreadimageblob(a0, a1));
}
Variant ei_eregi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("eregi", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_eregi(a0, a1));
  else return (x_eregi(a0, a1, ref(a2)));
}
Variant ei_pixelsetcolorcount(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcolorcount", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetcolorcount(a0, a1), null);
}
Variant ei_drawpathcurvetoquadraticbezierrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetoquadraticbezierrelative", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetoquadraticbezierrelative(a0, a1, a2, a3, a4), null);
}
Variant ei_posix_getgroups(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getgroups", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getgroups());
}
Variant ei_fileinode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileinode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fileinode(a0));
}
Variant ei_magickgetnumberimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetnumberimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetnumberimages(a0));
}
Variant ei_magickgetimagesblob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesblob", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagesblob(a0));
}
Variant ei_magickcontrastimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcontrastimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcontrastimage(a0, a1));
}
Variant ei_pcntl_setpriority(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pcntl_setpriority", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pcntl_setpriority(a0));
  else if (count == 2) return (x_pcntl_setpriority(a0, a1));
  else return (x_pcntl_setpriority(a0, a1, a2));
}
Variant ei_drawgetfontstretch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontstretch", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfontstretch(a0));
}
Variant ei_bcscale(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bcscale", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_bcscale(a0));
}
Variant ei_imageconvolution(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imageconvolution", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageconvolution(a0, a1, a2, a3));
}
Variant ei_utf8_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("utf8_decode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_utf8_decode(a0));
}
Variant ei_ldap_unbind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_unbind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_unbind(a0));
}
Variant ei_newpixelregioniterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("newpixelregioniterator", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newpixelregioniterator(a0, a1, a2, a3, a4));
}
Variant ei_array_intersect_assoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect_assoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_intersect_assoc(count, a0, a1));
  return (x_array_intersect_assoc(count, a0, a1,vargs));
}
Variant ei_ob_get_level(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_level", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_get_level());
}
Variant ei_hebrev(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hebrev", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_hebrev(a0));
  else return (x_hebrev(a0, a1));
}
Variant ei_socket_set_block(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_set_block", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_set_block(a0));
}
Variant ei_mcrypt_module_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_module_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_module_close(a0));
}
Variant ei_mb_strwidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strwidth", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_strwidth(a0));
  else return (x_mb_strwidth(a0, a1));
}
Variant ei_clonemagickwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clonemagickwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clonemagickwand(a0));
}
Variant ei_pixelgetred(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetred", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetred(a0));
}
Variant ei_dom_document_create_processing_instruction(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_create_processing_instruction", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_document_create_processing_instruction(a0, a1));
  else return (x_dom_document_create_processing_instruction(a0, a1, a2));
}
Variant ei_ip2long(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ip2long", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ip2long(a0));
}
Variant ei_mb_stristr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_stristr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_stristr(a0, a1));
  else if (count == 3) return (x_mb_stristr(a0, a1, a2));
  else return (x_mb_stristr(a0, a1, a2, a3));
}
Variant ei_array_diff_ukey(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_diff_ukey", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_diff_ukey(count, a0, a1, a2));
  return (x_array_diff_ukey(count, a0, a1, a2,vargs));
}
Variant ei_isdrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("isdrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_isdrawingwand(a0));
}
Variant ei_magicksetimagemattecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagemattecolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagemattecolor(a0, a1));
}
Variant ei_closedir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("closedir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_closedir(a0), null);
}
Variant ei_fb_call_user_func_safe_return(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fb_call_user_func_safe_return", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_fb_call_user_func_safe_return(count, a0, a1));
  return (x_fb_call_user_func_safe_return(count, a0, a1,vargs));
}
Variant ei_magickwriteimagesfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimagesfile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickwriteimagesfile(a0, a1));
}
Variant ei_magickdescribeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdescribeimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickdescribeimage(a0));
}
Variant ei_imageftbbox(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("imageftbbox", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_imageftbbox(a0, a1, a2, a3));
  else return (x_imageftbbox(a0, a1, a2, a3, a4));
}
Variant ei_magicksetlastiterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicksetlastiterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetlastiterator(a0), null);
}
Variant ei_hphp_output_global_state(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("hphp_output_global_state", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_hphp_output_global_state());
  else return (x_hphp_output_global_state(a0));
}
Variant ei_imagefontheight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagefontheight", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefontheight(a0));
}
Variant ei_putenv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("putenv", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_putenv(a0));
}
Variant ei_magickedgeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickedgeimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickedgeimage(a0, a1));
}
Variant ei_xml_error_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_error_string", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_error_string(a0));
}
Variant ei_array_rand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_rand", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_array_rand(a0));
  else return (x_array_rand(a0, a1));
}
Variant ei_ldap_mod_del(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_del", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_mod_del(a0, a1, a2));
}
Variant ei_range(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("range", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_range(a0, a1));
  else return (x_range(a0, a1, a2));
}
Variant ei_levenshtein(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("levenshtein", count, 2, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_levenshtein(a0, a1));
  else if (count == 3) return (x_levenshtein(a0, a1, a2));
  else if (count == 4) return (x_levenshtein(a0, a1, a2, a3));
  else return (x_levenshtein(a0, a1, a2, a3, a4));
}
Variant ei_curl_multi_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_multi_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_close(a0));
}
Variant ei_drawgetfillalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillalpha", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfillalpha(a0));
}
Variant ei_hash_hmac(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("hash_hmac", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_hash_hmac(a0, a1, a2));
  else return (x_hash_hmac(a0, a1, a2, a3));
}
Variant ei_get_html_translation_table(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("get_html_translation_table", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_html_translation_table());
  else if (count == 1) return (x_get_html_translation_table(a0));
  else return (x_get_html_translation_table(a0, a1));
}
Variant ei_user_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("user_error", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_user_error(a0));
  else return (x_user_error(a0, a1));
}
Variant ei_feof(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("feof", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_feof(a0));
}
Variant ei_filemtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filemtime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_filemtime(a0));
}
Variant ei_microtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("microtime", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_microtime());
  else return (x_microtime(a0));
}
Variant ei_zend_version(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_version", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_zend_version());
}
Variant ei_openssl_x509_free(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_x509_free", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_x509_free(a0), null);
}
Variant ei_fb_call_user_func_safe(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("fb_call_user_func_safe", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_fb_call_user_func_safe(count, a0));
  return (x_fb_call_user_func_safe(count, a0,vargs));
}
Variant ei_var_export(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("var_export", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_var_export(a0));
  else return (x_var_export(a0, a1));
}
Variant ei_mb_strcut(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strcut", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strcut(a0, a1));
  else if (count == 3) return (x_mb_strcut(a0, a1, a2));
  else return (x_mb_strcut(a0, a1, a2, a3));
}
Variant ei_xmlwriter_end_comment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_comment", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_comment(a0));
}
Variant ei_xmlwriter_end_dtd_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_element", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_dtd_element(a0));
}
Variant ei_dom_text_split_text(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_text_split_text", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_text_split_text(a0, a1));
}
Variant ei_openssl_pkey_export_to_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_pkey_export_to_file", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_pkey_export_to_file(a0, a1));
  else if (count == 3) return (x_openssl_pkey_export_to_file(a0, a1, a2));
  else return (x_openssl_pkey_export_to_file(a0, a1, a2, a3));
}
Variant ei_hphp_get_original_class_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_original_class_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_original_class_name(a0));
}
Variant ei_imagecolorclosesthwb(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorclosesthwb", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorclosesthwb(a0, a1, a2, a3));
}
Variant ei_ldap_get_attributes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_attributes", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_attributes(a0, a1));
}
Variant ei_date_modify(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_modify", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_modify(a0, a1), null);
}
Variant ei_hphp_splfileinfo_setinfoclass(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_setinfoclass", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_setinfoclass(a0, a1), null);
}
Variant ei_umask(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("umask", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_umask());
  else return (x_umask(a0));
}
Variant ei_xml_get_current_column_number(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_column_number", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_get_current_column_number(a0));
}
Variant ei_pixelsetblue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblue", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetblue(a0, a1), null);
}
Variant ei_mb_http_output(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_http_output", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_http_output());
  else return (x_mb_http_output(a0));
}
Variant ei_flock(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("flock", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_flock(a0, a1));
  else return (x_flock(a0, a1, ref(a2)));
}
Variant ei_hphp_splfileobject_ftell(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_ftell", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_ftell(a0));
}
Variant ei_pcntl_wifexited(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifexited", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wifexited(a0));
}
Variant ei_magicksetformat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetformat", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetformat(a0, a1));
}
Variant ei_array_map(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_map", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_map(count, a0, a1));
  return (x_array_map(count, a0, a1,vargs));
}
Variant ei_magicksharpenimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magicksharpenimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magicksharpenimage(a0, a1, a2));
  else return (x_magicksharpenimage(a0, a1, a2, a3));
}
Variant ei_is_infinite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_infinite", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_infinite(a0));
}
Variant ei_date_timezone_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_timezone_set", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_timezone_set(a0, a1), null);
}
Variant ei_mb_ereg_search_init(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_ereg_search_init", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_ereg_search_init(a0));
  else if (count == 2) return (x_mb_ereg_search_init(a0, a1));
  else return (x_mb_ereg_search_init(a0, a1, a2));
}
Variant ei_drawcircle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawcircle", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawcircle(a0, a1, a2, a3, a4), null);
}
Variant ei_is_readable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_readable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_readable(a0));
}
Variant ei_image_type_to_extension(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("image_type_to_extension", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_image_type_to_extension(a0));
  else return (x_image_type_to_extension(a0, a1));
}
Variant ei_printf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("printf", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_printf(count, a0));
  return (x_printf(count, a0,vargs));
}
Variant ei_magicksetimagecompression(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompression", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagecompression(a0, a1));
}
Variant ei_mcrypt_decrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_decrypt", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_decrypt(a0, a1, a2, a3));
  else return (x_mcrypt_decrypt(a0, a1, a2, a3, a4));
}
Variant ei_hphp_directoryiterator_next(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_next", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_next(a0), null);
}
Variant ei_natcasesort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("natcasesort", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_natcasesort(ref(a0)));
}
Variant ei_intl_get_error_message(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("intl_get_error_message", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_intl_get_error_message());
}
Variant ei_memcache_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_get", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_get(a0, a1));
  else return (x_memcache_get(a0, a1, ref(a2)));
}
Variant ei_array_chunk(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_chunk", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_chunk(a0, a1));
  else return (x_array_chunk(a0, a1, a2));
}
Variant ei_collator_asort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("collator_asort", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_collator_asort(a0, ref(a1)));
  else return (x_collator_asort(a0, ref(a1), a2));
}
Variant ei_imagefilledpolygon(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagefilledpolygon", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefilledpolygon(a0, a1, a2, a3));
}
Variant ei_drawpoppattern(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpoppattern", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpoppattern(a0), null);
}
Variant ei_magickgetimagewidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagewidth", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagewidth(a0));
}
Variant ei_drawgetfontfamily(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontfamily", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfontfamily(a0));
}
Variant ei_dl(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dl", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dl(a0));
}
Variant ei_touch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("touch", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_touch(a0));
  else if (count == 2) return (x_touch(a0, a1));
  else return (x_touch(a0, a1, a2));
}
Variant ei_hphp_recursivedirectoryiterator___tostring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator___tostring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator___tostring(a0));
}
Variant ei_magicksetimagebordercolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebordercolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagebordercolor(a0, a1));
}
Variant ei_hphp_directoryiterator_rewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_rewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_rewind(a0), null);
}
Variant ei_magickspliceimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickspliceimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickspliceimage(a0, a1, a2, a3, a4));
}
Variant ei_define(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("define", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_define(a0, a1));
  else return (x_define(a0, a1, a2));
}
Variant ei_headers_sent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("headers_sent", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_headers_sent());
  else if (count == 1) return (x_headers_sent(ref(a0)));
  else return (x_headers_sent(ref(a0), ref(a1)));
}
Variant ei_stream_context_get_options(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_context_get_options", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_context_get_options(a0));
}
Variant ei_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("file", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_file(a0));
  else if (count == 2) return (x_file(a0, a1));
  else return (x_file(a0, a1, a2));
}
Variant ei_memcache_get_extended_stats(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_get_extended_stats", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_memcache_get_extended_stats(a0));
  else if (count == 2) return (x_memcache_get_extended_stats(a0, a1));
  else if (count == 3) return (x_memcache_get_extended_stats(a0, a1, a2));
  else return (x_memcache_get_extended_stats(a0, a1, a2, a3));
}
Variant ei_hphp_crash_log(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_crash_log", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_crash_log(a0, a1), null);
}
Variant ei_imagecolorresolvealpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorresolvealpha", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorresolvealpha(a0, a1, a2, a3, a4));
}
Variant ei_strtr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strtr", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strtr(a0, a1));
  else return (x_strtr(a0, a1, a2));
}
Variant ei_posix_strerror(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_strerror", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_strerror(a0));
}
Variant ei_libxml_use_internal_errors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("libxml_use_internal_errors", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_libxml_use_internal_errors());
  else return (x_libxml_use_internal_errors(a0));
}
Variant ei_end_user_func_async(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("end_user_func_async", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_end_user_func_async(a0));
  else if (count == 2) return (x_end_user_func_async(a0, a1));
  else return (x_end_user_func_async(a0, a1, a2));
}
Variant ei_openssl_get_publickey(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_get_publickey", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_get_publickey(a0));
}
Variant ei_dom_node_lookup_prefix(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_lookup_prefix", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_lookup_prefix(a0, a1));
}
Variant ei_time_nanosleep(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("time_nanosleep", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_time_nanosleep(a0, a1));
}
Variant ei_magicksetimageunits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageunits", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageunits(a0, a1));
}
Variant ei_floor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("floor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_floor(a0));
}
Variant ei_array_pad(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("array_pad", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_pad(a0, a1, a2));
}
Variant ei_sem_release(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_release", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sem_release(a0));
}
Variant ei_hphp_splfileinfo_getctime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getctime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getctime(a0));
}
Variant ei_highlight_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("highlight_string", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_highlight_string(a0));
  else return (x_highlight_string(a0, a1));
}
Variant ei_hphp_invoke(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_invoke", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_invoke(a0, a1));
}
Variant ei_imageloadfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imageloadfont", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageloadfont(a0));
}
Variant ei_xmlwriter_start_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_element", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_element(a0, a1));
}
Variant ei_localeconv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("localeconv", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_localeconv());
}
Variant ei_exif_thumbnail(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("exif_thumbnail", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_exif_thumbnail(a0));
  else if (count == 2) return (x_exif_thumbnail(a0, ref(a1)));
  else if (count == 3) return (x_exif_thumbnail(a0, ref(a1), ref(a2)));
  else return (x_exif_thumbnail(a0, ref(a1), ref(a2), ref(a3)));
}
Variant ei_collator_get_error_message(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_error_message", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_get_error_message(a0));
}
Variant ei_mysql_get_proto_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_proto_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_get_proto_info());
  else return (x_mysql_get_proto_info(a0));
}
Variant ei_imagefontwidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagefontwidth", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefontwidth(a0));
}
Variant ei_substr_compare(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("substr_compare", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_substr_compare(a0, a1, a2));
  else if (count == 4) return (x_substr_compare(a0, a1, a2, a3));
  else return (x_substr_compare(a0, a1, a2, a3, a4));
}
Variant ei_xbox_post_message(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xbox_post_message", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_xbox_post_message(a0));
  else return (x_xbox_post_message(a0, a1));
}
Variant ei_fb_rename_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_rename_function", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_rename_function(a0, a1));
}
Variant ei_array_walk_recursive(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_walk_recursive", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_walk_recursive(ref(a0), a1));
  else return (x_array_walk_recursive(ref(a0), a1, a2));
}
Variant ei_mysql_list_processes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_list_processes", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_list_processes());
  else return (x_mysql_list_processes(a0));
}
Variant ei_imagedashedline(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagedashedline", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagedashedline(a0, a1, a2, a3, a4, a5));
}
Variant ei_magickgetimagedelay(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagedelay", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagedelay(a0));
}
Variant ei_pi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pi", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pi());
}
Variant ei_mb_substr_count(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_substr_count", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_substr_count(a0, a1));
  else return (x_mb_substr_count(a0, a1, a2));
}
Variant ei_hphp_splfileinfo_getinode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getinode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getinode(a0));
}
Variant ei_magickgettextdescent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgettextdescent", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgettextdescent(a0, a1, a2));
  else return (x_magickgettextdescent(a0, a1, a2, a3));
}
Variant ei_drawsetstrokealpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokealpha", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokealpha(a0, a1), null);
}
Variant ei_apc_delete_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apc_delete_file", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_delete_file(a0));
  else return (x_apc_delete_file(a0, a1));
}
Variant ei_strrpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strrpos", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strrpos(a0, a1));
  else return (x_strrpos(a0, a1, a2));
}
Variant ei_array_diff_assoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff_assoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_diff_assoc(count, a0, a1));
  return (x_array_diff_assoc(count, a0, a1,vargs));
}
Variant ei_magickclippathimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickclippathimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickclippathimage(a0, a1, a2));
}
Variant ei_xmlwriter_write_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("xmlwriter_write_element", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_xmlwriter_write_element(a0, a1));
  else return (x_xmlwriter_write_element(a0, a1, a2));
}
Variant ei_dom_document_schema_validate_xml(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_schema_validate_xml", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_schema_validate_xml(a0, a1));
}
Variant ei_ereg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("ereg", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_ereg(a0, a1));
  else return (x_ereg(a0, a1, ref(a2)));
}
Variant ei_curl_multi_info_read(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_multi_info_read", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_curl_multi_info_read(a0));
  else return (x_curl_multi_info_read(a0, ref(a1)));
}
Variant ei_magickthresholdimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickthresholdimage", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickthresholdimage(a0, a1));
  else return (x_magickthresholdimage(a0, a1, a2));
}
Variant ei_msg_remove_queue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("msg_remove_queue", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_msg_remove_queue(a0));
}
Variant ei_mb_strlen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strlen", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_strlen(a0));
  else return (x_mb_strlen(a0, a1));
}
Variant ei_drawgetclippath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetclippath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetclippath(a0));
}
Variant ei_imagecopy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagecopy", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecopy(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_pixelsetcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetcolor(a0, a1), null);
}
Variant ei_time_sleep_until(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("time_sleep_until", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_time_sleep_until(a0));
}
Variant ei_session_unset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_unset", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_unset());
}
Variant ei_mb_ereg_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("mb_ereg_replace", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_mb_ereg_replace(a0, a1, a2));
  else return (x_mb_ereg_replace(a0, a1, a2, a3));
}
Variant ei_openssl_csr_get_public_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_csr_get_public_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_csr_get_public_key(a0));
}
Variant ei_magickfximage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickfximage", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickfximage(a0, a1));
  else return (x_magickfximage(a0, a1, a2));
}
Variant ei_tmpfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("tmpfile", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_tmpfile());
}
Variant ei_hash(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_hash(a0, a1));
  else return (x_hash(a0, a1, a2));
}
Variant ei_uasort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("uasort", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_uasort(ref(a0), a1));
}
Variant ei_pixelgetalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetalpha", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetalpha(a0));
}
Variant ei_drawsettextencoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextencoding", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsettextencoding(a0, a1), null);
}
Variant ei_apache_request_headers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_request_headers", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_request_headers());
}
Variant ei_is_subclass_of(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("is_subclass_of", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_subclass_of(a0, a1));
}
Variant ei_pixelgetmagentaquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetmagentaquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetmagentaquantum(a0));
}
Variant ei_hphp_get_static_property(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_get_static_property", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_static_property(a0, a1));
}
Variant ei_array_pop(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_pop", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_pop(ref(a0)));
}
Variant ei_magickgetimagecolors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecolors", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecolors(a0));
}
Variant ei_session_regenerate_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_regenerate_id", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_regenerate_id());
  else return (x_session_regenerate_id(a0));
}
Variant ei_class_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_exists", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_class_exists(a0));
  else return (x_class_exists(a0, a1));
}
Variant ei_getallheaders(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getallheaders", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getallheaders());
}
Variant ei_get_extension_funcs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_extension_funcs", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_extension_funcs(a0));
}
Variant ei_imagecolordeallocate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolordeallocate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolordeallocate(a0, a1));
}
Variant ei_closelog(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("closelog", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_closelog());
}
Variant ei_drawpathlinetoabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathlinetoabsolute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetoabsolute(a0, a1, a2), null);
}
Variant ei_mcrypt_enc_get_iv_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_iv_size", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_iv_size(a0));
}
Variant ei_json_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("json_decode", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_json_decode(a0));
  else if (count == 2) return (x_json_decode(a0, a1));
  else return (x_json_decode(a0, a1, a2));
}
Variant ei_preg_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_replace", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_preg_replace(a0, a1, a2));
  else if (count == 4) return (x_preg_replace(a0, a1, a2, a3));
  else return (x_preg_replace(a0, a1, a2, a3, ref(a4)));
}
Variant ei_hphp_splfileinfo_getmtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getmtime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getmtime(a0));
}
Variant ei_fmod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fmod", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fmod(a0, a1));
}
Variant ei_curl_errno(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_errno", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_errno(a0));
}
Variant ei_pagelet_server_task_start(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pagelet_server_task_start", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pagelet_server_task_start(a0));
  else if (count == 2) return (x_pagelet_server_task_start(a0, a1));
  else return (x_pagelet_server_task_start(a0, a1, a2));
}
Variant ei_hash_init(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("hash_init", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_hash_init(a0));
  else if (count == 2) return (x_hash_init(a0, a1));
  else return (x_hash_init(a0, a1, a2));
}
Variant ei_mb_strripos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strripos", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strripos(a0, a1));
  else if (count == 3) return (x_mb_strripos(a0, a1, a2));
  else return (x_mb_strripos(a0, a1, a2, a3));
}
Variant ei_mysql_fetch_row(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_row", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_fetch_row(a0));
}
Variant ei_hphp_splfileobject_setcsvcontrol(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_setcsvcontrol", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_setcsvcontrol(a0, a1, a2, a3), null);
}
Variant ei_ob_get_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_flush", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_get_flush());
}
Variant ei_curl_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_error", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_error(a0));
}
Variant ei_set_magic_quotes_runtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_magic_quotes_runtime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_set_magic_quotes_runtime(a0));
}
Variant ei_magickcharcoalimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickcharcoalimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcharcoalimage(a0, a1, a2));
}
Variant ei_scandir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("scandir", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_scandir(a0));
  else if (count == 2) return (x_scandir(a0, a1));
  else return (x_scandir(a0, a1, a2));
}
Variant ei_magickmosaicimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickmosaicimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmosaicimages(a0));
}
Variant ei_timezone_transitions_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_transitions_get", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_transitions_get(a0));
}
Variant ei_drawsetfontweight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontweight", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfontweight(a0, a1), null);
}
Variant ei_popdrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("popdrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_popdrawingwand(a0), null);
}
Variant ei_collator_sort_with_sort_keys(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_sort_with_sort_keys", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_sort_with_sort_keys(a0, ref(a1)));
}
Variant ei_socket_shutdown(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_shutdown", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_socket_shutdown(a0));
  else return (x_socket_shutdown(a0, a1));
}
Variant ei_mcrypt_create_iv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_create_iv", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_create_iv(a0));
  else return (x_mcrypt_create_iv(a0, a1));
}
Variant ei_eval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("eval", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_eval(a0));
}
Variant ei_bindec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bindec", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_bindec(a0));
}
Variant ei_fileperms(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileperms", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fileperms(a0));
}
Variant ei_hphp_splfileobject_fstat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fstat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fstat(a0));
}
Variant ei_unserialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("unserialize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_unserialize(a0));
}
Variant ei_urldecode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("urldecode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_urldecode(a0));
}
Variant ei_magickannotateimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickannotateimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickannotateimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_mailparse_msg_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mailparse_msg_create", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_create());
}
Variant ei_session_set_cookie_params(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("session_set_cookie_params", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_session_set_cookie_params(a0), null);
  else if (count == 2) return (x_session_set_cookie_params(a0, a1), null);
  else if (count == 3) return (x_session_set_cookie_params(a0, a1, a2), null);
  else if (count == 4) return (x_session_set_cookie_params(a0, a1, a2, a3), null);
  else return (x_session_set_cookie_params(a0, a1, a2, a3, a4), null);
}
Variant ei_drawellipse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawellipse", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawellipse(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_xmlwriter_write_element_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("xmlwriter_write_element_ns", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_xmlwriter_write_element_ns(a0, a1, a2, a3));
  else return (x_xmlwriter_write_element_ns(a0, a1, a2, a3, a4));
}
Variant ei_magicksetcompressionquality(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetcompressionquality", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetcompressionquality(a0, a1));
}
Variant ei_magickaddnoiseimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaddnoiseimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickaddnoiseimage(a0, a1));
}
Variant ei_magickgetimagewhitepoint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagewhitepoint", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagewhitepoint(a0));
}
Variant ei_magickseparateimagechannel(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickseparateimagechannel", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickseparateimagechannel(a0, a1));
}
Variant ei_array_push(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_push", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_push(count, ref(a0), a1));
  return (x_array_push(count, ref(a0), a1,vargs));
}
Variant ei_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("flush", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_flush(), null);
}
Variant ei_connection_aborted(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_aborted", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_connection_aborted());
}
Variant ei_uksort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("uksort", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_uksort(ref(a0), a1));
}
Variant ei_mysql_set_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mysql_set_timeout", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_set_timeout());
  else if (count == 1) return (x_mysql_set_timeout(a0));
  else return (x_mysql_set_timeout(a0, a1));
}
Variant ei_hash_update_stream(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_update_stream", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_hash_update_stream(a0, a1));
  else return (x_hash_update_stream(a0, a1, a2));
}
Variant ei_ob_start(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 3) return throw_toomany_arguments("ob_start", 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ob_start());
  else if (count == 1) return (x_ob_start(a0));
  else if (count == 2) return (x_ob_start(a0, a1));
  else return (x_ob_start(a0, a1, a2));
}
Variant ei_mysql_get_host_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_host_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_get_host_info());
  else return (x_mysql_get_host_info(a0));
}
Variant ei_mb_language(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_language", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_language());
  else return (x_mb_language(a0));
}
Variant ei_pixelgetnextiteratorrow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetnextiteratorrow", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetnextiteratorrow(a0));
}
Variant ei_ldap_next_reference(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_reference", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_next_reference(a0, a1));
}
Variant ei_socket_get_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_get_status", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_get_status(a0));
}
Variant ei_checkdnsrr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("checkdnsrr", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_checkdnsrr(a0));
  else return (x_checkdnsrr(a0, a1));
}
Variant ei_openssl_verify(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_verify", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_verify(a0, a1, a2));
  else return (x_openssl_verify(a0, a1, a2, a3));
}
Variant ei_curl_exec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_exec", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_exec(a0));
}
Variant ei_magickgetexceptiontype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexceptiontype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetexceptiontype(a0));
}
Variant ei_array_sum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_sum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_sum(a0));
}
Variant ei_unregister_tick_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("unregister_tick_function", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_unregister_tick_function(a0), null);
}
Variant ei_newpixelwandarray(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixelwandarray", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newpixelwandarray(a0));
}
Variant ei_magickgetversion(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversion", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetversion());
}
Variant ei_imagelayereffect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagelayereffect", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagelayereffect(a0, a1));
}
Variant ei_glob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("glob", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_glob(a0));
  else return (x_glob(a0, a1));
}
Variant ei_exec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("exec", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_exec(a0));
  else if (count == 2) return (x_exec(a0, ref(a1)));
  else return (x_exec(a0, ref(a1), ref(a2)));
}
Variant ei_apd_continue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_continue", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_continue());
}
Variant ei_magickgetimagedepth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickgetimagedepth", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magickgetimagedepth(a0));
  else return (x_magickgetimagedepth(a0, a1));
}
Variant ei_pclose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pclose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pclose(a0));
}
Variant ei_get_parent_class(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_parent_class", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_parent_class());
  else return (x_get_parent_class(a0));
}
Variant ei_mb_strpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strpos", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strpos(a0, a1));
  else if (count == 3) return (x_mb_strpos(a0, a1, a2));
  else return (x_mb_strpos(a0, a1, a2, a3));
}
Variant ei_xmlwriter_write_dtd_attlist(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_dtd_attlist", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_dtd_attlist(a0, a1, a2));
}
Variant ei_xml_set_element_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xml_set_element_handler", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_element_handler(a0, a1, a2));
}
Variant ei_drawgetstrokeopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokeopacity", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokeopacity(a0));
}
Variant ei_ldap_get_entries(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_entries", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_entries(a0, a1));
}
Variant ei_ob_iconv_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ob_iconv_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_iconv_handler(a0, a1));
}
Variant ei_hphp_throw_fatal_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_throw_fatal_error", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_throw_fatal_error(a0), null);
}
Variant ei_pathinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("pathinfo", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pathinfo(a0));
  else return (x_pathinfo(a0, a1));
}
Variant ei_magickaffinetransformimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaffinetransformimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickaffinetransformimage(a0, a1));
}
Variant ei_fb_stubout_intercept_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("fb_stubout_intercept_handler", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_stubout_intercept_handler(a0, a1, a2, a3, ref(a4)));
}
Variant ei_ob_get_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ob_get_status", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ob_get_status());
  else return (x_ob_get_status(a0));
}
Variant ei_collator_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_create", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_create(a0));
}
Variant ei_exit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("exit", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_exit());
  else return (x_exit(a0));
}
Variant ei_memcache_debug(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_debug", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_memcache_debug(a0));
}
Variant ei_apc_sma_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("apc_sma_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_apc_sma_info());
  else return (x_apc_sma_info(a0));
}
Variant ei_ldap_bind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("ldap_bind", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_ldap_bind(a0));
  else if (count == 2) return (x_ldap_bind(a0, a1));
  else return (x_ldap_bind(a0, a1, a2));
}
Variant ei_pixelsetbluequantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetbluequantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetbluequantum(a0, a1), null);
}
Variant ei_magickreadimagefile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimagefile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickreadimagefile(a0, a1));
}
Variant ei_session_is_registered(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_is_registered", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_is_registered(a0));
}
Variant ei_mysql_real_escape_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_real_escape_string", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_real_escape_string(a0));
  else return (x_mysql_real_escape_string(a0, a1));
}
Variant ei_magickframeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickframeimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickframeimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_pixelgetblue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblue", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetblue(a0));
}
Variant ei_imagefill(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagefill", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefill(a0, a1, a2, a3));
}
Variant ei_hphp_set_property(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_set_property", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_set_property(a0, a1, a2, a3), null);
}
Variant ei_readgzfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("readgzfile", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_readgzfile(a0));
  else return (x_readgzfile(a0, a1));
}
Variant ei_memcache_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_set", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_memcache_set(a0, a1, a2));
  else if (count == 4) return (x_memcache_set(a0, a1, a2, a3));
  else return (x_memcache_set(a0, a1, a2, a3, a4));
}
Variant ei_magicksampleimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksampleimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksampleimage(a0, a1, a2));
}
Variant ei_mysql_escape_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_escape_string", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_escape_string(a0));
}
Variant ei_idn_to_utf8(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_utf8", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_idn_to_utf8(a0));
  else return (x_idn_to_utf8(a0, ref(a1)));
}
Variant ei_sql_regcase(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sql_regcase", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sql_regcase(a0));
}
Variant ei_in_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("in_array", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_in_array(a0, a1));
  else return (x_in_array(a0, a1, a2));
}
Variant ei_drawpathcurvetoquadraticbezierabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetoquadraticbezierabsolute", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetoquadraticbezierabsolute(a0, a1, a2, a3, a4), null);
}
Variant ei_socket_set_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_set_timeout", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_set_timeout(a0, a1));
  else return (x_socket_set_timeout(a0, a1, a2));
}
Variant ei_bin2hex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bin2hex", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_bin2hex(a0));
}
Variant ei_error_get_last(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("error_get_last", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_error_get_last());
}
Variant ei_is_link(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_link", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_link(a0));
}
Variant ei_set_file_buffer(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("set_file_buffer", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_set_file_buffer(a0, a1));
}
Variant ei_magicksetimageredprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageredprimary", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageredprimary(a0, a1, a2));
}
Variant ei_i18n_loc_set_default(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("i18n_loc_set_default", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_i18n_loc_set_default(a0));
}
Variant ei_ftok(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ftok", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ftok(a0, a1));
}
Variant ei_mysql_list_fields(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_list_fields", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mysql_list_fields(a0, a1));
  else return (x_mysql_list_fields(a0, a1, a2));
}
Variant ei_stream_wrapper_register(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_wrapper_register", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_wrapper_register(a0, a1));
}
Variant ei_pixelsetredquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetredquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetredquantum(a0, a1), null);
}
Variant ei_xhprof_disable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_disable", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xhprof_disable());
}
Variant ei_magickgammaimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickgammaimage", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickgammaimage(a0, a1));
  else return (x_magickgammaimage(a0, a1, a2));
}
Variant ei_pixelsetcyan(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcyan", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetcyan(a0, a1), null);
}
Variant ei_mb_decode_mimeheader(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_decode_mimeheader", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_decode_mimeheader(a0));
}
Variant ei_key_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("key_exists", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_key_exists(a0, a1));
}
Variant ei_htmlentities(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("htmlentities", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_htmlentities(a0));
  else if (count == 2) return (x_htmlentities(a0, a1));
  else if (count == 3) return (x_htmlentities(a0, a1, a2));
  else return (x_htmlentities(a0, a1, a2, a3));
}
Variant ei_rad2deg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rad2deg", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rad2deg(a0));
}
Variant ei_xmlwriter_start_dtd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("xmlwriter_start_dtd", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_xmlwriter_start_dtd(a0, a1));
  else if (count == 3) return (x_xmlwriter_start_dtd(a0, a1, a2));
  else return (x_xmlwriter_start_dtd(a0, a1, a2, a3));
}
Variant ei_drawpathstart(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathstart", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathstart(a0), null);
}
Variant ei_proc_nice(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_nice", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_proc_nice(a0));
}
Variant ei_hphp_thread_is_warmup_enabled(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_thread_is_warmup_enabled", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_thread_is_warmup_enabled());
}
Variant ei_mysql_pconnect_with_db(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 7) return throw_toomany_arguments("mysql_pconnect_with_db", 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_pconnect_with_db());
  else if (count == 1) return (x_mysql_pconnect_with_db(a0));
  else if (count == 2) return (x_mysql_pconnect_with_db(a0, a1));
  else if (count == 3) return (x_mysql_pconnect_with_db(a0, a1, a2));
  else if (count == 4) return (x_mysql_pconnect_with_db(a0, a1, a2, a3));
  else if (count == 5) return (x_mysql_pconnect_with_db(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_mysql_pconnect_with_db(a0, a1, a2, a3, a4, a5));
  else return (x_mysql_pconnect_with_db(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_imagepsslantfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsslantfont", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepsslantfont(a0, a1));
}
Variant ei_magickgetimagemattecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagemattecolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagemattecolor(a0));
}
Variant ei_mb_strstr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strstr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strstr(a0, a1));
  else if (count == 3) return (x_mb_strstr(a0, a1, a2));
  else return (x_mb_strstr(a0, a1, a2, a3));
}
Variant ei_pixelgetblack(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblack", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetblack(a0));
}
Variant ei_mysql_field_table(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_table", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_table(a0));
  else return (x_mysql_field_table(a0, a1));
}
Variant ei_magicksetimagescene(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagescene", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagescene(a0, a1));
}
Variant ei_magickgetimagerenderingintent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagerenderingintent", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagerenderingintent(a0));
}
Variant ei_setlocale(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("setlocale", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_setlocale(count, a0, a1));
  return (x_setlocale(count, a0, a1,vargs));
}
Variant ei_drawpushclippath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpushclippath", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpushclippath(a0, a1), null);
}
Variant ei_drawpopclippath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpopclippath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpopclippath(a0), null);
}
Variant ei_nl2br(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("nl2br", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_nl2br(a0));
}
Variant ei_hphp_splfileinfo_getperms(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getperms", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getperms(a0));
}
Variant ei_drawsetfillopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillopacity", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfillopacity(a0, a1), null);
}
Variant ei_mb_substitute_character(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_substitute_character", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_substitute_character());
  else return (x_mb_substitute_character(a0));
}
Variant ei_setrawcookie(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("setrawcookie", count, 1, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_setrawcookie(a0));
  else if (count == 2) return (x_setrawcookie(a0, a1));
  else if (count == 3) return (x_setrawcookie(a0, a1, a2));
  else if (count == 4) return (x_setrawcookie(a0, a1, a2, a3));
  else if (count == 5) return (x_setrawcookie(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_setrawcookie(a0, a1, a2, a3, a4, a5));
  else return (x_setrawcookie(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_evhttp_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("evhttp_get", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_evhttp_get(a0));
  else if (count == 2) return (x_evhttp_get(a0, a1));
  else return (x_evhttp_get(a0, a1, a2));
}
Variant ei_getimagesize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("getimagesize", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_getimagesize(a0));
  else return (x_getimagesize(a0, ref(a1)));
}
Variant ei_ldap_modify(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_modify", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_modify(a0, a1, a2));
}
Variant ei_ldap_search(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_search", count, 3, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_ldap_search(a0, a1, a2));
  else if (count == 4) return (x_ldap_search(a0, a1, a2, a3));
  else if (count == 5) return (x_ldap_search(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_ldap_search(a0, a1, a2, a3, a4, a5));
  else if (count == 7) return (x_ldap_search(a0, a1, a2, a3, a4, a5, a6));
  else return (x_ldap_search(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_strcasecmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcasecmp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strcasecmp(a0, a1));
}
Variant ei_magickgetimagesignature(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesignature", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagesignature(a0));
}
Variant ei_get_class_methods(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_class_methods", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_class_methods(a0));
}
Variant ei_fopen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("fopen", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fopen(a0, a1));
  else if (count == 3) return (x_fopen(a0, a1, a2));
  else return (x_fopen(a0, a1, a2, a3));
}
Variant ei_fb_const_fetch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_const_fetch", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_const_fetch(a0));
}
Variant ei_mcrypt_generic_end(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_generic_end", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_generic_end(a0));
}
Variant ei_openssl_pkey_free(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_free", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_pkey_free(a0), null);
}
Variant ei_readlink(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("readlink", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_readlink(a0));
}
Variant ei_header_remove(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("header_remove", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_header_remove(), null);
  else return (x_header_remove(a0), null);
}
Variant ei_magickechoimagesblob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickechoimagesblob", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickechoimagesblob(a0));
}
Variant ei_mailparse_msg_parse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mailparse_msg_parse", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_parse(a0, a1));
}
Variant ei_xmlwriter_text(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_text", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_text(a0, a1));
}
Variant ei_pixelsetindex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetindex", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetindex(a0, a1), null);
}
Variant ei_php_sapi_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_sapi_name", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_php_sapi_name());
}
Variant ei_mcrypt_enc_get_key_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_key_size", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_key_size(a0));
}
Variant ei_mysql_num_fields(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_num_fields", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_num_fields(a0));
}
Variant ei_dom_xpath_register_php_functions(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_xpath_register_php_functions", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dom_xpath_register_php_functions(a0));
  else return (x_dom_xpath_register_php_functions(a0, a1));
}
Variant ei_magicksteganoimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksteganoimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksteganoimage(a0, a1, a2));
}
Variant ei_magicksetfirstiterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicksetfirstiterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetfirstiterator(a0), null);
}
Variant ei_pixelgetcolorasstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcolorasstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetcolorasstring(a0));
}
Variant ei_magickremoveimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickremoveimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickremoveimage(a0));
}
Variant ei_file_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("file_exists", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_file_exists(a0));
}
Variant ei_call_user_func_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("call_user_func_array", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_call_user_func_array(a0, a1));
}
Variant ei_restore_include_path(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_include_path", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_restore_include_path(), null);
}
Variant ei_memcache_set_compress_threshold(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_set_compress_threshold", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_set_compress_threshold(a0, a1));
  else return (x_memcache_set_compress_threshold(a0, a1, a2));
}
Variant ei_dom_element_set_id_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_element_set_id_attribute_ns", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_id_attribute_ns(a0, a1, a2, a3));
}
Variant ei_drawgettextundercolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextundercolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgettextundercolor(a0));
}
Variant ei_array_shift(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_shift", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_shift(ref(a0)));
}
Variant ei_magicksetimageformat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageformat", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageformat(a0, a1));
}
Variant ei_xmlwriter_open_memory(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xmlwriter_open_memory", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_open_memory());
}
Variant ei_drawsetstrokemiterlimit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokemiterlimit", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokemiterlimit(a0, a1), null);
}
Variant ei_mb_convert_kana(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_convert_kana", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_convert_kana(a0));
  else if (count == 2) return (x_mb_convert_kana(a0, a1));
  else return (x_mb_convert_kana(a0, a1, a2));
}
Variant ei_token_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("token_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_token_name(a0));
}
Variant ei_preg_quote(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("preg_quote", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_preg_quote(a0));
  else return (x_preg_quote(a0, a1));
}
Variant ei_hphp_service_thread_started(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_service_thread_started", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_service_thread_started(), null);
}
Variant ei_magickconvolveimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickconvolveimage", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickconvolveimage(a0, a1));
  else return (x_magickconvolveimage(a0, a1, a2));
}
Variant ei_curl_getinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_getinfo", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_curl_getinfo(a0));
  else return (x_curl_getinfo(a0, a1));
}
Variant ei_pfsockopen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("pfsockopen", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pfsockopen(a0));
  else if (count == 2) return (x_pfsockopen(a0, a1));
  else if (count == 3) return (x_pfsockopen(a0, a1, ref(a2)));
  else if (count == 4) return (x_pfsockopen(a0, a1, ref(a2), ref(a3)));
  else return (x_pfsockopen(a0, a1, ref(a2), ref(a3), a4));
}
Variant ei_dom_element_get_elements_by_tag_name_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_elements_by_tag_name_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_elements_by_tag_name_ns(a0, a1, a2));
}
Variant ei_ucfirst(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ucfirst", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ucfirst(a0));
}
Variant ei_hphp_splfileinfo_isreadable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isreadable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_isreadable(a0));
}
Variant ei_chroot(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chroot", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chroot(a0));
}
Variant ei_chdir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chdir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chdir(a0));
}
Variant ei_socket_write(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_write", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_write(a0, a1));
  else return (x_socket_write(a0, a1, a2));
}
Variant ei_forward_static_call_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("forward_static_call_array", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_forward_static_call_array(a0, a1));
}
Variant ei_stream_bucket_new(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_new", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_bucket_new(a0, a1));
}
Variant ei_magickflipimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflipimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickflipimage(a0));
}
Variant ei_timezone_identifiers_list(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("timezone_identifiers_list", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_identifiers_list());
}
Variant ei_array_diff_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff_key", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_diff_key(count, a0, a1));
  return (x_array_diff_key(count, a0, a1,vargs));
}
Variant ei_session_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_encode", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_encode());
}
Variant ei_fread(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fread", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fread(a0, a1));
}
Variant ei_override_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("override_function", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_override_function(a0, a1, a2));
}
Variant ei_is_long(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_long", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_long(a0));
}
Variant ei_pixelsetred(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetred", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetred(a0, a1), null);
}
Variant ei_mailparse_uudecode_all(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_uudecode_all", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_uudecode_all(a0));
}
Variant ei_drawsetvectorgraphics(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetvectorgraphics", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetvectorgraphics(a0, a1));
}
Variant ei_ctype_upper(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_upper", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_upper(a0));
}
Variant ei_get_declared_classes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_declared_classes", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_declared_classes());
}
Variant ei_drawgetstrokelinejoin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokelinejoin", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokelinejoin(a0));
}
Variant ei_popen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("popen", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_popen(a0, a1));
}
Variant ei_ldap_next_entry(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_entry", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_next_entry(a0, a1));
}
Variant ei_mailparse_msg_parse_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_parse_file", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_parse_file(a0));
}
Variant ei_get_loaded_extensions(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_loaded_extensions", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_loaded_extensions());
  else return (x_get_loaded_extensions(a0));
}
Variant ei_magickdrawimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickdrawimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickdrawimage(a0, a1));
}
Variant ei_mcrypt_cbc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_cbc", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_cbc(a0, a1, a2, a3));
  else return (x_mcrypt_cbc(a0, a1, a2, a3, a4));
}
Variant ei_session_set_save_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("session_set_save_handler", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_set_save_handler(a0, a1, a2, a3, a4, a5));
}
Variant ei_dom_element_get_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_attribute(a0, a1));
}
Variant ei_imagecreatetruecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecreatetruecolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatetruecolor(a0, a1));
}
Variant ei_intl_is_failure(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("intl_is_failure", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_intl_is_failure(a0));
}
Variant ei_inet_ntop(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("inet_ntop", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_inet_ntop(a0));
}
Variant ei_magickreadimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickreadimage(a0, a1));
}
Variant ei_dom_node_is_default_namespace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_is_default_namespace", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_is_default_namespace(a0, a1));
}
Variant ei_curl_init(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("curl_init", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_curl_init());
  else return (x_curl_init(a0));
}
Variant ei_mcrypt_cfb(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_cfb", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_cfb(a0, a1, a2, a3));
  else return (x_mcrypt_cfb(a0, a1, a2, a3, a4));
}
Variant ei_dom_document_create_document_fragment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_create_document_fragment", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_document_fragment(a0));
}
Variant ei_set_time_limit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_time_limit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_set_time_limit(a0), null);
}
Variant ei_libxml_get_errors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_get_errors", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_libxml_get_errors());
}
Variant ei_get_magic_quotes_gpc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_magic_quotes_gpc", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_magic_quotes_gpc());
}
Variant ei_proc_get_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_get_status", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_proc_get_status(a0));
}
Variant ei_log10(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("log10", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_log10(a0));
}
Variant ei_hphp_directoryiterator_seek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_directoryiterator_seek", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_seek(a0, a1), null);
}
Variant ei_ldap_get_values(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_values", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_values(a0, a1, a2));
}
Variant ei_is_soap_fault(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_soap_fault", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_soap_fault(a0));
}
Variant ei_magickgetimagechannelmean(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimagechannelmean", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagechannelmean(a0, a1));
}
Variant ei_disk_total_space(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("disk_total_space", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_disk_total_space(a0));
}
Variant ei_imagegd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegd", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagegd(a0));
  else return (x_imagegd(a0, a1));
}
Variant ei_socket_set_blocking(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("socket_set_blocking", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_set_blocking(a0, a1));
}
Variant ei_dom_element_get_elements_by_tag_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_elements_by_tag_name", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_elements_by_tag_name(a0, a1));
}
Variant ei_posix_mknod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("posix_mknod", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_posix_mknod(a0, a1));
  else if (count == 3) return (x_posix_mknod(a0, a1, a2));
  else return (x_posix_mknod(a0, a1, a2, a3));
}
Variant ei_apc_define_constants(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_define_constants", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_apc_define_constants(a0, a1));
  else if (count == 3) return (x_apc_define_constants(a0, a1, a2));
  else return (x_apc_define_constants(a0, a1, a2, a3));
}
Variant ei_posix_kill(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_kill", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_kill(a0, a1));
}
Variant ei_drawgetstrokealpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokealpha", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokealpha(a0));
}
Variant ei_mcrypt_get_block_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_get_block_size", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_get_block_size(a0));
  else return (x_mcrypt_get_block_size(a0, a1));
}
Variant ei_magickmorphimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickmorphimages", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmorphimages(a0, a1));
}
Variant ei_getlastmod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getlastmod", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getlastmod());
}
Variant ei_magickquantizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickquantizeimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickquantizeimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_imagesavealpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesavealpha", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesavealpha(a0, a1));
}
Variant ei_drawsetfontfamily(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontfamily", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfontfamily(a0, a1));
}
Variant ei_drawsettextantialias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsettextantialias", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_drawsettextantialias(a0), null);
  else return (x_drawsettextantialias(a0, a1), null);
}
Variant ei_pixelsetgreenquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetgreenquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetgreenquantum(a0, a1), null);
}
Variant ei_bcsqrt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("bcsqrt", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_bcsqrt(a0));
  else return (x_bcsqrt(a0, a1));
}
Variant ei_pcntl_signal(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("pcntl_signal", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_pcntl_signal(a0, a1));
  else return (x_pcntl_signal(a0, a1, a2));
}
Variant ei_mcrypt_ecb(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_ecb", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_ecb(a0, a1, a2, a3));
  else return (x_mcrypt_ecb(a0, a1, a2, a3, a4));
}
Variant ei_pixelsetcyanquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcyanquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetcyanquantum(a0, a1), null);
}
Variant ei_array_walk(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_walk", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_walk(ref(a0), a1));
  else return (x_array_walk(ref(a0), a1, a2));
}
Variant ei_getmxrr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("getmxrr", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_getmxrr(a0, ref(a1)));
  else return (x_getmxrr(a0, ref(a1), ref(a2)));
}
Variant ei_magickqueryfonts(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryfonts", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickqueryfonts(a0));
}
Variant ei_floatval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("floatval", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_floatval(a0));
}
Variant ei_dom_element_get_attribute_node_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_attribute_node_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_attribute_node_ns(a0, a1, a2));
}
Variant ei_xml_set_object(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_object", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_object(a0, ref(a1)));
}
Variant ei_ctype_print(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_print", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_print(a0));
}
Variant ei_gzwrite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzwrite", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_gzwrite(a0, a1));
  else return (x_gzwrite(a0, a1, a2));
}
Variant ei_hphp_splfileinfo___tostring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo___tostring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo___tostring(a0));
}
Variant ei_magickaddimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaddimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickaddimage(a0, a1));
}
Variant ei_clearstatcache(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("clearstatcache", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clearstatcache(), null);
}
Variant ei_chgrp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chgrp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chgrp(a0, a1));
}
Variant ei_virtual(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("virtual", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_virtual(a0));
}
Variant ei_reset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("reset", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_reset(ref(a0)));
}
Variant ei_set_include_path(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_include_path", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_set_include_path(a0));
}
Variant ei_hphp_recursivedirectoryiterator_next(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_next", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_next(a0), null);
}
Variant ei_openssl_x509_export(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_x509_export", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_x509_export(a0, ref(a1)));
  else return (x_openssl_x509_export(a0, ref(a1), a2));
}
Variant ei_magickcolorizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickcolorizeimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcolorizeimage(a0, a1, a2));
}
Variant ei_imagettftext(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagettftext", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagettftext(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_mb_strrchr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrchr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strrchr(a0, a1));
  else if (count == 3) return (x_mb_strrchr(a0, a1, a2));
  else return (x_mb_strrchr(a0, a1, a2, a3));
}
Variant ei_magickgetimageprofile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimageprofile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageprofile(a0, a1));
}
Variant ei_file_put_contents(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("file_put_contents", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_file_put_contents(a0, a1));
  else if (count == 3) return (x_file_put_contents(a0, a1, a2));
  else return (x_file_put_contents(a0, a1, a2, a3));
}
Variant ei_iconv_mime_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iconv_mime_encode", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iconv_mime_encode(a0, a1));
  else return (x_iconv_mime_encode(a0, a1, a2));
}
Variant ei_log1p(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("log1p", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_log1p(a0));
}
Variant ei_fwrite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fwrite", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fwrite(a0, a1));
  else return (x_fwrite(a0, a1, a2));
}
Variant ei_atan2(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("atan2", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_atan2(a0, a1));
}
Variant ei_is_a(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("is_a", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_a(a0, a1));
}
Variant ei_idate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idate", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_idate(a0));
  else return (x_idate(a0, a1));
}
Variant ei_posix_initgroups(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_initgroups", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_initgroups(a0, a1));
}
Variant ei_arsort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("arsort", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_arsort(ref(a0)));
  else if (count == 2) return (x_arsort(ref(a0), a1));
  else return (x_arsort(ref(a0), a1, a2));
}
Variant ei_dom_characterdata_substring_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_substring_data", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_characterdata_substring_data(a0, a1, a2));
}
Variant ei_gethostbyaddr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbyaddr", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gethostbyaddr(a0));
}
Variant ei_apc_delete(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apc_delete", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  INTERCEPT_INJECTION_ALWAYS("apc_delete", "apc_delete", ArrayUtil::Slice(Array(ArrayInit(2, true).set(0, a0).set(1, a1).create()), 0, count, false), r);
  if (count <= 1) return (x_apc_delete(a0));
  else return (x_apc_delete(a0, a1));
}
Variant ei_magicklevelimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("magicklevelimage", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_magicklevelimage(a0, a1, a2, a3));
  else return (x_magicklevelimage(a0, a1, a2, a3, a4));
}
Variant ei_openssl_x509_parse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_x509_parse", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_openssl_x509_parse(a0));
  else return (x_openssl_x509_parse(a0, a1));
}
Variant ei_dom_nodelist_item(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_nodelist_item", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_nodelist_item(a0, a1));
}
Variant ei_magickcommentimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcommentimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcommentimage(a0, a1));
}
Variant ei_hphp_splfileinfo_islink(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_islink", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_islink(a0));
}
Variant ei_magicksetimagedelay(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagedelay", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagedelay(a0, a1));
}
Variant ei_magickposterizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickposterizeimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickposterizeimage(a0, a1, a2));
}
Variant ei_dom_namednodemap_get_named_item(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_namednodemap_get_named_item", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_namednodemap_get_named_item(a0, a1));
}
Variant ei_dom_element_get_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_attribute_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_attribute_ns(a0, a1, a2));
}
Variant ei_stream_socket_accept(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_socket_accept", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_socket_accept(a0));
  else if (count == 2) return (x_stream_socket_accept(a0, a1));
  else return (x_stream_socket_accept(a0, a1, ref(a2)));
}
Variant ei_magickqueryconfigureoption(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryconfigureoption", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickqueryconfigureoption(a0));
}
Variant ei_magickevaluateimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickevaluateimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickevaluateimage(a0, a1, a2));
  else return (x_magickevaluateimage(a0, a1, a2, a3));
}
Variant ei_imagesx(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagesx", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesx(a0));
}
Variant ei_imagesy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagesy", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesy(a0));
}
Variant ei_mysql_get_client_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mysql_get_client_info", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_get_client_info());
}
Variant ei_fb_crossall_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("fb_crossall_query", count, 1, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fb_crossall_query(a0));
  else if (count == 2) return (x_fb_crossall_query(a0, a1));
  else if (count == 3) return (x_fb_crossall_query(a0, a1, a2));
  else if (count == 4) return (x_fb_crossall_query(a0, a1, a2, a3));
  else if (count == 5) return (x_fb_crossall_query(a0, a1, a2, a3, a4));
  else return (x_fb_crossall_query(a0, a1, a2, a3, a4, a5));
}
Variant ei_fseek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fseek", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fseek(a0, a1));
  else return (x_fseek(a0, a1, a2));
}
Variant ei_call_user_func_array_async(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("call_user_func_array_async", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_call_user_func_array_async(a0, a1));
}
Variant ei_apc_compile_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_compile_file", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_compile_file(a0));
  else if (count == 2) return (x_apc_compile_file(a0, a1));
  else return (x_apc_compile_file(a0, a1, a2));
}
Variant ei_memcache_set_server_params(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 7) return throw_wrong_arguments("memcache_set_server_params", count, 2, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_set_server_params(a0, a1));
  else if (count == 3) return (x_memcache_set_server_params(a0, a1, a2));
  else if (count == 4) return (x_memcache_set_server_params(a0, a1, a2, a3));
  else if (count == 5) return (x_memcache_set_server_params(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_memcache_set_server_params(a0, a1, a2, a3, a4, a5));
  else return (x_memcache_set_server_params(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_magicksetpassphrase(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetpassphrase", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetpassphrase(a0, a1));
}
Variant ei_mysql_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_info());
  else return (x_mysql_info(a0));
}
Variant ei_is_writable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_writable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_writable(a0));
}
Variant ei_magickrotateimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickrotateimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickrotateimage(a0, a1, a2));
}
Variant ei_fgetcsv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("fgetcsv", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fgetcsv(a0));
  else if (count == 2) return (x_fgetcsv(a0, a1));
  else if (count == 3) return (x_fgetcsv(a0, a1, a2));
  else return (x_fgetcsv(a0, a1, a2, a3));
}
Variant ei_magickcolorfloodfillimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickcolorfloodfillimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcolorfloodfillimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_atanh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("atanh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_atanh(a0));
}
Variant ei_imagecopyresized(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  Variant a9;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 10) return throw_wrong_arguments("imagecopyresized", count, 10, 10, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a9 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecopyresized(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
Variant ei_fpassthru(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fpassthru", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fpassthru(a0));
}
Variant ei_magickblackthresholdimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickblackthresholdimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickblackthresholdimage(a0, a1));
}
Variant ei_mcrypt_encrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_encrypt", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_encrypt(a0, a1, a2, a3));
  else return (x_mcrypt_encrypt(a0, a1, a2, a3, a4));
}
Variant ei_magicksetimagegreenprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagegreenprimary", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagegreenprimary(a0, a1, a2));
}
Variant ei_xmlwriter_start_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("xmlwriter_start_attribute_ns", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_attribute_ns(a0, a1, a2, a3));
}
Variant ei_magickgetimageinterlacescheme(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageinterlacescheme", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageinterlacescheme(a0));
}
Variant ei_array_merge_recursive(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_merge_recursive", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_array_merge_recursive(count, a0));
  return (x_array_merge_recursive(count, a0,vargs));
}
Variant ei_array_uintersect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_uintersect", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_uintersect(count, a0, a1, a2));
  return (x_array_uintersect(count, a0, a1, a2,vargs));
}
Variant ei_xml_set_unparsed_entity_decl_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_unparsed_entity_decl_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_unparsed_entity_decl_handler(a0, a1));
}
Variant ei_ob_get_contents(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_contents", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_get_contents());
}
Variant ei_pixelgetcyan(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcyan", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetcyan(a0));
}
Variant ei_stream_select(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("stream_select", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_stream_select(ref(a0), ref(a1), ref(a2), a3));
  else return (x_stream_select(ref(a0), ref(a1), ref(a2), a3, a4));
}
Variant ei_get_resource_type(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_resource_type", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_resource_type(a0));
}
Variant ei_dangling_server_proxy_old_request(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("dangling_server_proxy_old_request", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dangling_server_proxy_old_request());
}
Variant ei_magickgetimagefilename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagefilename", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagefilename(a0));
}
Variant ei_exif_tagname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exif_tagname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_exif_tagname(a0));
}
Variant ei_dom_document_create_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_document_create_attribute_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_attribute_ns(a0, a1, a2));
}
Variant ei_drawsetfillalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillalpha", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfillalpha(a0, a1), null);
}
Variant ei_mb_convert_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_convert_encoding", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_convert_encoding(a0, a1));
  else return (x_mb_convert_encoding(a0, a1, a2));
}
Variant ei_wandgetexceptionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexceptionstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_wandgetexceptionstring(a0));
}
Variant ei_proc_open(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("proc_open", count, 3, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_proc_open(a0, a1, ref(a2)));
  else if (count == 4) return (x_proc_open(a0, a1, ref(a2), a3));
  else if (count == 5) return (x_proc_open(a0, a1, ref(a2), a3, a4));
  else return (x_proc_open(a0, a1, ref(a2), a3, a4, a5));
}
Variant ei_hphp_splfileobject_fgetss(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_fgetss", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fgetss(a0, a1));
}
Variant ei_clearpixeliterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearpixeliterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clearpixeliterator(a0), null);
}
Variant ei_socket_server(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("socket_server", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_socket_server(a0));
  else if (count == 2) return (x_socket_server(a0, a1));
  else if (count == 3) return (x_socket_server(a0, a1, ref(a2)));
  else return (x_socket_server(a0, a1, ref(a2), ref(a3)));
}
Variant ei_magickremoveimageprofile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickremoveimageprofile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickremoveimageprofile(a0, a1));
}
Variant ei_xmlwriter_write_dtd_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_dtd_element", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_dtd_element(a0, a1, a2));
}
Variant ei_drawpushdefs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpushdefs", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpushdefs(a0), null);
}
Variant ei_image2wbmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("image2wbmp", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_image2wbmp(a0));
  else if (count == 2) return (x_image2wbmp(a0, a1));
  else return (x_image2wbmp(a0, a1, a2));
}
Variant ei_join(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("join", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_join(a0));
  else return (x_join(a0, a1));
}
Variant ei_magicksetimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimage(a0, a1));
}
Variant ei_openssl_free_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_free_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_free_key(a0), null);
}
Variant ei_preg_grep(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("preg_grep", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_preg_grep(a0, a1));
  else return (x_preg_grep(a0, a1, a2));
}
Variant ei_is_float(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_float", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_float(a0));
}
Variant ei_stream_socket_pair(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("stream_socket_pair", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_socket_pair(a0, a1, a2));
}
Variant ei_get_required_files(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_required_files", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_required_files());
}
Variant ei_mysql_fetch_field(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_fetch_field", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_fetch_field(a0));
  else return (x_mysql_fetch_field(a0, a1));
}
Variant ei_chmod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chmod", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chmod(a0, a1));
}
Variant ei_magickgettextascent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgettextascent", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgettextascent(a0, a1, a2));
  else return (x_magickgettextascent(a0, a1, a2, a3));
}
Variant ei_mb_regex_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_regex_encoding", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_regex_encoding());
  else return (x_mb_regex_encoding(a0));
}
Variant ei_mail(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mail", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_mail(a0, a1, a2));
  else if (count == 4) return (x_mail(a0, a1, a2, a3));
  else return (x_mail(a0, a1, a2, a3, a4));
}
Variant ei_mcrypt_enc_self_test(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_self_test", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_self_test(a0));
}
Variant ei_ignore_user_abort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ignore_user_abort", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ignore_user_abort());
  else return (x_ignore_user_abort(a0));
}
Variant ei_imagesetthickness(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetthickness", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesetthickness(a0, a1));
}
Variant ei_str_pad(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("str_pad", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_str_pad(a0, a1));
  else if (count == 3) return (x_str_pad(a0, a1, a2));
  else return (x_str_pad(a0, a1, a2, a3));
}
Variant ei_openssl_pkcs7_decrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_pkcs7_decrypt", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_pkcs7_decrypt(a0, a1, a2));
  else return (x_openssl_pkcs7_decrypt(a0, a1, a2, a3));
}
Variant ei_pagelet_server_task_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("pagelet_server_task_result", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pagelet_server_task_result(a0, ref(a1), ref(a2)));
}
Variant ei_asinh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("asinh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_asinh(a0));
}
Variant ei_mailparse_msg_extract_part(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_part", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mailparse_msg_extract_part(a0, a1));
  else return (x_mailparse_msg_extract_part(a0, a1, a2));
}
Variant ei_magickgetimagecompose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecompose(a0));
}
Variant ei_hphp_splfileinfo_getpath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getpath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getpath(a0));
}
Variant ei_magickcropimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickcropimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcropimage(a0, a1, a2, a3, a4));
}
Variant ei_ob_gzhandler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ob_gzhandler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_gzhandler(a0, a1));
}
Variant ei_dom_document_normalize_document(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_normalize_document", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_normalize_document(a0));
}
Variant ei_drawcomment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawcomment", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawcomment(a0, a1), null);
}
Variant ei_call_user_method(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("call_user_method", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_call_user_method(count, a0, ref(a1)));
  return (x_call_user_method(count, a0, ref(a1),vargs));
}
Variant ei_parse_hdf_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("parse_hdf_file", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_parse_hdf_file(a0));
}
Variant ei_mb_split(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_split", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_split(a0, a1));
  else return (x_mb_split(a0, a1, a2));
}
Variant ei_imagepolygon(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagepolygon", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepolygon(a0, a1, a2, a3));
}
Variant ei_mysql_field_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_name", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_name(a0));
  else return (x_mysql_field_name(a0, a1));
}
Variant ei_fputs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fputs", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fputs(a0, a1));
  else return (x_fputs(a0, a1, a2));
}
Variant ei_imagecolorallocatealpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorallocatealpha", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorallocatealpha(a0, a1, a2, a3, a4));
}
Variant ei_substr_count(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("substr_count", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_substr_count(a0, a1));
  else if (count == 3) return (x_substr_count(a0, a1, a2));
  else return (x_substr_count(a0, a1, a2, a3));
}
Variant ei_ldap_first_reference(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_reference", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_first_reference(a0, a1));
}
Variant ei_clock_settime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_settime", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clock_settime(a0, a1, a2));
}
Variant ei_dom_namednodemap_get_named_item_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_namednodemap_get_named_item_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_namednodemap_get_named_item_ns(a0, a1, a2));
}
Variant ei_ftruncate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ftruncate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ftruncate(a0, a1));
}
Variant ei_curl_version(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("curl_version", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_curl_version());
  else return (x_curl_version(a0));
}
Variant ei_pixelgetbluequantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetbluequantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetbluequantum(a0));
}
Variant ei_print(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("print", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_print(a0));
}
Variant ei_mysql_unbuffered_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_unbuffered_query", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_unbuffered_query(a0));
  else return (x_mysql_unbuffered_query(a0, a1));
}
Variant ei_dom_characterdata_delete_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_delete_data", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_characterdata_delete_data(a0, a1, a2));
}
Variant ei_hphp_recursiveiteratoriterator___construct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_recursiveiteratoriterator___construct", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator___construct(a0, a1, a2, a3));
}
Variant ei_hash_final(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hash_final", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_hash_final(a0));
  else return (x_hash_final(a0, a1));
}
Variant ei_imagecolorresolve(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorresolve", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorresolve(a0, a1, a2, a3));
}
Variant ei_dom_document_import_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_import_node", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_document_import_node(a0, a1));
  else return (x_dom_document_import_node(a0, a1, a2));
}
Variant ei_date_date_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("date_date_set", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_date_set(a0, a1, a2, a3), null);
}
Variant ei_pixelsetyellow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetyellow", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetyellow(a0, a1), null);
}
Variant ei_furchash_hphp_ext_supported(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("furchash_hphp_ext_supported", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_furchash_hphp_ext_supported());
}
Variant ei_inet_pton(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("inet_pton", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_inet_pton(a0));
}
Variant ei_mcrypt_get_key_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_get_key_size", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_get_key_size(a0, a1));
}
Variant ei_drawsettextalignment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextalignment", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsettextalignment(a0, a1), null);
}
Variant ei_magickgetimageredprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageredprimary", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageredprimary(a0));
}
Variant ei_addslashes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("addslashes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_addslashes(a0));
}
Variant ei_ldap_count_entries(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_count_entries", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_count_entries(a0, a1));
}
Variant ei_ereg_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ereg_replace", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ereg_replace(a0, a1, a2));
}
Variant ei_hphp_recursivedirectoryiterator_getchildren(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getchildren", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_getchildren(a0));
}
Variant ei_call_user_func_async(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("call_user_func_async", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 1) return (x_call_user_func_async(count, a0));
  return (x_call_user_func_async(count, a0,vargs));
}
Variant ei_drawrender(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawrender", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawrender(a0));
}
Variant ei_fb_rpc_intercept_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("fb_rpc_intercept_handler", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_rpc_intercept_handler(a0, a1, a2, a3, ref(a4)));
}
Variant ei_fb_intercept(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_intercept", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fb_intercept(a0, a1));
  else return (x_fb_intercept(a0, a1, a2));
}
Variant ei_magickgetversionnumber(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversionnumber", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetversionnumber());
}
Variant ei_array_splice(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("array_splice", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_splice(ref(a0), a1));
  else if (count == 3) return (x_array_splice(ref(a0), a1, a2));
  else return (x_array_splice(ref(a0), a1, a2, a3));
}
Variant ei_ftell(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ftell", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ftell(a0));
}
Variant ei_magicksetimagedepth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magicksetimagedepth", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magicksetimagedepth(a0, a1));
  else return (x_magicksetimagedepth(a0, a1, a2));
}
Variant ei_apc_load_constants(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_load_constants", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_load_constants(a0));
  else if (count == 2) return (x_apc_load_constants(a0, a1));
  else return (x_apc_load_constants(a0, a1, a2));
}
Variant ei___halt_compiler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("__halt_compiler", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x___halt_compiler(), null);
}
Variant ei_magicklabelimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicklabelimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicklabelimage(a0, a1));
}
Variant ei_hphp_log(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_log", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_log(a0, a1));
}
Variant ei_stream_get_contents(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_get_contents", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_get_contents(a0));
  else if (count == 2) return (x_stream_get_contents(a0, a1));
  else return (x_stream_get_contents(a0, a1, a2));
}
Variant ei_imagecreatefromjpeg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromjpeg", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromjpeg(a0));
}
Variant ei_chown(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chown", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chown(a0, a1));
}
Variant ei_hash_hmac_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("hash_hmac_file", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_hash_hmac_file(a0, a1, a2));
  else return (x_hash_hmac_file(a0, a1, a2, a3));
}
Variant ei_magickechoimageblob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickechoimageblob", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickechoimageblob(a0));
}
Variant ei_link(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("link", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_link(a0, a1));
}
Variant ei_fb_utf8ize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_utf8ize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_utf8ize(ref(a0)));
}
Variant ei_drawsetfillpatternurl(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillpatternurl", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfillpatternurl(a0, a1));
}
Variant ei_iconv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("iconv", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_iconv(a0, a1, a2));
}
Variant ei_highlight_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("highlight_file", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_highlight_file(a0));
  else return (x_highlight_file(a0, a1));
}
Variant ei_iconv_mime_decode_headers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("iconv_mime_decode_headers", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_iconv_mime_decode_headers(a0));
  else if (count == 2) return (x_iconv_mime_decode_headers(a0, a1));
  else return (x_iconv_mime_decode_headers(a0, a1, a2));
}
Variant ei_ini_get_all(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ini_get_all", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ini_get_all());
  else return (x_ini_get_all(a0));
}
Variant ei_collator_get_strength(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_strength", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_get_strength(a0));
}
Variant ei_ldap_get_values_len(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_values_len", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_values_len(a0, a1, a2));
}
Variant ei_hphp_splfileinfo_getrealpath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getrealpath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getrealpath(a0));
}
Variant ei_openssl_pkcs7_verify(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) return throw_wrong_arguments("openssl_pkcs7_verify", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_pkcs7_verify(a0, a1));
  else if (count == 3) return (x_openssl_pkcs7_verify(a0, a1, a2));
  else if (count == 4) return (x_openssl_pkcs7_verify(a0, a1, a2, a3));
  else if (count == 5) return (x_openssl_pkcs7_verify(a0, a1, a2, a3, a4));
  else return (x_openssl_pkcs7_verify(a0, a1, a2, a3, a4, a5));
}
Variant ei_hphp_directoryiterator_current(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_current", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_current(a0));
}
Variant ei_hphp_splfileobject_fgetcsv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_fgetcsv", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fgetcsv(a0, a1, a2, a3));
}
Variant ei_furchash_hphp_ext(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("furchash_hphp_ext", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_furchash_hphp_ext(a0, a1, a2));
}
Variant ei_stream_socket_recvfrom(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_recvfrom", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_socket_recvfrom(a0, a1));
  else if (count == 3) return (x_stream_socket_recvfrom(a0, a1, a2));
  else return (x_stream_socket_recvfrom(a0, a1, a2, a3));
}
Variant ei_drawgetcliprule(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetcliprule", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetcliprule(a0));
}
Variant ei_apc_filehits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apc_filehits", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apc_filehits());
}
Variant ei_pixelgetexceptionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexceptionstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetexceptionstring(a0));
}
Variant ei_mcrypt_ofb(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_ofb", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_ofb(a0, a1, a2, a3));
  else return (x_mcrypt_ofb(a0, a1, a2, a3, a4));
}
Variant ei_imageantialias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imageantialias", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageantialias(a0, a1));
}
Variant ei_hphp_splfileinfo_openfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileinfo_openfile", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_openfile(a0, a1, a2, a3));
}
Variant ei_dom_document_validate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_validate", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_validate(a0));
}
Variant ei_idn_to_ascii(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_ascii", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_idn_to_ascii(a0));
  else return (x_idn_to_ascii(a0, ref(a1)));
}
Variant ei_error_log(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("error_log", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_error_log(a0));
  else if (count == 2) return (x_error_log(a0, a1));
  else if (count == 3) return (x_error_log(a0, a1, a2));
  else return (x_error_log(a0, a1, a2, a3));
}
Variant ei_hash_update(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hash_update", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hash_update(a0, a1));
}
Variant ei_ob_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_flush", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_flush(), null);
}
Variant ei_md5_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("md5_file", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_md5_file(a0));
  else return (x_md5_file(a0, a1));
}
Variant ei_drawgetexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetexception(a0));
}
Variant ei_file_get_contents(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("file_get_contents", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_file_get_contents(a0));
  else if (count == 2) return (x_file_get_contents(a0, a1));
  else if (count == 3) return (x_file_get_contents(a0, a1, a2));
  else if (count == 4) return (x_file_get_contents(a0, a1, a2, a3));
  else return (x_file_get_contents(a0, a1, a2, a3, a4));
}
Variant ei_uniqid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("uniqid", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_uniqid());
  else if (count == 1) return (x_uniqid(a0));
  else return (x_uniqid(a0, a1));
}
Variant ei_strncasecmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("strncasecmp", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strncasecmp(a0, a1, a2));
}
Variant ei_magicksetimagepixels(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("magicksetimagepixels", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagepixels(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_drawgetfillopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillopacity", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfillopacity(a0));
}
Variant ei_xml_parser_create_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("xml_parser_create_ns", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_xml_parser_create_ns());
  else if (count == 1) return (x_xml_parser_create_ns(a0));
  else return (x_xml_parser_create_ns(a0, a1));
}
Variant ei_ldap_delete(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_delete", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_delete(a0, a1));
}
Variant ei_fnmatch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fnmatch", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fnmatch(a0, a1));
  else return (x_fnmatch(a0, a1, a2));
}
Variant ei_hphp_splfileobject_eof(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_eof", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_eof(a0));
}
Variant ei_metaphone(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("metaphone", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_metaphone(a0));
  else return (x_metaphone(a0, a1));
}
Variant ei_mysql_errno(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_errno", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_errno());
  else return (x_mysql_errno(a0));
}
Variant ei_stream_wrapper_unregister(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_wrapper_unregister", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_wrapper_unregister(a0));
}
Variant ei_magickcyclecolormapimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcyclecolormapimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcyclecolormapimage(a0, a1));
}
Variant ei_hphp_recursiveiteratoriterator_current(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_current", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_current(a0));
}
Variant ei_restore_error_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_error_handler", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_restore_error_handler());
}
Variant ei_hphp_recursivedirectoryiterator___construct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_recursivedirectoryiterator___construct", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator___construct(a0, a1, a2));
}
Variant ei_magicksetimagevirtualpixelmethod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagevirtualpixelmethod", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagevirtualpixelmethod(a0, a1));
}
Variant ei_socket_getpeername(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_getpeername", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_getpeername(a0, ref(a1)));
  else return (x_socket_getpeername(a0, ref(a1), ref(a2)));
}
Variant ei_memcache_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_memcache_close(a0));
}
Variant ei_mysql_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_error", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_error());
  else return (x_mysql_error(a0));
}
Variant ei_drawtranslate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawtranslate", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawtranslate(a0, a1, a2), null);
}
Variant ei_mysql_list_dbs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_list_dbs", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_list_dbs());
  else return (x_mysql_list_dbs(a0));
}
Variant ei_imagefilter(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) return throw_wrong_arguments("imagefilter", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_imagefilter(a0, a1));
  else if (count == 3) return (x_imagefilter(a0, a1, a2));
  else if (count == 4) return (x_imagefilter(a0, a1, a2, a3));
  else if (count == 5) return (x_imagefilter(a0, a1, a2, a3, a4));
  else return (x_imagefilter(a0, a1, a2, a3, a4, a5));
}
Variant ei_base64_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("base64_encode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_base64_encode(a0));
}
Variant ei_dom_xpath_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_xpath_query", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_xpath_query(a0, a1));
  else return (x_dom_xpath_query(a0, a1, a2));
}
Variant ei_hphpd_install_user_command(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphpd_install_user_command", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphpd_install_user_command(a0, a1));
}
Variant ei_dom_element_set_id_attribute_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_id_attribute_node", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_id_attribute_node(a0, a1, a2));
}
Variant ei_is_null(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_null", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_null(a0));
}
Variant ei_octdec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("octdec", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_octdec(a0));
}
Variant ei_drawsetclippath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetclippath", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetclippath(a0, a1));
}
Variant ei_magickconstituteimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickconstituteimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickconstituteimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_pcntl_wexitstatus(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wexitstatus", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wexitstatus(a0));
}
Variant ei_iterator_apply(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iterator_apply", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iterator_apply(a0, a1));
  else return (x_iterator_apply(a0, a1, a2));
}
Variant ei_apache_setenv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("apache_setenv", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_apache_setenv(a0, a1));
  else return (x_apache_setenv(a0, a1, a2));
}
Variant ei_dom_node_is_same_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_is_same_node", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_is_same_node(a0, a1));
}
Variant ei_clonedrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clonedrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clonedrawingwand(a0));
}
Variant ei_ob_get_clean(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_clean", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_get_clean());
}
Variant ei_expm1(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("expm1", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_expm1(a0));
}
Variant ei_ldap_first_entry(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_entry", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_first_entry(a0, a1));
}
Variant ei_curl_multi_select(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_multi_select", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_curl_multi_select(a0));
  else return (x_curl_multi_select(a0, a1));
}
Variant ei_magickswirlimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickswirlimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickswirlimage(a0, a1));
}
Variant ei_mb_ereg_search_regs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search_regs", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_ereg_search_regs());
  else if (count == 1) return (x_mb_ereg_search_regs(a0));
  else return (x_mb_ereg_search_regs(a0, a1));
}
Variant ei_ldap_errno(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_errno", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_errno(a0));
}
Variant ei_mysql_get_server_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_server_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_get_server_info());
  else return (x_mysql_get_server_info(a0));
}
Variant ei_mailparse_rfc822_parse_addresses(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_rfc822_parse_addresses", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_rfc822_parse_addresses(a0));
}
Variant ei_magickgetimagemimetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagemimetype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagemimetype(a0));
}
Variant ei_soundex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("soundex", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_soundex(a0));
}
Variant ei_magickgetimageformat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageformat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageformat(a0));
}
Variant ei_mcrypt_module_get_supported_key_sizes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_supported_key_sizes", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_get_supported_key_sizes(a0));
  else return (x_mcrypt_module_get_supported_key_sizes(a0, a1));
}
Variant ei_preg_replace_callback(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_replace_callback", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_preg_replace_callback(a0, a1, a2));
  else if (count == 4) return (x_preg_replace_callback(a0, a1, a2, a3));
  else return (x_preg_replace_callback(a0, a1, a2, a3, ref(a4)));
}
Variant ei_dom_document_create_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_create_element", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_document_create_element(a0, a1));
  else return (x_dom_document_create_element(a0, a1, a2));
}
Variant ei_ldap_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_error", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_error(a0));
}
Variant ei_xmlwriter_full_end_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_full_end_element", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_full_end_element(a0));
}
Variant ei_ctype_graph(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_graph", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_graph(a0));
}
Variant ei_session_register(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("session_register", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_session_register(count, a0));
  return (x_session_register(count, a0,vargs));
}
Variant ei_asort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("asort", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_asort(ref(a0)));
  else if (count == 2) return (x_asort(ref(a0), a1));
  else return (x_asort(ref(a0), a1, a2));
}
Variant ei_apd_echo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("apd_echo", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_echo(a0));
}
Variant ei_rewinddir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rewinddir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rewinddir(a0), null);
}
Variant ei_ob_implicit_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ob_implicit_flush", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ob_implicit_flush(), null);
  else return (x_ob_implicit_flush(a0), null);
}
Variant ei_pcntl_signal_dispatch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pcntl_signal_dispatch", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_signal_dispatch());
}
Variant ei_session_get_cookie_params(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_get_cookie_params", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_get_cookie_params());
}
Variant ei_pixelgetiteratorexceptionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexceptionstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetiteratorexceptionstring(a0));
}
Variant ei_stream_socket_client(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("stream_socket_client", count, 1, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_socket_client(a0));
  else if (count == 2) return (x_stream_socket_client(a0, ref(a1)));
  else if (count == 3) return (x_stream_socket_client(a0, ref(a1), ref(a2)));
  else if (count == 4) return (x_stream_socket_client(a0, ref(a1), ref(a2), a3));
  else if (count == 5) return (x_stream_socket_client(a0, ref(a1), ref(a2), a3, a4));
  else return (x_stream_socket_client(a0, ref(a1), ref(a2), a3, a4, a5));
}
Variant ei_drawsetstrokedasharray(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsetstrokedasharray", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_drawsetstrokedasharray(a0), null);
  else return (x_drawsetstrokedasharray(a0, a1), null);
}
Variant ei_mysql_free_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_free_result", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_free_result(a0));
}
Variant ei_is_real(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_real", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_real(a0));
}
Variant ei_mcrypt_enc_is_block_algorithm_mode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_algorithm_mode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_is_block_algorithm_mode(a0));
}
Variant ei_array_slice(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("array_slice", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_slice(a0, a1));
  else if (count == 3) return (x_array_slice(a0, a1, a2));
  else return (x_array_slice(a0, a1, a2, a3));
}
Variant ei_count_chars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("count_chars", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_count_chars(a0));
  else return (x_count_chars(a0, a1));
}
Variant ei_hphp_splfileobject_getmaxlinelen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getmaxlinelen", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_getmaxlinelen(a0));
}
Variant ei_array_uintersect_uassoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4) return throw_missing_arguments("array_uintersect_uassoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 4) return (x_array_uintersect_uassoc(count, a0, a1, a2, a3));
  return (x_array_uintersect_uassoc(count, a0, a1, a2, a3,vargs));
}
Variant ei_drawsetstrokewidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokewidth", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokewidth(a0, a1), null);
}
Variant ei_posix_mkfifo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_mkfifo", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_mkfifo(a0, a1));
}
Variant ei_array_count_values(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_count_values", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_count_values(a0));
}
Variant ei_memcache_connect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_connect", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_memcache_connect(a0));
  else if (count == 2) return (x_memcache_connect(a0, a1));
  else if (count == 3) return (x_memcache_connect(a0, a1, a2));
  else return (x_memcache_connect(a0, a1, a2, a3));
}
Variant ei_pixelgetexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetexception(a0));
}
Variant ei_mkdir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("mkdir", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mkdir(a0));
  else if (count == 2) return (x_mkdir(a0, a1));
  else if (count == 3) return (x_mkdir(a0, a1, a2));
  else return (x_mkdir(a0, a1, a2, a3));
}
Variant ei_magicksetsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetsize", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetsize(a0, a1, a2));
}
Variant ei_debug_zval_dump(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("debug_zval_dump", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_debug_zval_dump(a0), null);
}
Variant ei_iconv_substr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("iconv_substr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iconv_substr(a0, a1));
  else if (count == 3) return (x_iconv_substr(a0, a1, a2));
  else return (x_iconv_substr(a0, a1, a2, a3));
}
Variant ei_xml_set_external_entity_ref_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_external_entity_ref_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_external_entity_ref_handler(a0, a1));
}
Variant ei_mb_decode_numericentity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_decode_numericentity", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_decode_numericentity(a0, a1));
  else return (x_mb_decode_numericentity(a0, a1, a2));
}
Variant ei_ldap_next_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_next_attribute(a0, a1));
}
Variant ei_hphp_splfileobject_fflush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fflush", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fflush(a0));
}
Variant ei_imagejpeg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagejpeg", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagejpeg(a0));
  else if (count == 2) return (x_imagejpeg(a0, a1));
  else return (x_imagejpeg(a0, a1, a2));
}
Variant ei_imagesetbrush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetbrush", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesetbrush(a0, a1));
}
Variant ei_mb_strtoupper(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strtoupper", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_strtoupper(a0));
  else return (x_mb_strtoupper(a0, a1));
}
Variant ei_usleep(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("usleep", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_usleep(a0), null);
}
Variant ei_mb_strrpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrpos", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strrpos(a0, a1));
  else if (count == 3) return (x_mb_strrpos(a0, a1, a2));
  else return (x_mb_strrpos(a0, a1, a2, a3));
}
Variant ei_collator_compare(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("collator_compare", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_compare(a0, a1, a2));
}
Variant ei_extract(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("extract", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_extract(a0));
  else if (count == 2) return (x_extract(a0, a1));
  else return (x_extract(a0, a1, a2));
}
Variant ei_session_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_decode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_decode(a0));
}
Variant ei_get_browser(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("get_browser", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_browser());
  else if (count == 1) return (x_get_browser(a0));
  else return (x_get_browser(a0, a1));
}
Variant ei_html_entity_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("html_entity_decode", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_html_entity_decode(a0));
  else if (count == 2) return (x_html_entity_decode(a0, a1));
  else return (x_html_entity_decode(a0, a1, a2));
}
Variant ei_spl_classes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("spl_classes", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_spl_classes());
}
Variant ei_preg_split(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("preg_split", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_preg_split(a0, a1));
  else if (count == 3) return (x_preg_split(a0, a1, a2));
  else return (x_preg_split(a0, a1, a2, a3));
}
Variant ei_magickpreviewimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickpreviewimages", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickpreviewimages(a0, a1));
}
Variant ei_zend_logo_guid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_logo_guid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_zend_logo_guid());
}
Variant ei_magickgetimagesize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagesize(a0));
}
Variant ei_apd_set_browser_trace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_set_browser_trace", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_set_browser_trace(), null);
}
Variant ei_xhprof_sample_enable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_sample_enable", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xhprof_sample_enable(), null);
}
Variant ei_hphp_splfileobject_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_key(a0));
}
Variant ei_mb_http_input(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_http_input", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_http_input());
  else return (x_mb_http_input(a0));
}
Variant ei_gzinflate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzinflate", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzinflate(a0));
  else return (x_gzinflate(a0, a1));
}
Variant ei_openssl_pkcs7_sign(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 7) return throw_wrong_arguments("openssl_pkcs7_sign", count, 5, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 5) return (x_openssl_pkcs7_sign(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_openssl_pkcs7_sign(a0, a1, a2, a3, a4, a5));
  else return (x_openssl_pkcs7_sign(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_assert(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("assert", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_assert(a0));
}
Variant ei_stream_get_wrappers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_wrappers", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_get_wrappers());
}
Variant ei_gzfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzfile", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzfile(a0));
  else return (x_gzfile(a0, a1));
}
Variant ei_session_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_id", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_id());
  else return (x_session_id(a0));
}
Variant ei_stream_socket_sendto(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_sendto", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_socket_sendto(a0, a1));
  else if (count == 3) return (x_stream_socket_sendto(a0, a1, a2));
  else return (x_stream_socket_sendto(a0, a1, a2, a3));
}
Variant ei_gzpassthru(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzpassthru", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzpassthru(a0));
}
Variant ei_stream_bucket_make_writeable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_bucket_make_writeable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_bucket_make_writeable(a0));
}
Variant ei_posix_setegid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setegid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_setegid(a0));
}
Variant ei_drawgetexceptionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexceptionstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetexceptionstring(a0));
}
Variant ei_hash_algos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hash_algos", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hash_algos());
}
Variant ei_drawsetstrokeantialias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsetstrokeantialias", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_drawsetstrokeantialias(a0), null);
  else return (x_drawsetstrokeantialias(a0, a1), null);
}
Variant ei_destroypixelwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroypixelwand(a0), null);
}
Variant ei_fstat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fstat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fstat(a0));
}
Variant ei_magicksetimageresolution(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageresolution", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageresolution(a0, a1, a2));
}
Variant ei_mysql_db_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_db_name", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mysql_db_name(a0, a1));
  else return (x_mysql_db_name(a0, a1, a2));
}
Variant ei_is_finite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_finite", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_finite(a0));
}
Variant ei_pixelgetyellowquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetyellowquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetyellowquantum(a0));
}
Variant ei_ksort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("ksort", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_ksort(ref(a0)));
  else return (x_ksort(ref(a0), a1));
}
Variant ei_thrift_protocol_read_binary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("thrift_protocol_read_binary", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_thrift_protocol_read_binary(a0, a1, a2));
}
Variant ei_get_included_files(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_included_files", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_included_files());
}
Variant ei_strip_tags(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strip_tags", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_strip_tags(a0));
  else return (x_strip_tags(a0, a1));
}
Variant ei_mb_ereg_search_getpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_ereg_search_getpos", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_ereg_search_getpos());
}
Variant ei_pixelgetcyanquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcyanquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetcyanquantum(a0));
}
Variant ei_magickgetexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetexception(a0));
}
Variant ei_ctype_punct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_punct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_punct(a0));
}
Variant ei_next(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("next", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_next(ref(a0)));
}
Variant ei_shm_detach(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shm_detach", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shm_detach(a0));
}
Variant ei_shm_attach(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("shm_attach", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_shm_attach(a0));
  else if (count == 2) return (x_shm_attach(a0, a1));
  else return (x_shm_attach(a0, a1, a2));
}
Variant ei_magickflattenimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflattenimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickflattenimages(a0));
}
Variant ei_dom_document_save_html_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_save_html_file", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_save_html_file(a0, a1));
}
Variant ei_similar_text(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("similar_text", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_similar_text(a0, a1));
  else return (x_similar_text(a0, a1, ref(a2)));
}
Variant ei_hphp_get_thread_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_get_thread_id", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_thread_id());
}
Variant ei_imagecreatefromgd2part(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecreatefromgd2part", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromgd2part(a0, a1, a2, a3, a4));
}
Variant ei_dom_element_set_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_attribute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_attribute(a0, a1, a2));
}
Variant ei_iterator_to_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("iterator_to_array", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_iterator_to_array(a0));
  else return (x_iterator_to_array(a0, a1));
}
Variant ei_iconv_get_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("iconv_get_encoding", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_iconv_get_encoding());
  else return (x_iconv_get_encoding(a0));
}
Variant ei_getmyinode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmyinode", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getmyinode());
}
Variant ei_gzgetc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzgetc", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzgetc(a0));
}
Variant ei_hphp_set_static_property(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_set_static_property", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_set_static_property(a0, a1, a2), null);
}
Variant ei_unlink(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("unlink", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_unlink(a0));
  else return (x_unlink(a0, a1));
}
Variant ei_mcrypt_module_open(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("mcrypt_module_open", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_module_open(a0, a1, a2, a3));
}
Variant ei_token_get_all(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("token_get_all", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_token_get_all(a0));
}
Variant ei_base_convert(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("base_convert", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_base_convert(a0, a1, a2));
}
Variant ei_gethostbynamel(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbynamel", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gethostbynamel(a0));
}
Variant ei_var_dump(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("var_dump", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_var_dump(count, a0), null);
  return (x_var_dump(count, a0,vargs), null);
}
Variant ei_xmlwriter_start_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_attribute(a0, a1));
}
Variant ei_pack(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("pack", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_pack(count, a0));
  return (x_pack(count, a0,vargs));
}
Variant ei_gzgets(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzgets", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzgets(a0));
  else return (x_gzgets(a0, a1));
}
Variant ei_array_intersect_uassoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_intersect_uassoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_intersect_uassoc(count, a0, a1, a2));
  return (x_array_intersect_uassoc(count, a0, a1, a2,vargs));
}
Variant ei_basename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("basename", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_basename(a0));
  else return (x_basename(a0, a1));
}
Variant ei_krsort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("krsort", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_krsort(ref(a0)));
  else return (x_krsort(ref(a0), a1));
}
Variant ei_clock_gettime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_gettime", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clock_gettime(a0, ref(a1), ref(a2)));
}
Variant ei_pushdrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pushdrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pushdrawingwand(a0), null);
}
Variant ei_imageline(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imageline", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageline(a0, a1, a2, a3, a4, a5));
}
Variant ei_socket_read(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_read", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_read(a0, a1));
  else return (x_socket_read(a0, a1, a2));
}
Variant ei_xmlwriter_write_dtd_entity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 7) return throw_wrong_arguments("xmlwriter_write_dtd_entity", count, 3, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_xmlwriter_write_dtd_entity(a0, a1, a2));
  else if (count == 4) return (x_xmlwriter_write_dtd_entity(a0, a1, a2, a3));
  else if (count == 5) return (x_xmlwriter_write_dtd_entity(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_xmlwriter_write_dtd_entity(a0, a1, a2, a3, a4, a5));
  else return (x_xmlwriter_write_dtd_entity(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_mysql_tablename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mysql_tablename", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_tablename(a0, a1));
}
Variant ei_collator_sort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("collator_sort", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_collator_sort(a0, ref(a1)));
  else return (x_collator_sort(a0, ref(a1), a2));
}
Variant ei_magickwriteimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickwriteimage(a0, a1));
}
Variant ei_mcrypt_module_get_algo_key_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_algo_key_size", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_get_algo_key_size(a0));
  else return (x_mcrypt_module_get_algo_key_size(a0, a1));
}
Variant ei_hash_update_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_update_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_hash_update_file(a0, a1));
  else return (x_hash_update_file(a0, a1, a2));
}
Variant ei_magickembossimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickembossimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickembossimage(a0, a1, a2));
}
Variant ei_forward_static_call(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("forward_static_call", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 1) return (x_forward_static_call(count, a0));
  return (x_forward_static_call(count, a0,vargs));
}
Variant ei_gzencode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("gzencode", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzencode(a0));
  else if (count == 2) return (x_gzencode(a0, a1));
  else return (x_gzencode(a0, a1, a2));
}
Variant ei_checkdate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("checkdate", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_checkdate(a0, a1, a2));
}
Variant ei_magickimplodeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickimplodeimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickimplodeimage(a0, a1));
}
Variant ei_magickgetimageindex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageindex", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageindex(a0));
}
Variant ei_ctype_lower(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_lower", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_lower(a0));
}
Variant ei_imagepsloadfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagepsloadfont", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepsloadfont(a0));
}
Variant ei_iconv_mime_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("iconv_mime_decode", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_iconv_mime_decode(a0));
  else if (count == 2) return (x_iconv_mime_decode(a0, a1));
  else return (x_iconv_mime_decode(a0, a1, a2));
}
Variant ei_hphp_recursiveiteratoriterator_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_key(a0));
}
Variant ei_mcrypt_module_is_block_algorithm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_algorithm", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_is_block_algorithm(a0));
  else return (x_mcrypt_module_is_block_algorithm(a0, a1));
}
Variant ei_wandgetexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_wandgetexception(a0));
}
Variant ei_fsockopen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("fsockopen", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fsockopen(a0));
  else if (count == 2) return (x_fsockopen(a0, a1));
  else if (count == 3) return (x_fsockopen(a0, a1, ref(a2)));
  else if (count == 4) return (x_fsockopen(a0, a1, ref(a2), ref(a3)));
  else return (x_fsockopen(a0, a1, ref(a2), ref(a3), a4));
}
Variant ei_usort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("usort", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_usort(ref(a0), a1));
}
Variant ei_pixelsetiteratorrow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetiteratorrow", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetiteratorrow(a0, a1));
}
Variant ei_call_user_func_serialized(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("call_user_func_serialized", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_call_user_func_serialized(a0));
}
Variant ei_hphp_splfileinfo_iswritable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_iswritable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_iswritable(a0));
}
Variant ei_dom_document_create_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_attribute(a0, a1));
}
Variant ei_ldap_get_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_option", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_option(a0, a1, ref(a2)));
}
Variant ei_socket_recv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_recv", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_recv(a0, ref(a1), a2, a3));
}
Variant ei_sys_getloadavg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("sys_getloadavg", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sys_getloadavg());
}
Variant ei_evhttp_async_post(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("evhttp_async_post", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_evhttp_async_post(a0, a1));
  else if (count == 3) return (x_evhttp_async_post(a0, a1, a2));
  else return (x_evhttp_async_post(a0, a1, a2, a3));
}
Variant ei_hphp_recursivedirectoryiterator_seek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_recursivedirectoryiterator_seek", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_seek(a0, a1), null);
}
Variant ei_array_values(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_values", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_values(a0));
}
Variant ei_ctype_digit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_digit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_digit(a0));
}
Variant ei_ob_get_length(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_length", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_get_length());
}
Variant ei_magicksolarizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksolarizeimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksolarizeimage(a0, a1));
}
Variant ei_ob_list_handlers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_list_handlers", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_list_handlers());
}
Variant ei_array_uintersect_assoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_uintersect_assoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_uintersect_assoc(count, a0, a1, a2));
  return (x_array_uintersect_assoc(count, a0, a1, a2,vargs));
}
Variant ei_openssl_x509_read(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_x509_read", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_x509_read(a0));
}
Variant ei_magickgetimagecolormapcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimagecolormapcolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecolormapcolor(a0, a1));
}
Variant ei_hphp_splfileobject_getcvscontrol(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getcvscontrol", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_getcvscontrol(a0));
}
Variant ei_settype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("settype", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_settype(ref(a0), a1));
}
Variant ei_posix_access(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("posix_access", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_posix_access(a0));
  else return (x_posix_access(a0, a1));
}
Variant ei_explode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("explode", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_explode(a0, a1));
  else return (x_explode(a0, a1, a2));
}
Variant ei_fb_load_local_databases(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_load_local_databases", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_load_local_databases(a0), null);
}
Variant ei_imagecreatefromgd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgd", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromgd(a0));
}
Variant ei_proc_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_proc_close(a0));
}
Variant ei_magickgaussianblurimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgaussianblurimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgaussianblurimage(a0, a1, a2));
  else return (x_magickgaussianblurimage(a0, a1, a2, a3));
}
Variant ei_apd_set_session_trace_socket(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("apd_set_session_trace_socket", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_set_session_trace_socket(a0, a1, a2, a3));
}
Variant ei_openssl_pkcs12_export_to_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("openssl_pkcs12_export_to_file", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_openssl_pkcs12_export_to_file(a0, a1, a2, a3));
  else return (x_openssl_pkcs12_export_to_file(a0, a1, a2, a3, a4));
}
Variant ei_mailparse_msg_free(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_free", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_free(a0));
}
Variant ei_openssl_private_decrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_private_decrypt", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_private_decrypt(a0, ref(a1), a2));
  else return (x_openssl_private_decrypt(a0, ref(a1), a2, a3));
}
Variant ei_dom_document_save(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_save", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_document_save(a0, a1));
  else return (x_dom_document_save(a0, a1, a2));
}
Variant ei_hphp_get_extension_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_extension_info", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_extension_info(a0));
}
Variant ei_output_add_rewrite_var(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("output_add_rewrite_var", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_output_add_rewrite_var(a0, a1));
}
Variant ei_xmlwriter_write_cdata(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_cdata", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_cdata(a0, a1));
}
Variant ei_mb_list_mime_names(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_list_mime_names", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_list_mime_names());
  else return (x_mb_list_mime_names(a0));
}
Variant ei_ispixelwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ispixelwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ispixelwand(a0));
}
Variant ei_xmlwriter_end_dtd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_dtd(a0));
}
Variant ei_curl_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_close(a0));
}
Variant ei_array_udiff(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_udiff", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_udiff(count, a0, a1, a2));
  return (x_array_udiff(count, a0, a1, a2,vargs));
}
Variant ei_session_cache_limiter(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_cache_limiter", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_cache_limiter());
  else return (x_session_cache_limiter(a0));
}
Variant ei_stream_context_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("stream_context_create", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_stream_context_create());
  else if (count == 1) return (x_stream_context_create(a0));
  else return (x_stream_context_create(a0, a1));
}
Variant ei_drawgetstrokedashoffset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokedashoffset", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokedashoffset(a0));
}
Variant ei_openssl_pkey_get_public(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_get_public", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_pkey_get_public(a0));
}
Variant ei_interface_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("interface_exists", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_interface_exists(a0));
  else return (x_interface_exists(a0, a1));
}
Variant ei_hphp_directoryiterator___construct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_directoryiterator___construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator___construct(a0, a1));
}
Variant ei_drawpathmovetorelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathmovetorelative", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathmovetorelative(a0, a1, a2), null);
}
Variant ei_apache_get_config(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_config", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_get_config());
}
Variant ei_curl_copy_handle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_copy_handle", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_copy_handle(a0));
}
Variant ei_drawgetvectorgraphics(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetvectorgraphics", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetvectorgraphics(a0));
}
Variant ei_drawpathfinish(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathfinish", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathfinish(a0), null);
}
Variant ei_png2wbmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("png2wbmp", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_png2wbmp(a0, a1, a2, a3, a4));
}
Variant ei_drawmatte(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawmatte", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawmatte(a0, a1, a2, a3), null);
}
Variant ei_imagecolormatch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolormatch", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolormatch(a0, a1));
}
Variant ei_drawrectangle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawrectangle", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawrectangle(a0, a1, a2, a3, a4), null);
}
Variant ei_fb_parallel_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("fb_parallel_query", count, 1, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fb_parallel_query(a0));
  else if (count == 2) return (x_fb_parallel_query(a0, a1));
  else if (count == 3) return (x_fb_parallel_query(a0, a1, a2));
  else if (count == 4) return (x_fb_parallel_query(a0, a1, a2, a3));
  else if (count == 5) return (x_fb_parallel_query(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_fb_parallel_query(a0, a1, a2, a3, a4, a5));
  else return (x_fb_parallel_query(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_dom_document_create_entity_reference(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_entity_reference", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_entity_reference(a0, a1));
}
Variant ei_mcrypt_enc_get_block_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_block_size", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_block_size(a0));
}
Variant ei_stream_context_set_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_context_set_option", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_context_set_option(a0, a1));
  else if (count == 3) return (x_stream_context_set_option(a0, a1, a2));
  else return (x_stream_context_set_option(a0, a1, a2, a3));
}
Variant ei_drawpathcurvetorelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawpathcurvetorelative", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetorelative(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_phpcredits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpcredits", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_phpcredits());
  else return (x_phpcredits(a0));
}
Variant ei_drawgetfillrule(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillrule", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfillrule(a0));
}
Variant ei_parse_hdf_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("parse_hdf_string", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_parse_hdf_string(a0));
}
Variant ei_xmlwriter_end_cdata(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_cdata", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_cdata(a0));
}
Variant ei_magickgetversionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversionstring", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetversionstring());
}
Variant ei_pcntl_fork(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pcntl_fork", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_fork());
}
Variant ei_dom_node_normalize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_normalize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_normalize(a0));
}
Variant ei_doubleval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("doubleval", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_doubleval(a0));
}
Variant ei_assert_options(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("assert_options", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_assert_options(a0));
  else return (x_assert_options(a0, a1));
}
Variant ei_magickhasnextimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickhasnextimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickhasnextimage(a0));
}
Variant ei_rmdir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("rmdir", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_rmdir(a0));
  else return (x_rmdir(a0, a1));
}
Variant ei_drawgetstrokelinecap(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokelinecap", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokelinecap(a0));
}
Variant ei_hphp_clear_unflushed(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_clear_unflushed", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_clear_unflushed(), null);
}
Variant ei_magickscaleimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickscaleimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickscaleimage(a0, a1, a2));
}
Variant ei_pixelgetblackquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblackquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetblackquantum(a0));
}
Variant ei_magicknewimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magicknewimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magicknewimage(a0, a1, a2));
  else return (x_magicknewimage(a0, a1, a2, a3));
}
Variant ei_destroypixelwands(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwands", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroypixelwands(a0), null);
}
Variant ei_shm_remove(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shm_remove", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shm_remove(a0));
}
Variant ei_hphp_splfileobject_setflags(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_setflags", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_setflags(a0, a1), null);
}
Variant ei_date_sun_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("date_sun_info", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_sun_info(a0, a1, a2));
}
Variant ei_hphp_directoryiterator_valid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_valid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_valid(a0));
}
Variant ei_magickresizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickresizeimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickresizeimage(a0, a1, a2, a3, a4));
}
Variant ei_parse_ini_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("parse_ini_file", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_parse_ini_file(a0));
  else if (count == 2) return (x_parse_ini_file(a0, a1));
  else return (x_parse_ini_file(a0, a1, a2));
}
Variant ei_stream_get_meta_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_get_meta_data", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_get_meta_data(a0));
}
Variant ei_imagepsencodefont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsencodefont", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepsencodefont(a0, a1));
}
Variant ei_ldap_set_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_set_option", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_set_option(a0, a1, a2));
}
Variant ei_magickgetsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetsize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetsize(a0));
}
Variant ei_memory_get_peak_usage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("memory_get_peak_usage", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_memory_get_peak_usage());
  else return (x_memory_get_peak_usage(a0));
}
Variant ei_pcntl_exec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pcntl_exec", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pcntl_exec(a0), null);
  else if (count == 2) return (x_pcntl_exec(a0, a1), null);
  else return (x_pcntl_exec(a0, a1, a2), null);
}
Variant ei_xmlwriter_set_indent_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_set_indent_string", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_set_indent_string(a0, a1));
}
Variant ei_php_strip_whitespace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("php_strip_whitespace", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_php_strip_whitespace(a0));
}
Variant ei_strcoll(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcoll", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strcoll(a0, a1));
}
Variant ei_write_hdf_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("write_hdf_file", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_write_hdf_file(a0, a1));
}
Variant ei_socket_send(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_send", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_send(a0, a1, a2, a3));
}
Variant ei_zlib_get_coding_type(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zlib_get_coding_type", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_zlib_get_coding_type());
}
Variant ei_hphp_splfileobject_fscanf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_fscanf", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fscanf(a0, a1, a2, a3));
}
Variant ei_mb_ereg_search_getregs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_ereg_search_getregs", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_ereg_search_getregs());
}
Variant ei_mb_eregi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_eregi", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_eregi(a0, a1));
  else return (x_mb_eregi(a0, a1, ref(a2)));
}
Variant ei_pixelgetgreen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetgreen", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetgreen(a0));
}
Variant ei_mysql_client_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_client_encoding", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_client_encoding());
  else return (x_mysql_client_encoding(a0));
}
Variant ei_zend_thread_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_thread_id", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_zend_thread_id());
}
Variant ei_ldap_mod_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_replace", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_mod_replace(a0, a1, a2));
}
Variant ei_collator_get_error_code(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_error_code", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_get_error_code(a0));
}
Variant ei_stream_filter_prepend(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_filter_prepend", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_filter_prepend(a0, a1));
  else if (count == 3) return (x_stream_filter_prepend(a0, a1, a2));
  else return (x_stream_filter_prepend(a0, a1, a2, a3));
}
Variant ei_substr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("substr", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_substr(a0, a1));
  else return (x_substr(a0, a1, a2));
}
Variant ei_magickcombineimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcombineimages", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcombineimages(a0, a1));
}
Variant ei_pixelgetexceptiontype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexceptiontype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetexceptiontype(a0));
}
Variant ei_unpack(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("unpack", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_unpack(a0, a1));
}
Variant ei_hphp_splfileinfo_isdir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isdir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_isdir(a0));
}
Variant ei_magickgetimagepixels(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("magickgetimagepixels", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagepixels(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_array_product(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_product", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_product(a0));
}
Variant ei_substr_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("substr_replace", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_substr_replace(a0, a1, a2));
  else return (x_substr_replace(a0, a1, a2, a3));
}
Variant ei_xbox_get_thread_time(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_get_thread_time", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_get_thread_time());
}
Variant ei_xmlwriter_write_dtd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("xmlwriter_write_dtd", count, 2, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_xmlwriter_write_dtd(a0, a1));
  else if (count == 3) return (x_xmlwriter_write_dtd(a0, a1, a2));
  else if (count == 4) return (x_xmlwriter_write_dtd(a0, a1, a2, a3));
  else return (x_xmlwriter_write_dtd(a0, a1, a2, a3, a4));
}
Variant ei_mysql_select_db(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_select_db", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_select_db(a0));
  else return (x_mysql_select_db(a0, a1));
}
Variant ei_fb_get_taint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_get_taint", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_get_taint(a0));
}
Variant ei_use_soap_error_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("use_soap_error_handler", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_use_soap_error_handler());
  else return (x_use_soap_error_handler(a0));
}
Variant ei_debug_backtrace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("debug_backtrace", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_debug_backtrace());
  else return (x_debug_backtrace(a0));
}
Variant ei_drawpathcurvetosmoothrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetosmoothrelative", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetosmoothrelative(a0, a1, a2, a3, a4), null);
}
Variant ei_mailparse_determine_best_xfer_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_determine_best_xfer_encoding", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_determine_best_xfer_encoding(a0));
}
Variant ei_imagettfbbox(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagettfbbox", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagettfbbox(a0, a1, a2, a3));
}
Variant ei_mb_internal_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_internal_encoding", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_internal_encoding());
  else return (x_mb_internal_encoding(a0));
}
Variant ei_msg_get_queue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("msg_get_queue", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_msg_get_queue(a0));
  else return (x_msg_get_queue(a0, a1));
}
Variant ei_posix_getegid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getegid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getegid());
}
Variant ei_magickmedianfilterimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickmedianfilterimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmedianfilterimage(a0, a1));
}
Variant ei_xbox_task_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xbox_task_result", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_task_result(a0, a1, ref(a2)));
}
Variant ei_mcrypt_generic_deinit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_generic_deinit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_generic_deinit(a0));
}
Variant ei_method_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("method_exists", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_method_exists(a0, a1));
}
Variant ei_money_format(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("money_format", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_money_format(a0, a1));
}
Variant ei_clearmagickwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearmagickwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clearmagickwand(a0), null);
}
Variant ei_dom_element_remove_attribute_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_remove_attribute_node", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_remove_attribute_node(a0, a1));
}
Variant ei_array_udiff_assoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_udiff_assoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_udiff_assoc(count, a0, a1, a2));
  return (x_array_udiff_assoc(count, a0, a1, a2,vargs));
}
Variant ei_xml_parser_free(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_parser_free", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_parser_free(a0));
}
Variant ei_is_resource(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_resource", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_resource(a0));
}
Variant ei_hphp_splfileinfo_getsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getsize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getsize(a0));
}
Variant ei_posix_seteuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_seteuid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_seteuid(a0));
}
Variant ei_magicksetinterlacescheme(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetinterlacescheme", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetinterlacescheme(a0, a1));
}
Variant ei_str_shuffle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("str_shuffle", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_str_shuffle(a0));
}
Variant ei_mcrypt_enc_is_block_algorithm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_algorithm", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_is_block_algorithm(a0));
}
Variant ei_call_user_func_array_rpc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("call_user_func_array_rpc", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_call_user_func_array_rpc(a0, a1, a2, a3, a4, a5));
}
Variant ei_fb_serialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_serialize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_serialize(a0));
}
Variant ei_magickgetcopyright(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetcopyright", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetcopyright());
}
Variant ei_magickstripimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickstripimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickstripimage(a0));
}
Variant ei_base64_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("base64_decode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_base64_decode(a0));
  else return (x_base64_decode(a0, a1));
}
Variant ei_rand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("rand", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_rand());
  else if (count == 1) return (x_rand(a0));
  else return (x_rand(a0, a1));
}
Variant ei_crc32(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("crc32", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_crc32(a0));
}
Variant ei_stream_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("stream_encoding", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_encoding(a0));
  else return (x_stream_encoding(a0, a1));
}
Variant ei_drawgetstrokedasharray(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokedasharray", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokedasharray(a0));
}
Variant ei_magickgetimagedispose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagedispose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagedispose(a0));
}
Variant ei_drawpopdefs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpopdefs", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpopdefs(a0), null);
}
Variant ei_xml_parser_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("xml_parser_create", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_xml_parser_create());
  else return (x_xml_parser_create(a0));
}
Variant ei_session_save_path(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_save_path", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_save_path());
  else return (x_session_save_path(a0));
}
Variant ei_pcntl_wifsignaled(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifsignaled", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wifsignaled(a0));
}
Variant ei_openssl_pkcs7_encrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 6) return throw_wrong_arguments("openssl_pkcs7_encrypt", count, 4, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_openssl_pkcs7_encrypt(a0, a1, a2, a3));
  else if (count == 5) return (x_openssl_pkcs7_encrypt(a0, a1, a2, a3, a4));
  else return (x_openssl_pkcs7_encrypt(a0, a1, a2, a3, a4, a5));
}
Variant ei_read_exif_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("read_exif_data", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_read_exif_data(a0));
  else if (count == 2) return (x_read_exif_data(a0, a1));
  else if (count == 3) return (x_read_exif_data(a0, a1, a2));
  else return (x_read_exif_data(a0, a1, a2, a3));
}
Variant ei_drawsetstrokeopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokeopacity", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokeopacity(a0, a1), null);
}
Variant ei_drawroundrectangle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawroundrectangle", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawroundrectangle(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_hphp_directoryiterator_isdot(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_isdot", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_isdot(a0));
}
Variant ei_drawgetstrokewidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokewidth", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokewidth(a0));
}
Variant ei_date_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("date_create", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_date_create());
  else if (count == 1) return (x_date_create(a0));
  else return (x_date_create(a0, a1));
}
Variant ei_strcspn(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("strcspn", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strcspn(a0, a1));
  else if (count == 3) return (x_strcspn(a0, a1, a2));
  else return (x_strcspn(a0, a1, a2, a3));
}
Variant ei_drawgetclipunits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetclipunits", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetclipunits(a0));
}
Variant ei_sem_acquire(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_acquire", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sem_acquire(a0));
}
Variant ei_socket_strerror(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_strerror", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_strerror(a0));
}
Variant ei_magickgetstringheight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetstringheight", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgetstringheight(a0, a1, a2));
  else return (x_magickgetstringheight(a0, a1, a2, a3));
}
Variant ei_dom_document_relaxng_validate_xml(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_relaxng_validate_xml", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_relaxng_validate_xml(a0, a1));
}
Variant ei_rawurlencode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rawurlencode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rawurlencode(a0));
}
Variant ei_strtotime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strtotime", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_strtotime(a0));
  else return (x_strtotime(a0, a1));
}
Variant ei_dom_element_set_id_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_id_attribute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_id_attribute(a0, a1, a2));
}
Variant ei_hphp_recursivedirectoryiterator_getsubpath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getsubpath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_getsubpath(a0));
}
Variant ei_apc_clear_cache(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("apc_clear_cache", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_apc_clear_cache());
  else return (x_apc_clear_cache(a0));
}
Variant ei_dirname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dirname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dirname(a0));
}
Variant ei_strnatcasecmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strnatcasecmp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strnatcasecmp(a0, a1));
}
Variant ei_magicksetsamplingfactors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetsamplingfactors", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetsamplingfactors(a0, a1, a2));
}
Variant ei_openssl_pkey_get_private(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_pkey_get_private", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_openssl_pkey_get_private(a0));
  else return (x_openssl_pkey_get_private(a0, a1));
}
Variant ei_magickaverageimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickaverageimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickaverageimages(a0));
}
Variant ei_iconv_strrpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iconv_strrpos", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iconv_strrpos(a0, a1));
  else return (x_iconv_strrpos(a0, a1, a2));
}
Variant ei_collator_get_locale(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("collator_get_locale", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_collator_get_locale(a0));
  else return (x_collator_get_locale(a0, a1));
}
Variant ei_drawsetviewbox(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawsetviewbox", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetviewbox(a0, a1, a2, a3, a4), null);
}
Variant ei_magicksetimagecompressionquality(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompressionquality", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagecompressionquality(a0, a1));
}
Variant ei_mysql_ping(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_ping", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_ping());
  else return (x_mysql_ping(a0));
}
Variant ei_xml_get_current_byte_index(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_byte_index", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_get_current_byte_index(a0));
}
Variant ei_magicktransformimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicktransformimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicktransformimage(a0, a1, a2));
}
Variant ei_drawgetstrokeantialias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokeantialias", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokeantialias(a0));
}
Variant ei_ini_alter(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ini_alter", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ini_alter(a0, a1));
}
Variant ei_get_class(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_class", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_class());
  else return (x_get_class(a0));
}
Variant ei_magicksetimageprofile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageprofile", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageprofile(a0, a1, a2));
}
Variant ei_mysql_field_seek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_seek", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_seek(a0));
  else return (x_mysql_field_seek(a0, a1));
}
Variant ei_drawgetfontsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontsize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfontsize(a0));
}
Variant ei_mysql_num_rows(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_num_rows", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_num_rows(a0));
}
Variant ei_hphp_recursiveiteratoriterator_rewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_rewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_rewind(a0), null);
}
Variant ei_magickgetimageresolution(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageresolution", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageresolution(a0));
}
Variant ei_array_diff(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_diff(count, a0, a1));
  return (x_array_diff(count, a0, a1,vargs));
}
Variant ei_xmlwriter_open_uri(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_open_uri", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_open_uri(a0));
}
Variant ei_magickgetimagetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagetype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagetype(a0));
}
Variant ei_simplexml_load_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("simplexml_load_string", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_simplexml_load_string(a0));
  else if (count == 2) return (x_simplexml_load_string(a0, a1));
  else if (count == 3) return (x_simplexml_load_string(a0, a1, a2));
  else if (count == 4) return (x_simplexml_load_string(a0, a1, a2, a3));
  else return (x_simplexml_load_string(a0, a1, a2, a3, a4));
}
Variant ei_magickunsharpmaskimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("magickunsharpmaskimage", count, 5, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 5) return (x_magickunsharpmaskimage(a0, a1, a2, a3, a4));
  else return (x_magickunsharpmaskimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_quoted_printable_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quoted_printable_encode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_quoted_printable_encode(a0));
}
Variant ei_gettype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gettype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gettype(a0));
}
Variant ei_magickgetimagebackgroundcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagebackgroundcolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagebackgroundcolor(a0));
}
Variant ei_hphp_splfileobject_setmaxlinelen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_setmaxlinelen", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_setmaxlinelen(a0, a1), null);
}
Variant ei_array_intersect_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect_key", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_intersect_key(count, a0, a1));
  return (x_array_intersect_key(count, a0, a1,vargs));
}
Variant ei_array_change_key_case(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_change_key_case", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_array_change_key_case(a0));
  else return (x_array_change_key_case(a0, a1));
}
Variant ei_ldap_first_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_first_attribute(a0, a1));
}
Variant ei_gettimeofday(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("gettimeofday", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_gettimeofday());
  else return (x_gettimeofday(a0));
}
Variant ei_xmlwriter_end_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_element", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_element(a0));
}
Variant ei_drawpoint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpoint", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpoint(a0, a1, a2), null);
}
Variant ei_strnatcmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strnatcmp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strnatcmp(a0, a1));
}
Variant ei_property_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("property_exists", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_property_exists(a0, a1));
}
Variant ei_mysql_affected_rows(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_affected_rows", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_affected_rows());
  else return (x_mysql_affected_rows(a0));
}
Variant ei_magickdespeckleimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdespeckleimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickdespeckleimage(a0));
}
Variant ei_imagecopymergegray(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagecopymergegray", count, 9, 9, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecopymergegray(a0, a1, a2, a3, a4, a5, a6, a7, a8));
}
Variant ei_ctype_cntrl(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_cntrl", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_cntrl(a0));
}
Variant ei_hphp_splfileobject_next(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_next", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_next(a0), null);
}
Variant ei_is_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_array", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_array(a0));
}
Variant ei_rename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("rename", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_rename(a0, a1));
  else return (x_rename(a0, a1, a2));
}
Variant ei_date_format(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_format", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_format(a0, a1));
}
Variant ei_hphp_splfileobject_fgetc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fgetc", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fgetc(a0));
}
Variant ei_magickshaveimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickshaveimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickshaveimage(a0, a1, a2));
}
Variant ei_dom_element_set_attribute_node_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_set_attribute_node_ns", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_attribute_node_ns(a0, a1));
}
Variant ei_xmlwriter_output_memory(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xmlwriter_output_memory", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_xmlwriter_output_memory(a0));
  else return (x_xmlwriter_output_memory(a0, a1));
}
Variant ei_ob_end_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_end_flush", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_end_flush());
}
Variant ei_magickwhitethresholdimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwhitethresholdimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickwhitethresholdimage(a0, a1));
}
Variant ei_drawpolyline(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpolyline", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpolyline(a0, a1), null);
}
Variant ei_hphp_splfileobject_fgets(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fgets", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fgets(a0));
}
Variant ei_hphp_get_function_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_function_info", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_function_info(a0));
}
Variant ei_prev(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("prev", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_prev(ref(a0)));
}
Variant ei_imagegammacorrect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagegammacorrect", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagegammacorrect(a0, a1, a2));
}
Variant ei_str_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("str_replace", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_str_replace(a0, a1, a2));
  else return (x_str_replace(a0, a1, a2, ref(a3)));
}
Variant ei_dom_node_lookup_namespace_uri(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_lookup_namespace_uri", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_lookup_namespace_uri(a0, a1));
}
Variant ei_fb_unserialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_unserialize", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fb_unserialize(a0, ref(a1)));
  else return (x_fb_unserialize(a0, ref(a1), ref(a2)));
}
Variant ei_clock_getres(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_getres", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clock_getres(a0, ref(a1), ref(a2)));
}
Variant ei_magicktrimimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicktrimimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicktrimimage(a0, a1));
}
Variant ei_hphp_splfileinfo_getpathinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getpathinfo", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getpathinfo(a0, a1));
}
Variant ei_magickgetimagegamma(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagegamma", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagegamma(a0));
}
Variant ei_newdrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("newdrawingwand", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newdrawingwand());
}
Variant ei_gzrewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzrewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzrewind(a0));
}
Variant ei_ldap_explode_dn(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_explode_dn", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_explode_dn(a0, a1));
}
Variant ei_posix_times(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_times", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_times());
}
Variant ei_drawgetfillcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillcolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfillcolor(a0));
}
Variant ei_dom_document_save_html(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_save_html", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_save_html(a0));
}
Variant ei_mb_strtolower(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strtolower", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_strtolower(a0));
  else return (x_mb_strtolower(a0, a1));
}
Variant ei_localtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("localtime", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_localtime());
  else if (count == 1) return (x_localtime(a0));
  else return (x_localtime(a0, a1));
}
Variant ei_fb_thrift_unserialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_thrift_unserialize", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fb_thrift_unserialize(a0, ref(a1)));
  else return (x_fb_thrift_unserialize(a0, ref(a1), ref(a2)));
}
Variant ei_sha1(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sha1", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_sha1(a0));
  else return (x_sha1(a0, a1));
}
Variant ei_collator_set_strength(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_set_strength", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_set_strength(a0, a1));
}
Variant ei_implode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("implode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_implode(a0));
  else return (x_implode(a0, a1));
}
Variant ei_date_isodate_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("date_isodate_set", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_date_isodate_set(a0, a1, a2), null);
  else return (x_date_isodate_set(a0, a1, a2, a3), null);
}
Variant ei_magickpaintopaqueimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickpaintopaqueimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickpaintopaqueimage(a0, a1, a2));
  else return (x_magickpaintopaqueimage(a0, a1, a2, a3));
}
Variant ei_mb_strimwidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mb_strimwidth", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_mb_strimwidth(a0, a1, a2));
  else if (count == 4) return (x_mb_strimwidth(a0, a1, a2, a3));
  else return (x_mb_strimwidth(a0, a1, a2, a3, a4));
}
Variant ei_drawsetfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfont", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfont(a0, a1));
}
Variant ei_xml_set_default_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_default_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_default_handler(a0, a1));
}
Variant ei_magickchopimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickchopimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickchopimage(a0, a1, a2, a3, a4));
}
Variant ei_wordwrap(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("wordwrap", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_wordwrap(a0));
  else if (count == 2) return (x_wordwrap(a0, a1));
  else if (count == 3) return (x_wordwrap(a0, a1, a2));
  else return (x_wordwrap(a0, a1, a2, a3));
}
Variant ei_gzgetss(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("gzgetss", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzgetss(a0));
  else if (count == 2) return (x_gzgetss(a0, a1));
  else return (x_gzgetss(a0, a1, a2));
}
Variant ei_magickgetimagevirtualpixelmethod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagevirtualpixelmethod", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagevirtualpixelmethod(a0));
}
Variant ei_imagedestroy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagedestroy", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagedestroy(a0));
}
Variant ei_timezone_open(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_open", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_open(a0));
}
Variant ei_ob_clean(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_clean", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_clean(), null);
}
Variant ei_mb_ereg_search_pos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search_pos", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_ereg_search_pos());
  else if (count == 1) return (x_mb_ereg_search_pos(a0));
  else return (x_mb_ereg_search_pos(a0, a1));
}
Variant ei_bccomp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bccomp", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bccomp(a0, a1));
  else return (x_bccomp(a0, a1, a2));
}
Variant ei_gzdecode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzdecode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzdecode(a0));
}
Variant ei_magicksetimagecompose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompose", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagecompose(a0, a1));
}
Variant ei_apc_bin_dump(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apc_bin_dump", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_apc_bin_dump());
  else if (count == 1) return (x_apc_bin_dump(a0));
  else return (x_apc_bin_dump(a0, a1));
}
Variant ei_ini_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ini_get", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ini_get(a0));
}
Variant ei_mb_ereg_search_setpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_ereg_search_setpos", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_ereg_search_setpos(a0));
}
Variant ei_stream_copy_to_stream(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_copy_to_stream", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_copy_to_stream(a0, a1));
  else if (count == 3) return (x_stream_copy_to_stream(a0, a1, a2));
  else return (x_stream_copy_to_stream(a0, a1, a2, a3));
}
Variant ei_xml_get_error_code(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_error_code", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_get_error_code(a0));
}
Variant ei_pcntl_alarm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_alarm", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_alarm(a0));
}
Variant ei_drawpolygon(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpolygon", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpolygon(a0, a1), null);
}
Variant ei_mysql_connect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 7) return throw_toomany_arguments("mysql_connect", 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_connect());
  else if (count == 1) return (x_mysql_connect(a0));
  else if (count == 2) return (x_mysql_connect(a0, a1));
  else if (count == 3) return (x_mysql_connect(a0, a1, a2));
  else if (count == 4) return (x_mysql_connect(a0, a1, a2, a3));
  else if (count == 5) return (x_mysql_connect(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_mysql_connect(a0, a1, a2, a3, a4, a5));
  else return (x_mysql_connect(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_xmlwriter_write_raw(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_raw", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_raw(a0, a1));
}
Variant ei_fgetss(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("fgetss", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fgetss(a0));
  else if (count == 2) return (x_fgetss(a0, a1));
  else return (x_fgetss(a0, a1, a2));
}
Variant ei_drawarc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawarc", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawarc(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_set_error_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("set_error_handler", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_set_error_handler(a0));
  else return (x_set_error_handler(a0, a1));
}
Variant ei_str_word_count(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("str_word_count", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_str_word_count(a0));
  else if (count == 2) return (x_str_word_count(a0, a1));
  else return (x_str_word_count(a0, a1, a2));
}
Variant ei_drawsetcliprule(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetcliprule", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetcliprule(a0, a1), null);
}
Variant ei_openssl_pkcs12_read(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("openssl_pkcs12_read", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_pkcs12_read(a0, ref(a1), a2));
}
Variant ei_ldap_list(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_list", count, 3, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_ldap_list(a0, a1, a2));
  else if (count == 4) return (x_ldap_list(a0, a1, a2, a3));
  else if (count == 5) return (x_ldap_list(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_ldap_list(a0, a1, a2, a3, a4, a5));
  else if (count == 7) return (x_ldap_list(a0, a1, a2, a3, a4, a5, a6));
  else return (x_ldap_list(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_func_num_args(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("func_num_args", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_func_num_args());
}
Variant ei_drawsettextdecoration(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextdecoration", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsettextdecoration(a0, a1), null);
}
Variant ei_str_rot13(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("str_rot13", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_str_rot13(a0));
}
Variant ei_openssl_pkey_new(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("openssl_pkey_new", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_openssl_pkey_new());
  else return (x_openssl_pkey_new(a0));
}
Variant ei_magicksetimageindex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageindex", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageindex(a0, a1));
}
Variant ei_ldap_rename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("ldap_rename", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_rename(a0, a1, a2, a3, a4));
}
Variant ei_ldap_start_tls(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_start_tls", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_start_tls(a0));
}
Variant ei_tanh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("tanh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_tanh(a0));
}
Variant ei_drawscale(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawscale", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawscale(a0, a1, a2), null);
}
Variant ei_drawrotate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawrotate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawrotate(a0, a1), null);
}
Variant ei_getservbyname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("getservbyname", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getservbyname(a0, a1));
}
Variant ei_compact(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("compact", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_compact(count, a0));
  return (x_compact(count, a0,vargs));
}
Variant ei_hphp_splfileobject_valid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_valid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_valid(a0));
}
Variant ei_imagecolorclosest(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorclosest", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorclosest(a0, a1, a2, a3));
}
Variant ei_magickwriteimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("magickwriteimages", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magickwriteimages(a0));
  else if (count == 2) return (x_magickwriteimages(a0, a1));
  else return (x_magickwriteimages(a0, a1, a2));
}
Variant ei_pixelsetalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetalpha", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetalpha(a0, a1), null);
}
Variant ei_magicksetimageiterations(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageiterations", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageiterations(a0, a1));
}
Variant ei_drawpathmovetoabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathmovetoabsolute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathmovetoabsolute(a0, a1, a2), null);
}
Variant ei_quotemeta(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quotemeta", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_quotemeta(a0));
}
Variant ei_parse_ini_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("parse_ini_string", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_parse_ini_string(a0));
  else if (count == 2) return (x_parse_ini_string(a0, a1));
  else return (x_parse_ini_string(a0, a1, a2));
}
Variant ei_imagefilltoborder(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagefilltoborder", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefilltoborder(a0, a1, a2, a3, a4));
}
Variant ei_xml_set_notation_decl_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_notation_decl_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_notation_decl_handler(a0, a1));
}
Variant ei_is_writeable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_writeable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_writeable(a0));
}
Variant ei_magickgetwandsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetwandsize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetwandsize(a0));
}
Variant ei_hphp_directoryiterator___tostring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator___tostring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator___tostring(a0));
}
Variant ei_memcache_add_server(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  Variant a9;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 10) return throw_wrong_arguments("memcache_add_server", count, 2, 10, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a9 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_add_server(a0, a1));
  else if (count == 3) return (x_memcache_add_server(a0, a1, a2));
  else if (count == 4) return (x_memcache_add_server(a0, a1, a2, a3));
  else if (count == 5) return (x_memcache_add_server(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_memcache_add_server(a0, a1, a2, a3, a4, a5));
  else if (count == 7) return (x_memcache_add_server(a0, a1, a2, a3, a4, a5, a6));
  else if (count == 8) return (x_memcache_add_server(a0, a1, a2, a3, a4, a5, a6, a7));
  else if (count == 9) return (x_memcache_add_server(a0, a1, a2, a3, a4, a5, a6, a7, a8));
  else return (x_memcache_add_server(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
Variant ei_dom_node_remove_child(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_remove_child", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_remove_child(a0, a1));
}
Variant ei_imageinterlace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imageinterlace", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imageinterlace(a0));
  else return (x_imageinterlace(a0, a1));
}
Variant ei_preg_match_all(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_match_all", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_preg_match_all(a0, a1, ref(a2)));
  else if (count == 4) return (x_preg_match_all(a0, a1, ref(a2), a3));
  else return (x_preg_match_all(a0, a1, ref(a2), a3, a4));
}
Variant ei_proc_terminate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("proc_terminate", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_proc_terminate(a0));
  else return (x_proc_terminate(a0, a1));
}
Variant ei_apc_bin_loadfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_bin_loadfile", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_bin_loadfile(a0));
  else if (count == 2) return (x_apc_bin_loadfile(a0, a1));
  else if (count == 3) return (x_apc_bin_loadfile(a0, a1, a2));
  else return (x_apc_bin_loadfile(a0, a1, a2, a3));
}
Variant ei_posix_getcwd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getcwd", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getcwd());
}
Variant ei_drawpathcurvetoabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawpathcurvetoabsolute", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetoabsolute(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_hphp_set_error_page(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_set_error_page", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_set_error_page(a0), null);
}
Variant ei_preg_match(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("preg_match", count, 2, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_preg_match(a0, a1));
  else if (count == 3) return (x_preg_match(a0, a1, ref(a2)));
  else if (count == 4) return (x_preg_match(a0, a1, ref(a2), a3));
  else return (x_preg_match(a0, a1, ref(a2), a3, a4));
}
Variant ei_timezone_abbreviations_list(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("timezone_abbreviations_list", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_abbreviations_list());
}
Variant ei_magickradialblurimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickradialblurimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickradialblurimage(a0, a1));
}
Variant ei_posix_geteuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_geteuid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_geteuid());
}
Variant ei_mysql_fetch_lengths(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_lengths", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_fetch_lengths(a0));
}
Variant ei_magickwriteimagefile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimagefile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickwriteimagefile(a0, a1));
}
Variant ei_serialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("serialize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_serialize(a0));
}
Variant ei_exif_read_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("exif_read_data", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_exif_read_data(a0));
  else if (count == 2) return (x_exif_read_data(a0, a1));
  else if (count == 3) return (x_exif_read_data(a0, a1, a2));
  else return (x_exif_read_data(a0, a1, a2, a3));
}
Variant ei_pixelgetiteratorexceptiontype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexceptiontype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetiteratorexceptiontype(a0));
}
Variant ei_destroydrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroydrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroydrawingwand(a0), null);
}
Variant ei_lstat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("lstat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_lstat(a0));
}
Variant ei_apache_note(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apache_note", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apache_note(a0));
  else return (x_apache_note(a0, a1));
}
Variant ei_drawgetexceptiontype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexceptiontype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetexceptiontype(a0));
}
Variant ei_drawbezier(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawbezier", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawbezier(a0, a1), null);
}
Variant ei_xmlwriter_start_comment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_start_comment", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_comment(a0));
}
Variant ei_ldap_set_rebind_proc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_set_rebind_proc", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_set_rebind_proc(a0, a1));
}
Variant ei_drawsetstrokecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokecolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokecolor(a0, a1), null);
}
Variant ei_drawpathlinetohorizontalrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetohorizontalrelative", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetohorizontalrelative(a0, a1), null);
}
Variant ei_gmmktime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("gmmktime", 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_gmmktime());
  else if (count == 1) return (x_gmmktime(a0));
  else if (count == 2) return (x_gmmktime(a0, a1));
  else if (count == 3) return (x_gmmktime(a0, a1, a2));
  else if (count == 4) return (x_gmmktime(a0, a1, a2, a3));
  else if (count == 5) return (x_gmmktime(a0, a1, a2, a3, a4));
  else return (x_gmmktime(a0, a1, a2, a3, a4, a5));
}
Variant ei_gmdate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gmdate", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gmdate(a0));
  else return (x_gmdate(a0, a1));
}
Variant ei_posix_getgid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getgid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getgid());
}
Variant ei_sinh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sinh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sinh(a0));
}
Variant ei_apc_fetch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_fetch", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  INTERCEPT_INJECTION_ALWAYS("apc_fetch", "apc_fetch", ArrayUtil::Slice(Array(ArrayInit(3, true).set(0, a0).setRef(1, a1).set(2, a2).create()), 0, count, false), r);
  if (count <= 1) return (x_apc_fetch(a0));
  else if (count == 2) return (x_apc_fetch(a0, ref(a1)));
  else return (x_apc_fetch(a0, ref(a1), a2));
}
Variant ei_fileowner(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileowner", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fileowner(a0));
}
Variant ei_imagecopymerge(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagecopymerge", count, 9, 9, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecopymerge(a0, a1, a2, a3, a4, a5, a6, a7, a8));
}
Variant ei_magickclipimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickclipimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickclipimage(a0));
}
Variant ei_intl_get_error_code(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("intl_get_error_code", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_intl_get_error_code());
}
Variant ei_imagestringup(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagestringup", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagestringup(a0, a1, a2, a3, a4, a5));
}
Variant ei_mt_getrandmax(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mt_getrandmax", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mt_getrandmax());
}
Variant ei_magickgetresourcelimit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetresourcelimit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetresourcelimit(a0));
}
Variant ei_hphp_splfileinfo_getlinktarget(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getlinktarget", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getlinktarget(a0));
}
Variant ei_imagecolorexact(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorexact", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorexact(a0, a1, a2, a3));
}
Variant ei_hphp_recursivedirectoryiterator_current(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_current", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_current(a0));
}
Variant ei_setcookie(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("setcookie", count, 1, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_setcookie(a0));
  else if (count == 2) return (x_setcookie(a0, a1));
  else if (count == 3) return (x_setcookie(a0, a1, a2));
  else if (count == 4) return (x_setcookie(a0, a1, a2, a3));
  else if (count == 5) return (x_setcookie(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_setcookie(a0, a1, a2, a3, a4, a5));
  else return (x_setcookie(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_fileatime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileatime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fileatime(a0));
}
Variant ei_apd_stop_trace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_stop_trace", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_stop_trace(), null);
}
Variant ei_hphpd_break(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("hphpd_break", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_hphpd_break(), null);
  else return (x_hphpd_break(a0), null);
}
Variant ei_addcslashes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("addcslashes", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_addcslashes(a0, a1));
}
Variant ei_magicksetimageoption(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magicksetimageoption", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageoption(a0, a1, a2, a3));
}
Variant ei_xmlwriter_write_comment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_comment", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_comment(a0, a1));
}
Variant ei_drawgetfontstyle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontstyle", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfontstyle(a0));
}
Variant ei_dom_element_set_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_element_set_attribute_ns", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_attribute_ns(a0, a1, a2, a3));
}
Variant ei_dom_xpath_evaluate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_xpath_evaluate", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_xpath_evaluate(a0, a1));
  else return (x_dom_xpath_evaluate(a0, a1, a2));
}
Variant ei_strtoupper(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strtoupper", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strtoupper(a0));
}
Variant ei_xml_set_processing_instruction_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_processing_instruction_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_processing_instruction_handler(a0, a1));
}
Variant ei_apd_breakpoint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_breakpoint", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_breakpoint());
}
Variant ei_memcache_delete(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_delete", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_delete(a0, a1));
  else return (x_memcache_delete(a0, a1, a2));
}
Variant ei_magickgetimageblueprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageblueprimary", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageblueprimary(a0));
}
Variant ei_magickspreadimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickspreadimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickspreadimage(a0, a1));
}
Variant ei_array_fill(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("array_fill", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_fill(a0, a1, a2));
}
Variant ei_dom_element_set_attribute_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_set_attribute_node", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_attribute_node(a0, a1));
}
Variant ei_memcache_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_replace", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_memcache_replace(a0, a1, a2));
  else if (count == 4) return (x_memcache_replace(a0, a1, a2, a3));
  else return (x_memcache_replace(a0, a1, a2, a3, a4));
}
Variant ei_stream_set_write_buffer(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_set_write_buffer", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_set_write_buffer(a0, a1));
}
Variant ei_mb_list_encodings(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_list_encodings", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_list_encodings());
}
Variant ei_sleep(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sleep", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sleep(a0));
}
Variant ei_cleardrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cleardrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_cleardrawingwand(a0), null);
}
Variant ei_imagecolorset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorset", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorset(a0, a1, a2, a3, a4));
}
Variant ei_openssl_x509_checkpurpose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_x509_checkpurpose", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_x509_checkpurpose(a0, a1));
  else if (count == 3) return (x_openssl_x509_checkpurpose(a0, a1, a2));
  else return (x_openssl_x509_checkpurpose(a0, a1, a2, a3));
}
Variant ei_drawpathcurvetosmoothabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetosmoothabsolute", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetosmoothabsolute(a0, a1, a2, a3, a4), null);
}
Variant ei_array_intersect_ukey(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_intersect_ukey", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_intersect_ukey(count, a0, a1, a2));
  return (x_array_intersect_ukey(count, a0, a1, a2,vargs));
}
Variant ei_timezone_name_from_abbr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("timezone_name_from_abbr", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_timezone_name_from_abbr(a0));
  else if (count == 2) return (x_timezone_name_from_abbr(a0, a1));
  else return (x_timezone_name_from_abbr(a0, a1, a2));
}
Variant ei_imagefilledellipse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagefilledellipse", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefilledellipse(a0, a1, a2, a3, a4, a5));
}
Variant ei_pcntl_wstopsig(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wstopsig", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wstopsig(a0));
}
Variant ei_get_defined_vars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_defined_vars", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_defined_vars());
}
Variant ei_memory_get_usage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("memory_get_usage", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_memory_get_usage());
  else return (x_memory_get_usage(a0));
}
Variant ei_intval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("intval", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_intval(a0));
  else return (x_intval(a0, a1));
}
Variant ei_pagelet_server_task_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pagelet_server_task_status", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pagelet_server_task_status(a0));
}
Variant ei_dom_document_get_elements_by_tag_name_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_document_get_elements_by_tag_name_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_get_elements_by_tag_name_ns(a0, a1, a2));
}
Variant ei_iconv_set_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("iconv_set_encoding", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_iconv_set_encoding(a0, a1));
}
Variant ei_magickmattefloodfillimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickmattefloodfillimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmattefloodfillimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_mailparse_msg_get_part(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mailparse_msg_get_part", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_get_part(a0, a1));
}
Variant ei_mb_check_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_check_encoding", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_check_encoding());
  else if (count == 1) return (x_mb_check_encoding(a0));
  else return (x_mb_check_encoding(a0, a1));
}
Variant ei_ldap_get_dn(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_dn", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_dn(a0, a1));
}
Variant ei_newpixeliterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixeliterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newpixeliterator(a0));
}
Variant ei_magicksetimagefilename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magicksetimagefilename", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magicksetimagefilename(a0));
  else return (x_magicksetimagefilename(a0, a1));
}
Variant ei_call_user_func(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("call_user_func", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 1) return (x_call_user_func(count, a0));
  return (x_call_user_func(count, a0,vargs));
}
Variant ei_mysql_list_tables(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_list_tables", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_list_tables(a0));
  else return (x_mysql_list_tables(a0, a1));
}
Variant ei_magickgetinterlacescheme(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetinterlacescheme", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetinterlacescheme(a0));
}
Variant ei_ltrim(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("ltrim", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_ltrim(a0));
  else return (x_ltrim(a0, a1));
}
Variant ei_magicktextureimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicktextureimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicktextureimage(a0, a1));
}
Variant ei_mb_ereg_match(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_ereg_match", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_ereg_match(a0, a1));
  else return (x_mb_ereg_match(a0, a1, a2));
}
Variant ei_mt_srand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mt_srand", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mt_srand(), null);
  else return (x_mt_srand(a0), null);
}
Variant ei_imagecolorallocate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorallocate", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorallocate(a0, a1, a2, a3));
}
Variant ei_define_syslog_variables(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("define_syslog_variables", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_define_syslog_variables(), null);
}
Variant ei_fb_get_code_coverage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("fb_get_code_coverage", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_get_code_coverage());
}
Variant ei_mcrypt_enc_get_modes_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_modes_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_modes_name(a0));
}
Variant ei_array_flip(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_flip", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_flip(a0));
}
Variant ei_count(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("count", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_count(a0));
  else return (x_count(a0, a1));
}
Variant ei_lcg_value(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("lcg_value", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_lcg_value());
}
Variant ei_php_logo_guid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_logo_guid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_php_logo_guid());
}
Variant ei_time(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("time", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_time());
}
Variant ei_magickcoalesceimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickcoalesceimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcoalesceimages(a0));
}
Variant ei_pixelgetquantumcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetquantumcolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetquantumcolor(a0));
}
Variant ei_openssl_private_encrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_private_encrypt", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_private_encrypt(a0, ref(a1), a2));
  else return (x_openssl_private_encrypt(a0, ref(a1), a2, a3));
}
Variant ei_xhprof_enable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xhprof_enable", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_xhprof_enable(a0), null);
  else return (x_xhprof_enable(a0, a1), null);
}
Variant ei_hphp_splfileinfo_gettype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_gettype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_gettype(a0));
}
Variant ei_xhprof_run_trace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xhprof_run_trace", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xhprof_run_trace(a0, a1));
}
Variant ei_xmlwriter_start_document(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("xmlwriter_start_document", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_xmlwriter_start_document(a0));
  else if (count == 2) return (x_xmlwriter_start_document(a0, a1));
  else if (count == 3) return (x_xmlwriter_start_document(a0, a1, a2));
  else return (x_xmlwriter_start_document(a0, a1, a2, a3));
}
Variant ei_libxml_clear_errors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_clear_errors", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_libxml_clear_errors(), null);
}
Variant ei_magicknormalizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicknormalizeimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicknormalizeimage(a0));
}
Variant ei_magickgetformat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetformat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetformat(a0));
}
Variant ei_hphp_get_class_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_class_info", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_class_info(a0));
}
Variant ei_dom_element_remove_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_remove_attribute_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_remove_attribute_ns(a0, a1, a2));
}
Variant ei_mailparse_msg_get_part_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_get_part_data", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_get_part_data(a0));
}
Variant ei_openssl_csr_new(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_csr_new", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_csr_new(a0, ref(a1)));
  else if (count == 3) return (x_openssl_csr_new(a0, ref(a1), a2));
  else return (x_openssl_csr_new(a0, ref(a1), a2, a3));
}
Variant ei_xbox_task_start(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_task_start", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_task_start(a0));
}
Variant ei_getcwd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getcwd", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getcwd());
}
Variant ei_posix_getrlimit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getrlimit", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getrlimit());
}
Variant ei_mb_get_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_get_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_get_info());
  else return (x_mb_get_info(a0));
}
Variant ei_newpixelwands(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixelwands", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newpixelwands(a0));
}
Variant ei_fputcsv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("fputcsv", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fputcsv(a0, a1));
  else if (count == 3) return (x_fputcsv(a0, a1, a2));
  else return (x_fputcsv(a0, a1, a2, a3));
}
Variant ei_stream_bucket_prepend(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_prepend", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_bucket_prepend(a0, a1), null);
}
Variant ei_apache_get_scoreboard(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_scoreboard", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_get_scoreboard());
}
Variant ei_sprintf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("sprintf", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_sprintf(count, a0));
  return (x_sprintf(count, a0,vargs));
}
Variant ei_ldap_err2str(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_err2str", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_err2str(a0));
}
Variant ei_memcache_get_stats(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_get_stats", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_memcache_get_stats(a0));
  else if (count == 2) return (x_memcache_get_stats(a0, a1));
  else if (count == 3) return (x_memcache_get_stats(a0, a1, a2));
  else return (x_memcache_get_stats(a0, a1, a2, a3));
}
Variant ei_xmlwriter_end_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_attribute", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_attribute(a0));
}
Variant ei_imagecharup(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagecharup", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecharup(a0, a1, a2, a3, a4, a5));
}
Variant ei_fflush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fflush", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fflush(a0));
}
Variant ei_magickwaveimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickwaveimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickwaveimage(a0, a1, a2));
}
Variant ei_imagepsfreefont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagepsfreefont", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepsfreefont(a0));
}
Variant ei_dom_node_is_supported(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_node_is_supported", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_is_supported(a0, a1, a2));
}
Variant ei_magickgetsamplingfactors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetsamplingfactors", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetsamplingfactors(a0));
}
Variant ei_mt_rand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mt_rand", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mt_rand());
  else if (count == 1) return (x_mt_rand(a0));
  else return (x_mt_rand(a0, a1));
}
Variant ei_hphp_splfileinfo_getpathname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getpathname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getpathname(a0));
}
Variant ei_magickflopimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflopimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickflopimage(a0));
}
Variant ei_register_cleanup_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_cleanup_function", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_register_cleanup_function(count, a0), null);
  return (x_register_cleanup_function(count, a0,vargs), null);
}
Variant ei_getenv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getenv", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getenv(a0));
}
Variant ei_is_dir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_dir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_dir(a0));
}
Variant ei_get_defined_functions(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_defined_functions", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_defined_functions());
}
Variant ei_stream_set_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("stream_set_timeout", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_set_timeout(a0, a1));
  else return (x_stream_set_timeout(a0, a1, a2));
}
Variant ei_magickenhanceimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickenhanceimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickenhanceimage(a0));
}
Variant ei_memcache_increment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_increment", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_increment(a0, a1));
  else return (x_memcache_increment(a0, a1, a2));
}
Variant ei_pixelsetblack(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblack", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetblack(a0, a1), null);
}
Variant ei_magickgetcharwidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetcharwidth", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgetcharwidth(a0, a1, a2));
  else return (x_magickgetcharwidth(a0, a1, a2, a3));
}
Variant ei_magickshearimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickshearimage", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickshearimage(a0, a1, a2, a3));
}
Variant ei_stream_socket_enable_crypto(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_enable_crypto", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_socket_enable_crypto(a0, a1));
  else if (count == 3) return (x_stream_socket_enable_crypto(a0, a1, a2));
  else return (x_stream_socket_enable_crypto(a0, a1, a2, a3));
}
Variant ei_stream_socket_server(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("stream_socket_server", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_socket_server(a0));
  else if (count == 2) return (x_stream_socket_server(a0, ref(a1)));
  else if (count == 3) return (x_stream_socket_server(a0, ref(a1), ref(a2)));
  else if (count == 4) return (x_stream_socket_server(a0, ref(a1), ref(a2), a3));
  else return (x_stream_socket_server(a0, ref(a1), ref(a2), a3, a4));
}
Variant ei_apd_set_pprof_trace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apd_set_pprof_trace", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_apd_set_pprof_trace());
  else if (count == 1) return (x_apd_set_pprof_trace(a0));
  else return (x_apd_set_pprof_trace(a0, a1));
}
Variant ei_ini_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ini_set", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ini_set(a0, a1));
}
Variant ei_sort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("sort", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_sort(ref(a0)));
  else if (count == 2) return (x_sort(ref(a0), a1));
  else return (x_sort(ref(a0), a1, a2));
}
Variant ei_drawgetfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfont", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfont(a0));
}
Variant ei_readdir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("readdir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_readdir(a0));
}
Variant ei_mysql_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_close", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_close());
  else return (x_mysql_close(a0));
}
Variant ei_magicksetimagerenderingintent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagerenderingintent", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagerenderingintent(a0, a1));
}
Variant ei_magickreducenoiseimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreducenoiseimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickreducenoiseimage(a0, a1));
}
Variant ei_magickblurimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickblurimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickblurimage(a0, a1, a2));
  else return (x_magickblurimage(a0, a1, a2, a3));
}
Variant ei_hphpd_get_user_commands(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphpd_get_user_commands", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphpd_get_user_commands());
}
Variant ei_magicktintimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicktintimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicktintimage(a0, a1, a2));
}
Variant ei_rawurldecode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rawurldecode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rawurldecode(a0));
}
Variant ei_strftime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strftime", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_strftime(a0));
  else return (x_strftime(a0, a1));
}
Variant ei_xmlwriter_start_element_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("xmlwriter_start_element_ns", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_element_ns(a0, a1, a2, a3));
}
Variant ei_imagecolorstotal(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecolorstotal", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorstotal(a0));
}
Variant ei_hphp_splfileinfo_getowner(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getowner", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getowner(a0));
}
Variant ei_write_hdf_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("write_hdf_string", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_write_hdf_string(a0));
}
Variant ei_dom_node_has_child_nodes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_has_child_nodes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_has_child_nodes(a0));
}
Variant ei_apc_bin_dumpfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("apc_bin_dumpfile", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_apc_bin_dumpfile(a0, a1, a2));
  else if (count == 4) return (x_apc_bin_dumpfile(a0, a1, a2, a3));
  else return (x_apc_bin_dumpfile(a0, a1, a2, a3, a4));
}
Variant ei_xml_parse_into_struct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("xml_parse_into_struct", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_xml_parse_into_struct(a0, a1, ref(a2)));
  else return (x_xml_parse_into_struct(a0, a1, ref(a2), ref(a3)));
}
Variant ei_icu_transliterate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("icu_transliterate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_icu_transliterate(a0, a1));
}
Variant ei_mb_eregi_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("mb_eregi_replace", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_mb_eregi_replace(a0, a1, a2));
  else return (x_mb_eregi_replace(a0, a1, a2, a3));
}
Variant ei_hphp_splfileinfo_getatime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getatime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getatime(a0));
}
Variant ei_array_unshift(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_unshift", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_unshift(count, ref(a0), a1));
  return (x_array_unshift(count, ref(a0), a1,vargs));
}
Variant ei_stat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stat(a0));
}
Variant ei_posix_getpid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getpid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getpid());
}
Variant ei_hphp_directoryiterator_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_key(a0));
}
Variant ei_get_current_user(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_current_user", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_current_user());
}
Variant ei_filesize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filesize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_filesize(a0));
}
Variant ei_round(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("round", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_round(a0));
  else return (x_round(a0, a1));
}
Variant ei_pdo_drivers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pdo_drivers", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pdo_drivers());
}
Variant ei_sqrt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sqrt", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sqrt(a0));
}
Variant ei_ldap_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_close(a0));
}
Variant ei_memcache_pconnect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_pconnect", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_memcache_pconnect(a0));
  else if (count == 2) return (x_memcache_pconnect(a0, a1));
  else if (count == 3) return (x_memcache_pconnect(a0, a1, a2));
  else return (x_memcache_pconnect(a0, a1, a2, a3));
}
Variant ei_mcrypt_enc_get_algorithms_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_algorithms_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_algorithms_name(a0));
}
Variant ei_hphp_splfileobject_rewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_rewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_rewind(a0), null);
}
Variant ei_fprintf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fprintf", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_fprintf(count, a0, a1));
  return (x_fprintf(count, a0, a1,vargs));
}
Variant ei_extension_loaded(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("extension_loaded", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_extension_loaded(a0));
}
Variant ei_mb_detect_order(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_detect_order", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_detect_order());
  else return (x_mb_detect_order(a0));
}
Variant ei_magickmapimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickmapimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmapimage(a0, a1, a2));
}
Variant ei_get_magic_quotes_runtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_magic_quotes_runtime", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_magic_quotes_runtime());
}
Variant ei_pixelsetopacityquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetopacityquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetopacityquantum(a0, a1), null);
}
Variant ei_ctype_space(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_space", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_space(a0));
}
Variant ei_destroymagickwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroymagickwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroymagickwand(a0), null);
}
Variant ei_mcrypt_generic_init(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("mcrypt_generic_init", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_generic_init(a0, a1, a2));
}
Variant ei_quoted_printable_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quoted_printable_decode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_quoted_printable_decode(a0));
}
Variant ei_hphp_splfileinfo_getfileinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getfileinfo", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getfileinfo(a0, a1));
}
Variant ei_get_cfg_var(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_cfg_var", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_cfg_var(a0));
}
Variant ei_imagerectangle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagerectangle", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagerectangle(a0, a1, a2, a3, a4, a5));
}
Variant ei_call_user_func_rpc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5) return throw_missing_arguments("call_user_func_rpc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 5) return (x_call_user_func_rpc(count, a0, a1, a2, a3, a4));
  return (x_call_user_func_rpc(count, a0, a1, a2, a3, a4,vargs));
}
Variant ei_pixelgetalphaquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetalphaquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetalphaquantum(a0));
}
Variant ei_fb_renamed_functions(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_renamed_functions", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_renamed_functions(a0), null);
}
Variant ei_imagepsextendfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsextendfont", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepsextendfont(a0, a1));
}
Variant ei_magickgetimageblob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageblob", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageblob(a0));
}
Variant ei_stream_get_filters(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_filters", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_get_filters());
}
Variant ei_magickqueryfontmetrics(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickqueryfontmetrics", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickqueryfontmetrics(a0, a1, a2));
  else return (x_magickqueryfontmetrics(a0, a1, a2, a3));
}
Variant ei_ispixeliterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ispixeliterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ispixeliterator(a0));
}
Variant ei_imagefilledarc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagefilledarc", count, 9, 9, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefilledarc(a0, a1, a2, a3, a4, a5, a6, a7, a8));
}
Variant ei_getdate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("getdate", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_getdate());
  else return (x_getdate(a0));
}
Variant ei_hphp_debug_caller_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_debug_caller_info", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_debug_caller_info());
}
Variant ei_xmlwriter_write_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_attribute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_attribute(a0, a1, a2));
}
Variant ei_imagearc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagearc", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagearc(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_magickreadimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimages", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickreadimages(a0, a1));
}
Variant ei_drawgetgravity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetgravity", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetgravity(a0));
}
Variant ei_connection_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_status", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_connection_status());
}
Variant ei_imagecreatefromgd2(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgd2", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromgd2(a0));
}
Variant ei_stream_socket_shutdown(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_socket_shutdown", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_socket_shutdown(a0, a1));
}
Variant ei_pixelresetiterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelresetiterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelresetiterator(a0), null);
}
Variant ei_msg_send(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("msg_send", count, 3, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_msg_send(a0, a1, a2));
  else if (count == 4) return (x_msg_send(a0, a1, a2, a3));
  else if (count == 5) return (x_msg_send(a0, a1, a2, a3, a4));
  else return (x_msg_send(a0, a1, a2, a3, a4, ref(a5)));
}
Variant ei_getmygid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmygid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getmygid());
}
Variant ei_dom_document_get_element_by_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_get_element_by_id", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_get_element_by_id(a0, a1));
}
Variant ei_array_udiff_uassoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4) return throw_missing_arguments("array_udiff_uassoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 4) return (x_array_udiff_uassoc(count, a0, a1, a2, a3));
  return (x_array_udiff_uassoc(count, a0, a1, a2, a3,vargs));
}
Variant ei_strptime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strptime", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strptime(a0, a1));
}
Variant ei_array_diff_uassoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_diff_uassoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_diff_uassoc(count, a0, a1, a2));
  return (x_array_diff_uassoc(count, a0, a1, a2,vargs));
}
Variant ei_xml_set_character_data_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_character_data_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_character_data_handler(a0, a1));
}
Variant ei_pcntl_waitpid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("pcntl_waitpid", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_pcntl_waitpid(a0, ref(a1)));
  else return (x_pcntl_waitpid(a0, ref(a1), a2));
}
Variant ei_array_replace_recursive(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_replace_recursive", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_array_replace_recursive(count, a0));
  return (x_array_replace_recursive(count, a0,vargs));
}
Variant ei_gd_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("gd_info", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gd_info());
}
Variant ei_stream_get_transports(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_transports", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_get_transports());
}
Variant ei_drawsetstrokepatternurl(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokepatternurl", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokepatternurl(a0, a1));
}
Variant ei_ldap_add(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_add", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_add(a0, a1, a2));
}
Variant ei_acosh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("acosh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_acosh(a0));
}
Variant ei_drawsetfillrule(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillrule", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfillrule(a0, a1), null);
}
Variant ei_posix_getlogin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getlogin", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getlogin());
}
Variant ei_posix_getsid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getsid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getsid(a0));
}
Variant ei_imagegd2(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("imagegd2", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagegd2(a0));
  else if (count == 2) return (x_imagegd2(a0, a1));
  else if (count == 3) return (x_imagegd2(a0, a1, a2));
  else return (x_imagegd2(a0, a1, a2, a3));
}
Variant ei_imagecreate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecreate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreate(a0, a1));
}
Variant ei_socket_create_pair(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_create_pair", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_create_pair(a0, a1, a2, ref(a3)));
}
Variant ei_openssl_x509_check_private_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("openssl_x509_check_private_key", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_x509_check_private_key(a0, a1));
}
Variant ei_collator_get_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_get_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_get_attribute(a0, a1));
}
Variant ei_shm_put_var(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("shm_put_var", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shm_put_var(a0, a1, a2));
}
Variant ei_debug_print_backtrace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("debug_print_backtrace", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_debug_print_backtrace(), null);
}
Variant ei_hphp_splfileobject_seek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_seek", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_seek(a0, a1), null);
}
Variant ei_stream_set_blocking(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_set_blocking", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_set_blocking(a0, a1));
}
Variant ei_ezmlm_hash(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ezmlm_hash", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ezmlm_hash(a0));
}
Variant ei_xml_parser_get_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_parser_get_option", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_parser_get_option(a0, a1));
}
Variant ei_array_search(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_search", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_search(a0, a1));
  else return (x_array_search(a0, a1, a2));
}
Variant ei_is_int(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_int", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_int(a0));
}
Variant ei_dangling_server_proxy_new_request(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dangling_server_proxy_new_request", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dangling_server_proxy_new_request(a0));
}
Variant ei_xmlwriter_end_dtd_entity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_entity", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_dtd_entity(a0));
}
Variant ei_trim(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("trim", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_trim(a0));
  else return (x_trim(a0, a1));
}
Variant ei_drawpathclose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathclose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathclose(a0), null);
}
Variant ei_magickprofileimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickprofileimage", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickprofileimage(a0, a1));
  else return (x_magickprofileimage(a0, a1, a2));
}
Variant ei_connection_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_timeout", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_connection_timeout());
}
Variant ei_mysql_data_seek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mysql_data_seek", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_data_seek(a0, a1));
}
Variant ei_pixelgetindex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetindex", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetindex(a0));
}
Variant ei_class_implements(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_implements", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_class_implements(a0));
  else return (x_class_implements(a0, a1));
}
Variant ei_hebrevc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hebrevc", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_hebrevc(a0));
  else return (x_hebrevc(a0, a1));
}
Variant ei_get_meta_tags(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("get_meta_tags", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_get_meta_tags(a0));
  else return (x_get_meta_tags(a0, a1));
}
Variant ei_magicknextimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicknextimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicknextimage(a0));
}
Variant ei_hphp_recursivedirectoryiterator_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_key(a0));
}
Variant ei_mysql_create_db(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_create_db", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_create_db(a0));
  else return (x_mysql_create_db(a0, a1));
}
Variant ei_mysql_stat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_stat", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_stat());
  else return (x_mysql_stat(a0));
}
Variant ei_get_object_vars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_object_vars", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_object_vars(a0));
}
Variant ei_msg_receive(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 8) return throw_wrong_arguments("msg_receive", count, 5, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 5) return (x_msg_receive(a0, a1, ref(a2), a3, ref(a4)));
  else if (count == 6) return (x_msg_receive(a0, a1, ref(a2), a3, ref(a4), a5));
  else if (count == 7) return (x_msg_receive(a0, a1, ref(a2), a3, ref(a4), a5, a6));
  else return (x_msg_receive(a0, a1, ref(a2), a3, ref(a4), a5, a6, ref(a7)));
}
Variant ei_is_integer(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_integer", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_integer(a0));
}
Variant ei_posix_getuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getuid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getuid());
}
Variant ei_imagecreatefromgif(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgif", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromgif(a0));
}
Variant ei_mb_send_mail(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mb_send_mail", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_mb_send_mail(a0, a1, a2));
  else if (count == 4) return (x_mb_send_mail(a0, a1, a2, a3));
  else return (x_mb_send_mail(a0, a1, a2, a3, a4));
}
Variant ei_hphp_splfileinfo___construct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo___construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo___construct(a0, a1));
}
Variant ei_register_postsend_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_postsend_function", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_register_postsend_function(count, a0), null);
  return (x_register_postsend_function(count, a0,vargs), null);
}
Variant ei_getrusage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("getrusage", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_getrusage());
  else return (x_getrusage(a0));
}
Variant ei_long2ip(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("long2ip", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_long2ip(a0));
}
Variant ei_evhttp_set_cache(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("evhttp_set_cache", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_evhttp_set_cache(a0, a1), null);
  else return (x_evhttp_set_cache(a0, a1, a2), null);
}
Variant ei_magickoilpaintimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickoilpaintimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickoilpaintimage(a0, a1));
}
Variant ei_strripos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strripos", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strripos(a0, a1));
  else return (x_strripos(a0, a1, a2));
}
Variant ei_magicksetimagecolormapcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagecolormapcolor", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagecolormapcolor(a0, a1, a2));
}
Variant ei_magickgetfilename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetfilename", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetfilename(a0));
}
Variant ei_magicksetimagegamma(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagegamma", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagegamma(a0, a1));
}
Variant ei_mysql_pconnect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("mysql_pconnect", 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_pconnect());
  else if (count == 1) return (x_mysql_pconnect(a0));
  else if (count == 2) return (x_mysql_pconnect(a0, a1));
  else if (count == 3) return (x_mysql_pconnect(a0, a1, a2));
  else if (count == 4) return (x_mysql_pconnect(a0, a1, a2, a3));
  else if (count == 5) return (x_mysql_pconnect(a0, a1, a2, a3, a4));
  else return (x_mysql_pconnect(a0, a1, a2, a3, a4, a5));
}
Variant ei_stripos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("stripos", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stripos(a0, a1));
  else return (x_stripos(a0, a1, a2));
}
Variant ei_http_build_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("http_build_query", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_http_build_query(a0));
  else if (count == 2) return (x_http_build_query(a0, a1));
  else return (x_http_build_query(a0, a1, a2));
}
Variant ei_apc_add(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_add", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  INTERCEPT_INJECTION_ALWAYS("apc_add", "apc_add", ArrayUtil::Slice(Array(ArrayInit(4, true).set(0, a0).set(1, a1).set(2, a2).set(3, a3).create()), 0, count, false), r);
  if (count <= 2) return (x_apc_add(a0, a1));
  else if (count == 3) return (x_apc_add(a0, a1, a2));
  else return (x_apc_add(a0, a1, a2, a3));
}
Variant ei_iconv_strlen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("iconv_strlen", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_iconv_strlen(a0));
  else return (x_iconv_strlen(a0, a1));
}
Variant ei_vsprintf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("vsprintf", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_vsprintf(a0, a1));
}
Variant ei_imageistruecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imageistruecolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageistruecolor(a0));
}
Variant ei_mailparse_msg_extract_part_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_part_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mailparse_msg_extract_part_file(a0, a1));
  else return (x_mailparse_msg_extract_part_file(a0, a1, a2));
}
Variant ei_dom_xpath_register_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_xpath_register_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_xpath_register_ns(a0, a1, a2));
}
Variant ei_is_nan(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_nan", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_nan(a0));
}
Variant ei_imagegif(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegif", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagegif(a0));
  else return (x_imagegif(a0, a1));
}
Variant ei_eregi_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("eregi_replace", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_eregi_replace(a0, a1, a2));
}
Variant ei_magickgetimageiterations(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageiterations", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageiterations(a0));
}
Variant ei_register_tick_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_tick_function", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_register_tick_function(count, a0));
  return (x_register_tick_function(count, a0,vargs));
}
Variant ei_pixelsetblackquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblackquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetblackquantum(a0, a1), null);
}
Variant ei_jpeg2wbmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("jpeg2wbmp", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_jpeg2wbmp(a0, a1, a2, a3, a4));
}
Variant ei_mcrypt_get_iv_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_get_iv_size", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_get_iv_size(a0, a1));
}
Variant ei_mysql_fetch_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_fetch_array", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_fetch_array(a0));
  else return (x_mysql_fetch_array(a0, a1));
}
Variant ei_magickpreviousimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickpreviousimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickpreviousimage(a0));
}
Variant ei_magickborderimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickborderimage", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickborderimage(a0, a1, a2, a3));
}
Variant ei_mcrypt_module_is_block_mode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_mode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_is_block_mode(a0));
  else return (x_mcrypt_module_is_block_mode(a0, a1));
}
Variant ei_mb_substr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_substr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_substr(a0, a1));
  else if (count == 3) return (x_mb_substr(a0, a1, a2));
  else return (x_mb_substr(a0, a1, a2, a3));
}
Variant ei_get_defined_constants(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_defined_constants", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_defined_constants());
  else return (x_get_defined_constants(a0));
}
Variant ei_mcrypt_enc_is_block_mode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_mode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_is_block_mode(a0));
}
Variant ei_mailparse_stream_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("mailparse_stream_encode", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_stream_encode(a0, a1, a2));
}
Variant ei_drawsetstrokedashoffset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokedashoffset", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokedashoffset(a0, a1), null);
}
Variant ei_php_ini_scanned_files(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_ini_scanned_files", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_php_ini_scanned_files());
}
Variant ei_disk_free_space(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("disk_free_space", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_disk_free_space(a0));
}
Variant ei_pixelsetyellowquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetyellowquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetyellowquantum(a0, a1), null);
}
Variant ei_dom_document_create_element_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("dom_document_create_element_ns", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_dom_document_create_element_ns(a0, a1, a2));
  else return (x_dom_document_create_element_ns(a0, a1, a2, a3));
}
Variant ei_openssl_public_decrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_public_decrypt", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_public_decrypt(a0, ref(a1), a2));
  else return (x_openssl_public_decrypt(a0, ref(a1), a2, a3));
}
Variant ei_convert_uuencode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("convert_uuencode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_convert_uuencode(a0));
}
Variant ei_magickequalizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickequalizeimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickequalizeimage(a0));
}
Variant ei_mysql_field_len(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_len", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_len(a0));
  else return (x_mysql_field_len(a0, a1));
}
Variant ei_drawsetclipunits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetclipunits", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetclipunits(a0, a1), null);
}
Variant ei_mdecrypt_generic(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mdecrypt_generic", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mdecrypt_generic(a0, a1));
}
Variant ei_getprotobyname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getprotobyname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getprotobyname(a0));
}
Variant ei_xmlwriter_start_pi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_pi", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_pi(a0, a1));
}
Variant ei_mysql_field_type(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_type", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_type(a0));
  else return (x_mysql_field_type(a0, a1));
}
Variant ei_apc_cas(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("apc_cas", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  INTERCEPT_INJECTION_ALWAYS("apc_cas", "apc_cas", ArrayUtil::Slice(Array(ArrayInit(4, true).set(0, a0).set(1, a1).set(2, a2).set(3, a3).create()), 0, count, false), r);
  if (count <= 3) return (x_apc_cas(a0, a1, a2));
  else return (x_apc_cas(a0, a1, a2, a3));
}
Variant ei_getopt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("getopt", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_getopt(a0));
  else return (x_getopt(a0, a1));
}
Variant ei_clearpixelwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearpixelwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clearpixelwand(a0), null);
}
Variant ei_drawsetgravity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetgravity", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetgravity(a0, a1), null);
}
Variant ei_magickgetimagecompressionquality(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompressionquality", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecompressionquality(a0));
}
Variant ei_magickquantizeimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickquantizeimages", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickquantizeimages(a0, a1, a2, a3, a4, a5));
}
Variant ei_mysql_insert_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_insert_id", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_insert_id());
  else return (x_mysql_insert_id(a0));
}
Variant ei_hphp_thread_set_warmup_enabled(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_thread_set_warmup_enabled", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_thread_set_warmup_enabled(), null);
}
Variant ei_stream_context_set_param(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_context_set_param", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_context_set_param(a0, a1));
}
Variant ei_drawpathlinetohorizontalabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetohorizontalabsolute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetohorizontalabsolute(a0, a1), null);
}
Variant ei_openssl_csr_export(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_csr_export", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_csr_export(a0, ref(a1)));
  else return (x_openssl_csr_export(a0, ref(a1), a2));
}
Variant ei_socket_connect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_connect", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_connect(a0, a1));
  else return (x_socket_connect(a0, a1, a2));
}
Variant ei_stripslashes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stripslashes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stripslashes(a0));
}
Variant ei_magickhaspreviousimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickhaspreviousimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickhaspreviousimage(a0));
}
Variant ei_drawgetstrokecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokecolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokecolor(a0));
}
Variant ei_imagecreatefromwbmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromwbmp", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromwbmp(a0));
}
Variant ei_str_repeat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("str_repeat", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_str_repeat(a0, a1));
}
Variant ei_stream_resolve_include_path(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("stream_resolve_include_path", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_resolve_include_path(a0));
  else return (x_stream_resolve_include_path(a0, a1));
}
Variant ei_ldap_read(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_read", count, 3, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_ldap_read(a0, a1, a2));
  else if (count == 4) return (x_ldap_read(a0, a1, a2, a3));
  else if (count == 5) return (x_ldap_read(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_ldap_read(a0, a1, a2, a3, a4, a5));
  else if (count == 7) return (x_ldap_read(a0, a1, a2, a3, a4, a5, a6));
  else return (x_ldap_read(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_apc_dec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_dec", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  INTERCEPT_INJECTION_ALWAYS("apc_dec", "apc_dec", ArrayUtil::Slice(Array(ArrayInit(4, true).set(0, a0).set(1, a1).setRef(2, a2).set(3, a3).create()), 0, count, false), r);
  if (count <= 1) return (x_apc_dec(a0));
  else if (count == 2) return (x_apc_dec(a0, a1));
  else if (count == 3) return (x_apc_dec(a0, a1, ref(a2)));
  else return (x_apc_dec(a0, a1, ref(a2), a3));
}
Variant ei_posix_get_last_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_get_last_error", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_get_last_error());
}
Variant ei_iptcparse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("iptcparse", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_iptcparse(a0));
}
Variant ei_iterator_count(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("iterator_count", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_iterator_count(a0));
}
Variant ei_curl_setopt_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_setopt_array", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_setopt_array(a0, a1));
}
Variant ei_socket_recvfrom(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("socket_recvfrom", count, 5, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a5 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 5) return (x_socket_recvfrom(a0, ref(a1), a2, a3, ref(a4)));
  else return (x_socket_recvfrom(a0, ref(a1), a2, a3, ref(a4), ref(a5)));
}
Variant ei_imagepstext(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  Variant a9;
  Variant a10;
  Variant a11;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 8 || count > 12) return throw_wrong_arguments("imagepstext", count, 8, 12, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a9 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a10 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a11 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 8) return (x_imagepstext(a0, a1, a2, a3, a4, a5, a6, a7));
  else if (count == 9) return (x_imagepstext(a0, a1, a2, a3, a4, a5, a6, a7, a8));
  else if (count == 10) return (x_imagepstext(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
  else if (count == 11) return (x_imagepstext(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));
  else return (x_imagepstext(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));
}
Variant ei_mb_encode_mimeheader(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("mb_encode_mimeheader", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_encode_mimeheader(a0));
  else if (count == 2) return (x_mb_encode_mimeheader(a0, a1));
  else if (count == 3) return (x_mb_encode_mimeheader(a0, a1, a2));
  else if (count == 4) return (x_mb_encode_mimeheader(a0, a1, a2, a3));
  else return (x_mb_encode_mimeheader(a0, a1, a2, a3, a4));
}
Variant ei_socket_getsockname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_getsockname", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_getsockname(a0, ref(a1)));
  else return (x_socket_getsockname(a0, ref(a1), ref(a2)));
}
Variant ei_imagecreatefromstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromstring(a0));
}
Variant ei_vfprintf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("vfprintf", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_vfprintf(a0, a1, a2));
}
Variant ei_magickcompareimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickcompareimages", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickcompareimages(a0, a1, a2));
  else return (x_magickcompareimages(a0, a1, a2, a3));
}
Variant ei_fscanf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fscanf", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 2) return (x_fscanf(count, a0, a1));
  return (x_fscanf(count, a0, a1,vargs));
}
Variant ei_stristr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stristr", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stristr(a0, a1));
}
Variant ei_xml_parser_set_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xml_parser_set_option", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_parser_set_option(a0, a1, a2));
}
Variant ei_dom_document_schema_validate_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_schema_validate_file", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_schema_validate_file(a0, a1));
}
Variant ei_magicksetimageinterlacescheme(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageinterlacescheme", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageinterlacescheme(a0, a1));
}
Variant ei_dom_element_get_attribute_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_attribute_node", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_attribute_node(a0, a1));
}
Variant ei_dom_document_create_cdatasection(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_cdatasection", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_cdatasection(a0, a1));
}
Variant ei_destroypixeliterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixeliterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroypixeliterator(a0), null);
}
Variant ei_magicksetimagetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagetype", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagetype(a0, a1));
}
Variant ei_hphp_recursiveiteratoriterator_getinneriterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_getinneriterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_getinneriterator(a0));
}
Variant ei_date_sunrise(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("date_sunrise", count, 1, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_date_sunrise(a0));
  else if (count == 2) return (x_date_sunrise(a0, a1));
  else if (count == 3) return (x_date_sunrise(a0, a1, a2));
  else if (count == 4) return (x_date_sunrise(a0, a1, a2, a3));
  else if (count == 5) return (x_date_sunrise(a0, a1, a2, a3, a4));
  else return (x_date_sunrise(a0, a1, a2, a3, a4, a5));
}
Variant ei_magickgethomeurl(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgethomeurl", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgethomeurl());
}
Variant ei_mb_detect_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_detect_encoding", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_detect_encoding(a0));
  else if (count == 2) return (x_mb_detect_encoding(a0, a1));
  else return (x_mb_detect_encoding(a0, a1, a2));
}
Variant ei_wandhasexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandhasexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_wandhasexception(a0));
}
Variant ei_error_reporting(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("error_reporting", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_error_reporting());
  else return (x_error_reporting(a0));
}
Variant ei_imagepalettecopy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepalettecopy", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepalettecopy(a0, a1), null);
}
Variant ei_hphp_splfileinfo_isexecutable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isexecutable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_isexecutable(a0));
}
Variant ei_rename_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("rename_function", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rename_function(a0, a1));
}
Variant ei_gzcompress(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzcompress", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzcompress(a0));
  else return (x_gzcompress(a0, a1));
}
Variant ei_gzeof(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzeof", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzeof(a0));
}
Variant ei_bcadd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcadd", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bcadd(a0, a1));
  else return (x_bcadd(a0, a1, a2));
}
Variant ei_curl_setopt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("curl_setopt", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_setopt(a0, a1, a2));
}
Variant ei_imagealphablending(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagealphablending", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagealphablending(a0, a1));
}
Variant ei_pixelgetmagenta(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetmagenta", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetmagenta(a0));
}
Variant ei_drawannotation(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawannotation", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawannotation(a0, a1, a2, a3), null);
}
Variant ei_getmypid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmypid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getmypid());
}
Variant ei_magicksetimagedispose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagedispose", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagedispose(a0, a1));
}
Variant ei_drawsetfontsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontsize", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfontsize(a0, a1), null);
}
Variant ei_gethostbyname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbyname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gethostbyname(a0));
}
Variant ei_stream_wrapper_restore(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_wrapper_restore", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_wrapper_restore(a0));
}
Variant ei_magickgetimagecompression(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompression", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecompression(a0));
}
Variant ei_hphp_invoke_method(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_invoke_method", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_invoke_method(a0, a1, a2, a3));
}
Variant ei_xbox_schedule_thread_reset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_schedule_thread_reset", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_schedule_thread_reset(), null);
}
Variant ei_date_offset_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_offset_get", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_offset_get(a0));
}
Variant ei_pixelgetiteratorexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetiteratorexception(a0));
}
Variant ei_mysql_field_flags(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_flags", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_flags(a0));
  else return (x_mysql_field_flags(a0, a1));
}
Variant ei_linkinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("linkinfo", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_linkinfo(a0));
}
Variant ei_strchr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strchr", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strchr(a0, a1));
}
Variant ei_magickqueryformats(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryformats", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickqueryformats(a0));
}
Variant ei_class_parents(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_parents", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_class_parents(a0));
  else return (x_class_parents(a0, a1));
}
Variant ei_date_time_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("date_time_set", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_date_time_set(a0, a1, a2), null);
  else return (x_date_time_set(a0, a1, a2, a3), null);
}
Variant ei_iconv_strpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("iconv_strpos", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iconv_strpos(a0, a1));
  else if (count == 3) return (x_iconv_strpos(a0, a1, a2));
  else return (x_iconv_strpos(a0, a1, a2, a3));
}
Variant ei_i18n_loc_set_strength(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("i18n_loc_set_strength", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_i18n_loc_set_strength(a0));
}
Variant ei_magickgetimagebordercolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagebordercolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagebordercolor(a0));
}
Variant ei_ob_end_clean(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_end_clean", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_end_clean());
}
Variant ei_dom_document_savexml(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("dom_document_savexml", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dom_document_savexml(a0));
  else if (count == 2) return (x_dom_document_savexml(a0, a1));
  else return (x_dom_document_savexml(a0, a1, a2));
}
Variant ei_trigger_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("trigger_error", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_trigger_error(a0));
  else return (x_trigger_error(a0, a1));
}
Variant ei_pcntl_getpriority(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("pcntl_getpriority", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_pcntl_getpriority());
  else if (count == 1) return (x_pcntl_getpriority(a0));
  else return (x_pcntl_getpriority(a0, a1));
}
Variant ei_date_default_timezone_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("date_default_timezone_get", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_default_timezone_get());
}
Variant ei_strcmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcmp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strcmp(a0, a1));
}
Variant ei_hphp_recursivedirectoryiterator_haschildren(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_haschildren", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_haschildren(a0));
}
Variant ei_hphp_instanceof(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_instanceof", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_instanceof(a0, a1));
}
Variant ei_import_request_variables(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("import_request_variables", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_import_request_variables(a0));
  else return (x_import_request_variables(a0, a1));
}
Variant ei_magickgetpackagename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetpackagename", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetpackagename());
}
Variant ei_destroypixelwandarray(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwandarray", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroypixelwandarray(a0), null);
}
Variant ei_spliti(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("spliti", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_spliti(a0, a1));
  else return (x_spliti(a0, a1, a2));
}
Variant ei_posix_setgid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setgid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_setgid(a0));
}
Variant ei_is_double(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_double", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_double(a0));
}
Variant ei_output_reset_rewrite_vars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("output_reset_rewrite_vars", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_output_reset_rewrite_vars());
}
Variant ei_get_declared_interfaces(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_declared_interfaces", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_declared_interfaces());
}
Variant ei_passthru(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("passthru", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_passthru(a0), null);
  else return (x_passthru(a0, ref(a1)), null);
}
Variant ei_magickmontageimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickmontageimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmontageimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_session_commit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_commit", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_commit(), null);
}
Variant ei_apc_cache_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apc_cache_info", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_apc_cache_info());
  else if (count == 1) return (x_apc_cache_info(a0));
  else return (x_apc_cache_info(a0, a1));
}
Variant ei_convert_cyr_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("convert_cyr_string", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_convert_cyr_string(a0, a1, a2));
}
Variant ei_sys_get_temp_dir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("sys_get_temp_dir", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sys_get_temp_dir());
}
Variant ei_libxml_get_last_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_get_last_error", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_libxml_get_last_error());
}
Variant ei_drawline(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawline", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawline(a0, a1, a2, a3, a4), null);
}
Variant ei_drawsetfillcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillcolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfillcolor(a0, a1), null);
}
Variant ei_gzopen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzopen", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_gzopen(a0, a1));
  else return (x_gzopen(a0, a1, a2));
}
Variant ei_getservbyport(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("getservbyport", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getservbyport(a0, a1));
}
Variant ei_hphp_splfileinfo_getfilename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getfilename", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getfilename(a0));
}
Variant ei_stripcslashes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stripcslashes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stripcslashes(a0));
}
Variant ei_curl_multi_add_handle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_add_handle", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_add_handle(a0, a1));
}
Variant ei_ldap_free_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_free_result", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_free_result(a0));
}
Variant ei_array_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_replace", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_array_replace(count, a0));
  return (x_array_replace(count, a0,vargs));
}
Variant ei_xmlwriter_end_pi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_pi", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_pi(a0));
}
Variant ei_imagewbmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagewbmp", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagewbmp(a0));
  else if (count == 2) return (x_imagewbmp(a0, a1));
  else return (x_imagewbmp(a0, a1, a2));
}
Variant ei_shm_get_var(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("shm_get_var", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shm_get_var(a0, a1));
}
Variant ei_magickgetmimetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetmimetype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetmimetype(a0));
}
Variant ei_mysql_fetch_assoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_assoc", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_fetch_assoc(a0));
}
Variant ei_socket_set_nonblock(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_set_nonblock", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_set_nonblock(a0));
}
Variant ei_array_filter(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_filter", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_array_filter(a0));
  else return (x_array_filter(a0, a1));
}
Variant ei_mysql_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_query", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_query(a0));
  else return (x_mysql_query(a0, a1));
}
Variant ei_crypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("crypt", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_crypt(a0));
  else return (x_crypt(a0, a1));
}
Variant ei_xmlwriter_start_cdata(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_start_cdata", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_cdata(a0));
}
Variant ei_fgetc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fgetc", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fgetc(a0));
}
Variant ei_move_uploaded_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("move_uploaded_file", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_move_uploaded_file(a0, a1));
}
Variant ei_hphp_splfileobject_flock(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_flock", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_flock(a0, ref(a1)));
}
Variant ei_imagecopyresampled(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  Variant a9;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 10) return throw_wrong_arguments("imagecopyresampled", count, 10, 10, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a9 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecopyresampled(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
Variant ei_imagecreatefrompng(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefrompng", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefrompng(a0));
}
Variant ei_magickgetimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimage(a0));
}
Variant ei_imagesettile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesettile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesettile(a0, a1));
}
Variant ei_hphp_recursiveiteratoriterator_valid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_valid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_valid(a0));
}
Variant ei_fgets(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("fgets", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fgets(a0));
  else return (x_fgets(a0, a1));
}
Variant ei_tempnam(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("tempnam", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_tempnam(a0, a1));
}
Variant ei_bcdiv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcdiv", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bcdiv(a0, a1));
  else return (x_bcdiv(a0, a1, a2));
}
Variant ei_hphp_splfileinfo_getbasename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getbasename", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getbasename(a0, a1));
}
Variant ei_rsort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("rsort", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_rsort(ref(a0)));
  else if (count == 2) return (x_rsort(ref(a0), a1));
  else return (x_rsort(ref(a0), a1, a2));
}
Variant ei_drawgettextdecoration(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextdecoration", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgettextdecoration(a0));
}
Variant ei_strtolower(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strtolower", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strtolower(a0));
}
Variant ei_posix_getgrgid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getgrgid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getgrgid(a0));
}
Variant ei_apc_inc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_inc", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  INTERCEPT_INJECTION_ALWAYS("apc_inc", "apc_inc", ArrayUtil::Slice(Array(ArrayInit(4, true).set(0, a0).set(1, a1).setRef(2, a2).set(3, a3).create()), 0, count, false), r);
  if (count <= 1) return (x_apc_inc(a0));
  else if (count == 2) return (x_apc_inc(a0, a1));
  else if (count == 3) return (x_apc_inc(a0, a1, ref(a2)));
  else return (x_apc_inc(a0, a1, ref(a2), a3));
}
Variant ei_hphp_create_object(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_create_object", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_create_object(a0, a1));
}
Variant ei_hexdec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hexdec", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hexdec(a0));
}
Variant ei_imagefttext(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 8 || count > 9) return throw_wrong_arguments("imagefttext", count, 8, 9, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 8) return (x_imagefttext(a0, a1, a2, a3, a4, a5, a6, a7));
  else return (x_imagefttext(a0, a1, a2, a3, a4, a5, a6, a7, a8));
}
Variant ei_xhprof_sample_disable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_sample_disable", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xhprof_sample_disable());
}
Variant ei_ldap_compare(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("ldap_compare", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_compare(a0, a1, a2, a3));
}
Variant ei_dns_get_record(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("dns_get_record", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dns_get_record(a0));
  else if (count == 2) return (x_dns_get_record(a0, a1));
  else if (count == 3) return (x_dns_get_record(a0, a1, ref(a2)));
  else return (x_dns_get_record(a0, a1, ref(a2), ref(a3)));
}
Variant ei_openssl_get_privatekey(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_get_privatekey", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_openssl_get_privatekey(a0));
  else return (x_openssl_get_privatekey(a0, a1));
}
Variant ei_imagepng(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("imagepng", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagepng(a0));
  else if (count == 2) return (x_imagepng(a0, a1));
  else if (count == 3) return (x_imagepng(a0, a1, a2));
  else return (x_imagepng(a0, a1, a2, a3));
}
Variant ei_socket_bind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_bind", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_bind(a0, a1));
  else return (x_socket_bind(a0, a1, a2));
}
Variant ei_getmyuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmyuid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getmyuid());
}
Variant ei_pixelgetopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetopacity", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetopacity(a0));
}
Variant ei_drawsetstrokelinecap(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokelinecap", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokelinecap(a0, a1), null);
}
Variant ei_xmlwriter_write_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("xmlwriter_write_attribute_ns", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_attribute_ns(a0, a1, a2, a3, a4));
}
Variant ei_array_keys(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("array_keys", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_array_keys(a0));
  else if (count == 2) return (x_array_keys(a0, a1));
  else return (x_array_keys(a0, a1, a2));
}
Variant ei_call_user_method_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("call_user_method_array", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_call_user_method_array(a0, ref(a1), a2));
}
Variant ei_magickmagnifyimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickmagnifyimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmagnifyimage(a0));
}
Variant ei_is_bool(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_bool", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_bool(a0));
}
Variant ei_magickgetimagegreenprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagegreenprimary", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagegreenprimary(a0));
}
Variant ei_session_start(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_start", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_start());
}
Variant ei_filegroup(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filegroup", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_filegroup(a0));
}
Variant ei_dom_attr_is_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_attr_is_id", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_attr_is_id(a0));
}
Variant ei_gzread(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzread", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzread(a0));
  else return (x_gzread(a0, a1));
}
Variant ei_drawpathellipticarcrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("drawpathellipticarcrelative", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathellipticarcrelative(a0, a1, a2, a3, a4, a5, a6, a7), null);
}
Variant ei_openssl_csr_export_to_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_csr_export_to_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_csr_export_to_file(a0, a1));
  else return (x_openssl_csr_export_to_file(a0, a1, a2));
}
Variant ei_magicksetimagecolorspace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecolorspace", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagecolorspace(a0, a1));
}
Variant ei_nl_langinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("nl_langinfo", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_nl_langinfo(a0));
}
Variant ei_hphp_get_stats(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_stats", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_stats(a0));
}
Variant ei_strncmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("strncmp", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strncmp(a0, a1, a2));
}
Variant ei_mb_regex_set_options(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_regex_set_options", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_regex_set_options());
  else return (x_mb_regex_set_options(a0));
}
Variant ei_pixelsetmagenta(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetmagenta", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetmagenta(a0, a1), null);
}
Variant ei_dom_element_remove_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_remove_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_remove_attribute(a0, a1));
}
Variant ei_magickdeconstructimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdeconstructimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickdeconstructimages(a0));
}
Variant ei_xbox_task_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_task_status", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_task_status(a0));
}
Variant ei_openssl_open(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("openssl_open", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_open(a0, ref(a1), a2, a3));
}
Variant ei_apc_bin_load(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_bin_load", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_bin_load(a0));
  else if (count == 2) return (x_apc_bin_load(a0, a1));
  else return (x_apc_bin_load(a0, a1, a2));
}
Variant ei_current(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("current", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_current(ref(a0)));
}
Variant ei_stream_register_wrapper(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_register_wrapper", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_register_wrapper(a0, a1));
}
Variant ei_hphp_stats(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_stats", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_stats(a0, a1), null);
}
Variant ei_opendir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("opendir", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_opendir(a0));
  else return (x_opendir(a0, a1));
}
Variant ei_magickgetexceptionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexceptionstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetexceptionstring(a0));
}
Variant ei_mcrypt_module_is_block_algorithm_mode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_algorithm_mode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_is_block_algorithm_mode(a0));
  else return (x_mcrypt_module_is_block_algorithm_mode(a0, a1));
}
Variant ei_posix_setpgid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_setpgid", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_setpgid(a0, a1));
}
Variant ei_dns_get_mx(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dns_get_mx", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dns_get_mx(a0, ref(a1)));
  else return (x_dns_get_mx(a0, ref(a1), ref(a2)));
}
Variant ei_headers_list(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("headers_list", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_headers_list());
}
Variant ei_escapeshellarg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("escapeshellarg", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_escapeshellarg(a0));
}
Variant ei_is_scalar(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_scalar", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_scalar(a0));
}
Variant ei_acos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("acos", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_acos(a0));
}
Variant ei_drawgettextencoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextencoding", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgettextencoding(a0));
}
Variant ei_filetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filetype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_filetype(a0));
}
Variant ei_magicksetresolution(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetresolution", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetresolution(a0, a1, a2));
}
Variant ei_posix_isatty(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_isatty", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_isatty(a0));
}
Variant ei_dom_document_relaxng_validate_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_relaxng_validate_file", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_relaxng_validate_file(a0, a1));
}
Variant ei_escapeshellcmd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("escapeshellcmd", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_escapeshellcmd(a0));
}
Variant ei_apc_store(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_store", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  INTERCEPT_INJECTION_ALWAYS("apc_store", "apc_store", ArrayUtil::Slice(Array(ArrayInit(4, true).set(0, a0).set(1, a1).set(2, a2).set(3, a3).create()), 0, count, false), r);
  if (count <= 2) return (x_apc_store(a0, a1));
  else if (count == 3) return (x_apc_store(a0, a1, a2));
  else return (x_apc_store(a0, a1, a2, a3));
}
Variant ei_magickresetiterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickresetiterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickresetiterator(a0), null);
}
Variant ei_libxml_disable_entity_loader(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("libxml_disable_entity_loader", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_libxml_disable_entity_loader());
  else return (x_libxml_disable_entity_loader(a0));
}
Variant ei_magickmotionblurimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickmotionblurimage", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmotionblurimage(a0, a1, a2, a3));
}
Variant ei_session_cache_expire(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_cache_expire", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_cache_expire());
  else return (x_session_cache_expire(a0));
}
Variant ei_magicksetwandsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetwandsize", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetwandsize(a0, a1, a2));
}
Variant ei_number_format(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("number_format", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_number_format(a0));
  else if (count == 2) return (x_number_format(a0, a1));
  else if (count == 3) return (x_number_format(a0, a1, a2));
  else return (x_number_format(a0, a1, a2, a3));
}
Variant ei_array_reduce(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_reduce", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_reduce(a0, a1));
  else return (x_array_reduce(a0, a1, a2));
}
Variant ei_xmlwriter_start_dtd_attlist(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_dtd_attlist", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_dtd_attlist(a0, a1));
}
Variant ei_constant(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("constant", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_constant(a0));
}
Variant ei_strlen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strlen", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strlen(a0));
}
Variant ei_srand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("srand", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_srand(), null);
  else return (x_srand(a0), null);
}
Variant ei_mysql_fetch_object(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mysql_fetch_object", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_fetch_object(a0));
  else if (count == 2) return (x_mysql_fetch_object(a0, a1));
  else return (x_mysql_fetch_object(a0, a1, a2));
}
Variant ei_drawpathlinetoverticalrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetoverticalrelative", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetoverticalrelative(a0, a1), null);
}
Variant ei_magickminifyimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickminifyimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickminifyimage(a0));
}
Variant ei_date_sunset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("date_sunset", count, 1, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_date_sunset(a0));
  else if (count == 2) return (x_date_sunset(a0, a1));
  else if (count == 3) return (x_date_sunset(a0, a1, a2));
  else if (count == 4) return (x_date_sunset(a0, a1, a2, a3));
  else if (count == 5) return (x_date_sunset(a0, a1, a2, a3, a4));
  else return (x_date_sunset(a0, a1, a2, a3, a4, a5));
}
Variant ei_symlink(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("symlink", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_symlink(a0, a1));
}
Variant ei_imagesetpixel(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagesetpixel", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesetpixel(a0, a1, a2, a3));
}
Variant ei_session_module_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_module_name", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_module_name());
  else return (x_session_module_name(a0));
}
Variant ei_split(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("split", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_split(a0, a1));
  else return (x_split(a0, a1, a2));
}
Variant ei_drawsetfontstyle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontstyle", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfontstyle(a0, a1), null);
}
Variant ei_imagecreatefromxbm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromxbm", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromxbm(a0));
}
Variant ei_mysql_db_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_db_query", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mysql_db_query(a0, a1));
  else return (x_mysql_db_query(a0, a1, a2));
}
Variant ei_imagecolorclosestalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorclosestalpha", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorclosestalpha(a0, a1, a2, a3, a4));
}
Variant ei_gzuncompress(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzuncompress", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzuncompress(a0));
  else return (x_gzuncompress(a0, a1));
}
Variant ei_is_executable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_executable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_executable(a0));
}
Variant ei_socket_create_listen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_create_listen", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_socket_create_listen(a0));
  else return (x_socket_create_listen(a0, a1));
}
Variant ei_pixelgetcolorcount(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcolorcount", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetcolorcount(a0));
}
Variant ei_magickqueryconfigureoptions(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryconfigureoptions", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickqueryconfigureoptions(a0));
}
Variant ei_iptcembed(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iptcembed", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iptcembed(a0, a1));
  else return (x_iptcembed(a0, a1, a2));
}
Variant ei_posix_getgrnam(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getgrnam", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getgrnam(a0));
}
Variant ei_rtrim(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("rtrim", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_rtrim(a0));
  else return (x_rtrim(a0, a1));
}
Variant ei_print_r(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("print_r", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_print_r(a0));
  else return (x_print_r(a0, a1));
}
Variant ei_drawpathcurvetoquadraticbeziersmoothrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathcurvetoquadraticbeziersmoothrelative", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetoquadraticbeziersmoothrelative(a0, a1, a2), null);
}
Variant ei_openssl_pkey_export(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_pkey_export", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_pkey_export(a0, ref(a1)));
  else if (count == 3) return (x_openssl_pkey_export(a0, ref(a1), a2));
  else return (x_openssl_pkey_export(a0, ref(a1), a2, a3));
}
Variant ei_abs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("abs", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_abs(a0));
}
Variant ei_restore_exception_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_exception_handler", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_restore_exception_handler());
}
Variant ei_shell_exec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shell_exec", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shell_exec(a0));
}
Variant ei_curl_multi_exec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_exec", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_exec(a0, ref(a1)));
}
Variant ei_htmlspecialchars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("htmlspecialchars", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_htmlspecialchars(a0));
  else if (count == 2) return (x_htmlspecialchars(a0, a1));
  else if (count == 3) return (x_htmlspecialchars(a0, a1, a2));
  else return (x_htmlspecialchars(a0, a1, a2, a3));
}
Variant ei_imagexbm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagexbm", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagexbm(a0));
  else if (count == 2) return (x_imagexbm(a0, a1));
  else return (x_imagexbm(a0, a1, a2));
}
Variant ei_magickgetreleasedate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetreleasedate", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetreleasedate());
}
Variant ei_xbox_set_thread_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_set_thread_timeout", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_set_thread_timeout(a0), null);
}
Variant ei_sem_remove(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_remove", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sem_remove(a0));
}
Variant ei_imageellipse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imageellipse", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageellipse(a0, a1, a2, a3, a4, a5));
}
Variant ei_getprotobynumber(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getprotobynumber", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getprotobynumber(a0));
}
Variant ei_pixelsetopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetopacity", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetopacity(a0, a1), null);
}
Variant ei_lchgrp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("lchgrp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_lchgrp(a0, a1));
}
Variant ei_simplexml_load_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("simplexml_load_file", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_simplexml_load_file(a0));
  else if (count == 2) return (x_simplexml_load_file(a0, a1));
  else if (count == 3) return (x_simplexml_load_file(a0, a1, a2));
  else if (count == 4) return (x_simplexml_load_file(a0, a1, a2, a3));
  else return (x_simplexml_load_file(a0, a1, a2, a3, a4));
}
Variant ei_openssl_pkey_get_details(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_get_details", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_pkey_get_details(a0));
}
Variant ei_imagetypes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("imagetypes", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagetypes());
}
Variant ei_gzseek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzseek", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_gzseek(a0, a1));
  else return (x_gzseek(a0, a1, a2));
}
Variant ei_magickgetmaxtextadvance(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetmaxtextadvance", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgetmaxtextadvance(a0, a1, a2));
  else return (x_magickgetmaxtextadvance(a0, a1, a2, a3));
}
Variant ei_func_get_arg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("func_get_arg", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_func_get_arg(a0));
}
Variant ei_imagefilledrectangle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagefilledrectangle", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefilledrectangle(a0, a1, a2, a3, a4, a5));
}
Variant ei_drawpushpattern(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("drawpushpattern", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpushpattern(a0, a1, a2, a3, a4, a5), null);
}
Variant ei_xmlwriter_set_indent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_set_indent", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_set_indent(a0, a1));
}
Variant ei_openssl_csr_get_subject(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_csr_get_subject", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_openssl_csr_get_subject(a0));
  else return (x_openssl_csr_get_subject(a0, a1));
}
Variant ei_is_numeric(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_numeric", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_numeric(a0));
}
Variant ei_gzdeflate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzdeflate", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzdeflate(a0));
  else return (x_gzdeflate(a0, a1));
}
Variant ei_dns_check_record(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dns_check_record", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dns_check_record(a0));
  else return (x_dns_check_record(a0, a1));
}
Variant ei_magicknegateimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("magicknegateimage", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magicknegateimage(a0));
  else if (count == 2) return (x_magicknegateimage(a0, a1));
  else return (x_magicknegateimage(a0, a1, a2));
}
Variant ei_socket_last_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("socket_last_error", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_socket_last_error());
  else return (x_socket_last_error(a0));
}
Variant ei_create_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("create_function", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_create_function(a0, a1));
}
Variant ei_str_split(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("str_split", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_str_split(a0));
  else return (x_str_split(a0, a1));
}
Variant ei_date_parse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_parse", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_parse(a0));
}
Variant ei_imagecreatefromxpm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromxpm", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromxpm(a0));
}
Variant ei_mysql_thread_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_thread_id", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_thread_id());
  else return (x_mysql_thread_id(a0));
}
Variant ei_mb_encode_numericentity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_encode_numericentity", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_encode_numericentity(a0, a1));
  else return (x_mb_encode_numericentity(a0, a1, a2));
}
Variant ei_fb_call_user_func_array_safe(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_call_user_func_array_safe", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_call_user_func_array_safe(a0, a1));
}
Variant Eval::invoke_from_eval_builtin(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 4095) {
    case 1:
      HASH_INVOKE_FROM_EVAL(0x4F7230DC25F0E001LL, magicknormalizeimage);
      break;
    case 2:
      HASH_INVOKE_FROM_EVAL(0x76C320EDB9B6E002LL, xmlwriter_flush);
      break;
    case 3:
      HASH_INVOKE_FROM_EVAL(0x7E0EC3E131BCA003LL, token_name);
      break;
    case 5:
      HASH_INVOKE_FROM_EVAL(0x20D579E7E4131005LL, imagecolorclosest);
      HASH_INVOKE_FROM_EVAL(0x18A0F1EE8E249005LL, msg_send);
      break;
    case 10:
      HASH_INVOKE_FROM_EVAL(0x555D7A3FB939300ALL, apache_setenv);
      break;
    case 11:
      HASH_INVOKE_FROM_EVAL(0x4FDCCE1C7754600BLL, ob_iconv_handler);
      break;
    case 13:
      HASH_INVOKE_FROM_EVAL(0x40FA17130FA7100DLL, openssl_seal);
      break;
    case 22:
      HASH_INVOKE_FROM_EVAL(0x5623A698A728F016LL, getlastmod);
      break;
    case 24:
      HASH_INVOKE_FROM_EVAL(0x4C915E3480E94018LL, mb_substr_count);
      break;
    case 26:
      HASH_INVOKE_FROM_EVAL(0x03834225EBBC101ALL, drawsettextundercolor);
      break;
    case 34:
      HASH_INVOKE_FROM_EVAL(0x145D42B2AB55D022LL, drawmatte);
      break;
    case 35:
      HASH_INVOKE_FROM_EVAL(0x35C74650867B7023LL, imagesetpixel);
      break;
    case 40:
      HASH_INVOKE_FROM_EVAL(0x601C5152277AE028LL, readfile);
      break;
    case 44:
      HASH_INVOKE_FROM_EVAL(0x464EB9B1F955202CLL, apc_add);
      break;
    case 45:
      HASH_INVOKE_FROM_EVAL(0x3BE730D90618202DLL, collator_sort_with_sort_keys);
      break;
    case 51:
      HASH_INVOKE_FROM_EVAL(0x48F35DFD653D7033LL, pclose);
      break;
    case 54:
      HASH_INVOKE_FROM_EVAL(0x32F23F206C394036LL, curl_setopt_array);
      break;
    case 55:
      HASH_INVOKE_FROM_EVAL(0x418D937957ECE037LL, tanh);
      break;
    case 59:
      HASH_INVOKE_FROM_EVAL(0x40329F2A6B84D03BLL, dom_node_lookup_prefix);
      break;
    case 62:
      HASH_INVOKE_FROM_EVAL(0x32E6E5D3CCE3703ELL, magickgetimagewidth);
      HASH_INVOKE_FROM_EVAL(0x43461C4D9130103ELL, exit);
      HASH_INVOKE_FROM_EVAL(0x67C1ED9B816E503ELL, md5_file);
      HASH_INVOKE_FROM_EVAL(0x497E31C70409603ELL, timezone_name_from_abbr);
      break;
    case 63:
      HASH_INVOKE_FROM_EVAL(0x24206A195B9C203FLL, ucfirst);
      break;
    case 65:
      HASH_INVOKE_FROM_EVAL(0x65B39B11F5D7C041LL, array_unique);
      break;
    case 67:
      HASH_INVOKE_FROM_EVAL(0x5ACCF9166CD9D043LL, ftruncate);
      break;
    case 68:
      HASH_INVOKE_FROM_EVAL(0x378A73FF98B60044LL, curl_init);
      break;
    case 73:
      HASH_INVOKE_FROM_EVAL(0x047A8BF04DB51049LL, range);
      HASH_INVOKE_FROM_EVAL(0x4282E0231F600049LL, fseek);
      break;
    case 75:
      HASH_INVOKE_FROM_EVAL(0x17CD0E68E778C04BLL, drawsetstrokelinejoin);
      HASH_INVOKE_FROM_EVAL(0x6370CF455EA8604BLL, socket_create);
      break;
    case 76:
      HASH_INVOKE_FROM_EVAL(0x7848970191D5A04CLL, mysql_connect_with_db);
      HASH_INVOKE_FROM_EVAL(0x03047FD5FC67204CLL, exif_read_data);
      break;
    case 83:
      HASH_INVOKE_FROM_EVAL(0x15A9EB33DA6E9053LL, getimagesize);
      HASH_INVOKE_FROM_EVAL(0x07EB5C3A3BEA3053LL, acosh);
      break;
    case 87:
      HASH_INVOKE_FROM_EVAL(0x12B22A2E6B344057LL, ldap_sort);
      break;
    case 90:
      HASH_INVOKE_FROM_EVAL(0x271AB768D202F05ALL, mcrypt_module_is_block_algorithm);
      break;
    case 92:
      HASH_INVOKE_FROM_EVAL(0x2B7532A070BF605CLL, openssl_get_privatekey);
      break;
    case 95:
      HASH_INVOKE_FROM_EVAL(0x4B70746F965E705FLL, preg_last_error);
      break;
    case 98:
      HASH_INVOKE_FROM_EVAL(0x745910AD5C922062LL, magickgetmimetype);
      break;
    case 100:
      HASH_INVOKE_FROM_EVAL(0x5CC8BA5ADFAC0064LL, imagegrabscreen);
      break;
    case 101:
      HASH_INVOKE_FROM_EVAL(0x777FE52584FAE065LL, apc_bin_dump);
      break;
    case 103:
      HASH_INVOKE_FROM_EVAL(0x0CE1918B30DF5067LL, sys_getloadavg);
      HASH_INVOKE_FROM_EVAL(0x4512BD5EA7076067LL, openssl_csr_export_to_file);
      break;
    case 111:
      HASH_INVOKE_FROM_EVAL(0x4C6FD8808A62506FLL, session_set_save_handler);
      break;
    case 112:
      HASH_INVOKE_FROM_EVAL(0x3C466098FF7B5070LL, mb_check_encoding);
      break;
    case 120:
      HASH_INVOKE_FROM_EVAL(0x6B268C26E21C1078LL, arsort);
      HASH_INVOKE_FROM_EVAL(0x01AE1DE8FA116078LL, call_user_func_array_async);
      break;
    case 121:
      HASH_INVOKE_FROM_EVAL(0x08AA4EA901C9B079LL, session_encode);
      break;
    case 122:
      HASH_INVOKE_FROM_EVAL(0x5F9DDC342A83807ALL, date_default_timezone_get);
      break;
    case 131:
      HASH_INVOKE_FROM_EVAL(0x1A90213EE1A56083LL, array_pop);
      break;
    case 132:
      HASH_INVOKE_FROM_EVAL(0x53FD8C9AC3F4D084LL, dangling_server_proxy_new_request);
      break;
    case 135:
      HASH_INVOKE_FROM_EVAL(0x255D919D501C5087LL, dom_characterdata_delete_data);
      break;
    case 137:
      HASH_INVOKE_FROM_EVAL(0x4AD554CBAB9CC089LL, call_user_method_array);
      break;
    case 140:
      HASH_INVOKE_FROM_EVAL(0x4F1D1ED7B087208CLL, exec);
      HASH_INVOKE_FROM_EVAL(0x3A0B58797E8FE08CLL, xml_set_external_entity_ref_handler);
      break;
    case 141:
      HASH_INVOKE_FROM_EVAL(0x200864F8F053C08DLL, magickgetversionstring);
      break;
    case 142:
      HASH_INVOKE_FROM_EVAL(0x3E4AE974AFA9708ELL, pixelsetquantumcolor);
      break;
    case 145:
      HASH_INVOKE_FROM_EVAL(0x3E5CF6378A49C091LL, ldap_get_attributes);
      HASH_INVOKE_FROM_EVAL(0x673B36244DC87091LL, closelog);
      HASH_INVOKE_FROM_EVAL(0x1C32BB63986C8091LL, socket_strerror);
      break;
    case 147:
      HASH_INVOKE_FROM_EVAL(0x3B5E32078E37A093LL, imagedestroy);
      break;
    case 158:
      HASH_INVOKE_FROM_EVAL(0x4AF87BA91163D09ELL, mysql_db_name);
      HASH_INVOKE_FROM_EVAL(0x74F0D6D8F1F2709ELL, drawsetstrokedashoffset);
      break;
    case 159:
      HASH_INVOKE_FROM_EVAL(0x2B130322DEC4B09FLL, pixelgetopacityquantum);
      break;
    case 161:
      HASH_INVOKE_FROM_EVAL(0x0DF945F12533F0A1LL, abs);
      break;
    case 162:
      HASH_INVOKE_FROM_EVAL(0x10DF7941C3F3E0A2LL, socket_bind);
      break;
    case 163:
      HASH_INVOKE_FROM_EVAL(0x54242D2846BC60A3LL, magickunsharpmaskimage);
      break;
    case 167:
      HASH_INVOKE_FROM_EVAL(0x74C787060F7290A7LL, icu_transliterate);
      break;
    case 168:
      HASH_INVOKE_FROM_EVAL(0x6E8C61326DCE40A8LL, var_export);
      break;
    case 171:
      HASH_INVOKE_FROM_EVAL(0x439DF153FC32D0ABLL, printf);
      HASH_INVOKE_FROM_EVAL(0x5B1D9F56698A40ABLL, html_entity_decode);
      break;
    case 172:
      HASH_INVOKE_FROM_EVAL(0x6E27DC1E74C5B0ACLL, drawpathstart);
      break;
    case 173:
      HASH_INVOKE_FROM_EVAL(0x4C9252FB9C3300ADLL, pixelsetalphaquantum);
      break;
    case 174:
      HASH_INVOKE_FROM_EVAL(0x47AB4A08446BD0AELL, bcmod);
      HASH_INVOKE_FROM_EVAL(0x4BBD5D8A6E0110AELL, error_log);
      break;
    case 175:
      HASH_INVOKE_FROM_EVAL(0x3954FFED1E0650AFLL, stream_register_wrapper);
      break;
    case 176:
      HASH_INVOKE_FROM_EVAL(0x5B9F8B3E1D8330B0LL, stream_socket_sendto);
      break;
    case 177:
      HASH_INVOKE_FROM_EVAL(0x191B5F1B190BC0B1LL, dom_xpath_register_ns);
      break;
    case 178:
      HASH_INVOKE_FROM_EVAL(0x48BBFB59FB7F90B2LL, iconv_strlen);
      break;
    case 184:
      HASH_INVOKE_FROM_EVAL(0x05A4C165810A30B8LL, gzread);
      break;
    case 185:
      HASH_INVOKE_FROM_EVAL(0x5C659372B2CD80B9LL, imagecolorstotal);
      break;
    case 187:
      HASH_INVOKE_FROM_EVAL(0x331E7DFBE6E240BBLL, libxml_get_errors);
      break;
    case 188:
      HASH_INVOKE_FROM_EVAL(0x3900350CD9D990BCLL, imagecreatefromjpeg);
      break;
    case 192:
      HASH_INVOKE_FROM_EVAL(0x6EDC1E7A8D5710C0LL, memcache_add_server);
      break;
    case 197:
      HASH_INVOKE_FROM_EVAL(0x7424946F7ED520C5LL, magickgetimagefilename);
      HASH_INVOKE_FROM_EVAL(0x6B477F3B9CDB10C5LL, base64_decode);
      break;
    case 199:
      HASH_INVOKE_FROM_EVAL(0x677F33E78342A0C7LL, function_exists);
      break;
    case 200:
      HASH_INVOKE_FROM_EVAL(0x30AB38D851C440C8LL, magickgetimagebackgroundcolor);
      break;
    case 202:
      HASH_INVOKE_FROM_EVAL(0x2EE0967F6EB5A0CALL, date_format);
      HASH_INVOKE_FROM_EVAL(0x4C67DEE74080E0CALL, magicksetimagecompose);
      break;
    case 206:
      HASH_INVOKE_FROM_EVAL(0x64E390E5F2FDC0CELL, ismagickwand);
      break;
    case 210:
      HASH_INVOKE_FROM_EVAL(0x7D1FAF3322A360D2LL, hphp_splfileobject___construct);
      HASH_INVOKE_FROM_EVAL(0x5365BD7509BE60D2LL, ldap_dn2ufn);
      HASH_INVOKE_FROM_EVAL(0x3E4DAD592CD0A0D2LL, magickdescribeimage);
      break;
    case 213:
      HASH_INVOKE_FROM_EVAL(0x3BF44C6DECD790D5LL, xmlwriter_start_dtd_entity);
      break;
    case 216:
      HASH_INVOKE_FROM_EVAL(0x79F2E516A3B070D8LL, libxml_disable_entity_loader);
      break;
    case 217:
      HASH_INVOKE_FROM_EVAL(0x08F6B727D60670D9LL, magicksetimagedepth);
      break;
    case 218:
      HASH_INVOKE_FROM_EVAL(0x6F242340B2E930DALL, hphp_splfileinfo_setfileclass);
      break;
    case 219:
      HASH_INVOKE_FROM_EVAL(0x3801923AD84670DBLL, apc_inc);
      break;
    case 224:
      HASH_INVOKE_FROM_EVAL(0x2E4612DF112010E0LL, imagecopyresized);
      break;
    case 228:
      HASH_INVOKE_FROM_EVAL(0x2B9425038D4230E4LL, imagecreatefromxpm);
      break;
    case 231:
      HASH_INVOKE_FROM_EVAL(0x79E6FD78989B10E7LL, tmpfile);
      HASH_INVOKE_FROM_EVAL(0x59DE3A26AFF570E7LL, magickshaveimage);
      break;
    case 232:
      HASH_INVOKE_FROM_EVAL(0x476F4B6CC987E0E8LL, magickframeimage);
      HASH_INVOKE_FROM_EVAL(0x17CB328F55FDF0E8LL, drawsetstrokeantialias);
      break;
    case 234:
      HASH_INVOKE_FROM_EVAL(0x53BA3992F8C240EALL, imagegrabwindow);
      break;
    case 243:
      HASH_INVOKE_FROM_EVAL(0x315CCBC8C5C7D0F3LL, xmlwriter_write_raw);
      break;
    case 249:
      HASH_INVOKE_FROM_EVAL(0x480797DB7165A0F9LL, xmlwriter_set_indent);
      break;
    case 259:
      HASH_INVOKE_FROM_EVAL(0x1FFCBCF1927D7103LL, posix_setpgid);
      break;
    case 261:
      HASH_INVOKE_FROM_EVAL(0x71E3372AA1AD0105LL, is_infinite);
      HASH_INVOKE_FROM_EVAL(0x509B763CDAD9D105LL, gethostbyaddr);
      break;
    case 264:
      HASH_INVOKE_FROM_EVAL(0x60B8B61133F59108LL, quoted_printable_decode);
      break;
    case 267:
      HASH_INVOKE_FROM_EVAL(0x7DE1BEE0C35D010BLL, pcntl_signal);
      break;
    case 272:
      HASH_INVOKE_FROM_EVAL(0x16B481D0DEA32110LL, call_user_func_async);
      break;
    case 273:
      HASH_INVOKE_FROM_EVAL(0x3A9A5D4FEE79A111LL, getmxrr);
      break;
    case 274:
      HASH_INVOKE_FROM_EVAL(0x0B1BA48B0CFB1112LL, strval);
      HASH_INVOKE_FROM_EVAL(0x28C44527BD59D112LL, is_link);
      break;
    case 276:
      HASH_INVOKE_FROM_EVAL(0x02A4724E6A881114LL, mb_decode_numericentity);
      break;
    case 281:
      HASH_INVOKE_FROM_EVAL(0x3AB82455A70F5119LL, imagecolortransparent);
      HASH_INVOKE_FROM_EVAL(0x2B31A877824A1119LL, stristr);
      break;
    case 284:
      HASH_INVOKE_FROM_EVAL(0x070A63F6A0B8711CLL, array_walk_recursive);
      break;
    case 285:
      HASH_INVOKE_FROM_EVAL(0x291088666B8BF11DLL, drawsetfontfamily);
      break;
    case 286:
      HASH_INVOKE_FROM_EVAL(0x658444BB4E29E11ELL, openssl_free_key);
      break;
    case 287:
      HASH_INVOKE_FROM_EVAL(0x4C70C24C84F5511FLL, magicksetimagegamma);
      break;
    case 291:
      HASH_INVOKE_FROM_EVAL(0x3669138315204123LL, mcrypt_module_get_algo_key_size);
      break;
    case 292:
      HASH_INVOKE_FROM_EVAL(0x7D4D28D561392124LL, drawsettextalignment);
      break;
    case 293:
      HASH_INVOKE_FROM_EVAL(0x7A8B3EC0235EF125LL, magickprofileimage);
      break;
    case 301:
      HASH_INVOKE_FROM_EVAL(0x7579DBE83CE5812DLL, imagerectangle);
      break;
    case 307:
      HASH_INVOKE_FROM_EVAL(0x6A7E0B15FF689133LL, mb_ereg_search_init);
      break;
    case 311:
      HASH_INVOKE_FROM_EVAL(0x5666016FA3C0F137LL, socket_clear_error);
      break;
    case 312:
      HASH_INVOKE_FROM_EVAL(0x2676902697E37138LL, xmlwriter_start_comment);
      break;
    case 314:
      HASH_INVOKE_FROM_EVAL(0x2A57E5D29D73D13ALL, register_tick_function);
      break;
    case 315:
      HASH_INVOKE_FROM_EVAL(0x1F61AFCDC510413BLL, imagefilter);
      break;
    case 319:
      HASH_INVOKE_FROM_EVAL(0x5BFDE63106CE713FLL, dom_element_get_attribute);
      break;
    case 323:
      HASH_INVOKE_FROM_EVAL(0x296C739F28D6C143LL, drawsetfontsize);
      break;
    case 335:
      HASH_INVOKE_FROM_EVAL(0x61A61E91C477514FLL, chop);
      HASH_INVOKE_FROM_EVAL(0x7863294A8F33D14FLL, file);
      break;
    case 337:
      HASH_INVOKE_FROM_EVAL(0x3044E9F91628E151LL, mb_strlen);
      break;
    case 338:
      HASH_INVOKE_FROM_EVAL(0x5D170BCBBBA02152LL, system);
      HASH_INVOKE_FROM_EVAL(0x26DD46D8C1F47152LL, ldap_bind);
      break;
    case 341:
      HASH_INVOKE_FROM_EVAL(0x2623917110168155LL, fclose);
      HASH_INVOKE_FROM_EVAL(0x4F43FE32079C0155LL, magickgetimagesblob);
      break;
    case 347:
      HASH_INVOKE_FROM_EVAL(0x3711AF36391EA15BLL, mysql_list_tables);
      break;
    case 348:
      HASH_INVOKE_FROM_EVAL(0x6CD7466174B9A15CLL, pixelsetredquantum);
      break;
    case 349:
      HASH_INVOKE_FROM_EVAL(0x517941D034E3015DLL, iterator_to_array);
      break;
    case 353:
      HASH_INVOKE_FROM_EVAL(0x309E780586D6C161LL, socket_set_nonblock);
      break;
    case 355:
      HASH_INVOKE_FROM_EVAL(0x36D6B73D289DD163LL, date_sunset);
      break;
    case 360:
      HASH_INVOKE_FROM_EVAL(0x14E46EA3CBCFB168LL, magickgetsamplingfactors);
      break;
    case 361:
      HASH_INVOKE_FROM_EVAL(0x4983571BFEAE6169LL, magickaffinetransformimage);
      HASH_INVOKE_FROM_EVAL(0x1612E331D1726169LL, drawsetstrokecolor);
      break;
    case 366:
      HASH_INVOKE_FROM_EVAL(0x15B61E061268B16ELL, magickenhanceimage);
      HASH_INVOKE_FROM_EVAL(0x0125F8B9428E416ELL, hphp_create_object);
      break;
    case 370:
      HASH_INVOKE_FROM_EVAL(0x59FE6A862E1CB172LL, get_browser);
      break;
    case 372:
      HASH_INVOKE_FROM_EVAL(0x345E070844E3F174LL, create_function);
      break;
    case 375:
      HASH_INVOKE_FROM_EVAL(0x174DB93CAF0D1177LL, hphp_splfileinfo___tostring);
      break;
    case 377:
      HASH_INVOKE_FROM_EVAL(0x6884FAF0D1EF3179LL, posix_mknod);
      break;
    case 379:
      HASH_INVOKE_FROM_EVAL(0x59594143EFC7617BLL, mcrypt_module_open);
      break;
    case 380:
      HASH_INVOKE_FROM_EVAL(0x3E1343B4A3AD717CLL, magickgettextascent);
      break;
    case 383:
      HASH_INVOKE_FROM_EVAL(0x4EF9496D16F9D17FLL, xmlwriter_start_element_ns);
      break;
    case 385:
      HASH_INVOKE_FROM_EVAL(0x2227E30BAB23B181LL, dom_xpath_query);
      HASH_INVOKE_FROM_EVAL(0x1CBD3B58296C8181LL, xmlwriter_write_dtd);
      break;
    case 386:
      HASH_INVOKE_FROM_EVAL(0x7BB7C27B2C118182LL, get_magic_quotes_gpc);
      HASH_INVOKE_FROM_EVAL(0x130B62A8C77F3182LL, mb_ereg_search_getregs);
      break;
    case 389:
      HASH_INVOKE_FROM_EVAL(0x13E90F8874839185LL, ob_get_status);
      HASH_INVOKE_FROM_EVAL(0x54DB5DC6A069A185LL, hphp_get_class_info);
      break;
    case 390:
      HASH_INVOKE_FROM_EVAL(0x5DB5E45860801186LL, openssl_csr_export);
      break;
    case 391:
      HASH_INVOKE_FROM_EVAL(0x1BC448670BA4E187LL, iconv_strpos);
      break;
    case 393:
      HASH_INVOKE_FROM_EVAL(0x0CC53B2F0D38D189LL, timezone_offset_get);
      break;
    case 402:
      HASH_INVOKE_FROM_EVAL(0x07B5BF934F6EA192LL, imagesettile);
      break;
    case 407:
      HASH_INVOKE_FROM_EVAL(0x15AD9CE061C75197LL, timezone_transitions_get);
      break;
    case 409:
      HASH_INVOKE_FROM_EVAL(0x0CE71BC3B75D8199LL, mb_strimwidth);
      break;
    case 411:
      HASH_INVOKE_FROM_EVAL(0x7FF6C2A693CE119BLL, magickcyclecolormapimage);
      HASH_INVOKE_FROM_EVAL(0x74F20C284227219BLL, similar_text);
      break;
    case 416:
      HASH_INVOKE_FROM_EVAL(0x6FB5104FC97A31A0LL, drawpathcurvetorelative);
      break;
    case 418:
      HASH_INVOKE_FROM_EVAL(0x6DFC0765EBAB81A2LL, mcrypt_decrypt);
      HASH_INVOKE_FROM_EVAL(0x2A9015499A2EB1A2LL, fnmatch);
      HASH_INVOKE_FROM_EVAL(0x615723D21421A1A2LL, sem_remove);
      break;
    case 419:
      HASH_INVOKE_FROM_EVAL(0x735B81C45C2971A3LL, drawgetfillopacity);
      break;
    case 422:
      HASH_INVOKE_FROM_EVAL(0x37B4612178EF91A6LL, memcache_get_version);
      break;
    case 425:
      HASH_INVOKE_FROM_EVAL(0x740DC7FFAD8BB1A9LL, imagecolorat);
      HASH_INVOKE_FROM_EVAL(0x0DDFE3B1F6EEE1A9LL, array_reduce);
      break;
    case 426:
      HASH_INVOKE_FROM_EVAL(0x11A5C66A3D0711AALL, apc_sma_info);
      break;
    case 429:
      HASH_INVOKE_FROM_EVAL(0x5A6EFF8C71A431ADLL, socket_get_status);
      HASH_INVOKE_FROM_EVAL(0x50538F37398AF1ADLL, ldap_get_option);
      break;
    case 431:
      HASH_INVOKE_FROM_EVAL(0x5B1F9C2E9FE111AFLL, fb_utf8ize);
      break;
    case 434:
      HASH_INVOKE_FROM_EVAL(0x4B96F870584541B2LL, hphp_splfileobject_setflags);
      break;
    case 438:
      HASH_INVOKE_FROM_EVAL(0x33BD672B4AC301B6LL, mt_rand);
      break;
    case 445:
      HASH_INVOKE_FROM_EVAL(0x589F7316EDC581BDLL, fb_serialize);
      HASH_INVOKE_FROM_EVAL(0x4B3F35310DEA31BDLL, socket_create_pair);
      break;
    case 447:
      HASH_INVOKE_FROM_EVAL(0x0E88ACEB15A581BFLL, magickgetimageextrema);
      HASH_INVOKE_FROM_EVAL(0x681CD0E7D9DB71BFLL, pow);
      break;
    case 450:
      HASH_INVOKE_FROM_EVAL(0x02103322F88C71C2LL, pixelgetcolorcount);
      break;
    case 452:
      HASH_INVOKE_FROM_EVAL(0x3617DAE43A23D1C4LL, xml_parser_set_option);
      break;
    case 454:
      HASH_INVOKE_FROM_EVAL(0x188D37410B6051C6LL, session_unregister);
      break;
    case 455:
      HASH_INVOKE_FROM_EVAL(0x5AE12CB1FFDC21C7LL, drawellipse);
      break;
    case 456:
      HASH_INVOKE_FROM_EVAL(0x11C0B5DA066891C8LL, preg_match_all);
      break;
    case 458:
      HASH_INVOKE_FROM_EVAL(0x75CA86838D24A1CALL, hash_algos);
      break;
    case 460:
      HASH_INVOKE_FROM_EVAL(0x3DF488365DAAF1CCLL, drawgettextencoding);
      break;
    case 461:
      HASH_INVOKE_FROM_EVAL(0x37340B707E7CD1CDLL, magickgetimagebordercolor);
      break;
    case 462:
      HASH_INVOKE_FROM_EVAL(0x2E7741B5440FB1CELL, magicksetlastiterator);
      break;
    case 464:
      HASH_INVOKE_FROM_EVAL(0x03012F3DDD7AB1D0LL, getservbyport);
      break;
    case 468:
      HASH_INVOKE_FROM_EVAL(0x219F3257BA3371D4LL, decbin);
      break;
    case 470:
      HASH_INVOKE_FROM_EVAL(0x78831282736801D6LL, stream_context_get_default);
      break;
    case 472:
      HASH_INVOKE_FROM_EVAL(0x60E9E392663921D8LL, readlink);
      break;
    case 473:
      HASH_INVOKE_FROM_EVAL(0x7A69D0078F4F31D9LL, ldap_start_tls);
      break;
    case 474:
      HASH_INVOKE_FROM_EVAL(0x0482E069503A91DALL, posix_setgid);
      break;
    case 475:
      HASH_INVOKE_FROM_EVAL(0x3FEBBC0DA79F31DBLL, fb_call_user_func_safe);
      break;
    case 476:
      HASH_INVOKE_FROM_EVAL(0x14FB46333D6D11DCLL, xml_set_default_handler);
      HASH_INVOKE_FROM_EVAL(0x5B3A4A72846B21DCLL, current);
      break;
    case 477:
      HASH_INVOKE_FROM_EVAL(0x04666D6F67C7A1DDLL, mysql_list_processes);
      HASH_INVOKE_FROM_EVAL(0x03A183D73942B1DDLL, apc_filehits);
      break;
    case 478:
      HASH_INVOKE_FROM_EVAL(0x44563CC8FA9B11DELL, memcache_set_server_params);
      break;
    case 479:
      HASH_INVOKE_FROM_EVAL(0x7403251412E931DFLL, syslog);
      break;
    case 480:
      HASH_INVOKE_FROM_EVAL(0x5932D2750A8A91E0LL, magickgetpackagename);
      break;
    case 481:
      HASH_INVOKE_FROM_EVAL(0x2771C632A60371E1LL, ftok);
      HASH_INVOKE_FROM_EVAL(0x0ED729A444C611E1LL, openssl_x509_read);
      break;
    case 482:
      HASH_INVOKE_FROM_EVAL(0x67D4BA8513BF41E2LL, newpixelwand);
      break;
    case 483:
      HASH_INVOKE_FROM_EVAL(0x131D11F79A8801E3LL, mb_http_output);
      HASH_INVOKE_FROM_EVAL(0x406BDC51A3FD81E3LL, pcntl_waitpid);
      break;
    case 484:
      HASH_INVOKE_FROM_EVAL(0x08F7A6C37FC7B1E4LL, shm_get_var);
      break;
    case 488:
      HASH_INVOKE_FROM_EVAL(0x7F843353646391E8LL, rad2deg);
      break;
    case 493:
      HASH_INVOKE_FROM_EVAL(0x1B09A9A533FFA1EDLL, drawgetexceptiontype);
      HASH_INVOKE_FROM_EVAL(0x19932EEC5CAE01EDLL, hphp_splfileinfo_getfileinfo);
      break;
    case 497:
      HASH_INVOKE_FROM_EVAL(0x02BCE5B0FBED61F1LL, strlen);
      break;
    case 498:
      HASH_INVOKE_FROM_EVAL(0x46AFE55982B371F2LL, posix_geteuid);
      break;
    case 499:
      HASH_INVOKE_FROM_EVAL(0x582D10141D5601F3LL, stream_context_set_option);
      HASH_INVOKE_FROM_EVAL(0x11BB3CDC5E4971F3LL, xmlwriter_end_pi);
      break;
    case 501:
      HASH_INVOKE_FROM_EVAL(0x542FBDCF960031F5LL, fprintf);
      HASH_INVOKE_FROM_EVAL(0x02ABC00C046291F5LL, imageellipse);
      break;
    case 502:
      HASH_INVOKE_FROM_EVAL(0x06DAF95935D221F6LL, dom_namednodemap_item);
      break;
    case 506:
      HASH_INVOKE_FROM_EVAL(0x135D5CBF936B11FALL, msg_receive);
      break;
    case 509:
      HASH_INVOKE_FROM_EVAL(0x5304E6B47ED0B1FDLL, srand);
      break;
    case 514:
      HASH_INVOKE_FROM_EVAL(0x16699E33370A8202LL, idn_to_unicode);
      break;
    case 515:
      HASH_INVOKE_FROM_EVAL(0x5B3C354575BB8203LL, mysql_free_result);
      break;
    case 520:
      HASH_INVOKE_FROM_EVAL(0x7B525920E026C208LL, gztell);
      break;
    case 523:
      HASH_INVOKE_FROM_EVAL(0x2F5144AB3647C20BLL, dom_text_is_whitespace_in_element_content);
      break;
    case 524:
      HASH_INVOKE_FROM_EVAL(0x41B15671649A320CLL, curl_multi_getcontent);
      HASH_INVOKE_FROM_EVAL(0x257BEA4D6DC9920CLL, ctype_alnum);
      break;
    case 525:
      HASH_INVOKE_FROM_EVAL(0x5C0DECC8CC67E20DLL, magickwriteimagesfile);
      break;
    case 526:
      HASH_INVOKE_FROM_EVAL(0x533642044A00520ELL, pixelgetmagentaquantum);
      break;
    case 527:
      HASH_INVOKE_FROM_EVAL(0x08DC8BF3ADAE520FLL, getallheaders);
      HASH_INVOKE_FROM_EVAL(0x53631CF3A937320FLL, get_class_methods);
      break;
    case 528:
      HASH_INVOKE_FROM_EVAL(0x15EF510022CAF210LL, xml_parser_create_ns);
      HASH_INVOKE_FROM_EVAL(0x2D41D7F8F4113210LL, sinh);
      break;
    case 529:
      HASH_INVOKE_FROM_EVAL(0x438CD1A0327A8211LL, apc_define_constants);
      break;
    case 532:
      HASH_INVOKE_FROM_EVAL(0x7D85E9FACB92D214LL, magickgetimageblob);
      break;
    case 535:
      HASH_INVOKE_FROM_EVAL(0x4BC4B81CC5F32217LL, dom_node_append_child);
      break;
    case 536:
      HASH_INVOKE_FROM_EVAL(0x56C95225813A5218LL, memory_get_usage);
      HASH_INVOKE_FROM_EVAL(0x4D63F2C9AAB79218LL, fb_renamed_functions);
      break;
    case 538:
      HASH_INVOKE_FROM_EVAL(0x72C0C89D897E721ALL, magicksetimagetype);
      break;
    case 539:
      HASH_INVOKE_FROM_EVAL(0x3A90CC67D58A021BLL, hash_hmac_file);
      break;
    case 545:
      HASH_INVOKE_FROM_EVAL(0x345E2BAE171FA221LL, date_sunrise);
      break;
    case 546:
      HASH_INVOKE_FROM_EVAL(0x39E4E0175FADC222LL, drawskewx);
      break;
    case 547:
      HASH_INVOKE_FROM_EVAL(0x5208E8B08455E223LL, dom_node_has_child_nodes);
      break;
    case 550:
      HASH_INVOKE_FROM_EVAL(0x007B6BD94D767226LL, hphp_splfileobject_fpassthru);
      break;
    case 551:
      HASH_INVOKE_FROM_EVAL(0x5A26F00A81BA5227LL, xmlwriter_start_attribute_ns);
      break;
    case 552:
      HASH_INVOKE_FROM_EVAL(0x44911AEE34D63228LL, time_sleep_until);
      HASH_INVOKE_FROM_EVAL(0x7CD3C6F6495D3228LL, memcache_get_stats);
      break;
    case 556:
      HASH_INVOKE_FROM_EVAL(0x4129FFBF3548E22CLL, mb_strpos);
      break;
    case 558:
      HASH_INVOKE_FROM_EVAL(0x0B7559F53F31D22ELL, fb_stubout_intercept_handler);
      break;
    case 560:
      HASH_INVOKE_FROM_EVAL(0x036A5935D9936230LL, hphp_splfileinfo_openfile);
      break;
    case 561:
      HASH_INVOKE_FROM_EVAL(0x61A192D10C004231LL, magickconvolveimage);
      HASH_INVOKE_FROM_EVAL(0x7C07D66F70E43231LL, mailparse_determine_best_xfer_encoding);
      break;
    case 564:
      HASH_INVOKE_FROM_EVAL(0x23C478B2D95F3234LL, dom_element_has_attribute_ns);
      HASH_INVOKE_FROM_EVAL(0x422C51C95928A234LL, str_replace);
      break;
    case 566:
      HASH_INVOKE_FROM_EVAL(0x5542AABF33A2F236LL, stream_filter_remove);
      break;
    case 568:
      HASH_INVOKE_FROM_EVAL(0x695AC59F79E2A238LL, mb_encode_mimeheader);
      break;
    case 570:
      HASH_INVOKE_FROM_EVAL(0x679ABBE5A08C523ALL, xml_parse_into_struct);
      break;
    case 574:
      HASH_INVOKE_FROM_EVAL(0x5E54CE856B78223ELL, array_flip);
      break;
    case 576:
      HASH_INVOKE_FROM_EVAL(0x0DB9DD4AE24B0240LL, base64_encode);
      break;
    case 579:
      HASH_INVOKE_FROM_EVAL(0x78183A24F2ACB243LL, strtotime);
      break;
    case 584:
      HASH_INVOKE_FROM_EVAL(0x7071BB6F0591E248LL, serialize);
      break;
    case 589:
      HASH_INVOKE_FROM_EVAL(0x5E73B9F3B7C8224DLL, parse_hdf_string);
      break;
    case 591:
      HASH_INVOKE_FROM_EVAL(0x1D8FE8E68F7EA24FLL, pixelsetiteratorrow);
      break;
    case 592:
      HASH_INVOKE_FROM_EVAL(0x30747B708DA1D250LL, pushdrawingwand);
      break;
    case 598:
      HASH_INVOKE_FROM_EVAL(0x0384346A8857D256LL, clonemagickwand);
      break;
    case 600:
      HASH_INVOKE_FROM_EVAL(0x32C51FFF185F4258LL, memcache_set);
      break;
    case 603:
      HASH_INVOKE_FROM_EVAL(0x2F8F40E95EDF925BLL, sizeof);
      break;
    case 605:
      HASH_INVOKE_FROM_EVAL(0x7E6024E53AEEE25DLL, apc_delete);
      break;
    case 608:
      HASH_INVOKE_FROM_EVAL(0x71D2D4757B7E4260LL, apache_request_headers);
      break;
    case 609:
      HASH_INVOKE_FROM_EVAL(0x48305E8ABB8BC261LL, hphp_instanceof);
      break;
    case 610:
      HASH_INVOKE_FROM_EVAL(0x63AC0EED6D946262LL, pcntl_fork);
      break;
    case 612:
      HASH_INVOKE_FROM_EVAL(0x261F403C4174D264LL, posix_getsid);
      break;
    case 613:
      HASH_INVOKE_FROM_EVAL(0x561DB8F1DC0BC265LL, magickseparateimagechannel);
      break;
    case 615:
      HASH_INVOKE_FROM_EVAL(0x50C5488E19492267LL, mb_list_encodings_alias_names);
      HASH_INVOKE_FROM_EVAL(0x38B376B9D9091267LL, xmlwriter_write_attribute);
      break;
    case 620:
      HASH_INVOKE_FROM_EVAL(0x188DF1EB5FD1B26CLL, mailparse_msg_parse_file);
      break;
    case 622:
      HASH_INVOKE_FROM_EVAL(0x5672949384A4F26ELL, stream_filter_register);
      break;
    case 626:
      HASH_INVOKE_FROM_EVAL(0x1C65F32FF28BC272LL, pathinfo);
      break;
    case 627:
      HASH_INVOKE_FROM_EVAL(0x61C991F216E85273LL, inet_ntop);
      HASH_INVOKE_FROM_EVAL(0x08CC1E49661DB273LL, dom_element_get_attribute_ns);
      break;
    case 634:
      HASH_INVOKE_FROM_EVAL(0x39E05F957C7DD27ALL, magickgetimagedepth);
      break;
    case 636:
      HASH_INVOKE_FROM_EVAL(0x0F7E33D551E0727CLL, posix_getpid);
      break;
    case 637:
      HASH_INVOKE_FROM_EVAL(0x7DB57C59E607627DLL, mcrypt_generic_deinit);
      break;
    case 638:
      HASH_INVOKE_FROM_EVAL(0x4111669F4862E27ELL, drawpathlinetoverticalrelative);
      break;
    case 639:
      HASH_INVOKE_FROM_EVAL(0x5B94A6962F1EC27FLL, magickechoimagesblob);
      HASH_INVOKE_FROM_EVAL(0x57E8781CF111727FLL, fileowner);
      break;
    case 640:
      HASH_INVOKE_FROM_EVAL(0x2E54EF1891172280LL, hphp_splfileinfo_isexecutable);
      break;
    case 641:
      HASH_INVOKE_FROM_EVAL(0x1765A2E5186DE281LL, socket_write);
      HASH_INVOKE_FROM_EVAL(0x0881440DCF5D3281LL, magickflattenimages);
      break;
    case 643:
      HASH_INVOKE_FROM_EVAL(0x4C83B098C8BDA283LL, posix_setsid);
      break;
    case 645:
      HASH_INVOKE_FROM_EVAL(0x5F7DC3612050A285LL, drawsetfontweight);
      HASH_INVOKE_FROM_EVAL(0x1A895A2307126285LL, openssl_pkcs7_decrypt);
      break;
    case 646:
      HASH_INVOKE_FROM_EVAL(0x3A2E2C40B019E286LL, is_a);
      HASH_INVOKE_FROM_EVAL(0x4F028FA6AAEEC286LL, call_user_method);
      break;
    case 647:
      HASH_INVOKE_FROM_EVAL(0x27698DDEDAD6E287LL, openssl_pkey_new);
      HASH_INVOKE_FROM_EVAL(0x23A1E13930E44287LL, xbox_schedule_thread_reset);
      break;
    case 656:
      HASH_INVOKE_FROM_EVAL(0x04C11602C720A290LL, convert_cyr_string);
      break;
    case 660:
      HASH_INVOKE_FROM_EVAL(0x4D05DD57E4052294LL, xmlwriter_output_memory);
      break;
    case 661:
      HASH_INVOKE_FROM_EVAL(0x69868C648BC12295LL, apc_store);
      break;
    case 665:
      HASH_INVOKE_FROM_EVAL(0x22D380E06E67E299LL, stream_encoding);
      HASH_INVOKE_FROM_EVAL(0x5665CB664C38A299LL, parse_ini_string);
      break;
    case 666:
      HASH_INVOKE_FROM_EVAL(0x68272A37CC9E729ALL, mb_strtolower);
      HASH_INVOKE_FROM_EVAL(0x24BD9EBDC721E29ALL, hphp_debug_caller_info);
      break;
    case 667:
      HASH_INVOKE_FROM_EVAL(0x4A09634AE6DFF29BLL, fileperms);
      break;
    case 668:
      HASH_INVOKE_FROM_EVAL(0x0F71D3E47044E29CLL, drawpathcurvetosmoothrelative);
      break;
    case 674:
      HASH_INVOKE_FROM_EVAL(0x1FBF8A270331C2A2LL, write_hdf_file);
      break;
    case 675:
      HASH_INVOKE_FROM_EVAL(0x10E7B5A0E29CF2A3LL, bcscale);
      HASH_INVOKE_FROM_EVAL(0x743EA4BF2CC8F2A3LL, mysql_field_type);
      break;
    case 678:
      HASH_INVOKE_FROM_EVAL(0x73EF3A19F76872A6LL, iconv_strrpos);
      break;
    case 680:
      HASH_INVOKE_FROM_EVAL(0x5409127FEDE332A8LL, exif_imagetype);
      break;
    case 685:
      HASH_INVOKE_FROM_EVAL(0x35D259398CDDA2ADLL, pixelgetredquantum);
      HASH_INVOKE_FROM_EVAL(0x00AB6FC4E9EE62ADLL, imagefilledrectangle);
      break;
    case 686:
      HASH_INVOKE_FROM_EVAL(0x36AB9E6AA687F2AELL, xmlwriter_start_dtd_element);
      break;
    case 691:
      HASH_INVOKE_FROM_EVAL(0x44530C37F2B522B3LL, drawgetstrokedasharray);
      HASH_INVOKE_FROM_EVAL(0x59BB7B8078AC22B3LL, tempnam);
      break;
    case 694:
      HASH_INVOKE_FROM_EVAL(0x0C4B98B47B0862B6LL, apd_echo);
      HASH_INVOKE_FROM_EVAL(0x0E9C9B409F94B2B6LL, setcookie);
      break;
    case 696:
      HASH_INVOKE_FROM_EVAL(0x3C6D50F3BB8102B8LL, next);
      break;
    case 698:
      HASH_INVOKE_FROM_EVAL(0x4A3D2113D3DFD2BALL, newpixelwandarray);
      break;
    case 700:
      HASH_INVOKE_FROM_EVAL(0x33E08846F3EB42BCLL, ldap_get_values);
      HASH_INVOKE_FROM_EVAL(0x41F7E2214DDE12BCLL, mcrypt_enc_self_test);
      break;
    case 701:
      HASH_INVOKE_FROM_EVAL(0x327C865E52FD12BDLL, ldap_get_values_len);
      break;
    case 702:
      HASH_INVOKE_FROM_EVAL(0x72D6F9B3661AB2BELL, magickgetimage);
      break;
    case 704:
      HASH_INVOKE_FROM_EVAL(0x5B7C1B74BA3452C0LL, newpixelregioniterator);
      break;
    case 707:
      HASH_INVOKE_FROM_EVAL(0x446D76A95365D2C3LL, pixelgetyellow);
      break;
    case 708:
      HASH_INVOKE_FROM_EVAL(0x6018C9F7DF40C2C4LL, xml_get_current_column_number);
      HASH_INVOKE_FROM_EVAL(0x1C7B8161F3C412C4LL, dom_document_create_document_fragment);
      break;
    case 716:
      HASH_INVOKE_FROM_EVAL(0x407EF03C23BF92CCLL, drawpathellipticarcabsolute);
      HASH_INVOKE_FROM_EVAL(0x44273F8BA3F542CCLL, imagesx);
      break;
    case 718:
      HASH_INVOKE_FROM_EVAL(0x1922D51F3E1522CELL, xmlwriter_end_dtd_attlist);
      break;
    case 719:
      HASH_INVOKE_FROM_EVAL(0x4ACE27EC476632CFLL, apc_bin_dumpfile);
      break;
    case 722:
      HASH_INVOKE_FROM_EVAL(0x4D9A87BD0CF742D2LL, imagepsextendfont);
      break;
    case 725:
      HASH_INVOKE_FROM_EVAL(0x4D04C580CF9212D5LL, posix_getgroups);
      break;
    case 726:
      HASH_INVOKE_FROM_EVAL(0x06E9C984B5F0B2D6LL, furchash_hphp_ext);
      break;
    case 728:
      HASH_INVOKE_FROM_EVAL(0x56C4896BA2FF52D8LL, drawsetstrokeopacity);
      break;
    case 730:
      HASH_INVOKE_FROM_EVAL(0x5C6A85B448C352DALL, posix_uname);
      break;
    case 733:
      HASH_INVOKE_FROM_EVAL(0x5F585DF7CB82E2DDLL, hphp_splfileinfo_iswritable);
      break;
    case 738:
      HASH_INVOKE_FROM_EVAL(0x4AEC19D75BF652E2LL, magickremoveimage);
      break;
    case 739:
      HASH_INVOKE_FROM_EVAL(0x45382D0BA5B262E3LL, mysql_get_proto_info);
      break;
    case 749:
      HASH_INVOKE_FROM_EVAL(0x1B9FC9E27B8AB2EDLL, memcache_flush);
      HASH_INVOKE_FROM_EVAL(0x215E0E2EFA7422EDLL, drawgetstrokeantialias);
      break;
    case 750:
      HASH_INVOKE_FROM_EVAL(0x5D43C0E4868EC2EELL, forward_static_call);
      HASH_INVOKE_FROM_EVAL(0x2884B7B3252B02EELL, imagealphablending);
      break;
    case 752:
      HASH_INVOKE_FROM_EVAL(0x25CA0794823AA2F0LL, openssl_csr_get_public_key);
      break;
    case 754:
      HASH_INVOKE_FROM_EVAL(0x2EE56D216BB832F2LL, time_nanosleep);
      break;
    case 756:
      HASH_INVOKE_FROM_EVAL(0x418EC805C5FD32F4LL, mcrypt_get_key_size);
      break;
    case 761:
      HASH_INVOKE_FROM_EVAL(0x00CFD56391DF82F9LL, mysql_data_seek);
      HASH_INVOKE_FROM_EVAL(0x319EF52B36AAB2F9LL, posix_isatty);
      break;
    case 763:
      HASH_INVOKE_FROM_EVAL(0x4D393D30CE1112FBLL, drawpathmovetoabsolute);
      break;
    case 764:
      HASH_INVOKE_FROM_EVAL(0x66D59E4DBC7382FCLL, drawscale);
      break;
    case 766:
      HASH_INVOKE_FROM_EVAL(0x208B66A8731F72FELL, sem_get);
      HASH_INVOKE_FROM_EVAL(0x755A9950B65472FELL, drawgetgravity);
      break;
    case 770:
      HASH_INVOKE_FROM_EVAL(0x0103FE1E2C307302LL, socket_recvfrom);
      break;
    case 772:
      HASH_INVOKE_FROM_EVAL(0x33A532FDB8EAC304LL, memcache_delete);
      break;
    case 773:
      HASH_INVOKE_FROM_EVAL(0x65D40C6B4842F305LL, clearpixelwand);
      break;
    case 774:
      HASH_INVOKE_FROM_EVAL(0x689D60184DD81306LL, htmlspecialchars_decode);
      break;
    case 777:
      HASH_INVOKE_FROM_EVAL(0x414038596F552309LL, magickgetversionnumber);
      HASH_INVOKE_FROM_EVAL(0x47CB27E8FDB60309LL, array_fill);
      break;
    case 779:
      HASH_INVOKE_FROM_EVAL(0x0C6F751411F5E30BLL, strrev);
      HASH_INVOKE_FROM_EVAL(0x65F586C35A88030BLL, magickresizeimage);
      HASH_INVOKE_FROM_EVAL(0x2D2BC1125ECA930BLL, dom_document_relaxng_validate_file);
      break;
    case 780:
      HASH_INVOKE_FROM_EVAL(0x553940FCE453330CLL, hphp_splfileobject_getmaxlinelen);
      break;
    case 785:
      HASH_INVOKE_FROM_EVAL(0x141EDCAE1D155311LL, xbox_get_thread_time);
      break;
    case 789:
      HASH_INVOKE_FROM_EVAL(0x4F1E663AE18FD315LL, msg_remove_queue);
      break;
    case 798:
      HASH_INVOKE_FROM_EVAL(0x27FF9DB54420531ELL, xml_error_string);
      break;
    case 804:
      HASH_INVOKE_FROM_EVAL(0x5E5E4F998C8E7324LL, pcntl_wifexited);
      break;
    case 808:
      HASH_INVOKE_FROM_EVAL(0x73FEB3BF75FFB328LL, ctype_space);
      break;
    case 811:
      HASH_INVOKE_FROM_EVAL(0x2BDB1EE3869E132BLL, restore_error_handler);
      break;
    case 815:
      HASH_INVOKE_FROM_EVAL(0x7DD6461A6290B32FLL, mysql_real_escape_string);
      break;
    case 816:
      HASH_INVOKE_FROM_EVAL(0x300F758BB0E16330LL, mysql_num_rows);
      HASH_INVOKE_FROM_EVAL(0x1601C1826E90B330LL, strptime);
      break;
    case 817:
      HASH_INVOKE_FROM_EVAL(0x00DAFE46631AE331LL, stream_set_timeout);
      break;
    case 818:
      HASH_INVOKE_FROM_EVAL(0x037055C215998332LL, bcsub);
      break;
    case 824:
      HASH_INVOKE_FROM_EVAL(0x549D51040C250338LL, cleardrawingwand);
      break;
    case 825:
      HASH_INVOKE_FROM_EVAL(0x48D57F17C5132339LL, drawgetclippath);
      break;
    case 826:
      HASH_INVOKE_FROM_EVAL(0x34DDF0DFC546033ALL, xbox_task_start);
      break;
    case 829:
      HASH_INVOKE_FROM_EVAL(0x4E166ECE0EC6A33DLL, openssl_pkey_get_public);
      break;
    case 830:
      HASH_INVOKE_FROM_EVAL(0x758EA7E9AA45C33ELL, xmlwriter_end_document);
      break;
    case 835:
      HASH_INVOKE_FROM_EVAL(0x6794CFB89DEEF343LL, curl_exec);
      break;
    case 836:
      HASH_INVOKE_FROM_EVAL(0x1A9DC76AB74F6344LL, openssl_verify);
      break;
    case 837:
      HASH_INVOKE_FROM_EVAL(0x45FAE3D08E96B345LL, curl_errno);
      break;
    case 838:
      HASH_INVOKE_FROM_EVAL(0x4B30FBA18042E346LL, session_cache_expire);
      break;
    case 842:
      HASH_INVOKE_FROM_EVAL(0x208BB4C3C0BA534ALL, xmlwriter_write_dtd_element);
      break;
    case 843:
      HASH_INVOKE_FROM_EVAL(0x3880550F6AD8034BLL, session_destroy);
      HASH_INVOKE_FROM_EVAL(0x57A9E8878872D34BLL, parse_ini_file);
      break;
    case 844:
      HASH_INVOKE_FROM_EVAL(0x0644E5FB91C8134CLL, array_udiff);
      break;
    case 845:
      HASH_INVOKE_FROM_EVAL(0x5998E61D600D634DLL, drawaffine);
      break;
    case 847:
      HASH_INVOKE_FROM_EVAL(0x4F2D0EFF0D4B534FLL, fb_get_taint);
      HASH_INVOKE_FROM_EVAL(0x5C8B3B9FA833934FLL, ldap_first_attribute);
      break;
    case 849:
      HASH_INVOKE_FROM_EVAL(0x2B422699C3A57351LL, sha1);
      break;
    case 852:
      HASH_INVOKE_FROM_EVAL(0x501F4DF5C8997354LL, hphp_get_property);
      HASH_INVOKE_FROM_EVAL(0x77EB4D2F5BDDB354LL, magickgetimageresolution);
      break;
    case 858:
      HASH_INVOKE_FROM_EVAL(0x4BF5DEBDB76EC35ALL, mcrypt_enc_get_iv_size);
      HASH_INVOKE_FROM_EVAL(0x0E0C79E42812235ALL, imagepng);
      break;
    case 859:
      HASH_INVOKE_FROM_EVAL(0x1AC48909BEEF935BLL, func_get_arg);
      break;
    case 861:
      HASH_INVOKE_FROM_EVAL(0x54C3E9AB6FB8E35DLL, magickswirlimage);
      break;
    case 863:
      HASH_INVOKE_FROM_EVAL(0x280DE04F84FB235FLL, popdrawingwand);
      break;
    case 869:
      HASH_INVOKE_FROM_EVAL(0x68DBF8ABB26A8365LL, hphp_directoryiterator_rewind);
      break;
    case 870:
      HASH_INVOKE_FROM_EVAL(0x4EF3469306E44366LL, floatval);
      break;
    case 871:
      HASH_INVOKE_FROM_EVAL(0x4810A9774785C367LL, posix_getpgrp);
      break;
    case 872:
      HASH_INVOKE_FROM_EVAL(0x5D406167C673D368LL, magickcompareimages);
      break;
    case 873:
      HASH_INVOKE_FROM_EVAL(0x6C715D7DD63DA369LL, is_integer);
      break;
    case 878:
      HASH_INVOKE_FROM_EVAL(0x7CE90898E882F36ELL, pixelsetyellow);
      break;
    case 882:
      HASH_INVOKE_FROM_EVAL(0x7107AE03689F5372LL, hphp_invoke);
      break;
    case 888:
      HASH_INVOKE_FROM_EVAL(0x34BAEFD8AE59D378LL, hphp_set_error_page);
      break;
    case 889:
      HASH_INVOKE_FROM_EVAL(0x5ED8901DB5D14379LL, magickcharcoalimage);
      break;
    case 890:
      HASH_INVOKE_FROM_EVAL(0x69EA8DC005FEC37ALL, hphp_splfileobject_fwrite);
      break;
    case 893:
      HASH_INVOKE_FROM_EVAL(0x7C40E2514FB5437DLL, dom_namednodemap_get_named_item_ns);
      break;
    case 900:
      HASH_INVOKE_FROM_EVAL(0x44C1BC500D175384LL, wandgetexception);
      break;
    case 901:
      HASH_INVOKE_FROM_EVAL(0x7C5CA3E2E3C8F385LL, magickflipimage);
      HASH_INVOKE_FROM_EVAL(0x57554E082E0ED385LL, pcntl_exec);
      HASH_INVOKE_FROM_EVAL(0x0B0B8765A4CDD385LL, hphp_splfileobject_fgets);
      break;
    case 902:
      HASH_INVOKE_FROM_EVAL(0x589E24C7664D5386LL, doubleval);
      break;
    case 904:
      HASH_INVOKE_FROM_EVAL(0x791E946E04F50388LL, magicksetresourcelimit);
      break;
    case 907:
      HASH_INVOKE_FROM_EVAL(0x32354CC291ECF38BLL, fb_intercept);
      HASH_INVOKE_FROM_EVAL(0x73A3F87C0A56238BLL, stat);
      break;
    case 908:
      HASH_INVOKE_FROM_EVAL(0x7F18BA1FBD95B38CLL, hphp_directoryiterator_next);
      break;
    case 909:
      HASH_INVOKE_FROM_EVAL(0x4127DE142CD4A38DLL, xml_get_error_code);
      break;
    case 913:
      HASH_INVOKE_FROM_EVAL(0x25FA64929C619391LL, asin);
      break;
    case 914:
      HASH_INVOKE_FROM_EVAL(0x2052D8D4822EF392LL, is_subclass_of);
      HASH_INVOKE_FROM_EVAL(0x2395B0A85E292392LL, hphp_splfileobject_flock);
      break;
    case 916:
      HASH_INVOKE_FROM_EVAL(0x269A220896FD2394LL, deg2rad);
      HASH_INVOKE_FROM_EVAL(0x36953788781F4394LL, mailparse_msg_extract_part);
      break;
    case 917:
      HASH_INVOKE_FROM_EVAL(0x7B0552A224E27395LL, bcsqrt);
      HASH_INVOKE_FROM_EVAL(0x422599B9E8AC0395LL, stream_bucket_make_writeable);
      break;
    case 918:
      HASH_INVOKE_FROM_EVAL(0x15EC64198D93C396LL, openssl_pkcs12_read);
      break;
    case 919:
      HASH_INVOKE_FROM_EVAL(0x1D2C305EA5C82397LL, idn_to_utf8);
      break;
    case 920:
      HASH_INVOKE_FROM_EVAL(0x215547858BA7E398LL, hphp_recursiveiteratoriterator___construct);
      break;
    case 921:
      HASH_INVOKE_FROM_EVAL(0x66DA89629BA5D399LL, posix_getgrgid);
      break;
    case 922:
      HASH_INVOKE_FROM_EVAL(0x0CC562CBD773639ALL, i18n_loc_get_default);
      HASH_INVOKE_FROM_EVAL(0x4C24BC37D807D39ALL, collator_get_strength);
      break;
    case 923:
      HASH_INVOKE_FROM_EVAL(0x25DF28703309C39BLL, idate);
      HASH_INVOKE_FROM_EVAL(0x5B33B55D4B7E339BLL, fpassthru);
      break;
    case 924:
      HASH_INVOKE_FROM_EVAL(0x0136F8F03932E39CLL, session_unset);
      break;
    case 926:
      HASH_INVOKE_FROM_EVAL(0x27AD0D17AA7FB39ELL, ldap_set_rebind_proc);
      break;
    case 927:
      HASH_INVOKE_FROM_EVAL(0x57E72C21F67D039FLL, user_error);
      HASH_INVOKE_FROM_EVAL(0x0368F1779E3AE39FLL, mysql_field_table);
      HASH_INVOKE_FROM_EVAL(0x4019A6916456339FLL, dom_node_remove_child);
      break;
    case 929:
      HASH_INVOKE_FROM_EVAL(0x5C29B6D7973903A1LL, proc_nice);
      break;
    case 930:
      HASH_INVOKE_FROM_EVAL(0x0207E332D629A3A2LL, mailparse_msg_get_structure);
      HASH_INVOKE_FROM_EVAL(0x0A2A4AA078D433A2LL, hexdec);
      break;
    case 932:
      HASH_INVOKE_FROM_EVAL(0x1676FB393F8493A4LL, constant);
      break;
    case 934:
      HASH_INVOKE_FROM_EVAL(0x40E0D496EE29B3A6LL, call_user_func_array);
      break;
    case 936:
      HASH_INVOKE_FROM_EVAL(0x0121CD6CDCE1C3A8LL, mysql_pconnect_with_db);
      HASH_INVOKE_FROM_EVAL(0x4120B8157ED413A8LL, i18n_loc_set_strength);
      break;
    case 937:
      HASH_INVOKE_FROM_EVAL(0x7F9E810BC93023A9LL, memcache_close);
      break;
    case 938:
      HASH_INVOKE_FROM_EVAL(0x3238A5BD362443AALL, escapeshellcmd);
      break;
    case 946:
      HASH_INVOKE_FROM_EVAL(0x3DB7EBC0B670C3B2LL, magicksetimageredprimary);
      break;
    case 947:
      HASH_INVOKE_FROM_EVAL(0x61720D771D1A23B3LL, posix_getpwnam);
      HASH_INVOKE_FROM_EVAL(0x6077CFE09EE4D3B3LL, session_save_path);
      break;
    case 950:
      HASH_INVOKE_FROM_EVAL(0x6E6C0E9A715073B6LL, dom_xpath_register_php_functions);
      HASH_INVOKE_FROM_EVAL(0x6C07640F7C5BD3B6LL, imagettfbbox);
      break;
    case 955:
      HASH_INVOKE_FROM_EVAL(0x5A3F5AAD1B13A3BBLL, is_executable);
      break;
    case 956:
      HASH_INVOKE_FROM_EVAL(0x0629158C42C893BCLL, compact);
      break;
    case 957:
      HASH_INVOKE_FROM_EVAL(0x60294C2616F6A3BDLL, mcrypt_enc_get_supported_key_sizes);
      break;
    case 958:
      HASH_INVOKE_FROM_EVAL(0x49A34964289453BELL, eregi);
      break;
    case 959:
      HASH_INVOKE_FROM_EVAL(0x0E38CDC93E5893BFLL, magicksetimagemattecolor);
      break;
    case 968:
      HASH_INVOKE_FROM_EVAL(0x4D100C70E86593C8LL, stream_set_write_buffer);
      HASH_INVOKE_FROM_EVAL(0x3101CE70BA49A3C8LL, error_reporting);
      break;
    case 971:
      HASH_INVOKE_FROM_EVAL(0x0173CC6FACAB93CBLL, quotemeta);
      HASH_INVOKE_FROM_EVAL(0x4C3B6BE9112E63CBLL, str_split);
      break;
    case 972:
      HASH_INVOKE_FROM_EVAL(0x50C88817090C63CCLL, pcntl_wait);
      break;
    case 974:
      HASH_INVOKE_FROM_EVAL(0x4F9F68F60FD7A3CELL, drawgetfillrule);
      HASH_INVOKE_FROM_EVAL(0x02BEFBEE8287D3CELL, get_magic_quotes_runtime);
      break;
    case 978:
      HASH_INVOKE_FROM_EVAL(0x67C155632E5373D2LL, mailparse_msg_create);
      break;
    case 979:
      HASH_INVOKE_FROM_EVAL(0x734FD402E190E3D3LL, evhttp_async_get);
      HASH_INVOKE_FROM_EVAL(0x0A8D4FAF266973D3LL, bcpow);
      break;
    case 980:
      HASH_INVOKE_FROM_EVAL(0x0FF21F9BE4CCC3D4LL, call_user_func_rpc);
      break;
    case 983:
      HASH_INVOKE_FROM_EVAL(0x382B5B1EF00153D7LL, imagecreatefrompng);
      break;
    case 996:
      HASH_INVOKE_FROM_EVAL(0x7E7718CC939D63E4LL, setrawcookie);
      break;
    case 1000:
      HASH_INVOKE_FROM_EVAL(0x6BB9D669DDB703E8LL, xml_get_current_byte_index);
      HASH_INVOKE_FROM_EVAL(0x4A3127C309B0C3E8LL, drawsetstrokelinecap);
      break;
    case 1002:
      HASH_INVOKE_FROM_EVAL(0x0D3C8F00B0C633EALL, inet_pton);
      HASH_INVOKE_FROM_EVAL(0x6DA49696220FE3EALL, mailparse_rfc822_parse_addresses);
      break;
    case 1003:
      HASH_INVOKE_FROM_EVAL(0x1DAE0831CECB63EBLL, ob_get_clean);
      break;
    case 1006:
      HASH_INVOKE_FROM_EVAL(0x598472448937E3EELL, magickqueryfontmetrics);
      break;
    case 1009:
      HASH_INVOKE_FROM_EVAL(0x5EFE291585A713F1LL, method_exists);
      break;
    case 1010:
      HASH_INVOKE_FROM_EVAL(0x0FE12E46BC9853F2LL, stream_filter_append);
      HASH_INVOKE_FROM_EVAL(0x41A19AE18BC8B3F2LL, curl_error);
      HASH_INVOKE_FROM_EVAL(0x696241660648B3F2LL, magickwhitethresholdimage);
      break;
    case 1012:
      HASH_INVOKE_FROM_EVAL(0x1938C8715806E3F4LL, spl_classes);
      HASH_INVOKE_FROM_EVAL(0x26D53A77483EF3F4LL, drawbezier);
      break;
    case 1015:
      HASH_INVOKE_FROM_EVAL(0x43F22CB4E3E8F3F7LL, apache_note);
      break;
    case 1016:
      HASH_INVOKE_FROM_EVAL(0x4C024573FCD5B3F8LL, var_dump);
      HASH_INVOKE_FROM_EVAL(0x514EA9C8FF5B33F8LL, posix_getrlimit);
      break;
    case 1018:
      HASH_INVOKE_FROM_EVAL(0x1B217E78CBC713FALL, zend_thread_id);
      break;
    case 1025:
      HASH_INVOKE_FROM_EVAL(0x36B9C440B1881401LL, fmod);
      HASH_INVOKE_FROM_EVAL(0x3DCB1C92B5864401LL, gzrewind);
      break;
    case 1028:
      HASH_INVOKE_FROM_EVAL(0x2B12B0E9109D0404LL, iptcembed);
      break;
    case 1033:
      HASH_INVOKE_FROM_EVAL(0x2E57E06900594409LL, xbox_send_message);
      break;
    case 1034:
      HASH_INVOKE_FROM_EVAL(0x6DC61C51FA1D340ALL, show_source);
      break;
    case 1035:
      HASH_INVOKE_FROM_EVAL(0x6C2CE092B900D40BLL, hphp_splfileinfo___construct);
      break;
    case 1037:
      HASH_INVOKE_FROM_EVAL(0x2939C5BAE0C4A40DLL, nl2br);
      HASH_INVOKE_FROM_EVAL(0x267529454569840DLL, ob_flush);
      HASH_INVOKE_FROM_EVAL(0x152C7161567F940DLL, func_num_args);
      HASH_INVOKE_FROM_EVAL(0x002CCCD877D9640DLL, drawpathclose);
      break;
    case 1043:
      HASH_INVOKE_FROM_EVAL(0x56EC1A6732D07413LL, drawgetfontsize);
      HASH_INVOKE_FROM_EVAL(0x20C24D873DC65413LL, openssl_csr_get_subject);
      break;
    case 1051:
      HASH_INVOKE_FROM_EVAL(0x47279C717370B41BLL, acos);
      break;
    case 1054:
      HASH_INVOKE_FROM_EVAL(0x3E4E7C561D3A541ELL, fgetss);
      break;
    case 1055:
      HASH_INVOKE_FROM_EVAL(0x301963016A91741FLL, hphp_stats);
      break;
    case 1059:
      HASH_INVOKE_FROM_EVAL(0x4C9108B5A5807423LL, drawsetfillcolor);
      break;
    case 1062:
      HASH_INVOKE_FROM_EVAL(0x21EFB0B9D1514426LL, magicksetpassphrase);
      HASH_INVOKE_FROM_EVAL(0x161D8EA3339AB426LL, apc_cas);
      break;
    case 1068:
      HASH_INVOKE_FROM_EVAL(0x12D324CC744BF42CLL, pixelgetcolorasstring);
      break;
    case 1069:
      HASH_INVOKE_FROM_EVAL(0x333D1E2E28B0942DLL, imagejpeg);
      HASH_INVOKE_FROM_EVAL(0x2A5A519E4BFE442DLL, mb_eregi);
      break;
    case 1071:
      HASH_INVOKE_FROM_EVAL(0x316F2725AC15042FLL, stream_resolve_include_path);
      break;
    case 1072:
      HASH_INVOKE_FROM_EVAL(0x6349C9658B2A2430LL, memcache_pconnect);
      break;
    case 1074:
      HASH_INVOKE_FROM_EVAL(0x71C6E38BC56CE432LL, stream_wrapper_register);
      break;
    case 1075:
      HASH_INVOKE_FROM_EVAL(0x6829094421CDB433LL, touch);
      break;
    case 1077:
      HASH_INVOKE_FROM_EVAL(0x75DAFEF5BFEF1435LL, imagesetstyle);
      HASH_INVOKE_FROM_EVAL(0x044386A0E8B25435LL, drawgetclipunits);
      break;
    case 1079:
      HASH_INVOKE_FROM_EVAL(0x1AAF02CF6DEBB437LL, magickdeconstructimages);
      break;
    case 1081:
      HASH_INVOKE_FROM_EVAL(0x34C52EF423EFD439LL, proc_open);
      break;
    case 1082:
      HASH_INVOKE_FROM_EVAL(0x5019A1FBF377C43ALL, imagepsbbox);
      break;
    case 1084:
      HASH_INVOKE_FROM_EVAL(0x59ECE01C7629643CLL, mysql_drop_db);
      break;
    case 1088:
      HASH_INVOKE_FROM_EVAL(0x5247425ED698B440LL, hphp_thread_is_warmup_enabled);
      break;
    case 1089:
      HASH_INVOKE_FROM_EVAL(0x158E2271E381C441LL, hash_file);
      HASH_INVOKE_FROM_EVAL(0x05892E3C5B9EB441LL, closedir);
      break;
    case 1090:
      HASH_INVOKE_FROM_EVAL(0x3F869126D0336442LL, trigger_error);
      break;
    case 1105:
      HASH_INVOKE_FROM_EVAL(0x7539134E1CC61451LL, xmlwriter_start_cdata);
      break;
    case 1106:
      HASH_INVOKE_FROM_EVAL(0x1056EF1C14D2A452LL, socket_connect);
      break;
    case 1116:
      HASH_INVOKE_FROM_EVAL(0x436AB52B2099145CLL, ldap_close);
      break;
    case 1117:
      HASH_INVOKE_FROM_EVAL(0x0246AF48CD31245DLL, count_chars);
      break;
    case 1118:
      HASH_INVOKE_FROM_EVAL(0x0ED191E71A60545ELL, magicksetfirstiterator);
      break;
    case 1125:
      HASH_INVOKE_FROM_EVAL(0x05D72365192CE465LL, fwrite);
      HASH_INVOKE_FROM_EVAL(0x406A1404F48E4465LL, posix_getuid);
      break;
    case 1130:
      HASH_INVOKE_FROM_EVAL(0x32643AE461D3F46ALL, mailparse_stream_encode);
      break;
    case 1132:
      HASH_INVOKE_FROM_EVAL(0x07D959A8C0CF546CLL, stream_wrapper_unregister);
      HASH_INVOKE_FROM_EVAL(0x4F39BD300305746CLL, hphp_splfileobject_key);
      break;
    case 1133:
      HASH_INVOKE_FROM_EVAL(0x738D381800CE946DLL, ldap_parse_result);
      HASH_INVOKE_FROM_EVAL(0x5229C0069FD7D46DLL, vfprintf);
      break;
    case 1136:
      HASH_INVOKE_FROM_EVAL(0x0C626F268F120470LL, __halt_compiler);
      break;
    case 1139:
      HASH_INVOKE_FROM_EVAL(0x0F8F276A48900473LL, drawgetstrokelinecap);
      break;
    case 1141:
      HASH_INVOKE_FROM_EVAL(0x268706C46202C475LL, sem_acquire);
      break;
    case 1143:
      HASH_INVOKE_FROM_EVAL(0x18666906A8001477LL, array_diff_assoc);
      break;
    case 1144:
      HASH_INVOKE_FROM_EVAL(0x080594ABE715B478LL, hphp_splfileobject_current);
      HASH_INVOKE_FROM_EVAL(0x6497CC8295DDB478LL, fb_thrift_unserialize);
      break;
    case 1145:
      HASH_INVOKE_FROM_EVAL(0x4859AF715D5A3479LL, magickmagnifyimage);
      break;
    case 1148:
      HASH_INVOKE_FROM_EVAL(0x1A08C578AD3BC47CLL, apache_response_headers);
      HASH_INVOKE_FROM_EVAL(0x2FA7269AB0E1147CLL, mysql_field_seek);
      break;
    case 1150:
      HASH_INVOKE_FROM_EVAL(0x1D583AA4F7F6547ELL, drawpathlinetorelative);
      HASH_INVOKE_FROM_EVAL(0x0AC36D9F961B247ELL, newpixeliterator);
      break;
    case 1151:
      HASH_INVOKE_FROM_EVAL(0x68AE04B02253B47FLL, mb_parse_str);
      break;
    case 1154:
      HASH_INVOKE_FROM_EVAL(0x4590C853C2027482LL, magickembossimage);
      break;
    case 1157:
      HASH_INVOKE_FROM_EVAL(0x250DD3D58EA37485LL, gmstrftime);
      HASH_INVOKE_FROM_EVAL(0x61499C92F4FBA485LL, hphp_splfileobject_fgetc);
      break;
    case 1161:
      HASH_INVOKE_FROM_EVAL(0x4F7EAF5B37663489LL, magickgetimageredprimary);
      HASH_INVOKE_FROM_EVAL(0x7505924F05854489LL, dom_element_set_attribute_ns);
      break;
    case 1162:
      HASH_INVOKE_FROM_EVAL(0x7E88764A1DE8548ALL, drawgetstrokewidth);
      break;
    case 1163:
      HASH_INVOKE_FROM_EVAL(0x5860ACF621DD948BLL, is_file);
      break;
    case 1165:
      HASH_INVOKE_FROM_EVAL(0x23511F83C2BC548DLL, header);
      HASH_INVOKE_FROM_EVAL(0x275D127C87EF048DLL, mysql_db_query);
      break;
    case 1167:
      HASH_INVOKE_FROM_EVAL(0x43672229728A648FLL, drawpushpattern);
      break;
    case 1171:
      HASH_INVOKE_FROM_EVAL(0x56377FCC2447D493LL, magicksetimagepixels);
      break;
    case 1175:
      HASH_INVOKE_FROM_EVAL(0x353E2A635A47F497LL, evhttp_get);
      HASH_INVOKE_FROM_EVAL(0x5388045C2D13D497LL, mysql_num_fields);
      break;
    case 1181:
      HASH_INVOKE_FROM_EVAL(0x7A59813AC331449DLL, mb_ereg_search_regs);
      break;
    case 1183:
      HASH_INVOKE_FROM_EVAL(0x7FF66005524E649FLL, drawgettextdecoration);
      break;
    case 1188:
      HASH_INVOKE_FROM_EVAL(0x6EC476E42A53A4A4LL, ldap_err2str);
      break;
    case 1189:
      HASH_INVOKE_FROM_EVAL(0x18BE9B1C2DE6D4A5LL, imagexbm);
      break;
    case 1192:
      HASH_INVOKE_FROM_EVAL(0x6F4497457F1584A8LL, dom_element_set_id_attribute_node);
      break;
    case 1193:
      HASH_INVOKE_FROM_EVAL(0x386378F2BA3234A9LL, magickevaluateimage);
      break;
    case 1196:
      HASH_INVOKE_FROM_EVAL(0x245AA2790C87C4ACLL, image_type_to_mime_type);
      HASH_INVOKE_FROM_EVAL(0x6E8FFA56842304ACLL, drawgetfont);
      break;
    case 1197:
      HASH_INVOKE_FROM_EVAL(0x3D98ACFCEBB764ADLL, hphp_set_property);
      break;
    case 1199:
      HASH_INVOKE_FROM_EVAL(0x42463E7E5C3434AFLL, mb_strrichr);
      HASH_INVOKE_FROM_EVAL(0x6AC751181531F4AFLL, simplexml_load_string);
      break;
    case 1200:
      HASH_INVOKE_FROM_EVAL(0x0E11D317044974B0LL, magickgetnumberimages);
      HASH_INVOKE_FROM_EVAL(0x3AF65A9F3653E4B0LL, addslashes);
      break;
    case 1201:
      HASH_INVOKE_FROM_EVAL(0x060619D7A1B5F4B1LL, checkdate);
      break;
    case 1203:
      HASH_INVOKE_FROM_EVAL(0x57034CAD772AF4B3LL, magickgetimagechannelmean);
      break;
    case 1204:
      HASH_INVOKE_FROM_EVAL(0x00621C58E54D44B4LL, hphp_recursiveiteratoriterator_key);
      break;
    case 1206:
      HASH_INVOKE_FROM_EVAL(0x3DE291DCBA5134B6LL, dom_document_create_element);
      HASH_INVOKE_FROM_EVAL(0x12A9166E68DCF4B6LL, pixelgetgreen);
      break;
    case 1207:
      HASH_INVOKE_FROM_EVAL(0x7EEBC81AF9BC54B7LL, xml_parser_free);
      break;
    case 1209:
      HASH_INVOKE_FROM_EVAL(0x5351290CD139A4B9LL, mb_strrpos);
      break;
    case 1210:
      HASH_INVOKE_FROM_EVAL(0x6B49D11E633274BALL, fopen);
      break;
    case 1213:
      HASH_INVOKE_FROM_EVAL(0x35BE8F6E7726C4BDLL, dechex);
      HASH_INVOKE_FROM_EVAL(0x5BA371A93F60F4BDLL, use_soap_error_handler);
      break;
    case 1214:
      HASH_INVOKE_FROM_EVAL(0x57278846B8B0E4BELL, ldap_count_entries);
      break;
    case 1215:
      HASH_INVOKE_FROM_EVAL(0x01681C307C5AE4BFLL, strtoupper);
      break;
    case 1219:
      HASH_INVOKE_FROM_EVAL(0x7AAC29849263C4C3LL, getprotobyname);
      break;
    case 1220:
      HASH_INVOKE_FROM_EVAL(0x67EADCF4E81084C4LL, mb_ereg);
      HASH_INVOKE_FROM_EVAL(0x4A24DB9D6B0334C4LL, hphp_recursivedirectoryiterator_next);
      break;
    case 1221:
      HASH_INVOKE_FROM_EVAL(0x34A38DDF2CD914C5LL, long2ip);
      break;
    case 1222:
      HASH_INVOKE_FROM_EVAL(0x651F7FBBA90604C6LL, magickgetimageindex);
      HASH_INVOKE_FROM_EVAL(0x4F7AA8120E33E4C6LL, collator_get_attribute);
      break;
    case 1224:
      HASH_INVOKE_FROM_EVAL(0x1B8BBFC882FDB4C8LL, magicktintimage);
      break;
    case 1230:
      HASH_INVOKE_FROM_EVAL(0x60783C20BF7724CELL, mailparse_msg_free);
      break;
    case 1231:
      HASH_INVOKE_FROM_EVAL(0x72DECE786967A4CFLL, magickpreviousimage);
      break;
    case 1233:
      HASH_INVOKE_FROM_EVAL(0x29EE24C41FD3D4D1LL, mysql_field_name);
      break;
    case 1238:
      HASH_INVOKE_FROM_EVAL(0x19ECDD5A937DD4D6LL, mailparse_msg_get_part_data);
      break;
    case 1239:
      HASH_INVOKE_FROM_EVAL(0x215403F1E335C4D7LL, magicksolarizeimage);
      break;
    case 1240:
      HASH_INVOKE_FROM_EVAL(0x2532EB687D51E4D8LL, unregister_tick_function);
      HASH_INVOKE_FROM_EVAL(0x14BF763DDDC014D8LL, imagepsencodefont);
      HASH_INVOKE_FROM_EVAL(0x56B908FC91C834D8LL, magickflopimage);
      HASH_INVOKE_FROM_EVAL(0x1301F911ED6D54D8LL, is_nan);
      HASH_INVOKE_FROM_EVAL(0x575C5AE3D2A694D8LL, ob_end_clean);
      break;
    case 1247:
      HASH_INVOKE_FROM_EVAL(0x747A7F585CD694DFLL, zend_version);
      HASH_INVOKE_FROM_EVAL(0x2E5E5A0FC3B5C4DFLL, xml_set_character_data_handler);
      break;
    case 1248:
      HASH_INVOKE_FROM_EVAL(0x340A51AE22A924E0LL, reset);
      break;
    case 1251:
      HASH_INVOKE_FROM_EVAL(0x7D57A0D72D6254E3LL, ob_implicit_flush);
      break;
    case 1262:
      HASH_INVOKE_FROM_EVAL(0x5895ADDD91F354EELL, hphp_thread_set_warmup_enabled);
      break;
    case 1265:
      HASH_INVOKE_FROM_EVAL(0x65BD541EAB38E4F1LL, mysql_close);
      break;
    case 1266:
      HASH_INVOKE_FROM_EVAL(0x41276F8DE35354F2LL, dom_document_get_elements_by_tag_name);
      break;
    case 1268:
      HASH_INVOKE_FROM_EVAL(0x436B36C5EB8DB4F4LL, mcrypt_generic);
      break;
    case 1269:
      HASH_INVOKE_FROM_EVAL(0x528AC8D252D224F5LL, log10);
      HASH_INVOKE_FROM_EVAL(0x112A0ACDD8B9D4F5LL, mb_list_mime_names);
      break;
    case 1271:
      HASH_INVOKE_FROM_EVAL(0x0BD9C5D811CB04F7LL, dom_element_set_id_attribute_ns);
      break;
    case 1272:
      HASH_INVOKE_FROM_EVAL(0x011006D90D79E4F8LL, mysql_errno);
      break;
    case 1277:
      HASH_INVOKE_FROM_EVAL(0x002387F1D23B44FDLL, mcrypt_list_modes);
      HASH_INVOKE_FROM_EVAL(0x2CEAE845E4F404FDLL, dom_document_save);
      break;
    case 1287:
      HASH_INVOKE_FROM_EVAL(0x4FC9FE38A748B507LL, intl_get_error_message);
      HASH_INVOKE_FROM_EVAL(0x197A5D237BD4C507LL, mb_ereg_search_getpos);
      break;
    case 1288:
      HASH_INVOKE_FROM_EVAL(0x63A08D6AD1209508LL, magickgetexception);
      break;
    case 1291:
      HASH_INVOKE_FROM_EVAL(0x71DCF11E3640C50BLL, hphp_directoryiterator_valid);
      break;
    case 1295:
      HASH_INVOKE_FROM_EVAL(0x5A66CCB3D924450FLL, xml_parser_create);
      break;
    case 1297:
      HASH_INVOKE_FROM_EVAL(0x09D5355CA8198511LL, mb_internal_encoding);
      HASH_INVOKE_FROM_EVAL(0x3C0304A55503D511LL, magickgetimageiterations);
      break;
    case 1299:
      HASH_INVOKE_FROM_EVAL(0x772E8BF114FEF513LL, eregi_replace);
      break;
    case 1300:
      HASH_INVOKE_FROM_EVAL(0x100385A0988FD514LL, magickgetfilename);
      break;
    case 1305:
      HASH_INVOKE_FROM_EVAL(0x54EDBB6BAF318519LL, memcache_add);
      break;
    case 1314:
      HASH_INVOKE_FROM_EVAL(0x7DA98E0379D33522LL, chdir);
      break;
    case 1316:
      HASH_INVOKE_FROM_EVAL(0x28E724EDE0BB6524LL, mb_strcut);
      break;
    case 1317:
      HASH_INVOKE_FROM_EVAL(0x230FE1D6EC599525LL, link);
      break;
    case 1318:
      HASH_INVOKE_FROM_EVAL(0x57DDA4C3F7FF8526LL, fputcsv);
      break;
    case 1319:
      HASH_INVOKE_FROM_EVAL(0x6B2B942CAF1A2527LL, array_shift);
      break;
    case 1324:
      HASH_INVOKE_FROM_EVAL(0x1AB55BBA0967952CLL, mb_convert_variables);
      break;
    case 1327:
      HASH_INVOKE_FROM_EVAL(0x6770E2559C9A152FLL, openssl_private_decrypt);
      break;
    case 1329:
      HASH_INVOKE_FROM_EVAL(0x6776C27C6123D531LL, dl);
      break;
    case 1330:
      HASH_INVOKE_FROM_EVAL(0x6193A26936F4D532LL, disk_total_space);
      break;
    case 1331:
      HASH_INVOKE_FROM_EVAL(0x313D2A505076A533LL, dir);
      break;
    case 1333:
      HASH_INVOKE_FROM_EVAL(0x6C87406DDC0AB535LL, mcrypt_ecb);
      break;
    case 1334:
      HASH_INVOKE_FROM_EVAL(0x0E80D04691227536LL, eval);
      HASH_INVOKE_FROM_EVAL(0x746DC7AD953EA536LL, memcache_set_compress_threshold);
      break;
    case 1335:
      HASH_INVOKE_FROM_EVAL(0x0830FF7C379D7537LL, dom_text_split_text);
      HASH_INVOKE_FROM_EVAL(0x557C72DE98679537LL, hash_update_stream);
      HASH_INVOKE_FROM_EVAL(0x175B86BCB3124537LL, magickgetexceptionstring);
      break;
    case 1337:
      HASH_INVOKE_FROM_EVAL(0x3C88F0FAC3EDD539LL, phpversion);
      break;
    case 1340:
      HASH_INVOKE_FROM_EVAL(0x5CA55E62F2A5953CLL, drawgetstrokeopacity);
      break;
    case 1341:
      HASH_INVOKE_FROM_EVAL(0x0F32841DBF7A053DLL, fb_crossall_query);
      break;
    case 1342:
      HASH_INVOKE_FROM_EVAL(0x36A80B48E08B753ELL, implode);
      break;
    case 1346:
      HASH_INVOKE_FROM_EVAL(0x59A44591E67D4542LL, drawrender);
      break;
    case 1347:
      HASH_INVOKE_FROM_EVAL(0x20E2B1D920122543LL, die);
      HASH_INVOKE_FROM_EVAL(0x0962EACAE0F0B543LL, hphp_splfileinfo_getlinktarget);
      break;
    case 1348:
      HASH_INVOKE_FROM_EVAL(0x4D397FE5D0C0B544LL, magickmedianfilterimage);
      break;
    case 1350:
      HASH_INVOKE_FROM_EVAL(0x12A739BE0ED32546LL, ignore_user_abort);
      HASH_INVOKE_FROM_EVAL(0x081F76AC889BC546LL, getrusage);
      break;
    case 1352:
      HASH_INVOKE_FROM_EVAL(0x0AD3BFAB5F780548LL, magickcoalesceimages);
      break;
    case 1355:
      HASH_INVOKE_FROM_EVAL(0x40CE61115E11154BLL, msg_stat_queue);
      break;
    case 1356:
      HASH_INVOKE_FROM_EVAL(0x1D011CB0E810D54CLL, pdo_drivers);
      break;
    case 1357:
      HASH_INVOKE_FROM_EVAL(0x0F0702D91EAFB54DLL, drawgettextantialias);
      HASH_INVOKE_FROM_EVAL(0x1B9E769FFEC3C54DLL, pcntl_wtermsig);
      break;
    case 1359:
      HASH_INVOKE_FROM_EVAL(0x30DE78E7131B954FLL, furchash_hphp_ext_supported);
      HASH_INVOKE_FROM_EVAL(0x063200B5AAFEC54FLL, mysql_thread_id);
      break;
    case 1370:
      HASH_INVOKE_FROM_EVAL(0x268EE73DB2EA555ALL, get_object_vars);
      break;
    case 1372:
      HASH_INVOKE_FROM_EVAL(0x5749AD20CAFCD55CLL, pixelgetbluequantum);
      break;
    case 1379:
      HASH_INVOKE_FROM_EVAL(0x1B1B2D70792D9563LL, mysql_get_client_info);
      break;
    case 1382:
      HASH_INVOKE_FROM_EVAL(0x6E2FDBD28F895566LL, timezone_abbreviations_list);
      HASH_INVOKE_FROM_EVAL(0x3DA2058E5C540566LL, spliti);
      break;
    case 1386:
      HASH_INVOKE_FROM_EVAL(0x74599147803DC56ALL, magickgetstringwidth);
      break;
    case 1387:
      HASH_INVOKE_FROM_EVAL(0x0DE86977367F656BLL, register_shutdown_function);
      break;
    case 1390:
      HASH_INVOKE_FROM_EVAL(0x2A1F1B52160DE56ELL, zend_logo_guid);
      break;
    case 1391:
      HASH_INVOKE_FROM_EVAL(0x016722439BBA756FLL, filetype);
      break;
    case 1392:
      HASH_INVOKE_FROM_EVAL(0x13D0427F3BB3E570LL, get_declared_interfaces);
      HASH_INVOKE_FROM_EVAL(0x21B3935EB3140570LL, mysql_fetch_object);
      break;
    case 1393:
      HASH_INVOKE_FROM_EVAL(0x2AD3361DE8B1D571LL, pcntl_signal_dispatch);
      break;
    case 1396:
      HASH_INVOKE_FROM_EVAL(0x636C871213F37574LL, mcrypt_encrypt);
      break;
    case 1399:
      HASH_INVOKE_FROM_EVAL(0x412521E7ADB21577LL, iconv_mime_decode_headers);
      HASH_INVOKE_FROM_EVAL(0x1E154D823451B577LL, magicksetresolution);
      break;
    case 1401:
      HASH_INVOKE_FROM_EVAL(0x1DC8A386E219C579LL, ldap_add);
      break;
    case 1405:
      HASH_INVOKE_FROM_EVAL(0x78EDB608B02A857DLL, join);
      HASH_INVOKE_FROM_EVAL(0x22E08DEDF360057DLL, pixelsetmagenta);
      break;
    case 1406:
      HASH_INVOKE_FROM_EVAL(0x31529E9BCA1E157ELL, shm_remove);
      HASH_INVOKE_FROM_EVAL(0x132776D93181E57ELL, ldap_set_option);
      break;
    case 1410:
      HASH_INVOKE_FROM_EVAL(0x02688986D5D76582LL, magickspreadimage);
      HASH_INVOKE_FROM_EVAL(0x0B1F0EB755BDB582LL, ispixeliterator);
      break;
    case 1411:
      HASH_INVOKE_FROM_EVAL(0x3B2CD86F5DB72583LL, magickblackthresholdimage);
      break;
    case 1419:
      HASH_INVOKE_FROM_EVAL(0x1EF2C1426AB0A58BLL, dom_node_replace_child);
      HASH_INVOKE_FROM_EVAL(0x3A34B44E4C51C58BLL, xml_set_element_handler);
      break;
    case 1420:
      HASH_INVOKE_FROM_EVAL(0x560C2F71978CE58CLL, shm_put_var);
      break;
    case 1426:
      HASH_INVOKE_FROM_EVAL(0x3E9519FE856C4592LL, curl_multi_init);
      HASH_INVOKE_FROM_EVAL(0x5464E148E8A0C592LL, get_extension_funcs);
      HASH_INVOKE_FROM_EVAL(0x7F65501600346592LL, mcrypt_get_block_size);
      break;
    case 1427:
      HASH_INVOKE_FROM_EVAL(0x0F5984B8A7FD8593LL, hphp_splfileinfo_getperms);
      break;
    case 1431:
      HASH_INVOKE_FROM_EVAL(0x513787A813DB0597LL, date_date_set);
      break;
    case 1433:
      HASH_INVOKE_FROM_EVAL(0x12F502A88E0AA599LL, magickcompositeimage);
      break;
    case 1434:
      HASH_INVOKE_FROM_EVAL(0x77F1EDE7D5EF759ALL, apc_cache_info);
      break;
    case 1435:
      HASH_INVOKE_FROM_EVAL(0x37D003B09D0C759BLL, stream_get_contents);
      break;
    case 1440:
      HASH_INVOKE_FROM_EVAL(0x20502FCACBB9F5A0LL, convert_uuencode);
      break;
    case 1441:
      HASH_INVOKE_FROM_EVAL(0x297690F3A63335A1LL, magickrotateimage);
      break;
    case 1444:
      HASH_INVOKE_FROM_EVAL(0x3C014439AE5D75A4LL, magickgetcharheight);
      break;
    case 1448:
      HASH_INVOKE_FROM_EVAL(0x4FBB1F662399A5A8LL, is_soap_fault);
      break;
    case 1452:
      HASH_INVOKE_FROM_EVAL(0x763BA2B1C60A55ACLL, pixelgetalphaquantum);
      break;
    case 1453:
      HASH_INVOKE_FROM_EVAL(0x4110AF96B98B25ADLL, gzeof);
      break;
    case 1455:
      HASH_INVOKE_FROM_EVAL(0x1636FBA5043CF5AFLL, ldap_error);
      break;
    case 1459:
      HASH_INVOKE_FROM_EVAL(0x001DBE44BC0B55B3LL, magicksetimagecolormapcolor);
      HASH_INVOKE_FROM_EVAL(0x7AFA32F70E8195B3LL, xbox_set_thread_timeout);
      break;
    case 1461:
      HASH_INVOKE_FROM_EVAL(0x3F9C5B4708FC55B5LL, timezone_name_get);
      HASH_INVOKE_FROM_EVAL(0x5EFE573046B565B5LL, mcrypt_module_close);
      break;
    case 1462:
      HASH_INVOKE_FROM_EVAL(0x1A05907F563235B6LL, collator_set_attribute);
      break;
    case 1466:
      HASH_INVOKE_FROM_EVAL(0x05B8EB2C515885BALL, vprintf);
      break;
    case 1472:
      HASH_INVOKE_FROM_EVAL(0x61465CD8C67905C0LL, openssl_pkey_free);
      break;
    case 1473:
      HASH_INVOKE_FROM_EVAL(0x7731B90FB7C975C1LL, magickremoveimageprofile);
      break;
    case 1478:
      HASH_INVOKE_FROM_EVAL(0x3B3D5CE69B1565C6LL, mcrypt_module_is_block_mode);
      break;
    case 1480:
      HASH_INVOKE_FROM_EVAL(0x1CE8175A87C785C8LL, dom_document_validate);
      break;
    case 1481:
      HASH_INVOKE_FROM_EVAL(0x75B299F5E35A95C9LL, mb_strwidth);
      HASH_INVOKE_FROM_EVAL(0x60F8818C0F38D5C9LL, hphp_directoryiterator___tostring);
      break;
    case 1483:
      HASH_INVOKE_FROM_EVAL(0x6751946191FBE5CBLL, override_function);
      break;
    case 1484:
      HASH_INVOKE_FROM_EVAL(0x2A6F86821A39C5CCLL, expm1);
      break;
    case 1486:
      HASH_INVOKE_FROM_EVAL(0x406AC1DDB92925CELL, parse_hdf_file);
      break;
    case 1487:
      HASH_INVOKE_FROM_EVAL(0x5D9818B3E1C385CFLL, openssl_pkey_export_to_file);
      break;
    case 1489:
      HASH_INVOKE_FROM_EVAL(0x054503DBBF5CA5D1LL, imagecopy);
      break;
    case 1492:
      HASH_INVOKE_FROM_EVAL(0x2FE56B4C457AB5D4LL, ctype_graph);
      break;
    case 1493:
      HASH_INVOKE_FROM_EVAL(0x43901543EA8625D5LL, curl_multi_select);
      break;
    case 1494:
      HASH_INVOKE_FROM_EVAL(0x6D265875A19685D6LL, is_float);
      break;
    case 1495:
      HASH_INVOKE_FROM_EVAL(0x617AD1AD708785D7LL, magickmodulateimage);
      break;
    case 1508:
      HASH_INVOKE_FROM_EVAL(0x3A9643992AC805E4LL, magickdrawimage);
      break;
    case 1509:
      HASH_INVOKE_FROM_EVAL(0x470F990B218315E5LL, fb_unset_taint);
      break;
    case 1510:
      HASH_INVOKE_FROM_EVAL(0x6FE2E44FBC44E5E6LL, magickaddnoiseimage);
      HASH_INVOKE_FROM_EVAL(0x08069ECE0EA3C5E6LL, imagecopymergegray);
      break;
    case 1514:
      HASH_INVOKE_FROM_EVAL(0x0B7ACBAB402015EALL, mb_send_mail);
      break;
    case 1518:
      HASH_INVOKE_FROM_EVAL(0x3076D369F63E65EELL, pixelgetalpha);
      break;
    case 1524:
      HASH_INVOKE_FROM_EVAL(0x1E89F15B7F2805F4LL, openssl_pkcs7_encrypt);
      HASH_INVOKE_FROM_EVAL(0x459330C31956A5F4LL, vsprintf);
      break;
    case 1525:
      HASH_INVOKE_FROM_EVAL(0x0D1BD0E5AF4175F5LL, drawsetfont);
      HASH_INVOKE_FROM_EVAL(0x73A1F34DF95B35F5LL, get_defined_constants);
      break;
    case 1527:
      HASH_INVOKE_FROM_EVAL(0x18E4CC945005E5F7LL, drawpushclippath);
      break;
    case 1528:
      HASH_INVOKE_FROM_EVAL(0x7C48F6EA39B7B5F8LL, magickadaptivethresholdimage);
      break;
    case 1531:
      HASH_INVOKE_FROM_EVAL(0x3535B6615F2B05FBLL, session_cache_limiter);
      HASH_INVOKE_FROM_EVAL(0x0FEC4ED541B7F5FBLL, magickgetimagevirtualpixelmethod);
      break;
    case 1532:
      HASH_INVOKE_FROM_EVAL(0x39156C7CCE2D75FCLL, hash_update);
      break;
    case 1533:
      HASH_INVOKE_FROM_EVAL(0x0C1CB24A3FC065FDLL, bcmul);
      HASH_INVOKE_FROM_EVAL(0x46832743CAF5C5FDLL, dom_element_set_attribute_node);
      break;
    case 1534:
      HASH_INVOKE_FROM_EVAL(0x397D3C6576ED75FELL, set_include_path);
      break;
    case 1535:
      HASH_INVOKE_FROM_EVAL(0x40A557CBB9FC35FFLL, mysql_tablename);
      break;
    case 1536:
      HASH_INVOKE_FROM_EVAL(0x552D7CAD93755600LL, dom_document_create_comment);
      break;
    case 1537:
      HASH_INVOKE_FROM_EVAL(0x0F3403D8676C2601LL, mysql_query);
      break;
    case 1545:
      HASH_INVOKE_FROM_EVAL(0x52D5698F31D12609LL, pcntl_setpriority);
      break;
    case 1555:
      HASH_INVOKE_FROM_EVAL(0x36783304F63C4613LL, sscanf);
      HASH_INVOKE_FROM_EVAL(0x4AC405EA2B8C4613LL, magickresetiterator);
      break;
    case 1557:
      HASH_INVOKE_FROM_EVAL(0x6AD774816F8F7615LL, mb_strrchr);
      break;
    case 1558:
      HASH_INVOKE_FROM_EVAL(0x66C7616225F1C616LL, pixelsetgreen);
      HASH_INVOKE_FROM_EVAL(0x7FA6D13B0D38E616LL, imagegif);
      break;
    case 1561:
      HASH_INVOKE_FROM_EVAL(0x6DD51BF03F003619LL, mailparse_uudecode_all);
      HASH_INVOKE_FROM_EVAL(0x2F29627AF1A97619LL, shm_attach);
      break;
    case 1563:
      HASH_INVOKE_FROM_EVAL(0x40DDE277D934061BLL, gzputs);
      break;
    case 1564:
      HASH_INVOKE_FROM_EVAL(0x70725954DC99F61CLL, mcrypt_create_iv);
      break;
    case 1565:
      HASH_INVOKE_FROM_EVAL(0x69E1368FD737F61DLL, dom_namednodemap_get_named_item);
      HASH_INVOKE_FROM_EVAL(0x7E98B97C1B5D861DLL, magickqueryconfigureoptions);
      break;
    case 1569:
      HASH_INVOKE_FROM_EVAL(0x0F71DDE51AA55621LL, hphp_output_global_state);
      break;
    case 1570:
      HASH_INVOKE_FROM_EVAL(0x134550B9EB596622LL, drawgetfontstyle);
      break;
    case 1576:
      HASH_INVOKE_FROM_EVAL(0x1E77B3BCF062D628LL, magickreadimage);
      break;
    case 1577:
      HASH_INVOKE_FROM_EVAL(0x679B81CE06EE0629LL, bcdiv);
      break;
    case 1578:
      HASH_INVOKE_FROM_EVAL(0x608EA42B08A7462ALL, linkinfo);
      break;
    case 1580:
      HASH_INVOKE_FROM_EVAL(0x5CEA60D9C54A162CLL, pcntl_wifstopped);
      break;
    case 1583:
      HASH_INVOKE_FROM_EVAL(0x652C331CE138362FLL, is_string);
      break;
    case 1585:
      HASH_INVOKE_FROM_EVAL(0x5AD6595ACA656631LL, pixelresetiterator);
      break;
    case 1591:
      HASH_INVOKE_FROM_EVAL(0x60276BC7990F9637LL, mysql_list_dbs);
      HASH_INVOKE_FROM_EVAL(0x75AFA49220C9B637LL, collator_sort);
      break;
    case 1595:
      HASH_INVOKE_FROM_EVAL(0x391C68F2BE85E63BLL, pixelgetiteratorexceptionstring);
      break;
    case 1596:
      HASH_INVOKE_FROM_EVAL(0x62DE03461EF4663CLL, symlink);
      break;
    case 1598:
      HASH_INVOKE_FROM_EVAL(0x60302D15A677963ELL, ldap_free_result);
      break;
    case 1599:
      HASH_INVOKE_FROM_EVAL(0x17242BC6C9C9563FLL, crypt);
      break;
    case 1606:
      HASH_INVOKE_FROM_EVAL(0x4901517CB796F646LL, msg_set_queue);
      HASH_INVOKE_FROM_EVAL(0x234F6A0A486E8646LL, natcasesort);
      break;
    case 1614:
      HASH_INVOKE_FROM_EVAL(0x7E978C38D741664ELL, fgetcsv);
      HASH_INVOKE_FROM_EVAL(0x769E5C6A5369F64ELL, ob_list_handlers);
      break;
    case 1618:
      HASH_INVOKE_FROM_EVAL(0x03066277F647E652LL, hphp_splfileobject_ftell);
      break;
    case 1621:
      HASH_INVOKE_FROM_EVAL(0x629EDDC1E74ED655LL, array_uintersect_assoc);
      break;
    case 1625:
      HASH_INVOKE_FROM_EVAL(0x7A4B37C23D674659LL, collator_get_error_message);
      break;
    case 1628:
      HASH_INVOKE_FROM_EVAL(0x381BBFEABFEC865CLL, libxml_get_last_error);
      break;
    case 1630:
      HASH_INVOKE_FROM_EVAL(0x1491ED033E39465ELL, dom_document_schema_validate_xml);
      HASH_INVOKE_FROM_EVAL(0x205BB9CFF397B65ELL, ldap_mod_replace);
      break;
    case 1631:
      HASH_INVOKE_FROM_EVAL(0x1355AFB40AB1165FLL, drawsetfontstyle);
      break;
    case 1634:
      HASH_INVOKE_FROM_EVAL(0x5629E14D6B9FF662LL, dom_document_get_element_by_id);
      break;
    case 1636:
      HASH_INVOKE_FROM_EVAL(0x5B0759F776EC2664LL, newdrawingwand);
      break;
    case 1637:
      HASH_INVOKE_FROM_EVAL(0x08A6AD20C2C5A665LL, hphp_set_static_property);
      break;
    case 1639:
      HASH_INVOKE_FROM_EVAL(0x557A08AC57724667LL, hphp_splfileinfo_getpathinfo);
      break;
    case 1647:
      HASH_INVOKE_FROM_EVAL(0x7D68CADB8069466FLL, magickaverageimages);
      break;
    case 1651:
      HASH_INVOKE_FROM_EVAL(0x126FC82D358E9673LL, magicksetimagevirtualpixelmethod);
      break;
    case 1655:
      HASH_INVOKE_FROM_EVAL(0x001F23CAC36E3677LL, magickgetimagescene);
      break;
    case 1658:
      HASH_INVOKE_FROM_EVAL(0x583AA7498A40E67ALL, drawgetcliprule);
      break;
    case 1659:
      HASH_INVOKE_FROM_EVAL(0x5BCED33A57D9B67BLL, intval);
      break;
    case 1660:
      HASH_INVOKE_FROM_EVAL(0x43B1BAFFB27F367CLL, session_is_registered);
      break;
    case 1661:
      HASH_INVOKE_FROM_EVAL(0x69616E2817E1967DLL, fileinode);
      HASH_INVOKE_FROM_EVAL(0x111DACCF8628267DLL, array_replace_recursive);
      break;
    case 1666:
      HASH_INVOKE_FROM_EVAL(0x665D2615E377A682LL, pagelet_server_task_start);
      HASH_INVOKE_FROM_EVAL(0x5F6750E1C7E5D682LL, imageinterlace);
      break;
    case 1677:
      HASH_INVOKE_FROM_EVAL(0x07A946E3DD8E968DLL, ldap_connect);
      break;
    case 1679:
      HASH_INVOKE_FROM_EVAL(0x2EFF4F69EB1DF68FLL, apache_get_config);
      break;
    case 1680:
      HASH_INVOKE_FROM_EVAL(0x166D5E2336878690LL, imagepolygon);
      break;
    case 1681:
      HASH_INVOKE_FROM_EVAL(0x57BA0BC1A4870691LL, magickgetquantumdepth);
      break;
    case 1682:
      HASH_INVOKE_FROM_EVAL(0x16BE0DBA42800692LL, magickgetimagesize);
      break;
    case 1684:
      HASH_INVOKE_FROM_EVAL(0x2673FAB2B4DE4694LL, destroypixelwands);
      break;
    case 1685:
      HASH_INVOKE_FROM_EVAL(0x7186EF5EF0581695LL, exp);
      break;
    case 1686:
      HASH_INVOKE_FROM_EVAL(0x0DD7A2DB53093696LL, utf8_decode);
      break;
    case 1690:
      HASH_INVOKE_FROM_EVAL(0x5CC40F6A365FE69ALL, session_register);
      break;
    case 1691:
      HASH_INVOKE_FROM_EVAL(0x24D34E49C21DE69BLL, mb_stristr);
      break;
    case 1694:
      HASH_INVOKE_FROM_EVAL(0x5E9821F06711669ELL, gethostbynamel);
      break;
    case 1702:
      HASH_INVOKE_FROM_EVAL(0x0D841874977646A6LL, krsort);
      break;
    case 1703:
      HASH_INVOKE_FROM_EVAL(0x38BBEE42F136D6A7LL, magickgetimageblueprimary);
      break;
    case 1704:
      HASH_INVOKE_FROM_EVAL(0x45AB8F419BA666A8LL, drawpathlinetohorizontalabsolute);
      break;
    case 1706:
      HASH_INVOKE_FROM_EVAL(0x6E9D4D3A119D76AALL, wandgetexceptiontype);
      HASH_INVOKE_FROM_EVAL(0x48C4DB333172F6AALL, parse_url);
      HASH_INVOKE_FROM_EVAL(0x541926FB6D6FC6AALL, magickgetimagecolors);
      break;
    case 1707:
      HASH_INVOKE_FROM_EVAL(0x72B3F8E02D8B16ABLL, array_unshift);
      break;
    case 1711:
      HASH_INVOKE_FROM_EVAL(0x65497D63C0D716AFLL, getdate);
      break;
    case 1712:
      HASH_INVOKE_FROM_EVAL(0x23AAF570C78AC6B0LL, ip2long);
      break;
    case 1714:
      HASH_INVOKE_FROM_EVAL(0x0D669C546C0EC6B2LL, proc_terminate);
      break;
    case 1717:
      HASH_INVOKE_FROM_EVAL(0x798B4197212456B5LL, bcpowmod);
      HASH_INVOKE_FROM_EVAL(0x623CE67C41A9E6B5LL, ldap_next_attribute);
      HASH_INVOKE_FROM_EVAL(0x7E773A36449576B5LL, imagecharup);
      break;
    case 1719:
      HASH_INVOKE_FROM_EVAL(0x0C44E5EEB9C646B7LL, memcache_connect);
      break;
    case 1721:
      HASH_INVOKE_FROM_EVAL(0x316F054CB76446B9LL, openssl_sign);
      break;
    case 1722:
      HASH_INVOKE_FROM_EVAL(0x4605D48C234606BALL, dom_document_import_node);
      HASH_INVOKE_FROM_EVAL(0x72B901C3605CB6BALL, pixelsetopacity);
      break;
    case 1726:
      HASH_INVOKE_FROM_EVAL(0x081D5EA9920076BELL, drawgetfillalpha);
      break;
    case 1732:
      HASH_INVOKE_FROM_EVAL(0x4842AF70A71BE6C4LL, uksort);
      HASH_INVOKE_FROM_EVAL(0x34184B42D6AA86C4LL, mb_ereg_search_pos);
      HASH_INVOKE_FROM_EVAL(0x3C042C09F662C6C4LL, drawsetstrokepatternurl);
      break;
    case 1733:
      HASH_INVOKE_FROM_EVAL(0x28526EF49FF516C5LL, pixelsetgreenquantum);
      break;
    case 1736:
      HASH_INVOKE_FROM_EVAL(0x29DD2C9F889246C8LL, passthru);
      break;
    case 1737:
      HASH_INVOKE_FROM_EVAL(0x2D8DF100C30D06C9LL, xmlwriter_set_indent_string);
      break;
    case 1738:
      HASH_INVOKE_FROM_EVAL(0x41BCD0A72B1396CALL, xmlwriter_start_dtd_attlist);
      break;
    case 1745:
      HASH_INVOKE_FROM_EVAL(0x2B3D5B9AF915D6D1LL, imagecopymerge);
      break;
    case 1746:
      HASH_INVOKE_FROM_EVAL(0x1FDF80EA9B8A96D2LL, collator_set_strength);
      break;
    case 1748:
      HASH_INVOKE_FROM_EVAL(0x04A0E6E8337E56D4LL, drawcolor);
      break;
    case 1749:
      HASH_INVOKE_FROM_EVAL(0x317FFA522A7D96D5LL, imagefilledpolygon);
      break;
    case 1750:
      HASH_INVOKE_FROM_EVAL(0x158348EB08F406D6LL, strtr);
      break;
    case 1761:
      HASH_INVOKE_FROM_EVAL(0x11DA0A0EB8E0D6E1LL, clock_getres);
      break;
    case 1764:
      HASH_INVOKE_FROM_EVAL(0x40D0E3AF799226E4LL, bin2hex);
      HASH_INVOKE_FROM_EVAL(0x1CF3544CB5C9D6E4LL, xml_set_processing_instruction_handler);
      HASH_INVOKE_FROM_EVAL(0x31FFFC333AA6D6E4LL, drawsetfillrule);
      break;
    case 1767:
      HASH_INVOKE_FROM_EVAL(0x44201A16F3D876E7LL, trim);
      break;
    case 1772:
      HASH_INVOKE_FROM_EVAL(0x0A5EFECAE87EA6ECLL, hphp_splfileobject_eof);
      break;
    case 1773:
      HASH_INVOKE_FROM_EVAL(0x04BD4B43921956EDLL, ldap_search);
      HASH_INVOKE_FROM_EVAL(0x2B661CD43C6006EDLL, hphpd_break);
      break;
    case 1774:
      HASH_INVOKE_FROM_EVAL(0x76382756EA00B6EELL, is_object);
      break;
    case 1775:
      HASH_INVOKE_FROM_EVAL(0x0FA74D85885F86EFLL, output_add_rewrite_var);
      break;
    case 1776:
      HASH_INVOKE_FROM_EVAL(0x014BD9A6823256F0LL, extract);
      break;
    case 1777:
      HASH_INVOKE_FROM_EVAL(0x6B7347DF1AA7E6F1LL, drawpopdefs);
      break;
    case 1778:
      HASH_INVOKE_FROM_EVAL(0x314DA880FE2CE6F2LL, session_start);
      break;
    case 1779:
      HASH_INVOKE_FROM_EVAL(0x6F1968BE449FB6F3LL, stream_socket_pair);
      HASH_INVOKE_FROM_EVAL(0x5768A80BB0B926F3LL, apd_set_session_trace_socket);
      break;
    case 1782:
      HASH_INVOKE_FROM_EVAL(0x534C1A5E626C26F6LL, collator_get_error_code);
      break;
    case 1785:
      HASH_INVOKE_FROM_EVAL(0x20740D956F0236F9LL, image2wbmp);
      break;
    case 1791:
      HASH_INVOKE_FROM_EVAL(0x623C20A027A606FFLL, array_uintersect_uassoc);
      break;
    case 1793:
      HASH_INVOKE_FROM_EVAL(0x1A80392751AA7701LL, magickgetformat);
      break;
    case 1796:
      HASH_INVOKE_FROM_EVAL(0x5EFE15CE970A5704LL, drawpolyline);
      break;
    case 1801:
      HASH_INVOKE_FROM_EVAL(0x7681C631B34CC709LL, hphp_splfileobject_fflush);
      HASH_INVOKE_FROM_EVAL(0x21972B2BC7A14709LL, imageistruecolor);
      break;
    case 1803:
      HASH_INVOKE_FROM_EVAL(0x27AF8F6A5DF0B70BLL, dom_document_xinclude);
      HASH_INVOKE_FROM_EVAL(0x5F7873F2DF5BE70BLL, ctype_cntrl);
      break;
    case 1805:
      HASH_INVOKE_FROM_EVAL(0x7CE752299E80B70DLL, unserialize);
      HASH_INVOKE_FROM_EVAL(0x4F3C0DB2F6C8F70DLL, unlink);
      break;
    case 1807:
      HASH_INVOKE_FROM_EVAL(0x2FB2FA1DD832C70FLL, xmlwriter_write_attribute_ns);
      break;
    case 1812:
      HASH_INVOKE_FROM_EVAL(0x1778ED2AF035F714LL, rsort);
      break;
    case 1813:
      HASH_INVOKE_FROM_EVAL(0x25D578B4772C1715LL, define);
      break;
    case 1816:
      HASH_INVOKE_FROM_EVAL(0x7971A5647C957718LL, date_time_set);
      break;
    case 1819:
      HASH_INVOKE_FROM_EVAL(0x3C16230CBC6D471BLL, imagecreatetruecolor);
      break;
    case 1820:
      HASH_INVOKE_FROM_EVAL(0x50AC61A28C5AC71CLL, imagecolorclosestalpha);
      break;
    case 1824:
      HASH_INVOKE_FROM_EVAL(0x2D213FD80048F720LL, usleep);
      break;
    case 1827:
      HASH_INVOKE_FROM_EVAL(0x78420E0B5D110723LL, imagetruecolortopalette);
      break;
    case 1828:
      HASH_INVOKE_FROM_EVAL(0x4DAA3FBC2BD3A724LL, magickequalizeimage);
      break;
    case 1829:
      HASH_INVOKE_FROM_EVAL(0x31EAD049860CE725LL, posix_kill);
      break;
    case 1830:
      HASH_INVOKE_FROM_EVAL(0x523AB2EA95DAD726LL, get_included_files);
      break;
    case 1831:
      HASH_INVOKE_FROM_EVAL(0x11641BE0F11CD727LL, magickgammaimage);
      break;
    case 1833:
      HASH_INVOKE_FROM_EVAL(0x1D30F1E638D71729LL, readgzfile);
      break;
    case 1834:
      HASH_INVOKE_FROM_EVAL(0x17C0D9B1C10B872ALL, openssl_x509_export);
      HASH_INVOKE_FROM_EVAL(0x1F98B41362CDA72ALL, magickgetimagegreenprimary);
      break;
    case 1837:
      HASH_INVOKE_FROM_EVAL(0x14563723F798172DLL, magickpaintopaqueimage);
      break;
    case 1840:
      HASH_INVOKE_FROM_EVAL(0x0D558F552A784730LL, ob_get_contents);
      break;
    case 1842:
      HASH_INVOKE_FROM_EVAL(0x2B1C192C419B8732LL, drawgetexception);
      break;
    case 1850:
      HASH_INVOKE_FROM_EVAL(0x404236CC5ABD973ALL, xhprof_run_trace);
      break;
    case 1855:
      HASH_INVOKE_FROM_EVAL(0x650E641CC0E3873FLL, connection_aborted);
      break;
    case 1857:
      HASH_INVOKE_FROM_EVAL(0x5062777D2B947741LL, wordwrap);
      break;
    case 1863:
      HASH_INVOKE_FROM_EVAL(0x3CD58419E181A747LL, magickstereoimage);
      HASH_INVOKE_FROM_EVAL(0x13BB9EC5A2D2E747LL, hphp_splfileinfo_isdir);
      break;
    case 1864:
      HASH_INVOKE_FROM_EVAL(0x0D7BBA9608A36748LL, magickcombineimages);
      break;
    case 1865:
      HASH_INVOKE_FROM_EVAL(0x73E4417BA7B49749LL, curl_multi_info_read);
      break;
    case 1866:
      HASH_INVOKE_FROM_EVAL(0x1FF03B7DE19DD74ALL, drawpathmovetorelative);
      break;
    case 1867:
      HASH_INVOKE_FROM_EVAL(0x7DA9307A6149B74BLL, get_meta_tags);
      break;
    case 1873:
      HASH_INVOKE_FROM_EVAL(0x017FF216C00D9751LL, property_exists);
      break;
    case 1875:
      HASH_INVOKE_FROM_EVAL(0x42795829DF700753LL, mysql_get_host_info);
      break;
    case 1876:
      HASH_INVOKE_FROM_EVAL(0x53AEFD595C044754LL, max);
      break;
    case 1879:
      HASH_INVOKE_FROM_EVAL(0x7554E3E8674F2757LL, mb_list_encodings);
      break;
    case 1883:
      HASH_INVOKE_FROM_EVAL(0x05D293F45C15F75BLL, ldap_mod_del);
      break;
    case 1884:
      HASH_INVOKE_FROM_EVAL(0x6D5B592E524AF75CLL, hphp_splfileinfo_getbasename);
      break;
    case 1887:
      HASH_INVOKE_FROM_EVAL(0x3EDB48C5DDD9675FLL, socket_select);
      break;
    case 1888:
      HASH_INVOKE_FROM_EVAL(0x1BD984C11BB16760LL, array_merge);
      HASH_INVOKE_FROM_EVAL(0x7AB5E6EA37196760LL, date_timezone_set);
      break;
    case 1889:
      HASH_INVOKE_FROM_EVAL(0x6AF50085AC2AC761LL, xmlwriter_write_element);
      break;
    case 1891:
      HASH_INVOKE_FROM_EVAL(0x7FCE6DD53FED6763LL, intl_is_failure);
      break;
    case 1893:
      HASH_INVOKE_FROM_EVAL(0x1D803CE961921765LL, md5);
      HASH_INVOKE_FROM_EVAL(0x45631C592AD6D765LL, str_ireplace);
      break;
    case 1894:
      HASH_INVOKE_FROM_EVAL(0x1F4505BE6460D766LL, scandir);
      break;
    case 1895:
      HASH_INVOKE_FROM_EVAL(0x2FC27987B3F88767LL, dom_node_clone_node);
      HASH_INVOKE_FROM_EVAL(0x6C280D5855D20767LL, drawsetfillalpha);
      break;
    case 1896:
      HASH_INVOKE_FROM_EVAL(0x179A72074C778768LL, openssl_x509_export_to_file);
      break;
    case 1901:
      HASH_INVOKE_FROM_EVAL(0x3304663FBC6C976DLL, get_html_translation_table);
      HASH_INVOKE_FROM_EVAL(0x553ADA5A41AE976DLL, mb_ereg_replace);
      break;
    case 1902:
      HASH_INVOKE_FROM_EVAL(0x6DB71D850799D76ELL, hphp_splfileobject_fscanf);
      break;
    case 1904:
      HASH_INVOKE_FROM_EVAL(0x6F6C5B9E3DC64770LL, drawgetstrokemiterlimit);
      break;
    case 1909:
      HASH_INVOKE_FROM_EVAL(0x04D9076808F79775LL, getenv);
      break;
    case 1910:
      HASH_INVOKE_FROM_EVAL(0x616DDB67073A0776LL, ord);
      HASH_INVOKE_FROM_EVAL(0x4102C410C5031776LL, magickcolorizeimage);
      break;
    case 1914:
      HASH_INVOKE_FROM_EVAL(0x1FBF36B5D65E677ALL, fb_call_user_func_safe_return);
      HASH_INVOKE_FROM_EVAL(0x4330CE9C9002477ALL, array_udiff_uassoc);
      break;
    case 1915:
      HASH_INVOKE_FROM_EVAL(0x129E39AC523A977BLL, magickgethomeurl);
      break;
    case 1920:
      HASH_INVOKE_FROM_EVAL(0x29824AAA934CE780LL, array_filter);
      break;
    case 1923:
      HASH_INVOKE_FROM_EVAL(0x53B4DBE58B356783LL, imagesetthickness);
      HASH_INVOKE_FROM_EVAL(0x38704D99FEA9B783LL, mysql_fetch_array);
      break;
    case 1924:
      HASH_INVOKE_FROM_EVAL(0x784FD2E7191A3784LL, drawpathellipticarcrelative);
      break;
    case 1925:
      HASH_INVOKE_FROM_EVAL(0x5BFC6198960A5785LL, in_array);
      break;
    case 1927:
      HASH_INVOKE_FROM_EVAL(0x4991643BD854D787LL, drawgetexceptionstring);
      break;
    case 1928:
      HASH_INVOKE_FROM_EVAL(0x32D8CE5D0FA6D788LL, ldap_rename);
      break;
    case 1930:
      HASH_INVOKE_FROM_EVAL(0x70A1EC006032E78ALL, pixelgetquantumcolor);
      break;
    case 1935:
      HASH_INVOKE_FROM_EVAL(0x7B4E25772D0AC78FLL, simplexml_load_file);
      break;
    case 1938:
      HASH_INVOKE_FROM_EVAL(0x0D4891A5E1A20792LL, get_defined_functions);
      break;
    case 1941:
      HASH_INVOKE_FROM_EVAL(0x34BA3AAA6711C795LL, dom_document_create_entity_reference);
      break;
    case 1942:
      HASH_INVOKE_FROM_EVAL(0x5B42B2AB1B57D796LL, array_replace);
      break;
    case 1945:
      HASH_INVOKE_FROM_EVAL(0x26D226FD28566799LL, date_isodate_set);
      break;
    case 1947:
      HASH_INVOKE_FROM_EVAL(0x1196D899ACCD379BLL, evhttp_recv);
      break;
    case 1949:
      HASH_INVOKE_FROM_EVAL(0x02ECD8C169DF579DLL, feof);
      break;
    case 1951:
      HASH_INVOKE_FROM_EVAL(0x4B092931EFB7979FLL, mysql_create_db);
      break;
    case 1959:
      HASH_INVOKE_FROM_EVAL(0x1F76E954F9A147A7LL, magickcontrastimage);
      break;
    case 1961:
      HASH_INVOKE_FROM_EVAL(0x7C251B7DE8DB87A9LL, mcrypt_list_algorithms);
      HASH_INVOKE_FROM_EVAL(0x7707A7FEA07FB7A9LL, hphp_recursivedirectoryiterator___construct);
      break;
    case 1962:
      HASH_INVOKE_FROM_EVAL(0x45A53A884414A7AALL, pack);
      HASH_INVOKE_FROM_EVAL(0x58D6464A3A9127AALL, apc_bin_loadfile);
      break;
    case 1965:
      HASH_INVOKE_FROM_EVAL(0x7DA08D9D148837ADLL, posix_mkfifo);
      break;
    case 1966:
      HASH_INVOKE_FROM_EVAL(0x00141B0E3E6F77AELL, xml_set_unparsed_entity_decl_handler);
      break;
    case 1967:
      HASH_INVOKE_FROM_EVAL(0x16CB9891EF26D7AFLL, drawgetstrokedashoffset);
      break;
    case 1977:
      HASH_INVOKE_FROM_EVAL(0x1FC9406FD7FCD7B9LL, strrpos);
      HASH_INVOKE_FROM_EVAL(0x1B6467AD87E167B9LL, log1p);
      break;
    case 1983:
      HASH_INVOKE_FROM_EVAL(0x3F46374E6E1B07BFLL, posix_getpwuid);
      break;
    case 1984:
      HASH_INVOKE_FROM_EVAL(0x152D1AB941A647C0LL, hphp_get_extension_info);
      HASH_INVOKE_FROM_EVAL(0x52FDAC1D298D67C0LL, mcrypt_enc_get_algorithms_name);
      break;
    case 1985:
      HASH_INVOKE_FROM_EVAL(0x4E172EA6743697C1LL, ldap_first_entry);
      break;
    case 1988:
      HASH_INVOKE_FROM_EVAL(0x3C696836396BE7C4LL, mb_language);
      break;
    case 1990:
      HASH_INVOKE_FROM_EVAL(0x0C8A7BE6ABC957C6LL, clearpixeliterator);
      HASH_INVOKE_FROM_EVAL(0x3D6D684AF537A7C6LL, ldap_explode_dn);
      break;
    case 1991:
      HASH_INVOKE_FROM_EVAL(0x686C5142FD0337C7LL, lcg_value);
      break;
    case 1993:
      HASH_INVOKE_FROM_EVAL(0x6BF7D7B5FBFF77C9LL, hphp_get_thread_id);
      break;
    case 1994:
      HASH_INVOKE_FROM_EVAL(0x3C781898488687CALL, xml_parse);
      HASH_INVOKE_FROM_EVAL(0x55B68546CFAC87CALL, magicksetimageresolution);
      break;
    case 1998:
      HASH_INVOKE_FROM_EVAL(0x3AE33FEA6830C7CELL, magickshearimage);
      break;
    case 1999:
      HASH_INVOKE_FROM_EVAL(0x2FAB1F75659707CFLL, is_scalar);
      break;
    case 2001:
      HASH_INVOKE_FROM_EVAL(0x35B661C87484D7D1LL, openssl_csr_sign);
      break;
    case 2009:
      HASH_INVOKE_FROM_EVAL(0x2ED6760DAA3A67D9LL, strcasecmp);
      break;
    case 2012:
      HASH_INVOKE_FROM_EVAL(0x1FE65AFCC92967DCLL, rmdir);
      break;
    case 2013:
      HASH_INVOKE_FROM_EVAL(0x2B5AEDF1A5FC47DDLL, strripos);
      break;
    case 2017:
      HASH_INVOKE_FROM_EVAL(0x7AA1691D3D94A7E1LL, dom_xpath_evaluate);
      break;
    case 2018:
      HASH_INVOKE_FROM_EVAL(0x0888289CBD2887E2LL, iconv_substr);
      break;
    case 2020:
      HASH_INVOKE_FROM_EVAL(0x2621680306BC97E4LL, magicksetimagescene);
      break;
    case 2023:
      HASH_INVOKE_FROM_EVAL(0x4215DDB57604F7E7LL, xmlwriter_start_pi);
      break;
    case 2024:
      HASH_INVOKE_FROM_EVAL(0x53B7BF8991FA67E8LL, i18n_loc_get_error_code);
      break;
    case 2025:
      HASH_INVOKE_FROM_EVAL(0x6BB8AC68771287E9LL, strcmp);
      break;
    case 2027:
      HASH_INVOKE_FROM_EVAL(0x54AE7140B95027EBLL, pixelgetgreenquantum);
      HASH_INVOKE_FROM_EVAL(0x1A397501431EC7EBLL, is_numeric);
      break;
    case 2029:
      HASH_INVOKE_FROM_EVAL(0x0DC2C2D372EC97EDLL, hphp_crash_log);
      break;
    case 2031:
      HASH_INVOKE_FROM_EVAL(0x5367B0F3A4D2D7EFLL, ldap_list);
      break;
    case 2032:
      HASH_INVOKE_FROM_EVAL(0x14F700DD189DB7F0LL, drawsetclipunits);
      break;
    case 2035:
      HASH_INVOKE_FROM_EVAL(0x73877357478137F3LL, posix_ctermid);
      HASH_INVOKE_FROM_EVAL(0x4B57E07A323FE7F3LL, drawpathlinetoverticalabsolute);
      HASH_INVOKE_FROM_EVAL(0x7F436B50B7BBD7F3LL, getcwd);
      break;
    case 2041:
      HASH_INVOKE_FROM_EVAL(0x376FB2649384A7F9LL, str_pad);
      break;
    case 2042:
      HASH_INVOKE_FROM_EVAL(0x0FD7C3144B4007FALL, libxml_set_streams_context);
      break;
    case 2045:
      HASH_INVOKE_FROM_EVAL(0x238E501F2536E7FDLL, drawsetclippath);
      break;
    case 2048:
      HASH_INVOKE_FROM_EVAL(0x0E66983DD04B0800LL, get_current_user);
      break;
    case 2049:
      HASH_INVOKE_FROM_EVAL(0x290E54137CF06801LL, dom_nodelist_item);
      break;
    case 2051:
      HASH_INVOKE_FROM_EVAL(0x10F7244AA9CB5803LL, imagepstext);
      break;
    case 2052:
      HASH_INVOKE_FROM_EVAL(0x349A0DF6723B6804LL, pixelsetcolorcount);
      break;
    case 2054:
      HASH_INVOKE_FROM_EVAL(0x4D832DD6A72AB806LL, dom_document_create_attribute);
      break;
    case 2056:
      HASH_INVOKE_FROM_EVAL(0x19279D6DB4F70808LL, hash_hmac);
      HASH_INVOKE_FROM_EVAL(0x083B8F01AE15B808LL, assert);
      break;
    case 2057:
      HASH_INVOKE_FROM_EVAL(0x52DCFB6F41D41809LL, dom_characterdata_append_data);
      HASH_INVOKE_FROM_EVAL(0x221F5A9D5E021809LL, magickwriteimages);
      break;
    case 2058:
      HASH_INVOKE_FROM_EVAL(0x5A0D1AE1D4C6F80ALL, array_slice);
      break;
    case 2060:
      HASH_INVOKE_FROM_EVAL(0x3FF63423EC4B280CLL, posix_getegid);
      break;
    case 2061:
      HASH_INVOKE_FROM_EVAL(0x11EC19E702F2C80DLL, getmyinode);
      HASH_INVOKE_FROM_EVAL(0x727F5A6D8E26B80DLL, extension_loaded);
      break;
    case 2064:
      HASH_INVOKE_FROM_EVAL(0x4297B1072CE76810LL, fb_call_user_func_array_safe);
      break;
    case 2067:
      HASH_INVOKE_FROM_EVAL(0x1A6B577442218813LL, pixelsetmagentaquantum);
      HASH_INVOKE_FROM_EVAL(0x5F7940A713863813LL, floor);
      break;
    case 2068:
      HASH_INVOKE_FROM_EVAL(0x3C0DFA15D3447814LL, rawurldecode);
      break;
    case 2071:
      HASH_INVOKE_FROM_EVAL(0x0D8B1D0A8C381817LL, stream_bucket_new);
      break;
    case 2072:
      HASH_INVOKE_FROM_EVAL(0x0FBDB0B22A59B818LL, mailparse_msg_parse);
      break;
    case 2077:
      HASH_INVOKE_FROM_EVAL(0x4D624A655A9B581DLL, drawpoint);
      break;
    case 2081:
      HASH_INVOKE_FROM_EVAL(0x2D52FB9B52EC2821LL, xml_set_notation_decl_handler);
      HASH_INVOKE_FROM_EVAL(0x107DBCA79C15B821LL, addcslashes);
      break;
    case 2082:
      HASH_INVOKE_FROM_EVAL(0x13C241C02DE72822LL, dom_document_relaxng_validate_xml);
      break;
    case 2084:
      HASH_INVOKE_FROM_EVAL(0x2B78E204F615A824LL, openssl_pkcs12_export_to_file);
      break;
    case 2087:
      HASH_INVOKE_FROM_EVAL(0x33EC567341B9C827LL, magickgetmaxtextadvance);
      break;
    case 2089:
      HASH_INVOKE_FROM_EVAL(0x39EE4CCCA716E829LL, stream_context_get_options);
      HASH_INVOKE_FROM_EVAL(0x57FFCEB7FA2D9829LL, usort);
      break;
    case 2092:
      HASH_INVOKE_FROM_EVAL(0x34F0E032AB05C82CLL, pixelsetblue);
      break;
    case 2093:
      HASH_INVOKE_FROM_EVAL(0x1C4AE57BF4E4A82DLL, apc_dec);
      break;
    case 2094:
      HASH_INVOKE_FROM_EVAL(0x3402C1E7544C382ELL, lstat);
      break;
    case 2095:
      HASH_INVOKE_FROM_EVAL(0x79A05154A7F5482FLL, magickgetimagedelay);
      break;
    case 2096:
      HASH_INVOKE_FROM_EVAL(0x5BBFA7EAEBD25830LL, pixelgetcyanquantum);
      break;
    case 2100:
      HASH_INVOKE_FROM_EVAL(0x605132E71CE7D834LL, array_push);
      break;
    case 2101:
      HASH_INVOKE_FROM_EVAL(0x1C4A162E6635B835LL, imageftbbox);
      HASH_INVOKE_FROM_EVAL(0x43A96BA7F58EB835LL, hphp_splfileobject_valid);
      break;
    case 2104:
      HASH_INVOKE_FROM_EVAL(0x63E554E0F11CE838LL, mysql_unbuffered_query);
      HASH_INVOKE_FROM_EVAL(0x03098F16B0AD5838LL, mcrypt_module_get_supported_key_sizes);
      HASH_INVOKE_FROM_EVAL(0x0890F9052322E838LL, fstat);
      break;
    case 2107:
      HASH_INVOKE_FROM_EVAL(0x63E2EA180786B83BLL, pixelsetblack);
      break;
    case 2108:
      HASH_INVOKE_FROM_EVAL(0x7C8969C75CA1783CLL, get_declared_classes);
      HASH_INVOKE_FROM_EVAL(0x034EDEBD109FD83CLL, filesize);
      break;
    case 2115:
      HASH_INVOKE_FROM_EVAL(0x567A7139AD476843LL, socket_listen);
      break;
    case 2118:
      HASH_INVOKE_FROM_EVAL(0x50088ED5D482C846LL, ldap_mod_add);
      break;
    case 2119:
      HASH_INVOKE_FROM_EVAL(0x4E69A952E3EA4847LL, magicksetfilename);
      break;
    case 2122:
      HASH_INVOKE_FROM_EVAL(0x7D3F626E636C084ALL, ldap_delete);
      break;
    case 2123:
      HASH_INVOKE_FROM_EVAL(0x68B7597C22FA484BLL, openssl_public_encrypt);
      break;
    case 2124:
      HASH_INVOKE_FROM_EVAL(0x26A2BBC465A2B84CLL, strcoll);
      break;
    case 2126:
      HASH_INVOKE_FROM_EVAL(0x488C2F267BF2884ELL, array_intersect);
      break;
    case 2127:
      HASH_INVOKE_FROM_EVAL(0x632D491E42E7E84FLL, session_get_cookie_params);
      break;
    case 2128:
      HASH_INVOKE_FROM_EVAL(0x4DDB82A3632FA850LL, atan);
      break;
    case 2129:
      HASH_INVOKE_FROM_EVAL(0x488BFCC942C73851LL, gzopen);
      break;
    case 2134:
      HASH_INVOKE_FROM_EVAL(0x51FD8C9B5109F856LL, dom_characterdata_replace_data);
      break;
    case 2140:
      HASH_INVOKE_FROM_EVAL(0x5A017A4C6A41E85CLL, curl_multi_add_handle);
      break;
    case 2142:
      HASH_INVOKE_FROM_EVAL(0x3D8327794429585ELL, hphpd_install_user_command);
      HASH_INVOKE_FROM_EVAL(0x6B4DE6865142285ELL, destroypixeliterator);
      break;
    case 2145:
      HASH_INVOKE_FROM_EVAL(0x2AD6B0E3B9F3B861LL, array_search);
      break;
    case 2147:
      HASH_INVOKE_FROM_EVAL(0x21B30164F5D49863LL, is_resource);
      break;
    case 2148:
      HASH_INVOKE_FROM_EVAL(0x168EDA8238EEE864LL, mb_detect_order);
      break;
    case 2151:
      HASH_INVOKE_FROM_EVAL(0x65A68A31B96E7867LL, hash);
      break;
    case 2152:
      HASH_INVOKE_FROM_EVAL(0x785C812E6292E868LL, i18n_loc_set_default);
      break;
    case 2153:
      HASH_INVOKE_FROM_EVAL(0x246EC2B1844DB869LL, pixelgetexception);
      break;
    case 2155:
      HASH_INVOKE_FROM_EVAL(0x0C1BBEDECEF1C86BLL, newmagickwand);
      break;
    case 2156:
      HASH_INVOKE_FROM_EVAL(0x6414504A6658286CLL, stripos);
      break;
    case 2159:
      HASH_INVOKE_FROM_EVAL(0x1476A177CC50686FLL, mb_strstr);
      break;
    case 2160:
      HASH_INVOKE_FROM_EVAL(0x34F50577C14C6870LL, array_diff_uassoc);
      break;
    case 2162:
      HASH_INVOKE_FROM_EVAL(0x3C7B86F57AFA0872LL, hebrev);
      HASH_INVOKE_FROM_EVAL(0x558D62FBEB210872LL, str_rot13);
      break;
    case 2163:
      HASH_INVOKE_FROM_EVAL(0x4C06B4AFC1C08873LL, str_shuffle);
      break;
    case 2167:
      HASH_INVOKE_FROM_EVAL(0x6AA3788C9B737877LL, magickdespeckleimage);
      break;
    case 2168:
      HASH_INVOKE_FROM_EVAL(0x00F8C6758B50B878LL, drawpathcurvetoquadraticbezierabsolute);
      break;
    case 2172:
      HASH_INVOKE_FROM_EVAL(0x11DFC3C9D916387CLL, hphp_splfileobject_ftruncate);
      HASH_INVOKE_FROM_EVAL(0x6451BCB825D1787CLL, chroot);
      break;
    case 2173:
      HASH_INVOKE_FROM_EVAL(0x54F84DC9A334287DLL, gzencode);
      HASH_INVOKE_FROM_EVAL(0x2B36081E0828487DLL, debug_print_backtrace);
      break;
    case 2176:
      HASH_INVOKE_FROM_EVAL(0x7549612A72BA5880LL, hphp_splfileinfo_getrealpath);
      break;
    case 2179:
      HASH_INVOKE_FROM_EVAL(0x3EBD8F559B4EA883LL, hphp_splfileobject_getflags);
      break;
    case 2180:
      HASH_INVOKE_FROM_EVAL(0x766CD15A7F2A0884LL, array_uintersect);
      break;
    case 2184:
      HASH_INVOKE_FROM_EVAL(0x1062CF2DA5443888LL, imagedashedline);
      break;
    case 2191:
      HASH_INVOKE_FROM_EVAL(0x5DDC2A079AB7988FLL, dom_document_schema_validate_file);
      HASH_INVOKE_FROM_EVAL(0x539868C56806688FLL, imagecopyresampled);
      break;
    case 2200:
      HASH_INVOKE_FROM_EVAL(0x4AC522FF7BB60898LL, xmlwriter_write_dtd_entity);
      break;
    case 2205:
      HASH_INVOKE_FROM_EVAL(0x1FC855F0E4F1189DLL, magickminifyimage);
      break;
    case 2208:
      HASH_INVOKE_FROM_EVAL(0x6B1A3BCE67BAC8A0LL, openssl_csr_new);
      break;
    case 2209:
      HASH_INVOKE_FROM_EVAL(0x1756D4437A4098A1LL, date_modify);
      break;
    case 2215:
      HASH_INVOKE_FROM_EVAL(0x57105D4E43B078A7LL, magicksetformat);
      HASH_INVOKE_FROM_EVAL(0x6C6B4B739AE1B8A7LL, curl_close);
      break;
    case 2217:
      HASH_INVOKE_FROM_EVAL(0x346B2DB3BA2378A9LL, imagecolormatch);
      break;
    case 2218:
      HASH_INVOKE_FROM_EVAL(0x44BC069A75EE98AALL, xhprof_disable);
      break;
    case 2219:
      HASH_INVOKE_FROM_EVAL(0x39F11BA6A4D778ABLL, strnatcmp);
      break;
    case 2220:
      HASH_INVOKE_FROM_EVAL(0x5B1F4C6424DDD8ACLL, openlog);
      break;
    case 2224:
      HASH_INVOKE_FROM_EVAL(0x2CEF8DDC092698B0LL, drawgetvectorgraphics);
      break;
    case 2226:
      HASH_INVOKE_FROM_EVAL(0x31830AA5032428B2LL, is_double);
      break;
    case 2230:
      HASH_INVOKE_FROM_EVAL(0x5866C5DF3A1AD8B6LL, dom_element_get_attribute_node);
      break;
    case 2236:
      HASH_INVOKE_FROM_EVAL(0x7AE3AE9B634988BCLL, stream_context_create);
      break;
    case 2244:
      HASH_INVOKE_FROM_EVAL(0x5C28BE7FFE6A68C4LL, xml_set_start_namespace_decl_handler);
      break;
    case 2245:
      HASH_INVOKE_FROM_EVAL(0x146A1A7658CCA8C5LL, asinh);
      break;
    case 2247:
      HASH_INVOKE_FROM_EVAL(0x4623383F8534E8C7LL, array_multisort);
      HASH_INVOKE_FROM_EVAL(0x6D9B9BE3CED388C7LL, apc_load_constants);
      break;
    case 2254:
      HASH_INVOKE_FROM_EVAL(0x3FFAA982E4B1E8CELL, date_offset_get);
      break;
    case 2257:
      HASH_INVOKE_FROM_EVAL(0x1015EB3F52B098D1LL, print);
      break;
    case 2258:
      HASH_INVOKE_FROM_EVAL(0x74EB6C564ABC68D2LL, dom_document_create_text_node);
      break;
    case 2260:
      HASH_INVOKE_FROM_EVAL(0x6DB4EE8696C7E8D4LL, magicksetimageiterations);
      break;
    case 2262:
      HASH_INVOKE_FROM_EVAL(0x2F585B36DDDB68D6LL, mb_convert_case);
      HASH_INVOKE_FROM_EVAL(0x26DC8AB4A9CBE8D6LL, iconv);
      break;
    case 2264:
      HASH_INVOKE_FROM_EVAL(0x3A65182A3E8908D8LL, openssl_open);
      break;
    case 2265:
      HASH_INVOKE_FROM_EVAL(0x18B64D6BFE4208D9LL, stream_get_transports);
      break;
    case 2267:
      HASH_INVOKE_FROM_EVAL(0x4052842EC87038DBLL, magickcropimage);
      break;
    case 2268:
      HASH_INVOKE_FROM_EVAL(0x31F50FDA18B888DCLL, magickgetimagetype);
      break;
    case 2276:
      HASH_INVOKE_FROM_EVAL(0x16A18007E10F48E4LL, socket_getsockname);
      break;
    case 2278:
      HASH_INVOKE_FROM_EVAL(0x69887F054A1E28E6LL, strtok);
      break;
    case 2279:
      HASH_INVOKE_FROM_EVAL(0x608729F27FA428E7LL, error_get_last);
      break;
    case 2280:
      HASH_INVOKE_FROM_EVAL(0x4F7ED8C3156AD8E8LL, magicksetimagedispose);
      break;
    case 2293:
      HASH_INVOKE_FROM_EVAL(0x45DA105C5B48F8F5LL, apd_set_pprof_trace);
      break;
    case 2295:
      HASH_INVOKE_FROM_EVAL(0x17582BEA497D48F7LL, ctype_alpha);
      break;
    case 2298:
      HASH_INVOKE_FROM_EVAL(0x6F0F82818B68A8FALL, array_values);
      break;
    case 2299:
      HASH_INVOKE_FROM_EVAL(0x214532C4A2BC28FBLL, ldap_next_entry);
      break;
    case 2300:
      HASH_INVOKE_FROM_EVAL(0x4C2AFB2EFDB1B8FCLL, stripslashes);
      break;
    case 2302:
      HASH_INVOKE_FROM_EVAL(0x047BF4D3D0ED08FELL, strchr);
      break;
    case 2315:
      HASH_INVOKE_FROM_EVAL(0x67B879A1120C190BLL, headers_sent);
      HASH_INVOKE_FROM_EVAL(0x2987B15E11FE890BLL, clock_settime);
      break;
    case 2321:
      HASH_INVOKE_FROM_EVAL(0x04F822B7817E5911LL, bindec);
      HASH_INVOKE_FROM_EVAL(0x0AFD4F231D6CB911LL, magickaddimage);
      HASH_INVOKE_FROM_EVAL(0x5B9B2C3B32906911LL, drawsetfillpatternurl);
      break;
    case 2323:
      HASH_INVOKE_FROM_EVAL(0x55757E1242390913LL, cos);
      break;
    case 2324:
      HASH_INVOKE_FROM_EVAL(0x6E22C6D840B44914LL, mcrypt_generic_init);
      break;
    case 2329:
      HASH_INVOKE_FROM_EVAL(0x022B16C0D64D7919LL, file_put_contents);
      break;
    case 2331:
      HASH_INVOKE_FROM_EVAL(0x37A3DF6E0795091BLL, memcache_increment);
      break;
    case 2333:
      HASH_INVOKE_FROM_EVAL(0x069C028EFEF8C91DLL, date);
      break;
    case 2335:
      HASH_INVOKE_FROM_EVAL(0x277D7E2D1F5C191FLL, drawpathcurvetoquadraticbezierrelative);
      HASH_INVOKE_FROM_EVAL(0x4E2C55C92D71F91FLL, magickcolorfloodfillimage);
      break;
    case 2337:
      HASH_INVOKE_FROM_EVAL(0x0F5917FFCDD6C921LL, mb_substr);
      break;
    case 2339:
      HASH_INVOKE_FROM_EVAL(0x044B276686B77923LL, fscanf);
      break;
    case 2346:
      HASH_INVOKE_FROM_EVAL(0x174C510386E6492ALL, hphp_directoryiterator_key);
      break;
    case 2349:
      HASH_INVOKE_FROM_EVAL(0x27363CE6CBFC392DLL, pcntl_wexitstatus);
      HASH_INVOKE_FROM_EVAL(0x2337F8C3EE17192DLL, sprintf);
      break;
    case 2350:
      HASH_INVOKE_FROM_EVAL(0x26E8B741BDDDC92ELL, xmlwriter_start_element);
      break;
    case 2352:
      HASH_INVOKE_FROM_EVAL(0x507CE1912FD74930LL, mail);
      HASH_INVOKE_FROM_EVAL(0x30972530BD557930LL, shell_exec);
      break;
    case 2354:
      HASH_INVOKE_FROM_EVAL(0x72C01E1D90BE5932LL, mcrypt_enc_get_block_size);
      break;
    case 2356:
      HASH_INVOKE_FROM_EVAL(0x4FB95164A5F84934LL, mcrypt_generic_end);
      break;
    case 2357:
      HASH_INVOKE_FROM_EVAL(0x46BD9A56BDE40935LL, mysql_escape_string);
      HASH_INVOKE_FROM_EVAL(0x06486B6912479935LL, zlib_get_coding_type);
      HASH_INVOKE_FROM_EVAL(0x48D3CA6CA0B29935LL, mb_regex_set_options);
      break;
    case 2361:
      HASH_INVOKE_FROM_EVAL(0x5B60C8396C624939LL, mb_substitute_character);
      break;
    case 2366:
      HASH_INVOKE_FROM_EVAL(0x3946D67A0D16D93ELL, hphp_splfileinfo_isreadable);
      HASH_INVOKE_FROM_EVAL(0x0CADFE289C92893ELL, socket_getpeername);
      break;
    case 2371:
      HASH_INVOKE_FROM_EVAL(0x7C565AD57BC84943LL, pixelsetindex);
      break;
    case 2373:
      HASH_INVOKE_FROM_EVAL(0x7CB0596B6CCFA945LL, split);
      break;
    case 2375:
      HASH_INVOKE_FROM_EVAL(0x630288865DE68947LL, php_strip_whitespace);
      break;
    case 2376:
      HASH_INVOKE_FROM_EVAL(0x6A3412DE82715948LL, openssl_x509_checkpurpose);
      break;
    case 2377:
      HASH_INVOKE_FROM_EVAL(0x243BB8B284895949LL, apache_get_rewrite_rules);
      break;
    case 2379:
      HASH_INVOKE_FROM_EVAL(0x37F356F578FA394BLL, substr);
      break;
    case 2381:
      HASH_INVOKE_FROM_EVAL(0x3D3AD12E52FF294DLL, imagecreatefromwbmp);
      break;
    case 2387:
      HASH_INVOKE_FROM_EVAL(0x068438AFD33A9953LL, imagecolorclosesthwb);
      break;
    case 2391:
      HASH_INVOKE_FROM_EVAL(0x253AC5D4E450A957LL, magickgetreleasedate);
      break;
    case 2394:
      HASH_INVOKE_FROM_EVAL(0x103C12985527295ALL, hphp_splfileobject_setcsvcontrol);
      HASH_INVOKE_FROM_EVAL(0x7056E766A274895ALL, virtual);
      break;
    case 2397:
      HASH_INVOKE_FROM_EVAL(0x21DBCE74EB1FC95DLL, xmlwriter_text);
      break;
    case 2401:
      HASH_INVOKE_FROM_EVAL(0x5EA7052A00E88961LL, magickgetcopyright);
      break;
    case 2407:
      HASH_INVOKE_FROM_EVAL(0x1419B3BF428B2967LL, evhttp_async_post);
      break;
    case 2415:
      HASH_INVOKE_FROM_EVAL(0x134EF88685C0396FLL, magickgetexceptiontype);
      break;
    case 2417:
      HASH_INVOKE_FROM_EVAL(0x442A28FB6F6C3971LL, xmlwriter_start_attribute);
      HASH_INVOKE_FROM_EVAL(0x72C73F5DA7D6F971LL, magickgetimagecolormapcolor);
      break;
    case 2418:
      HASH_INVOKE_FROM_EVAL(0x758263CEBF2E8972LL, assert_options);
      break;
    case 2421:
      HASH_INVOKE_FROM_EVAL(0x7E26D48503362975LL, drawpathcurvetoabsolute);
      HASH_INVOKE_FROM_EVAL(0x488141281A75E975LL, imagecreatefromgif);
      break;
    case 2423:
      HASH_INVOKE_FROM_EVAL(0x0C16C797916C2977LL, posix_setegid);
      break;
    case 2430:
      HASH_INVOKE_FROM_EVAL(0x5067A65AD1D0297ELL, pixelgetiteratorexception);
      break;
    case 2432:
      HASH_INVOKE_FROM_EVAL(0x3D3445105C335980LL, filectime);
      break;
    case 2434:
      HASH_INVOKE_FROM_EVAL(0x214EA70BDD8FB982LL, magickmorphimages);
      break;
    case 2435:
      HASH_INVOKE_FROM_EVAL(0x3DA64BF893DBF983LL, strncmp);
      break;
    case 2438:
      HASH_INVOKE_FROM_EVAL(0x6ECE4BDB8842E986LL, posix_strerror);
      break;
    case 2439:
      HASH_INVOKE_FROM_EVAL(0x22B3CF8DD3D1A987LL, pixelsynciterator);
      break;
    case 2440:
      HASH_INVOKE_FROM_EVAL(0x489355BDBE396988LL, drawsettextencoding);
      HASH_INVOKE_FROM_EVAL(0x55BE7AE8DEF3F988LL, magickgetstringheight);
      break;
    case 2443:
      HASH_INVOKE_FROM_EVAL(0x0E863EF8C11A598BLL, is_writable);
      break;
    case 2445:
      HASH_INVOKE_FROM_EVAL(0x69003892F71C798DLL, apache_get_scoreboard);
      HASH_INVOKE_FROM_EVAL(0x651A8CBB8D2A398DLL, mysql_stat);
      break;
    case 2446:
      HASH_INVOKE_FROM_EVAL(0x45CFDEE19995398ELL, hphp_recursiveiteratoriterator_next);
      HASH_INVOKE_FROM_EVAL(0x333D4DFD4927898ELL, magickgetimagewhitepoint);
      break;
    case 2448:
      HASH_INVOKE_FROM_EVAL(0x342D957A86A03990LL, hphp_splfileobject_seek);
      break;
    case 2456:
      HASH_INVOKE_FROM_EVAL(0x501AAD31C8086998LL, posix_getcwd);
      break;
    case 2459:
      HASH_INVOKE_FROM_EVAL(0x564D8D3DA1E8E99BLL, xml_get_current_line_number);
      break;
    case 2462:
      HASH_INVOKE_FROM_EVAL(0x59D2DFF08F4DB99ELL, imagecreate);
      break;
    case 2464:
      HASH_INVOKE_FROM_EVAL(0x047EF9173590C9A0LL, session_decode);
      break;
    case 2466:
      HASH_INVOKE_FROM_EVAL(0x01D2367A02F0A9A2LL, magicksetsize);
      break;
    case 2467:
      HASH_INVOKE_FROM_EVAL(0x43D1339C52E309A3LL, hphp_service_thread_started);
      HASH_INVOKE_FROM_EVAL(0x78261FA60B8D89A3LL, imagepsloadfont);
      break;
    case 2468:
      HASH_INVOKE_FROM_EVAL(0x6F8676B049C919A4LL, array_intersect_uassoc);
      break;
    case 2469:
      HASH_INVOKE_FROM_EVAL(0x76988956F35329A5LL, xmlwriter_end_cdata);
      break;
    case 2473:
      HASH_INVOKE_FROM_EVAL(0x6F9CF95104CAE9A9LL, pixelgetyellowquantum);
      break;
    case 2476:
      HASH_INVOKE_FROM_EVAL(0x522256BAA78159ACLL, popen);
      break;
    case 2477:
      HASH_INVOKE_FROM_EVAL(0x05C5AD90751159ADLL, drawpathcurvetoquadraticbeziersmoothabsolute);
      break;
    case 2479:
      HASH_INVOKE_FROM_EVAL(0x25268012A48A99AFLL, magickclipimage);
      break;
    case 2481:
      HASH_INVOKE_FROM_EVAL(0x7C1CE38F14E529B1LL, date_default_timezone_set);
      break;
    case 2482:
      HASH_INVOKE_FROM_EVAL(0x65D7CBE8681CE9B2LL, gzgetss);
      break;
    case 2486:
      HASH_INVOKE_FROM_EVAL(0x5FC1B94446EA59B6LL, magickremoveimageprofiles);
      break;
    case 2487:
      HASH_INVOKE_FROM_EVAL(0x18F2C246FACAD9B7LL, each);
      break;
    case 2488:
      HASH_INVOKE_FROM_EVAL(0x3741447B159359B8LL, mcrypt_get_cipher_name);
      HASH_INVOKE_FROM_EVAL(0x4EFD7A9C90E559B8LL, posix_ttyname);
      break;
    case 2489:
      HASH_INVOKE_FROM_EVAL(0x145702974C97F9B9LL, ltrim);
      break;
    case 2490:
      HASH_INVOKE_FROM_EVAL(0x13B3172E092D99BALL, is_dir);
      break;
    case 2492:
      HASH_INVOKE_FROM_EVAL(0x7E7BF1BDA6DB49BCLL, hphp_splfileinfo_getgroup);
      break;
    case 2494:
      HASH_INVOKE_FROM_EVAL(0x458B5ABEDAC1C9BELL, disk_free_space);
      break;
    case 2498:
      HASH_INVOKE_FROM_EVAL(0x6A7BDB900E7429C2LL, magickconstituteimage);
      break;
    case 2500:
      HASH_INVOKE_FROM_EVAL(0x47B7D3745D80B9C4LL, socket_get_option);
      break;
    case 2502:
      HASH_INVOKE_FROM_EVAL(0x080F661DB8BFC9C6LL, hphp_splfileinfo_getmtime);
      break;
    case 2503:
      HASH_INVOKE_FROM_EVAL(0x6ECDF24B29D789C7LL, strtolower);
      break;
    case 2506:
      HASH_INVOKE_FROM_EVAL(0x5C5B0CC85133B9CALL, mkdir);
      break;
    case 2507:
      HASH_INVOKE_FROM_EVAL(0x032DFAC5B24679CBLL, header_remove);
      break;
    case 2509:
      HASH_INVOKE_FROM_EVAL(0x4E61FE901C1C29CDLL, array_intersect_key);
      break;
    case 2510:
      HASH_INVOKE_FROM_EVAL(0x7A9FB932873D09CELL, gmmktime);
      break;
    case 2511:
      HASH_INVOKE_FROM_EVAL(0x415B91CAEE0689CFLL, magickgetimageinterlacescheme);
      break;
    case 2514:
      HASH_INVOKE_FROM_EVAL(0x3DCCD1FEAD8759D2LL, array_sum);
      break;
    case 2515:
      HASH_INVOKE_FROM_EVAL(0x1C31A9E1207209D3LL, mb_split);
      HASH_INVOKE_FROM_EVAL(0x10C82F357BB7E9D3LL, curl_version);
      HASH_INVOKE_FROM_EVAL(0x25CA0299103F49D3LL, magickgetsize);
      break;
    case 2517:
      HASH_INVOKE_FROM_EVAL(0x245860A2FE4CB9D5LL, socket_set_blocking);
      break;
    case 2519:
      HASH_INVOKE_FROM_EVAL(0x7628053EFCC0C9D7LL, hphp_clear_unflushed);
      break;
    case 2523:
      HASH_INVOKE_FROM_EVAL(0x48B2E069B89489DBLL, magickappendimages);
      break;
    case 2526:
      HASH_INVOKE_FROM_EVAL(0x5C039967E60089DELL, array_intersect_ukey);
      break;
    case 2527:
      HASH_INVOKE_FROM_EVAL(0x349E2E0F2CD7B9DFLL, magickgetversion);
      break;
    case 2534:
      HASH_INVOKE_FROM_EVAL(0x1B44CF284E9B09E6LL, interface_exists);
      break;
    case 2537:
      HASH_INVOKE_FROM_EVAL(0x4ADFA265F07AB9E9LL, drawgettextalignment);
      HASH_INVOKE_FROM_EVAL(0x6A45EB471332A9E9LL, imagecolorexactalpha);
      HASH_INVOKE_FROM_EVAL(0x330EE2729DB7C9E9LL, drawgetfontstretch);
      break;
    case 2538:
      HASH_INVOKE_FROM_EVAL(0x25DDD924EFE979EALL, hash_update_file);
      break;
    case 2539:
      HASH_INVOKE_FROM_EVAL(0x71B0FF80B88459EBLL, diskfreespace);
      break;
    case 2543:
      HASH_INVOKE_FROM_EVAL(0x7EA6200B688459EFLL, ldap_modify);
      break;
    case 2544:
      HASH_INVOKE_FROM_EVAL(0x1FC307200E8959F0LL, stream_bucket_append);
      break;
    case 2547:
      HASH_INVOKE_FROM_EVAL(0x6535B60A4BC449F3LL, dns_get_record);
      break;
    case 2548:
      HASH_INVOKE_FROM_EVAL(0x51201EE65BC729F4LL, localtime);
      break;
    case 2549:
      HASH_INVOKE_FROM_EVAL(0x2BC61637253BE9F5LL, drawgetfontweight);
      HASH_INVOKE_FROM_EVAL(0x35BABFBC091759F5LL, socket_server);
      break;
    case 2557:
      HASH_INVOKE_FROM_EVAL(0x2394D4E030AB69FDLL, getmypid);
      break;
    case 2564:
      HASH_INVOKE_FROM_EVAL(0x0B88D3F582D16A04LL, memcache_get_extended_stats);
      HASH_INVOKE_FROM_EVAL(0x17B83C425BD09A04LL, atanh);
      break;
    case 2567:
      HASH_INVOKE_FROM_EVAL(0x391E0A4CF1EC9A07LL, stream_socket_recvfrom);
      break;
    case 2568:
      HASH_INVOKE_FROM_EVAL(0x0436CA4DFB315A08LL, soundex);
      break;
    case 2571:
      HASH_INVOKE_FROM_EVAL(0x70075DC878825A0BLL, ctype_lower);
      break;
    case 2573:
      HASH_INVOKE_FROM_EVAL(0x736C133EFF8E5A0DLL, mysql_list_fields);
      HASH_INVOKE_FROM_EVAL(0x50A7146A79877A0DLL, pcntl_alarm);
      break;
    case 2577:
      HASH_INVOKE_FROM_EVAL(0x472CA39715598A11LL, mb_eregi_replace);
      break;
    case 2584:
      HASH_INVOKE_FROM_EVAL(0x66A378C6BBC26A18LL, dom_document_create_cdatasection);
      break;
    case 2588:
      HASH_INVOKE_FROM_EVAL(0x12D49AD562F38A1CLL, date_timezone_get);
      break;
    case 2591:
      HASH_INVOKE_FROM_EVAL(0x35C8BD7DFDADEA1FLL, hphp_directoryiterator_current);
      break;
    case 2592:
      HASH_INVOKE_FROM_EVAL(0x2A420675E6AF0A20LL, basename);
      break;
    case 2593:
      HASH_INVOKE_FROM_EVAL(0x14279BB1A6872A21LL, atan2);
      break;
    case 2594:
      HASH_INVOKE_FROM_EVAL(0x3FC127C442BAEA22LL, session_id);
      break;
    case 2597:
      HASH_INVOKE_FROM_EVAL(0x5EC0A3DD935EEA25LL, magickresampleimage);
      HASH_INVOKE_FROM_EVAL(0x1DB9A1FB97A3AA25LL, magicksetimageoption);
      break;
    case 2601:
      HASH_INVOKE_FROM_EVAL(0x618D2A98986B1A29LL, ldap_unbind);
      break;
    case 2602:
      HASH_INVOKE_FROM_EVAL(0x3CAEA6B8D1C92A2ALL, stream_bucket_prepend);
      break;
    case 2604:
      HASH_INVOKE_FROM_EVAL(0x073ACDF9B3F06A2CLL, memcache_setoptimeout);
      break;
    case 2609:
      HASH_INVOKE_FROM_EVAL(0x1F3E32847C1CCA31LL, mb_ereg_match);
      break;
    case 2612:
      HASH_INVOKE_FROM_EVAL(0x2D948E4099975A34LL, restore_include_path);
      HASH_INVOKE_FROM_EVAL(0x5AB266C6E7075A34LL, mysql_error);
      break;
    case 2616:
      HASH_INVOKE_FROM_EVAL(0x3E65EF9761BE5A38LL, pixelgetiteratorexceptiontype);
      break;
    case 2619:
      HASH_INVOKE_FROM_EVAL(0x545A7BE199EC4A3BLL, pcntl_getpriority);
      HASH_INVOKE_FROM_EVAL(0x785ECCF53D98BA3BLL, curl_multi_exec);
      break;
    case 2620:
      HASH_INVOKE_FROM_EVAL(0x21DF7BAEEFABCA3CLL, umask);
      break;
    case 2622:
      HASH_INVOKE_FROM_EVAL(0x31C3A072D092FA3ELL, socket_create_listen);
      break;
    case 2623:
      HASH_INVOKE_FROM_EVAL(0x4C0E2C6882051A3FLL, magickgetresourcelimit);
      break;
    case 2624:
      HASH_INVOKE_FROM_EVAL(0x4926EE59103B2A40LL, destroydrawingwand);
      HASH_INVOKE_FROM_EVAL(0x682C14726D484A40LL, fileatime);
      break;
    case 2626:
      HASH_INVOKE_FROM_EVAL(0x128914E131AFFA42LL, microtime);
      HASH_INVOKE_FROM_EVAL(0x5FF7C3A6BDDCFA42LL, mb_convert_kana);
      break;
    case 2628:
      HASH_INVOKE_FROM_EVAL(0x7F6A6306BBE8AA44LL, imagelayereffect);
      break;
    case 2629:
      HASH_INVOKE_FROM_EVAL(0x7CDF1FB642529A45LL, dom_characterdata_insert_data);
      break;
    case 2631:
      HASH_INVOKE_FROM_EVAL(0x1B45CFF586F85A47LL, utf8_encode);
      break;
    case 2636:
      HASH_INVOKE_FROM_EVAL(0x4894583F517C6A4CLL, intl_get_error_code);
      HASH_INVOKE_FROM_EVAL(0x7039B1C3356B8A4CLL, hphp_splfileobject_rewind);
      break;
    case 2638:
      HASH_INVOKE_FROM_EVAL(0x1635DCC4882CBA4ELL, dom_node_has_attributes);
      break;
    case 2640:
      HASH_INVOKE_FROM_EVAL(0x506BBFC1B32AEA50LL, memcache_replace);
      break;
    case 2647:
      HASH_INVOKE_FROM_EVAL(0x5088945958DD4A57LL, mktime);
      HASH_INVOKE_FROM_EVAL(0x7E929ED7D9BE6A57LL, ini_get);
      break;
    case 2648:
      HASH_INVOKE_FROM_EVAL(0x6E823A722DE1EA58LL, stream_socket_client);
      break;
    case 2651:
      HASH_INVOKE_FROM_EVAL(0x2B18DFF183C0BA5BLL, mb_get_info);
      break;
    case 2653:
      HASH_INVOKE_FROM_EVAL(0x7E1E9C4C3D4E8A5DLL, stream_select);
      break;
    case 2654:
      HASH_INVOKE_FROM_EVAL(0x2C6826999658AA5ELL, getopt);
      break;
    case 2655:
      HASH_INVOKE_FROM_EVAL(0x7CAE3FE798EC0A5FLL, php_logo_guid);
      break;
    case 2661:
      HASH_INVOKE_FROM_EVAL(0x469199B8FD886A65LL, putenv);
      HASH_INVOKE_FROM_EVAL(0x3590F3AAC94E0A65LL, array_change_key_case);
      break;
    case 2662:
      HASH_INVOKE_FROM_EVAL(0x60C4B9EEDBD5FA66LL, pos);
      break;
    case 2664:
      HASH_INVOKE_FROM_EVAL(0x01DD2057FD9B1A68LL, xmlwriter_write_cdata);
      HASH_INVOKE_FROM_EVAL(0x32AD0455A7689A68LL, magickoilpaintimage);
      break;
    case 2665:
      HASH_INVOKE_FROM_EVAL(0x1DD37E722E11AA69LL, session_regenerate_id);
      HASH_INVOKE_FROM_EVAL(0x10CDCF2BB4057A69LL, debug_zval_dump);
      break;
    case 2667:
      HASH_INVOKE_FROM_EVAL(0x0912965F4440FA6BLL, str_repeat);
      break;
    case 2673:
      HASH_INVOKE_FROM_EVAL(0x5B5DA6AD0AD63A71LL, drawannotation);
      break;
    case 2674:
      HASH_INVOKE_FROM_EVAL(0x71AFF1D58D103A72LL, imagefontheight);
      break;
    case 2677:
      HASH_INVOKE_FROM_EVAL(0x7A957BEC6CA57A75LL, preg_replace_callback);
      break;
    case 2681:
      HASH_INVOKE_FROM_EVAL(0x28AC28C54C4E6A79LL, openssl_error_string);
      break;
    case 2685:
      HASH_INVOKE_FROM_EVAL(0x414C2E31304E9A7DLL, stream_get_filters);
      break;
    case 2689:
      HASH_INVOKE_FROM_EVAL(0x09367774F803EA81LL, hphp_recursiveiteratoriterator_valid);
      break;
    case 2690:
      HASH_INVOKE_FROM_EVAL(0x258205B54DC06A82LL, newpixelwands);
      HASH_INVOKE_FROM_EVAL(0x79786FABC5551A82LL, jpeg2wbmp);
      break;
    case 2691:
      HASH_INVOKE_FROM_EVAL(0x11149278DB0A9A83LL, levenshtein);
      break;
    case 2692:
      HASH_INVOKE_FROM_EVAL(0x08C1A5A05B6A0A84LL, ob_get_length);
      break;
    case 2693:
      HASH_INVOKE_FROM_EVAL(0x755DEFDEDF35DA85LL, ctype_print);
      HASH_INVOKE_FROM_EVAL(0x2180916F8D4F6A85LL, drawcomment);
      break;
    case 2695:
      HASH_INVOKE_FROM_EVAL(0x7C5A22328CAB4A87LL, ereg_replace);
      break;
    case 2696:
      HASH_INVOKE_FROM_EVAL(0x1818A3CFBA357A88LL, magicksetwandsize);
      break;
    case 2699:
      HASH_INVOKE_FROM_EVAL(0x7588BD0546C8BA8BLL, hphp_recursivedirectoryiterator_valid);
      HASH_INVOKE_FROM_EVAL(0x7ACBCD9CF335AA8BLL, xmlwriter_start_document);
      break;
    case 2700:
      HASH_INVOKE_FROM_EVAL(0x6A2EEE463F969A8CLL, getservbyname);
      break;
    case 2706:
      HASH_INVOKE_FROM_EVAL(0x1257DB9F159E9A92LL, magickmontageimage);
      break;
    case 2707:
      HASH_INVOKE_FROM_EVAL(0x4A32653C8E719A93LL, pixelgetcyan);
      break;
    case 2708:
      HASH_INVOKE_FROM_EVAL(0x465E6C67F885AA94LL, drawgetstrokelinejoin);
      HASH_INVOKE_FROM_EVAL(0x7761D019E0B5EA94LL, magickstripimage);
      HASH_INVOKE_FROM_EVAL(0x4B1501C4C22FFA94LL, quoted_printable_encode);
      HASH_INVOKE_FROM_EVAL(0x0AC7CBCE30442A94LL, imagepalettecopy);
      break;
    case 2709:
      HASH_INVOKE_FROM_EVAL(0x34B8A4E5AE0EFA95LL, pixelgetopacity);
      break;
    case 2711:
      HASH_INVOKE_FROM_EVAL(0x0089115038C03A97LL, array_diff_ukey);
      break;
    case 2714:
      HASH_INVOKE_FROM_EVAL(0x19AFF8596E19DA9ALL, xhprof_enable);
      break;
    case 2717:
      HASH_INVOKE_FROM_EVAL(0x1234AB687C515A9DLL, mb_encode_numericentity);
      break;
    case 2719:
      HASH_INVOKE_FROM_EVAL(0x2E5E23ECA0525A9FLL, bcadd);
      break;
    case 2720:
      HASH_INVOKE_FROM_EVAL(0x55FAF12AF1920AA0LL, sha1_file);
      break;
    case 2723:
      HASH_INVOKE_FROM_EVAL(0x2B75B48A53AACAA3LL, imagestring);
      break;
    case 2725:
      HASH_INVOKE_FROM_EVAL(0x2418528164415AA5LL, magickscaleimage);
      break;
    case 2726:
      HASH_INVOKE_FROM_EVAL(0x4BBA1E164DF9CAA6LL, localeconv);
      break;
    case 2727:
      HASH_INVOKE_FROM_EVAL(0x797CEC173CBB7AA7LL, ob_get_flush);
      break;
    case 2729:
      HASH_INVOKE_FROM_EVAL(0x2238FC7870E9CAA9LL, strspn);
      break;
    case 2731:
      HASH_INVOKE_FROM_EVAL(0x1331979EF8EF0AABLL, mb_ereg_search);
      break;
    case 2732:
      HASH_INVOKE_FROM_EVAL(0x18CF3E4A60E4AAACLL, pi);
      break;
    case 2735:
      HASH_INVOKE_FROM_EVAL(0x3ED47399FE1D6AAFLL, dom_document_create_attribute_ns);
      break;
    case 2738:
      HASH_INVOKE_FROM_EVAL(0x569EED88F20BAAB2LL, drawgettextundercolor);
      HASH_INVOKE_FROM_EVAL(0x62519270CC9F1AB2LL, stream_get_meta_data);
      break;
    case 2740:
      HASH_INVOKE_FROM_EVAL(0x1BAFB965204D0AB4LL, openssl_x509_check_private_key);
      break;
    case 2751:
      HASH_INVOKE_FROM_EVAL(0x030DFC3D3C88BABFLL, filegroup);
      break;
    case 2757:
      HASH_INVOKE_FROM_EVAL(0x3754E97715176AC5LL, hphp_get_stats);
      break;
    case 2759:
      HASH_INVOKE_FROM_EVAL(0x5D2F899A270D9AC7LL, xmlwriter_end_dtd_element);
      HASH_INVOKE_FROM_EVAL(0x79215854355CBAC7LL, proc_get_status);
      HASH_INVOKE_FROM_EVAL(0x3886D2664F874AC7LL, openssl_pkcs7_verify);
      break;
    case 2761:
      HASH_INVOKE_FROM_EVAL(0x5CA9671385EF0AC9LL, sem_release);
      break;
    case 2762:
      HASH_INVOKE_FROM_EVAL(0x45B30CD663284ACALL, is_int);
      break;
    case 2763:
      HASH_INVOKE_FROM_EVAL(0x348888DDF223AACBLL, mt_getrandmax);
      break;
    case 2764:
      HASH_INVOKE_FROM_EVAL(0x750D0396676E6ACCLL, imagecolorexact);
      HASH_INVOKE_FROM_EVAL(0x2BD6476D2C467ACCLL, pagelet_server_task_status);
      break;
    case 2765:
      HASH_INVOKE_FROM_EVAL(0x173EDC165B673ACDLL, magicktransformimage);
      break;
    case 2769:
      HASH_INVOKE_FROM_EVAL(0x47E2B4F7B8DE5AD1LL, xmlwriter_write_dtd_attlist);
      HASH_INVOKE_FROM_EVAL(0x314317450857FAD1LL, ctype_punct);
      break;
    case 2773:
      HASH_INVOKE_FROM_EVAL(0x0D5DAF8034B41AD5LL, get_include_path);
      HASH_INVOKE_FROM_EVAL(0x5338F971C6DCEAD5LL, hphp_splfileinfo_islink);
      break;
    case 2774:
      HASH_INVOKE_FROM_EVAL(0x231BCE6071220AD6LL, drawcircle);
      break;
    case 2776:
      HASH_INVOKE_FROM_EVAL(0x52401023E146AAD8LL, xmlwriter_end_dtd);
      break;
    case 2779:
      HASH_INVOKE_FROM_EVAL(0x24771ED112008ADBLL, echo);
      HASH_INVOKE_FROM_EVAL(0x56E867A1F7507ADBLL, dom_document_create_processing_instruction);
      break;
    case 2780:
      HASH_INVOKE_FROM_EVAL(0x547E7EE64761AADCLL, imagecreatefromxbm);
      break;
    case 2781:
      HASH_INVOKE_FROM_EVAL(0x3E319E451A32FADDLL, magicksharpenimage);
      break;
    case 2782:
      HASH_INVOKE_FROM_EVAL(0x31D1C58F7BD89ADELL, hphp_directoryiterator_seek);
      break;
    case 2788:
      HASH_INVOKE_FROM_EVAL(0x47B15A7136E94AE4LL, strnatcasecmp);
      HASH_INVOKE_FROM_EVAL(0x1827F1C22F1CCAE4LL, hebrevc);
      break;
    case 2790:
      HASH_INVOKE_FROM_EVAL(0x0E09D0FEA30B6AE6LL, hphp_get_function_info);
      break;
    case 2795:
      HASH_INVOKE_FROM_EVAL(0x225F05071947BAEBLL, drawpathlinetoabsolute);
      break;
    case 2797:
      HASH_INVOKE_FROM_EVAL(0x46C33B4739C2FAEDLL, shm_remove_var);
      break;
    case 2798:
      HASH_INVOKE_FROM_EVAL(0x160A82E3E2CBBAEELL, is_finite);
      break;
    case 2800:
      HASH_INVOKE_FROM_EVAL(0x6B259D5D9D681AF0LL, register_postsend_function);
      break;
    case 2804:
      HASH_INVOKE_FROM_EVAL(0x2EC0ABF9A979FAF4LL, ob_get_level);
      break;
    case 2806:
      HASH_INVOKE_FROM_EVAL(0x2C7C9772AE983AF6LL, drawsetgravity);
      break;
    case 2808:
      HASH_INVOKE_FROM_EVAL(0x12859AD75BAF3AF8LL, magickreadimageblob);
      HASH_INVOKE_FROM_EVAL(0x757229A894864AF8LL, session_set_cookie_params);
      break;
    case 2813:
      HASH_INVOKE_FROM_EVAL(0x16BA422EB6C51AFDLL, gzwrite);
      break;
    case 2814:
      HASH_INVOKE_FROM_EVAL(0x04E86BA79B6CBAFELL, stream_socket_shutdown);
      break;
    case 2815:
      HASH_INVOKE_FROM_EVAL(0x7833F4C337542AFFLL, openssl_pkey_export);
      break;
    case 2817:
      HASH_INVOKE_FROM_EVAL(0x6F3503C7FB12DB01LL, lchgrp);
      break;
    case 2819:
      HASH_INVOKE_FROM_EVAL(0x673A96C50F00FB03LL, str_word_count);
      HASH_INVOKE_FROM_EVAL(0x32458C11C6E74B03LL, pixelsetblackquantum);
      break;
    case 2826:
      HASH_INVOKE_FROM_EVAL(0x14B366EF64A66B0ALL, get_loaded_extensions);
      HASH_INVOKE_FROM_EVAL(0x14AF32A23B507B0ALL, metaphone);
      break;
    case 2829:
      HASH_INVOKE_FROM_EVAL(0x368DBC0699272B0DLL, magicknegateimage);
      break;
    case 2836:
      HASH_INVOKE_FROM_EVAL(0x76675F14C1138B14LL, gzuncompress);
      break;
    case 2837:
      HASH_INVOKE_FROM_EVAL(0x24D0895FBB7BCB15LL, is_callable);
      HASH_INVOKE_FROM_EVAL(0x773E3809C4954B15LL, hphp_recursivedirectoryiterator_current);
      break;
    case 2839:
      HASH_INVOKE_FROM_EVAL(0x66F9A476DAB47B17LL, pixelsetcolor);
      break;
    case 2840:
      HASH_INVOKE_FROM_EVAL(0x70448A629A74FB18LL, ksort);
      break;
    case 2841:
      HASH_INVOKE_FROM_EVAL(0x0551EACBE8278B19LL, decoct);
      break;
    case 2842:
      HASH_INVOKE_FROM_EVAL(0x399522EE0CF3EB1ALL, drawsetstrokewidth);
      break;
    case 2843:
      HASH_INVOKE_FROM_EVAL(0x1B7CE8114AEACB1BLL, magickannotateimage);
      break;
    case 2844:
      HASH_INVOKE_FROM_EVAL(0x249399CEC35B7B1CLL, png2wbmp);
      break;
    case 2846:
      HASH_INVOKE_FROM_EVAL(0x7160AA24D4251B1ELL, mb_strripos);
      break;
    case 2848:
      HASH_INVOKE_FROM_EVAL(0x1112712715D75B20LL, pixelgetblackquantum);
      break;
    case 2853:
      HASH_INVOKE_FROM_EVAL(0x798F2776FECAEB25LL, get_required_files);
      break;
    case 2854:
      HASH_INVOKE_FROM_EVAL(0x24CE95457EACBB26LL, get_parent_class);
      break;
    case 2857:
      HASH_INVOKE_FROM_EVAL(0x17C38BE3A6EE8B29LL, mysql_field_flags);
      break;
    case 2858:
      HASH_INVOKE_FROM_EVAL(0x1F4984938E1DBB2ALL, sort);
      break;
    case 2860:
      HASH_INVOKE_FROM_EVAL(0x70742211FA3EFB2CLL, imagettftext);
      break;
    case 2865:
      HASH_INVOKE_FROM_EVAL(0x442B1E05FC146B31LL, stream_context_set_param);
      break;
    case 2867:
      HASH_INVOKE_FROM_EVAL(0x00DCD60DD8752B33LL, set_exception_handler);
      HASH_INVOKE_FROM_EVAL(0x4D5D45D1F1EB3B33LL, posix_access);
      break;
    case 2868:
      HASH_INVOKE_FROM_EVAL(0x0B7D52E2540ABB34LL, tan);
      break;
    case 2869:
      HASH_INVOKE_FROM_EVAL(0x78842C1950B38B35LL, drawpathfinish);
      break;
    case 2871:
      HASH_INVOKE_FROM_EVAL(0x053B14F52350FB37LL, socket_shutdown);
      break;
    case 2872:
      HASH_INVOKE_FROM_EVAL(0x68C09D6CB8E79B38LL, class_exists);
      break;
    case 2873:
      HASH_INVOKE_FROM_EVAL(0x02A2C373E54FFB39LL, hash_init);
      break;
    case 2874:
      HASH_INVOKE_FROM_EVAL(0x49A45F75B2B25B3ALL, apd_breakpoint);
      break;
    case 2876:
      HASH_INVOKE_FROM_EVAL(0x35F4A0789F367B3CLL, drawpathlinetohorizontalrelative);
      break;
    case 2878:
      HASH_INVOKE_FROM_EVAL(0x5E2AF775FEB04B3ELL, posix_getppid);
      break;
    case 2879:
      HASH_INVOKE_FROM_EVAL(0x0B07AD87DF1B5B3FLL, urldecode);
      break;
    case 2880:
      HASH_INVOKE_FROM_EVAL(0x24CBCBA5C4407B40LL, evhttp_set_cache);
      break;
    case 2884:
      HASH_INVOKE_FROM_EVAL(0x4E4449EBAADD7B44LL, magickpingimage);
      break;
    case 2885:
      HASH_INVOKE_FROM_EVAL(0x684881C79ED1AB45LL, func_get_args);
      HASH_INVOKE_FROM_EVAL(0x72E3AE55A0B33B45LL, ispixelwand);
      break;
    case 2886:
      HASH_INVOKE_FROM_EVAL(0x00D8FE7A00252B46LL, escapeshellarg);
      break;
    case 2893:
      HASH_INVOKE_FROM_EVAL(0x37DF53E4D9348B4DLL, xbox_post_message);
      break;
    case 2896:
      HASH_INVOKE_FROM_EVAL(0x6237393C71E56B50LL, array_fill_keys);
      break;
    case 2899:
      HASH_INVOKE_FROM_EVAL(0x40F0B69D55F7EB53LL, drawsetstrokealpha);
      break;
    case 2901:
      HASH_INVOKE_FROM_EVAL(0x333FB673518A1B55LL, ldap_get_entries);
      break;
    case 2904:
      HASH_INVOKE_FROM_EVAL(0x6158E2E0A5ACCB58LL, idn_to_ascii);
      break;
    case 2907:
      HASH_INVOKE_FROM_EVAL(0x29203294F6214B5BLL, memcache_debug);
      HASH_INVOKE_FROM_EVAL(0x23FD09A13E0D8B5BLL, xmlwriter_open_memory);
      break;
    case 2909:
      HASH_INVOKE_FROM_EVAL(0x4888951358F53B5DLL, dom_document_get_elements_by_tag_name_ns);
      break;
    case 2913:
      HASH_INVOKE_FROM_EVAL(0x7636825871399B61LL, highlight_file);
      break;
    case 2920:
      HASH_INVOKE_FROM_EVAL(0x674F1DA24EDE7B68LL, xmlwriter_end_attribute);
      break;
    case 2922:
      HASH_INVOKE_FROM_EVAL(0x4BD4E9D9D4A56B6ALL, exif_tagname);
      break;
    case 2923:
      HASH_INVOKE_FROM_EVAL(0x5543A0CACD153B6BLL, substr_replace);
      HASH_INVOKE_FROM_EVAL(0x1D4136B4CEAE4B6BLL, stripcslashes);
      break;
    case 2927:
      HASH_INVOKE_FROM_EVAL(0x2D8D57FC1DC6CB6FLL, import_request_variables);
      break;
    case 2928:
      HASH_INVOKE_FROM_EVAL(0x1A73FD4416FECB70LL, magickwriteimagefile);
      break;
    case 2929:
      HASH_INVOKE_FROM_EVAL(0x5E5C875DB04CFB71LL, drawrectangle);
      break;
    case 2933:
      HASH_INVOKE_FROM_EVAL(0x42F0AED7599C1B75LL, magickechoimageblob);
      break;
    case 2934:
      HASH_INVOKE_FROM_EVAL(0x2A63A0BF9B7E3B76LL, ini_alter);
      break;
    case 2935:
      HASH_INVOKE_FROM_EVAL(0x7F5F29D8E63ABB77LL, mcrypt_module_self_test);
      HASH_INVOKE_FROM_EVAL(0x5025B43B46679B77LL, openssl_x509_free);
      break;
    case 2937:
      HASH_INVOKE_FROM_EVAL(0x31242F51AA828B79LL, drawpoppattern);
      break;
    case 2940:
      HASH_INVOKE_FROM_EVAL(0x3A096F905FBF7B7CLL, magickcommentimage);
      break;
    case 2941:
      HASH_INVOKE_FROM_EVAL(0x28DE19828167FB7DLL, magickmapimage);
      break;
    case 2943:
      HASH_INVOKE_FROM_EVAL(0x308C90AD9478CB7FLL, substr_compare);
      break;
    case 2946:
      HASH_INVOKE_FROM_EVAL(0x5BDE96FD5015AB82LL, base_convert);
      break;
    case 2949:
      HASH_INVOKE_FROM_EVAL(0x41F8FDD700C0CB85LL, socket_last_error);
      break;
    case 2955:
      HASH_INVOKE_FROM_EVAL(0x3B72159A4B04FB8BLL, set_time_limit);
      break;
    case 2957:
      HASH_INVOKE_FROM_EVAL(0x3B831DB1A615FB8DLL, xhprof_sample_enable);
      break;
    case 2958:
      HASH_INVOKE_FROM_EVAL(0x62A4D7A03F7C3B8ELL, ceil);
      break;
    case 2967:
      HASH_INVOKE_FROM_EVAL(0x09837A82A928AB97LL, is_null);
      break;
    case 2969:
      HASH_INVOKE_FROM_EVAL(0x076E66D4089A3B99LL, mb_stripos);
      break;
    case 2970:
      HASH_INVOKE_FROM_EVAL(0x023133732CB51B9ALL, exif_thumbnail);
      break;
    case 2975:
      HASH_INVOKE_FROM_EVAL(0x390A267EC6B51B9FLL, socket_sendto);
      break;
    case 2978:
      HASH_INVOKE_FROM_EVAL(0x4870ADD98EE02BA2LL, pcntl_wifsignaled);
      break;
    case 2979:
      HASH_INVOKE_FROM_EVAL(0x444A3375EFBC2BA3LL, openssl_public_decrypt);
      break;
    case 2980:
      HASH_INVOKE_FROM_EVAL(0x0D95DD13A2D3BBA4LL, drawtranslate);
      break;
    case 2986:
      HASH_INVOKE_FROM_EVAL(0x7C833A303C7CFBAALL, getrandmax);
      break;
    case 2987:
      HASH_INVOKE_FROM_EVAL(0x006481EAF2A70BABLL, ldap_errno);
      break;
    case 2991:
      HASH_INVOKE_FROM_EVAL(0x6A2236CDDFF12BAFLL, magickhaspreviousimage);
      break;
    case 2992:
      HASH_INVOKE_FROM_EVAL(0x1F3E4C6660247BB0LL, imagecolorresolve);
      HASH_INVOKE_FROM_EVAL(0x7D9BF61D6CDE3BB0LL, fb_parallel_query);
      break;
    case 2993:
      HASH_INVOKE_FROM_EVAL(0x04A24B397CF46BB1LL, strrchr);
      break;
    case 2997:
      HASH_INVOKE_FROM_EVAL(0x3F7DCC3A00800BB5LL, imagecolorallocate);
      break;
    case 3004:
      HASH_INVOKE_FROM_EVAL(0x43B74276235F4BBCLL, is_bool);
      break;
    case 3006:
      HASH_INVOKE_FROM_EVAL(0x79617ED8EFD1ABBELL, get_class_vars);
      HASH_INVOKE_FROM_EVAL(0x3F56AF1511AEDBBELL, magicklabelimage);
      HASH_INVOKE_FROM_EVAL(0x5ECB0B145B88EBBELL, imagefilledarc);
      HASH_INVOKE_FROM_EVAL(0x42684202E2E62BBELL, mcrypt_get_iv_size);
      break;
    case 3015:
      HASH_INVOKE_FROM_EVAL(0x10C5CF7B55173BC7LL, settype);
      break;
    case 3017:
      HASH_INVOKE_FROM_EVAL(0x0B4E7B9180C4ABC9LL, xml_set_end_namespace_decl_handler);
      HASH_INVOKE_FROM_EVAL(0x22BA0903D344CBC9LL, array_rand);
      break;
    case 3018:
      HASH_INVOKE_FROM_EVAL(0x0D375A94E75ACBCALL, hphp_throw_fatal_error);
      HASH_INVOKE_FROM_EVAL(0x4122DFAC25BDFBCALL, hphp_splfileinfo_getowner);
      break;
    case 3021:
      HASH_INVOKE_FROM_EVAL(0x22251ECF8CD58BCDLL, array_product);
      HASH_INVOKE_FROM_EVAL(0x53A88C8F973CFBCDLL, apc_clear_cache);
      break;
    case 3022:
      HASH_INVOKE_FROM_EVAL(0x45D6BA980AFFDBCELL, msg_get_queue);
      HASH_INVOKE_FROM_EVAL(0x600AFF0A6378ABCELL, is_writeable);
      break;
    case 3024:
      HASH_INVOKE_FROM_EVAL(0x7046755D8374EBD0LL, ctype_digit);
      HASH_INVOKE_FROM_EVAL(0x6846CA07A5E21BD0LL, hphp_directoryiterator___construct);
      break;
    case 3026:
      HASH_INVOKE_FROM_EVAL(0x6FE3C5FF5E883BD2LL, round);
      break;
    case 3028:
      HASH_INVOKE_FROM_EVAL(0x5B2F2A23D8368BD4LL, magickraiseimage);
      HASH_INVOKE_FROM_EVAL(0x4E4EB301A994DBD4LL, drawpolygon);
      break;
    case 3032:
      HASH_INVOKE_FROM_EVAL(0x21E44C7C7A911BD8LL, phpinfo);
      HASH_INVOKE_FROM_EVAL(0x06D5979AB150EBD8LL, dom_node_lookup_namespace_uri);
      break;
    case 3038:
      HASH_INVOKE_FROM_EVAL(0x58D0D9B66F045BDELL, strpos);
      break;
    case 3040:
      HASH_INVOKE_FROM_EVAL(0x2E10B74DC6067BE0LL, strip_tags);
      break;
    case 3041:
      HASH_INVOKE_FROM_EVAL(0x25FBB61480091BE1LL, mysql_client_encoding);
      break;
    case 3047:
      HASH_INVOKE_FROM_EVAL(0x1BB5D99C1D29CBE7LL, strstr);
      break;
    case 3048:
      HASH_INVOKE_FROM_EVAL(0x4E903B706977ABE8LL, imagepsslantfont);
      break;
    case 3051:
      HASH_INVOKE_FROM_EVAL(0x505B44DDF2383BEBLL, drawgetfillcolor);
      HASH_INVOKE_FROM_EVAL(0x0C1904372E8EDBEBLL, stream_copy_to_stream);
      break;
    case 3052:
      HASH_INVOKE_FROM_EVAL(0x44279BB3E2191BECLL, socket_accept);
      HASH_INVOKE_FROM_EVAL(0x5A22BA9B012A9BECLL, dom_document_save_html);
      break;
    case 3054:
      HASH_INVOKE_FROM_EVAL(0x03F50E435DE20BEELL, magickclippathimage);
      HASH_INVOKE_FROM_EVAL(0x790B7C44A3442BEELL, asort);
      break;
    case 3056:
      HASH_INVOKE_FROM_EVAL(0x187C049E785A1BF0LL, iconv_get_encoding);
      HASH_INVOKE_FROM_EVAL(0x04C0582DB1AD7BF0LL, mt_srand);
      break;
    case 3057:
      HASH_INVOKE_FROM_EVAL(0x0CA96856E5BEFBF1LL, iptcparse);
      break;
    case 3060:
      HASH_INVOKE_FROM_EVAL(0x1444DB037B4D5BF4LL, imagegammacorrect);
      break;
    case 3062:
      HASH_INVOKE_FROM_EVAL(0x08B4BEBAB3312BF6LL, image_type_to_extension);
      break;
    case 3063:
      HASH_INVOKE_FROM_EVAL(0x74ABB4A1E10BBBF7LL, time);
      break;
    case 3065:
      HASH_INVOKE_FROM_EVAL(0x5B7F6E0A642BBBF9LL, sleep);
      break;
    case 3068:
      HASH_INVOKE_FROM_EVAL(0x64F52E1DB5E95BFCLL, curl_multi_remove_handle);
      break;
    case 3074:
      HASH_INVOKE_FROM_EVAL(0x249340DF734D9C02LL, magickgetimageheight);
      break;
    case 3077:
      HASH_INVOKE_FROM_EVAL(0x2EC378A759F9EC05LL, xbox_task_status);
      break;
    case 3080:
      HASH_INVOKE_FROM_EVAL(0x48E1616EE837FC08LL, is_uploaded_file);
      break;
    case 3082:
      HASH_INVOKE_FROM_EVAL(0x1E47C281193ABC0ALL, collator_compare);
      break;
    case 3083:
      HASH_INVOKE_FROM_EVAL(0x0EEE484739520C0BLL, magickthresholdimage);
      HASH_INVOKE_FROM_EVAL(0x0833BCE91C40CC0BLL, magickqueryconfigureoption);
      break;
    case 3090:
      HASH_INVOKE_FROM_EVAL(0x062C0FFA8E29DC12LL, intl_error_name);
      HASH_INVOKE_FROM_EVAL(0x510B683F2E764C12LL, fb_load_local_databases);
      break;
    case 3095:
      HASH_INVOKE_FROM_EVAL(0x3A702EF906B37C17LL, collator_get_locale);
      break;
    case 3099:
      HASH_INVOKE_FROM_EVAL(0x67742A0F218F6C1BLL, posix_initgroups);
      HASH_INVOKE_FROM_EVAL(0x7D615C7E3ADB2C1BLL, xmlwriter_write_comment);
      break;
    case 3100:
      HASH_INVOKE_FROM_EVAL(0x758A62BD65E6FC1CLL, imagegd2);
      break;
    case 3102:
      HASH_INVOKE_FROM_EVAL(0x7039C5EBB1D6BC1ELL, array_walk);
      break;
    case 3103:
      HASH_INVOKE_FROM_EVAL(0x3A5D921797669C1FLL, hphp_log);
      break;
    case 3104:
      HASH_INVOKE_FROM_EVAL(0x7BD43EB167198C20LL, xmlwriter_write_pi);
      break;
    case 3105:
      HASH_INVOKE_FROM_EVAL(0x0179CBA2C5F4DC21LL, magickgetimageformat);
      break;
    case 3111:
      HASH_INVOKE_FROM_EVAL(0x5A02EE8ED39F0C27LL, posix_getgrnam);
      break;
    case 3112:
      HASH_INVOKE_FROM_EVAL(0x79A4E240F18BAC28LL, rand);
      break;
    case 3115:
      HASH_INVOKE_FROM_EVAL(0x09A98E99D51E8C2BLL, hphp_recursivedirectoryiterator_seek);
      break;
    case 3116:
      HASH_INVOKE_FROM_EVAL(0x116C3EC924B9AC2CLL, imagegd);
      break;
    case 3122:
      HASH_INVOKE_FROM_EVAL(0x0B9B362534621C32LL, isdrawingwand);
      break;
    case 3123:
      HASH_INVOKE_FROM_EVAL(0x49965C44E9EE3C33LL, set_file_buffer);
      break;
    case 3125:
      HASH_INVOKE_FROM_EVAL(0x2B9A380A29D0EC35LL, session_write_close);
      break;
    case 3128:
      HASH_INVOKE_FROM_EVAL(0x21564F9315F3FC38LL, drawsettextdecoration);
      break;
    case 3132:
      HASH_INVOKE_FROM_EVAL(0x69488CC69B897C3CLL, hphp_recursiveiteratoriterator_getinneriterator);
      break;
    case 3134:
      HASH_INVOKE_FROM_EVAL(0x15EC581662651C3ELL, date_parse);
      break;
    case 3141:
      HASH_INVOKE_FROM_EVAL(0x6EF89BCAD607CC45LL, strncasecmp);
      break;
    case 3142:
      HASH_INVOKE_FROM_EVAL(0x7D992445F5E37C46LL, magicktextureimage);
      break;
    case 3143:
      HASH_INVOKE_FROM_EVAL(0x44055093E56E4C47LL, mcrypt_enc_get_key_size);
      break;
    case 3145:
      HASH_INVOKE_FROM_EVAL(0x2D3F0F8DB0C20C49LL, dom_node_insert_before);
      HASH_INVOKE_FROM_EVAL(0x357F73CEBD6E2C49LL, write_hdf_string);
      break;
    case 3146:
      HASH_INVOKE_FROM_EVAL(0x3C23768CFB492C4ALL, gzinflate);
      break;
    case 3147:
      HASH_INVOKE_FROM_EVAL(0x120E7B01366DFC4BLL, call_user_func_serialized);
      break;
    case 3150:
      HASH_INVOKE_FROM_EVAL(0x5DAC1C64D8F08C4ELL, openssl_pkey_get_private);
      break;
    case 3152:
      HASH_INVOKE_FROM_EVAL(0x04534F26B8D05C50LL, drawgetstrokecolor);
      break;
    case 3153:
      HASH_INVOKE_FROM_EVAL(0x56EDB60C824E8C51LL, key);
      break;
    case 3154:
      HASH_INVOKE_FROM_EVAL(0x1FC294B806F76C52LL, php_sapi_name);
      break;
    case 3159:
      HASH_INVOKE_FROM_EVAL(0x793259E03C37CC57LL, memcache_decrement);
      HASH_INVOKE_FROM_EVAL(0x313E8EB28A111C57LL, hphp_splfileinfo_setinfoclass);
      break;
    case 3160:
      HASH_INVOKE_FROM_EVAL(0x1B8C3DA27170DC58LL, dirname);
      break;
    case 3161:
      HASH_INVOKE_FROM_EVAL(0x57633BDF8DB3FC59LL, i18n_loc_set_attribute);
      break;
    case 3166:
      HASH_INVOKE_FROM_EVAL(0x47B38F1E4FA29C5ELL, fb_get_code_coverage);
      break;
    case 3169:
      HASH_INVOKE_FROM_EVAL(0x6E54EEDA1D887C61LL, magicksetimageinterlacescheme);
      HASH_INVOKE_FROM_EVAL(0x5176725DA884DC61LL, curl_setopt);
      break;
    case 3171:
      HASH_INVOKE_FROM_EVAL(0x43C0E9827D502C63LL, array_intersect_assoc);
      break;
    case 3172:
      HASH_INVOKE_FROM_EVAL(0x3409D717D9246C64LL, libxml_use_internal_errors);
      break;
    case 3175:
      HASH_INVOKE_FROM_EVAL(0x07DC355325165C67LL, magickwriteimage);
      break;
    case 3176:
      HASH_INVOKE_FROM_EVAL(0x10D6AE9D688D1C68LL, copy);
      break;
    case 3178:
      HASH_INVOKE_FROM_EVAL(0x41BD9EA0BC5E4C6ALL, move_uploaded_file);
      break;
    case 3179:
      HASH_INVOKE_FROM_EVAL(0x7C6B37BF6300AC6BLL, iconv_mime_encode);
      break;
    case 3185:
      HASH_INVOKE_FROM_EVAL(0x1E074215FE5FCC71LL, set_error_handler);
      HASH_INVOKE_FROM_EVAL(0x18D9ED67E8E0FC71LL, dom_attr_is_id);
      break;
    case 3188:
      HASH_INVOKE_FROM_EVAL(0x20F0AAA486F39C74LL, dom_element_get_elements_by_tag_name_ns);
      break;
    case 3189:
      HASH_INVOKE_FROM_EVAL(0x528366F3195ACC75LL, xbox_task_result);
      break;
    case 3190:
      HASH_INVOKE_FROM_EVAL(0x1C35934C6BC52C76LL, libxml_clear_errors);
      break;
    case 3192:
      HASH_INVOKE_FROM_EVAL(0x665F08996BD4AC78LL, magicksetimagegreenprimary);
      break;
    case 3194:
      HASH_INVOKE_FROM_EVAL(0x05D7B804ECDE8C7ALL, checkdnsrr);
      HASH_INVOKE_FROM_EVAL(0x05F3BC04D61CAC7ALL, get_defined_vars);
      break;
    case 3195:
      HASH_INVOKE_FROM_EVAL(0x749E45FBD48BEC7BLL, hphp_recursivedirectoryiterator___tostring);
      HASH_INVOKE_FROM_EVAL(0x71B25229CD080C7BLL, dom_element_set_attribute_node_ns);
      break;
    case 3198:
      HASH_INVOKE_FROM_EVAL(0x5F41821072A06C7ELL, hphp_splfileinfo_getctime);
      break;
    case 3201:
      HASH_INVOKE_FROM_EVAL(0x767806D6F1053C81LL, sin);
      break;
    case 3204:
      HASH_INVOKE_FROM_EVAL(0x5D49AF7004696C84LL, shm_detach);
      break;
    case 3205:
      HASH_INVOKE_FROM_EVAL(0x56DA17241B793C85LL, mysql_set_timeout);
      break;
    case 3209:
      HASH_INVOKE_FROM_EVAL(0x0F9C0C82F40F2C89LL, pixelsetcyanquantum);
      break;
    case 3214:
      HASH_INVOKE_FROM_EVAL(0x467470230015AC8ELL, mcrypt_module_is_block_algorithm_mode);
      break;
    case 3215:
      HASH_INVOKE_FROM_EVAL(0x4173EFD9A8EECC8FLL, magicknewimage);
      break;
    case 3216:
      HASH_INVOKE_FROM_EVAL(0x05556EDFC1BB0C90LL, mysql_info);
      HASH_INVOKE_FROM_EVAL(0x3F0C947E68D02C90LL, ini_get_all);
      break;
    case 3217:
      HASH_INVOKE_FROM_EVAL(0x4E04B71729485C91LL, clonedrawingwand);
      break;
    case 3219:
      HASH_INVOKE_FROM_EVAL(0x0F8242C6327B5C93LL, dns_check_record);
      break;
    case 3222:
      HASH_INVOKE_FROM_EVAL(0x47C5BC101A512C96LL, magickquantizeimage);
      break;
    case 3225:
      HASH_INVOKE_FROM_EVAL(0x2EA6E1D600786C99LL, mb_strtoupper);
      break;
    case 3226:
      HASH_INVOKE_FROM_EVAL(0x374F20BDAF709C9ALL, mb_preferred_mime_name);
      break;
    case 3227:
      HASH_INVOKE_FROM_EVAL(0x36F7F9FD7766DC9BLL, xmlwriter_end_comment);
      break;
    case 3230:
      HASH_INVOKE_FROM_EVAL(0x50296037C7968C9ELL, preg_split);
      break;
    case 3233:
      HASH_INVOKE_FROM_EVAL(0x4590B5971EC9ACA1LL, getmygid);
      break;
    case 3235:
      HASH_INVOKE_FROM_EVAL(0x737253E9FC112CA3LL, socket_close);
      break;
    case 3245:
      HASH_INVOKE_FROM_EVAL(0x1C1216F2B7C16CADLL, ftell);
      break;
    case 3246:
      HASH_INVOKE_FROM_EVAL(0x12580A083B0D7CAELL, iterator_apply);
      HASH_INVOKE_FROM_EVAL(0x3ACD2F1EA5282CAELL, magickmattefloodfillimage);
      break;
    case 3248:
      HASH_INVOKE_FROM_EVAL(0x373B3FADEACB7CB0LL, openssl_private_encrypt);
      break;
    case 3249:
      HASH_INVOKE_FROM_EVAL(0x40D8DC24FA917CB1LL, hphp_splfileobject_fgetss);
      HASH_INVOKE_FROM_EVAL(0x735555B148E58CB1LL, ldap_read);
      break;
    case 3250:
      HASH_INVOKE_FROM_EVAL(0x56023CC5ECC9ECB2LL, dns_get_mx);
      break;
    case 3252:
      HASH_INVOKE_FROM_EVAL(0x41FBEF9F7A024CB4LL, xmlwriter_end_element);
      HASH_INVOKE_FROM_EVAL(0x742AD1AA5A80ECB4LL, output_reset_rewrite_vars);
      break;
    case 3254:
      HASH_INVOKE_FROM_EVAL(0x560637BE51C36CB6LL, ezmlm_hash);
      break;
    case 3255:
      HASH_INVOKE_FROM_EVAL(0x3DFD5CA79919DCB7LL, imageantialias);
      HASH_INVOKE_FROM_EVAL(0x39E03AAC188D3CB7LL, magickgetimagecompressionquality);
      break;
    case 3259:
      HASH_INVOKE_FROM_EVAL(0x41D3B07854936CBBLL, token_get_all);
      HASH_INVOKE_FROM_EVAL(0x15ACD9F32D214CBBLL, mysql_fetch_lengths);
      break;
    case 3260:
      HASH_INVOKE_FROM_EVAL(0x19C1872E55A7ECBCLL, is_long);
      HASH_INVOKE_FROM_EVAL(0x3978BE548631ECBCLL, hash_final);
      HASH_INVOKE_FROM_EVAL(0x733137183026ACBCLL, hphp_splfileobject_next);
      break;
    case 3264:
      HASH_INVOKE_FROM_EVAL(0x3033FE14E114FCC0LL, magicksetimageblueprimary);
      break;
    case 3266:
      HASH_INVOKE_FROM_EVAL(0x42BCEFCF899D0CC2LL, magickgetimagecolorspace);
      HASH_INVOKE_FROM_EVAL(0x34B6388D7730BCC2LL, drawline);
      break;
    case 3267:
      HASH_INVOKE_FROM_EVAL(0x7A147B8B98C76CC3LL, key_exists);
      break;
    case 3278:
      HASH_INVOKE_FROM_EVAL(0x0183A548B759BCCELL, posix_getpgid);
      HASH_INVOKE_FROM_EVAL(0x66273C5932B1FCCELL, clock_gettime);
      break;
    case 3279:
      HASH_INVOKE_FROM_EVAL(0x407B1F3AFEC43CCFLL, pixelgetblue);
      break;
    case 3281:
      HASH_INVOKE_FROM_EVAL(0x576C5DC462663CD1LL, explode);
      break;
    case 3282:
      HASH_INVOKE_FROM_EVAL(0x1FD3FB2AB0F48CD2LL, magickgetimagesignature);
      break;
    case 3283:
      HASH_INVOKE_FROM_EVAL(0x544302E2FAD3FCD3LL, magicknextimage);
      HASH_INVOKE_FROM_EVAL(0x6406BC03A5D84CD3LL, dom_element_remove_attribute);
      break;
    case 3284:
      HASH_INVOKE_FROM_EVAL(0x323FE1D92C9B3CD4LL, gzdecode);
      break;
    case 3285:
      HASH_INVOKE_FROM_EVAL(0x757BC444FDF79CD5LL, posix_get_last_error);
      break;
    case 3286:
      HASH_INVOKE_FROM_EVAL(0x11166D3106DB6CD6LL, wandhasexception);
      break;
    case 3289:
      HASH_INVOKE_FROM_EVAL(0x27BFAF1293A60CD9LL, ldap_get_dn);
      break;
    case 3290:
      HASH_INVOKE_FROM_EVAL(0x674AA2DBDA5E4CDALL, imageloadfont);
      HASH_INVOKE_FROM_EVAL(0x09C6455B4BC6FCDALL, drawsetviewbox);
      break;
    case 3298:
      HASH_INVOKE_FROM_EVAL(0x6B92530A9ABA0CE2LL, session_commit);
      break;
    case 3300:
      HASH_INVOKE_FROM_EVAL(0x7CDDF96AFEA2DCE4LL, chunk_split);
      break;
    case 3306:
      HASH_INVOKE_FROM_EVAL(0x5A8AF4F880DA4CEALL, mailparse_msg_extract_whole_part_file);
      HASH_INVOKE_FROM_EVAL(0x7821BD05E5228CEALL, imagewbmp);
      break;
    case 3310:
      HASH_INVOKE_FROM_EVAL(0x78FFA0E69D6AACEELL, mcrypt_cfb);
      break;
    case 3311:
      HASH_INVOKE_FROM_EVAL(0x6AA89C314C647CEFLL, magickgetimagehistogram);
      break;
    case 3313:
      HASH_INVOKE_FROM_EVAL(0x21C8FC9A94404CF1LL, php_ini_scanned_files);
      break;
    case 3314:
      HASH_INVOKE_FROM_EVAL(0x26C49BBC67475CF2LL, magicksetimagewhitepoint);
      break;
    case 3315:
      HASH_INVOKE_FROM_EVAL(0x5C1F75D51C077CF3LL, pixelgetindex);
      break;
    case 3317:
      HASH_INVOKE_FROM_EVAL(0x26729ECB00B8ECF5LL, end_user_func_async);
      break;
    case 3319:
      HASH_INVOKE_FROM_EVAL(0x1C30C8470100ECF7LL, mcrypt_enc_is_block_mode);
      break;
    case 3321:
      HASH_INVOKE_FROM_EVAL(0x537CF5DE8C43CCF9LL, curl_getinfo);
      break;
    case 3323:
      HASH_INVOKE_FROM_EVAL(0x09B4EE276DCCFCFBLL, mysql_fetch_row);
      break;
    case 3326:
      HASH_INVOKE_FROM_EVAL(0x768F3E6D1CBA5CFELL, socket_recv);
      break;
    case 3327:
      HASH_INVOKE_FROM_EVAL(0x748D3DFF0EB57CFFLL, uniqid);
      HASH_INVOKE_FROM_EVAL(0x48A2F2A7A4620CFFLL, pixelsetyellowquantum);
      break;
    case 3330:
      HASH_INVOKE_FROM_EVAL(0x018F22AEA371ED02LL, filemtime);
      HASH_INVOKE_FROM_EVAL(0x7EB48D1BB5B7AD02LL, dom_element_set_attribute);
      break;
    case 3332:
      HASH_INVOKE_FROM_EVAL(0x1248250E701DAD04LL, magickgaussianblurimage);
      break;
    case 3334:
      HASH_INVOKE_FROM_EVAL(0x2BA9FB0F8B76DD06LL, number_format);
      break;
    case 3335:
      HASH_INVOKE_FROM_EVAL(0x19B643D858DC6D07LL, magickgetimagerenderingintent);
      break;
    case 3337:
      HASH_INVOKE_FROM_EVAL(0x153F7DBFC9047D09LL, pixelsetred);
      break;
    case 3338:
      HASH_INVOKE_FROM_EVAL(0x6E8996DD071CED0ALL, dom_element_remove_attribute_node);
      break;
    case 3340:
      HASH_INVOKE_FROM_EVAL(0x30A8326034801D0CLL, mysql_pconnect);
      break;
    case 3341:
      HASH_INVOKE_FROM_EVAL(0x3ACE8A8BC9ACDD0DLL, iconv_mime_decode);
      break;
    case 3344:
      HASH_INVOKE_FROM_EVAL(0x42BEEC88EE81FD10LL, imagechar);
      HASH_INVOKE_FROM_EVAL(0x08F41A00D5D57D10LL, mb_decode_mimeheader);
      HASH_INVOKE_FROM_EVAL(0x5CEFA5A265104D10LL, count);
      break;
    case 3345:
      HASH_INVOKE_FROM_EVAL(0x2D484921B5400D11LL, magickradialblurimage);
      break;
    case 3346:
      HASH_INVOKE_FROM_EVAL(0x5F165B40AEEE5D12LL, hphp_splfileinfo_getfilename);
      break;
    case 3348:
      HASH_INVOKE_FROM_EVAL(0x63837ECAF6235D14LL, preg_replace);
      break;
    case 3351:
      HASH_INVOKE_FROM_EVAL(0x12BB5E00E714ED17LL, magickgetimagecompose);
      break;
    case 3354:
      HASH_INVOKE_FROM_EVAL(0x75DB75CA9DE56D1ALL, xml_parser_get_option);
      HASH_INVOKE_FROM_EVAL(0x39994614C6315D1ALL, hphp_recursivedirectoryiterator_key);
      break;
    case 3355:
      HASH_INVOKE_FROM_EVAL(0x70C22A7EEF54CD1BLL, ldap_compare);
      break;
    case 3358:
      HASH_INVOKE_FROM_EVAL(0x25DADFF238A15D1ELL, collator_create);
      break;
    case 3359:
      HASH_INVOKE_FROM_EVAL(0x566465036CCBCD1FLL, min);
      break;
    case 3365:
      HASH_INVOKE_FROM_EVAL(0x71DF0C17F47EDD25LL, getprotobynumber);
      break;
    case 3366:
      HASH_INVOKE_FROM_EVAL(0x429D088E9779CD26LL, dom_document_normalize_document);
      break;
    case 3368:
      HASH_INVOKE_FROM_EVAL(0x7C12261259F87D28LL, mcrypt_enc_is_block_algorithm_mode);
      break;
    case 3369:
      HASH_INVOKE_FROM_EVAL(0x632D50B69429ED29LL, socket_set_block);
      break;
    case 3370:
      HASH_INVOKE_FROM_EVAL(0x7A9C06B9CF853D2ALL, substr_count);
      break;
    case 3378:
      HASH_INVOKE_FROM_EVAL(0x4DAC43060BA57D32LL, stream_wrapper_restore);
      break;
    case 3382:
      HASH_INVOKE_FROM_EVAL(0x515841235FADCD36LL, class_implements);
      break;
    case 3383:
      HASH_INVOKE_FROM_EVAL(0x3ACF745D381E9D37LL, rtrim);
      break;
    case 3384:
      HASH_INVOKE_FROM_EVAL(0x0BA3AD85EB597D38LL, pagelet_server_task_result);
      break;
    case 3387:
      HASH_INVOKE_FROM_EVAL(0x0784B2B034560D3BLL, destroypixelwand);
      HASH_INVOKE_FROM_EVAL(0x6C9AE626DAD02D3BLL, mailparse_msg_extract_part_file);
      break;
    case 3392:
      HASH_INVOKE_FROM_EVAL(0x198627C81DABAD40LL, register_cleanup_function);
      break;
    case 3393:
      HASH_INVOKE_FROM_EVAL(0x6B6DA1EE18673D41LL, xmlwriter_end_dtd_entity);
      break;
    case 3394:
      HASH_INVOKE_FROM_EVAL(0x40497FCA4EC4DD42LL, posix_seteuid);
      HASH_INVOKE_FROM_EVAL(0x298BA735FA3ABD42LL, nl_langinfo);
      break;
    case 3397:
      HASH_INVOKE_FROM_EVAL(0x400A44045A999D45LL, rawurlencode);
      break;
    case 3398:
      HASH_INVOKE_FROM_EVAL(0x502CF4EB0A747D46LL, magicksetimagebias);
      HASH_INVOKE_FROM_EVAL(0x455DB7F86BCEDD46LL, pixelsetopacityquantum);
      HASH_INVOKE_FROM_EVAL(0x59AD2C922FF75D46LL, mdecrypt_generic);
      break;
    case 3401:
      HASH_INVOKE_FROM_EVAL(0x113ED435AEFDDD49LL, imagecolorallocatealpha);
      HASH_INVOKE_FROM_EVAL(0x41785512C45FCD49LL, mysql_ping);
      break;
    case 3407:
      HASH_INVOKE_FROM_EVAL(0x0FBCF35ADD209D4FLL, drawarc);
      break;
    case 3408:
      HASH_INVOKE_FROM_EVAL(0x39B11A2A25E40D50LL, mysql_get_server_info);
      HASH_INVOKE_FROM_EVAL(0x337D2252CDA22D50LL, is_real);
      break;
    case 3413:
      HASH_INVOKE_FROM_EVAL(0x36D672EF4FBEFD55LL, json_encode);
      break;
    case 3416:
      HASH_INVOKE_FROM_EVAL(0x146109BDD2F97D58LL, hphp_splfileobject_setmaxlinelen);
      break;
    case 3418:
      HASH_INVOKE_FROM_EVAL(0x4ACCF26A7AE80D5ALL, imagefilltoborder);
      break;
    case 3419:
      HASH_INVOKE_FROM_EVAL(0x41B5E3D2AADE2D5BLL, drawroundrectangle);
      break;
    case 3420:
      HASH_INVOKE_FROM_EVAL(0x1371413B4F6F8D5CLL, pixelgetred);
      break;
    case 3424:
      HASH_INVOKE_FROM_EVAL(0x6FACBD7F02B6FD60LL, uasort);
      HASH_INVOKE_FROM_EVAL(0x567276D68FE12D60LL, preg_quote);
      break;
    case 3425:
      HASH_INVOKE_FROM_EVAL(0x34F150F3D94E6D61LL, gzpassthru);
      HASH_INVOKE_FROM_EVAL(0x357BAB6E700EBD61LL, destroypixelwandarray);
      break;
    case 3430:
      HASH_INVOKE_FROM_EVAL(0x0C393EE8F6540D66LL, bccomp);
      break;
    case 3437:
      HASH_INVOKE_FROM_EVAL(0x21D924BA98BFCD6DLL, file_get_contents);
      HASH_INVOKE_FROM_EVAL(0x7D9E024FD8696D6DLL, get_class);
      HASH_INVOKE_FROM_EVAL(0x4351AFD0FD818D6DLL, magickmotionblurimage);
      break;
    case 3438:
      HASH_INVOKE_FROM_EVAL(0x0B1348D1540E7D6ELL, magicksetimageformat);
      break;
    case 3441:
      HASH_INVOKE_FROM_EVAL(0x74FDC4596C654D71LL, dom_node_is_default_namespace);
      break;
    case 3443:
      HASH_INVOKE_FROM_EVAL(0x7D8DCC72522CBD73LL, mb_detect_encoding);
      break;
    case 3446:
      HASH_INVOKE_FROM_EVAL(0x7467E8107EF08D76LL, unpack);
      break;
    case 3447:
      HASH_INVOKE_FROM_EVAL(0x3ED49C2BBDDFAD77LL, ldap_next_reference);
      HASH_INVOKE_FROM_EVAL(0x7FCAAAB932C57D77LL, iterator_count);
      break;
    case 3448:
      HASH_INVOKE_FROM_EVAL(0x6352349F97557D78LL, stream_socket_get_name);
      break;
    case 3451:
      HASH_INVOKE_FROM_EVAL(0x680A7EB3DA1F5D7BLL, prev);
      break;
    case 3454:
      HASH_INVOKE_FROM_EVAL(0x384E8BC9B5FE2D7ELL, magickfximage);
      break;
    case 3455:
      HASH_INVOKE_FROM_EVAL(0x4E19AFB75A62AD7FLL, imagerotate);
      break;
    case 3457:
      HASH_INVOKE_FROM_EVAL(0x25EA810DAEA74D81LL, ob_clean);
      break;
    case 3458:
      HASH_INVOKE_FROM_EVAL(0x2D15262403ADDD82LL, drawcomposite);
      break;
    case 3459:
      HASH_INVOKE_FROM_EVAL(0x1B0FF5C02F571D83LL, fb_rename_function);
      break;
    case 3463:
      HASH_INVOKE_FROM_EVAL(0x344091B785FE8D87LL, socket_set_timeout);
      break;
    case 3464:
      HASH_INVOKE_FROM_EVAL(0x2AFF8525E93D6D88LL, drawsetfillopacity);
      HASH_INVOKE_FROM_EVAL(0x1F22C82816F9AD88LL, hphp_splfileinfo_getpath);
      break;
    case 3465:
      HASH_INVOKE_FROM_EVAL(0x230E7AD147721D89LL, end);
      break;
    case 3470:
      HASH_INVOKE_FROM_EVAL(0x6A351AEDFC4D0D8ELL, magickgetimagemimetype);
      break;
    case 3471:
      HASH_INVOKE_FROM_EVAL(0x1806DC9468882D8FLL, gzfile);
      break;
    case 3472:
      HASH_INVOKE_FROM_EVAL(0x5E4360FC28D0AD90LL, magicksetinterlacescheme);
      break;
    case 3473:
      HASH_INVOKE_FROM_EVAL(0x5695393CF6428D91LL, dom_element_set_id_attribute);
      HASH_INVOKE_FROM_EVAL(0x48444F8F18E60D91LL, strftime);
      HASH_INVOKE_FROM_EVAL(0x7C2B3FE61FBDFD91LL, openssl_pkey_get_details);
      break;
    case 3480:
      HASH_INVOKE_FROM_EVAL(0x06A796D329C21D98LL, call_user_func);
      break;
    case 3485:
      HASH_INVOKE_FROM_EVAL(0x74BE8836F3B13D9DLL, session_name);
      break;
    case 3486:
      HASH_INVOKE_FROM_EVAL(0x30C1AE2B06990D9ELL, gzseek);
      break;
    case 3488:
      HASH_INVOKE_FROM_EVAL(0x73B43ABDD5C61DA0LL, shuffle);
      HASH_INVOKE_FROM_EVAL(0x5E8606470A09BDA0LL, magickposterizeimage);
      HASH_INVOKE_FROM_EVAL(0x7084C6294240CDA0LL, octdec);
      HASH_INVOKE_FROM_EVAL(0x167A11C41EB71DA0LL, pixelgetexceptiontype);
      break;
    case 3490:
      HASH_INVOKE_FROM_EVAL(0x71583A8FEF5C7DA2LL, sys_get_temp_dir);
      break;
    case 3493:
      HASH_INVOKE_FROM_EVAL(0x46B2F287D2FC7DA5LL, memcache_get);
      break;
    case 3494:
      HASH_INVOKE_FROM_EVAL(0x28DC1AD6DA9E7DA6LL, gethostbyname);
      break;
    case 3496:
      HASH_INVOKE_FROM_EVAL(0x18FEAF2459E5ADA8LL, dom_element_has_attribute);
      HASH_INVOKE_FROM_EVAL(0x572AE270D9E4FDA8LL, socket_set_option);
      HASH_INVOKE_FROM_EVAL(0x474A096265502DA8LL, glob);
      break;
    case 3498:
      HASH_INVOKE_FROM_EVAL(0x6326C14D0FFA7DAALL, fb_thrift_serialize);
      break;
    case 3499:
      HASH_INVOKE_FROM_EVAL(0x188720048AB37DABLL, magickquantizeimages);
      HASH_INVOKE_FROM_EVAL(0x66764CAABFF4CDABLL, array_keys);
      break;
    case 3505:
      HASH_INVOKE_FROM_EVAL(0x67EAC6D7332F3DB1LL, hphp_splfileobject_fgetcsv);
      break;
    case 3506:
      HASH_INVOKE_FROM_EVAL(0x257371BC40186DB2LL, magickblurimage);
      break;
    case 3507:
      HASH_INVOKE_FROM_EVAL(0x628069E483F35DB3LL, hphp_splfileobject_fstat);
      HASH_INVOKE_FROM_EVAL(0x53F2C6F5AE244DB3LL, drawpushdefs);
      break;
    case 3512:
      HASH_INVOKE_FROM_EVAL(0x2B1D442AEA06ADB8LL, strpbrk);
      break;
    case 3514:
      HASH_INVOKE_FROM_EVAL(0x5E0C6E797607DDBALL, mysql_result);
      HASH_INVOKE_FROM_EVAL(0x7964DE73DCA17DBALL, magickhasnextimage);
      break;
    case 3516:
      HASH_INVOKE_FROM_EVAL(0x770DEDCB168B0DBCLL, mb_ereg_search_setpos);
      break;
    case 3517:
      HASH_INVOKE_FROM_EVAL(0x48AA091B1E493DBDLL, setlocale);
      HASH_INVOKE_FROM_EVAL(0x01E6FF7D9746CDBDLL, stream_socket_accept);
      break;
    case 3521:
      HASH_INVOKE_FROM_EVAL(0x683E88F441F9BDC1LL, chgrp);
      break;
    case 3523:
      HASH_INVOKE_FROM_EVAL(0x069EE6F604BA2DC3LL, array_reverse);
      HASH_INVOKE_FROM_EVAL(0x0433140BB339DDC3LL, log);
      break;
    case 3524:
      HASH_INVOKE_FROM_EVAL(0x2A38BA8B4A0F9DC4LL, apc_fetch);
      break;
    case 3526:
      HASH_INVOKE_FROM_EVAL(0x73210FEAA2EACDC6LL, imagecolorsforindex);
      break;
    case 3528:
      HASH_INVOKE_FROM_EVAL(0x66C3E73210067DC8LL, magickgetimageunits);
      break;
    case 3530:
      HASH_INVOKE_FROM_EVAL(0x3BB701F2BDD0ADCALL, magickgetimageprofile);
      break;
    case 3534:
      HASH_INVOKE_FROM_EVAL(0x3E5C990C32470DCELL, array_combine);
      HASH_INVOKE_FROM_EVAL(0x4AD5B65BCE665DCELL, array_key_exists);
      HASH_INVOKE_FROM_EVAL(0x40C3C7DE46D62DCELL, ob_start);
      break;
    case 3536:
      HASH_INVOKE_FROM_EVAL(0x0E1C354339208DD0LL, imagetypes);
      break;
    case 3541:
      HASH_INVOKE_FROM_EVAL(0x7E1801C8E70D1DD5LL, imagefontwidth);
      break;
    case 3543:
      HASH_INVOKE_FROM_EVAL(0x638690DF6D06FDD7LL, imageconvolution);
      HASH_INVOKE_FROM_EVAL(0x1AE08377A1630DD7LL, mysql_insert_id);
      break;
    case 3548:
      HASH_INVOKE_FROM_EVAL(0x5EBE067E3FAECDDCLL, ob_gzhandler);
      HASH_INVOKE_FROM_EVAL(0x2497295AC9F72DDCLL, stream_set_blocking);
      break;
    case 3549:
      HASH_INVOKE_FROM_EVAL(0x3B00B916C3682DDDLL, ctype_upper);
      break;
    case 3560:
      HASH_INVOKE_FROM_EVAL(0x47A4BA8616D02DE8LL, restore_exception_handler);
      break;
    case 3564:
      HASH_INVOKE_FROM_EVAL(0x5B51DD18C3E13DECLL, openssl_x509_parse);
      HASH_INVOKE_FROM_EVAL(0x5ABB7486CE861DECLL, array_merge_recursive);
      break;
    case 3567:
      HASH_INVOKE_FROM_EVAL(0x0BB22147ADADDDEFLL, pfsockopen);
      HASH_INVOKE_FROM_EVAL(0x72293DCE8CC4BDEFLL, htmlspecialchars);
      break;
    case 3571:
      HASH_INVOKE_FROM_EVAL(0x7AE1BE187F18FDF3LL, fgets);
      break;
    case 3572:
      HASH_INVOKE_FROM_EVAL(0x73B30E65808A6DF4LL, ctype_xdigit);
      HASH_INVOKE_FROM_EVAL(0x5046A0D9DFDB5DF4LL, strcspn);
      break;
    case 3575:
      HASH_INVOKE_FROM_EVAL(0x23E563F1EC919DF7LL, hphp_splfileinfo_getpathname);
      break;
    case 3576:
      HASH_INVOKE_FROM_EVAL(0x5E43280BC8DD1DF8LL, magicktrimimage);
      break;
    case 3579:
      HASH_INVOKE_FROM_EVAL(0x47C62D58B0B65DFBLL, thrift_protocol_write_binary);
      break;
    case 3582:
      HASH_INVOKE_FROM_EVAL(0x21F24104004CFDFELL, evhttp_post);
      HASH_INVOKE_FROM_EVAL(0x072690BF719D7DFELL, hphp_recursivedirectoryiterator_rewind);
      break;
    case 3586:
      HASH_INVOKE_FROM_EVAL(0x7829D2171DFBFE02LL, magickgetimagegamma);
      break;
    case 3596:
      HASH_INVOKE_FROM_EVAL(0x3AD6E084483B2E0CLL, array_udiff_assoc);
      break;
    case 3597:
      HASH_INVOKE_FROM_EVAL(0x5EB0A2F93E650E0DLL, array_diff_key);
      HASH_INVOKE_FROM_EVAL(0x756B92411E7FBE0DLL, stream_get_wrappers);
      break;
    case 3598:
      HASH_INVOKE_FROM_EVAL(0x5230E4C9D8D64E0ELL, highlight_string);
      break;
    case 3602:
      HASH_INVOKE_FROM_EVAL(0x05FAA2085D94FE12LL, urlencode);
      HASH_INVOKE_FROM_EVAL(0x76636D0F0C090E12LL, curl_copy_handle);
      break;
    case 3604:
      HASH_INVOKE_FROM_EVAL(0x41E394B12170BE14LL, socket_send);
      HASH_INVOKE_FROM_EVAL(0x3192209D50C1FE14LL, pixelsetalpha);
      break;
    case 3605:
      HASH_INVOKE_FROM_EVAL(0x525F197D74423E15LL, get_resource_type);
      break;
    case 3607:
      HASH_INVOKE_FROM_EVAL(0x0F5759A501FAFE17LL, imagecreatefromgd2part);
      HASH_INVOKE_FROM_EVAL(0x3D13FD5FE3AF6E17LL, imagestringup);
      break;
    case 3609:
      HASH_INVOKE_FROM_EVAL(0x4A694B42B21A9E19LL, destroymagickwand);
      break;
    case 3611:
      HASH_INVOKE_FROM_EVAL(0x7FA0B63054221E1BLL, magickrollimage);
      break;
    case 3616:
      HASH_INVOKE_FROM_EVAL(0x7BDA47B5C47EAE20LL, fread);
      break;
    case 3617:
      HASH_INVOKE_FROM_EVAL(0x5B7F218FA08D8E21LL, imagefilledellipse);
      break;
    case 3621:
      HASH_INVOKE_FROM_EVAL(0x1C6246FA51EBDE25LL, hphp_get_static_property);
      break;
    case 3624:
      HASH_INVOKE_FROM_EVAL(0x3456885FF0679E28LL, lchown);
      break;
    case 3625:
      HASH_INVOKE_FROM_EVAL(0x73FE5C79E14A0E29LL, pixelsetbluequantum);
      break;
    case 3629:
      HASH_INVOKE_FROM_EVAL(0x7817FA38BAAEFE2DLL, fsockopen);
      break;
    case 3630:
      HASH_INVOKE_FROM_EVAL(0x3E62C1A48E9EEE2ELL, hphp_splfileinfo_getsize);
      break;
    case 3634:
      HASH_INVOKE_FROM_EVAL(0x000AAF93F814AE32LL, drawsetvectorgraphics);
      break;
    case 3635:
      HASH_INVOKE_FROM_EVAL(0x38433635F28B4E33LL, is_readable);
      break;
    case 3638:
      HASH_INVOKE_FROM_EVAL(0x2E42ED1E15CCFE36LL, mysql_affected_rows);
      break;
    case 3642:
      HASH_INVOKE_FROM_EVAL(0x6E2CF6ECA0987E3ALL, get_headers);
      HASH_INVOKE_FROM_EVAL(0x13048F0A79F7CE3ALL, magicksetsamplingfactors);
      break;
    case 3648:
      HASH_INVOKE_FROM_EVAL(0x11681FDE841D0E40LL, drawskewy);
      break;
    case 3650:
      HASH_INVOKE_FROM_EVAL(0x160B01F095B20E42LL, mb_output_handler);
      break;
    case 3652:
      HASH_INVOKE_FROM_EVAL(0x71B7756BD1B43E44LL, dom_document_savexml);
      break;
    case 3654:
      HASH_INVOKE_FROM_EVAL(0x7F4C1DF551150E46LL, pixelgetnextiteratorrow);
      break;
    case 3660:
      HASH_INVOKE_FROM_EVAL(0x1EEBDFD62B6BEE4CLL, mcrypt_module_get_algo_block_size);
      break;
    case 3663:
      HASH_INVOKE_FROM_EVAL(0x62C934CD93938E4FLL, magickimplodeimage);
      break;
    case 3664:
      HASH_INVOKE_FROM_EVAL(0x4022005DE7E24E50LL, openssl_pkcs7_sign);
      break;
    case 3668:
      HASH_INVOKE_FROM_EVAL(0x6BF155774D546E54LL, define_syslog_variables);
      HASH_INVOKE_FROM_EVAL(0x7B6BF544EB420E54LL, hphp_recursivedirectoryiterator_haschildren);
      break;
    case 3671:
      HASH_INVOKE_FROM_EVAL(0x21B07F1F212BDE57LL, hphp_get_original_class_name);
      HASH_INVOKE_FROM_EVAL(0x2DEF52641933CE57LL, magickgetimagemattecolor);
      break;
    case 3675:
      HASH_INVOKE_FROM_EVAL(0x299F1A5895461E5BLL, curl_multi_close);
      break;
    case 3676:
      HASH_INVOKE_FROM_EVAL(0x532D0D905CE60E5CLL, posix_times);
      break;
    case 3677:
      HASH_INVOKE_FROM_EVAL(0x38373F6643B14E5DLL, ldap_parse_reference);
      break;
    case 3681:
      HASH_INVOKE_FROM_EVAL(0x593EA675D239CE61LL, ldap_first_reference);
      break;
    case 3682:
      HASH_INVOKE_FROM_EVAL(0x7639C74DBC4F4E62LL, array_splice);
      break;
    case 3683:
      HASH_INVOKE_FROM_EVAL(0x4B6FE37D66784E63LL, imagesy);
      HASH_INVOKE_FROM_EVAL(0x5697E5F6AAF47E63LL, mb_http_input);
      break;
    case 3684:
      HASH_INVOKE_FROM_EVAL(0x4F0DF8BBC4340E64LL, stream_socket_server);
      break;
    case 3685:
      HASH_INVOKE_FROM_EVAL(0x21D5A3208639EE65LL, dom_element_get_attribute_node_ns);
      break;
    case 3686:
      HASH_INVOKE_FROM_EVAL(0x6CB3DEB458A2DE66LL, apc_bin_load);
      break;
    case 3688:
      HASH_INVOKE_FROM_EVAL(0x5B1DFB89BFC1CE68LL, realpath);
      break;
    case 3689:
      HASH_INVOKE_FROM_EVAL(0x24B836D2C79D0E69LL, magickgetimagepixels);
      break;
    case 3690:
      HASH_INVOKE_FROM_EVAL(0x2F9816D9A2B2CE6ALL, mysql_set_charset);
      HASH_INVOKE_FROM_EVAL(0x25C0C5E961AFDE6ALL, xmlwriter_full_end_element);
      break;
    case 3693:
      HASH_INVOKE_FROM_EVAL(0x714001ABB0D76E6DLL, magickgetinterlacescheme);
      break;
    case 3695:
      HASH_INVOKE_FROM_EVAL(0x7E6223D0CF184E6FLL, magickqueryformats);
      break;
    case 3697:
      HASH_INVOKE_FROM_EVAL(0x6AC126DCE941FE71LL, memory_get_peak_usage);
      break;
    case 3699:
      HASH_INVOKE_FROM_EVAL(0x3B28CA1BE1D0DE73LL, xbox_get_thread_timeout);
      break;
    case 3700:
      HASH_INVOKE_FROM_EVAL(0x47D0510206B89E74LL, ini_restore);
      break;
    case 3701:
      HASH_INVOKE_FROM_EVAL(0x4EC7C66593DDEE75LL, sql_regcase);
      break;
    case 3702:
      HASH_INVOKE_FROM_EVAL(0x36E9EC047FC73E76LL, mb_convert_encoding);
      break;
    case 3703:
      HASH_INVOKE_FROM_EVAL(0x12B7B2D835B80E77LL, chmod);
      break;
    case 3706:
      HASH_INVOKE_FROM_EVAL(0x6A3D9F8EDB005E7ALL, flush);
      break;
    case 3708:
      HASH_INVOKE_FROM_EVAL(0x4D9C5B9A944CCE7CLL, convert_uudecode);
      break;
    case 3710:
      HASH_INVOKE_FROM_EVAL(0x51060D186C703E7ELL, headers_list);
      break;
    case 3713:
      HASH_INVOKE_FROM_EVAL(0x0ECFC3676B4FDE81LL, chr);
      HASH_INVOKE_FROM_EVAL(0x3B426B13FA584E81LL, fb_unserialize);
      break;
    case 3714:
      HASH_INVOKE_FROM_EVAL(0x379F7BF525FF1E82LL, magicksetimagecolorspace);
      break;
    case 3715:
      HASH_INVOKE_FROM_EVAL(0x724011CF7C31AE83LL, sqrt);
      break;
    case 3716:
      HASH_INVOKE_FROM_EVAL(0x1765A63835CC4E84LL, drawgetfontfamily);
      break;
    case 3717:
      HASH_INVOKE_FROM_EVAL(0x4710320ED6638E85LL, rename_function);
      break;
    case 3720:
      HASH_INVOKE_FROM_EVAL(0x1569DCC552EE8E88LL, cosh);
      break;
    case 3722:
      HASH_INVOKE_FROM_EVAL(0x15C9E5C16374EE8ALL, gzclose);
      break;
    case 3726:
      HASH_INVOKE_FROM_EVAL(0x29A2FBD427647E8ELL, mysql_connect);
      break;
    case 3728:
      HASH_INVOKE_FROM_EVAL(0x33D6CC3959D3CE90LL, clearmagickwand);
      break;
    case 3731:
      HASH_INVOKE_FROM_EVAL(0x5E968924197F5E93LL, mcrypt_ofb);
      HASH_INVOKE_FROM_EVAL(0x37A9E8F91C33EE93LL, magickborderimage);
      break;
    case 3735:
      HASH_INVOKE_FROM_EVAL(0x6254E9BDC11F3E97LL, imagecreatefromgd2);
      break;
    case 3739:
      HASH_INVOKE_FROM_EVAL(0x2A019CAA1188BE9BLL, preg_grep);
      break;
    case 3742:
      HASH_INVOKE_FROM_EVAL(0x76EBE919625D8E9ELL, openssl_pkcs12_export);
      break;
    case 3743:
      HASH_INVOKE_FROM_EVAL(0x224004A728974E9FLL, spl_object_hash);
      HASH_INVOKE_FROM_EVAL(0x7CFF820207DC6E9FLL, debug_backtrace);
      break;
    case 3744:
      HASH_INVOKE_FROM_EVAL(0x37C5AF6E7E8B5EA0LL, fputs);
      break;
    case 3747:
      HASH_INVOKE_FROM_EVAL(0x6467FFB910B8BEA3LL, magickspliceimage);
      break;
    case 3750:
      HASH_INVOKE_FROM_EVAL(0x1D7B8E395613AEA6LL, dom_element_remove_attribute_ns);
      break;
    case 3753:
      HASH_INVOKE_FROM_EVAL(0x308D76DB12424EA9LL, magicksetimageindex);
      break;
    case 3755:
      HASH_INVOKE_FROM_EVAL(0x632D4FC346797EABLL, pixelgetexceptionstring);
      break;
    case 3758:
      HASH_INVOKE_FROM_EVAL(0x5772A0B8C16DAEAELL, posix_setuid);
      break;
    case 3759:
      HASH_INVOKE_FROM_EVAL(0x12D83A92EFB0EEAFLL, xmlwriter_open_uri);
      break;
    case 3761:
      HASH_INVOKE_FROM_EVAL(0x33FE101882726EB1LL, proc_close);
      break;
    case 3763:
      HASH_INVOKE_FROM_EVAL(0x7DB9D839ACE0DEB3LL, natsort);
      HASH_INVOKE_FROM_EVAL(0x7379B5B97EC2EEB3LL, hypot);
      break;
    case 3764:
      HASH_INVOKE_FROM_EVAL(0x1F936B3C5406DEB4LL, fb_set_taint);
      break;
    case 3767:
      HASH_INVOKE_FROM_EVAL(0x58B9EFA0FB35FEB7LL, stream_filter_prepend);
      break;
    case 3769:
      HASH_INVOKE_FROM_EVAL(0x2A483AD7A3D07EB9LL, magickgetwandsize);
      break;
    case 3770:
      HASH_INVOKE_FROM_EVAL(0x1F5B2728DE875EBALL, magicksetimage);
      break;
    case 3773:
      HASH_INVOKE_FROM_EVAL(0x31A30B274AD2DEBDLL, call_user_func_array_rpc);
      break;
    case 3776:
      HASH_INVOKE_FROM_EVAL(0x2475D7045D9DEEC0LL, magicksetimagecompression);
      HASH_INVOKE_FROM_EVAL(0x495316E596537EC0LL, imagefttext);
      break;
    case 3778:
      HASH_INVOKE_FROM_EVAL(0x4CDD0B7BF826FEC2LL, rewinddir);
      break;
    case 3780:
      HASH_INVOKE_FROM_EVAL(0x7052903F1B17AEC4LL, parse_str);
      break;
    case 3781:
      HASH_INVOKE_FROM_EVAL(0x7D69B3537C353EC5LL, hphp_splfileinfo_isfile);
      break;
    case 3783:
      HASH_INVOKE_FROM_EVAL(0x4FC99DC20A955EC7LL, session_module_name);
      break;
    case 3785:
      HASH_INVOKE_FROM_EVAL(0x58C8DCAAE5B7CEC9LL, get_cfg_var);
      break;
    case 3786:
      HASH_INVOKE_FROM_EVAL(0x08E6C1CD3AC64ECALL, hphp_splfileinfo_gettype);
      HASH_INVOKE_FROM_EVAL(0x1AA83A1057BE6ECALL, mysql_field_len);
      break;
    case 3794:
      HASH_INVOKE_FROM_EVAL(0x3CCD09EC3511CED2LL, apd_stop_trace);
      break;
    case 3798:
      HASH_INVOKE_FROM_EVAL(0x134B37520683DED6LL, imagesetbrush);
      break;
    case 3800:
      HASH_INVOKE_FROM_EVAL(0x338D9D95095D1ED8LL, magicksetimagedelay);
      break;
    case 3801:
      HASH_INVOKE_FROM_EVAL(0x7F802A06996BBED9LL, apd_set_browser_trace);
      break;
    case 3802:
      HASH_INVOKE_FROM_EVAL(0x29E2771785CCBEDALL, magickgettextdescent);
      break;
    case 3803:
      HASH_INVOKE_FROM_EVAL(0x16331E18B5CD8EDBLL, timezone_open);
      HASH_INVOKE_FROM_EVAL(0x1340509769275EDBLL, magickgetimagecompression);
      break;
    case 3808:
      HASH_INVOKE_FROM_EVAL(0x7A1C6E429399CEE0LL, iconv_set_encoding);
      break;
    case 3809:
      HASH_INVOKE_FROM_EVAL(0x528BA9796BD0FEE1LL, fb_rpc_intercept_handler);
      break;
    case 3811:
      HASH_INVOKE_FROM_EVAL(0x1F4AACF075E9CEE3LL, memcache_get_server_status);
      HASH_INVOKE_FROM_EVAL(0x28A98134BD97BEE3LL, mb_regex_encoding);
      HASH_INVOKE_FROM_EVAL(0x0E1368A3BDFE6EE3LL, hphp_recursiveiteratoriterator_rewind);
      break;
    case 3812:
      HASH_INVOKE_FROM_EVAL(0x5B6FF42ACB2FBEE4LL, getmyuid);
      break;
    case 3813:
      HASH_INVOKE_FROM_EVAL(0x367CFD20B4446EE5LL, is_array);
      break;
    case 3816:
      HASH_INVOKE_FROM_EVAL(0x6CB6650E66CE4EE8LL, magicksetimagebordercolor);
      HASH_INVOKE_FROM_EVAL(0x32B3951DFD2B9EE8LL, hphp_directoryiterator_isdot);
      break;
    case 3819:
      HASH_INVOKE_FROM_EVAL(0x72882DBF2D49CEEBLL, set_magic_quotes_runtime);
      break;
    case 3824:
      HASH_INVOKE_FROM_EVAL(0x7DFF9707F1CD9EF0LL, dangling_server_proxy_old_request);
      break;
    case 3832:
      HASH_INVOKE_FROM_EVAL(0x33FD10AC81146EF8LL, thrift_protocol_read_binary);
      break;
    case 3833:
      HASH_INVOKE_FROM_EVAL(0x200FC256EB093EF9LL, gettimeofday);
      break;
    case 3835:
      HASH_INVOKE_FROM_EVAL(0x6D450F078F02BEFBLL, apd_continue);
      break;
    case 3837:
      HASH_INVOKE_FROM_EVAL(0x0CF27A6BC84CEEFDLL, openssl_get_publickey);
      HASH_INVOKE_FROM_EVAL(0x283E167EB3F04EFDLL, posix_getgid);
      break;
    case 3840:
      HASH_INVOKE_FROM_EVAL(0x09637D7CA2E33F00LL, fgetc);
      break;
    case 3841:
      HASH_INVOKE_FROM_EVAL(0x66137942508EBF01LL, date_create);
      HASH_INVOKE_FROM_EVAL(0x7B6A0D7510184F01LL, mysql_fetch_assoc);
      break;
    case 3842:
      HASH_INVOKE_FROM_EVAL(0x78A02A603FA6FF02LL, magickreducenoiseimage);
      break;
    case 3845:
      HASH_INVOKE_FROM_EVAL(0x6842585E79988F05LL, magickmosaicimages);
      break;
    case 3846:
      HASH_INVOKE_FROM_EVAL(0x1D3B08AA0AF50F06LL, gettype);
      HASH_INVOKE_FROM_EVAL(0x6692475BA65A2F06LL, imagearc);
      break;
    case 3851:
      HASH_INVOKE_FROM_EVAL(0x7756593AAC1F6F0BLL, imagecreatefromstring);
      break;
    case 3855:
      HASH_INVOKE_FROM_EVAL(0x61E7A36CA7FF5F0FLL, drawsetcliprule);
      HASH_INVOKE_FROM_EVAL(0x4BD54A631F665F0FLL, drawpathcurvetosmoothabsolute);
      break;
    case 3856:
      HASH_INVOKE_FROM_EVAL(0x700A75BF904DAF10LL, magickgetcharwidth);
      break;
    case 3858:
      HASH_INVOKE_FROM_EVAL(0x042492DDA48C4F12LL, gzdeflate);
      break;
    case 3859:
      HASH_INVOKE_FROM_EVAL(0x3B197C0731233F13LL, dom_characterdata_substring_data);
      break;
    case 3860:
      HASH_INVOKE_FROM_EVAL(0x04525BA2AE51EF14LL, date_sun_info);
      break;
    case 3861:
      HASH_INVOKE_FROM_EVAL(0x12F09EAED9078F15LL, mysql_fetch_field);
      break;
    case 3862:
      HASH_INVOKE_FROM_EVAL(0x23B7D9E4EC992F16LL, stream_get_line);
      HASH_INVOKE_FROM_EVAL(0x38664EFE3E0A0F16LL, json_decode);
      HASH_INVOKE_FROM_EVAL(0x0287B907DDA3EF16LL, hphpd_get_user_commands);
      break;
    case 3867:
      HASH_INVOKE_FROM_EVAL(0x27A4633381195F1BLL, chown);
      break;
    case 3871:
      HASH_INVOKE_FROM_EVAL(0x7C0C145EFE0EBF1FLL, defined);
      break;
    case 3872:
      HASH_INVOKE_FROM_EVAL(0x2C4206A0BD904F20LL, hphp_splfileobject_fseek);
      break;
    case 3873:
      HASH_INVOKE_FROM_EVAL(0x4282496A4BF42F21LL, php_uname);
      HASH_INVOKE_FROM_EVAL(0x77EC28645855AF21LL, magicksetcompressionquality);
      HASH_INVOKE_FROM_EVAL(0x1FF5B9A4FC78BF21LL, drawsettextantialias);
      break;
    case 3876:
      HASH_INVOKE_FROM_EVAL(0x05BD68F1D09CEF24LL, array_count_values);
      HASH_INVOKE_FROM_EVAL(0x5FA07E8B63BEAF24LL, mcrypt_enc_get_modes_name);
      break;
    case 3879:
      HASH_INVOKE_FROM_EVAL(0x4BAA5B688E6F6F27LL, gd_info);
      break;
    case 3884:
      HASH_INVOKE_FROM_EVAL(0x035EFF9E1757DF2CLL, http_build_query);
      break;
    case 3890:
      HASH_INVOKE_FROM_EVAL(0x78257F34467BDF32LL, drawsetstrokedasharray);
      HASH_INVOKE_FROM_EVAL(0x2B66EACB77AE9F32LL, print_r);
      break;
    case 3897:
      HASH_INVOKE_FROM_EVAL(0x0D4446B2DBC8EF39LL, hphp_splfileinfo_getinode);
      HASH_INVOKE_FROM_EVAL(0x3E9146C06AAEFF39LL, magicksetimagecompressionquality);
      HASH_INVOKE_FROM_EVAL(0x496CF4113CEA8F39LL, magicksetimagefilename);
      break;
    case 3899:
      HASH_INVOKE_FROM_EVAL(0x7EE74F798791CF3BLL, magickedgeimage);
      break;
    case 3900:
      HASH_INVOKE_FROM_EVAL(0x41136A5F28E84F3CLL, forward_static_call_array);
      break;
    case 3903:
      HASH_INVOKE_FROM_EVAL(0x1A9EFDD653DB8F3FLL, pcntl_wstopsig);
      break;
    case 3906:
      HASH_INVOKE_FROM_EVAL(0x3B46305DA1154F42LL, drawpopclippath);
      break;
    case 3909:
      HASH_INVOKE_FROM_EVAL(0x4E36A077234B8F45LL, pixelgetblack);
      HASH_INVOKE_FROM_EVAL(0x79265AADD9A8AF45LL, mcrypt_cbc);
      HASH_INVOKE_FROM_EVAL(0x5D3A31AB0E326F45LL, crc32);
      break;
    case 3910:
      HASH_INVOKE_FROM_EVAL(0x079EA27F72594F46LL, gzgets);
      break;
    case 3920:
      HASH_INVOKE_FROM_EVAL(0x7978A278AEAFAF50LL, pixelgetmagenta);
      break;
    case 3925:
      HASH_INVOKE_FROM_EVAL(0x49D986274B1C5F55LL, collator_asort);
      break;
    case 3926:
      HASH_INVOKE_FROM_EVAL(0x621590803EC88F56LL, imageline);
      break;
    case 3928:
      HASH_INVOKE_FROM_EVAL(0x0551AAE8F1A6FF58LL, magicklevelimage);
      break;
    case 3929:
      HASH_INVOKE_FROM_EVAL(0x38246B6BDE246F59LL, magickgetimagedispose);
      break;
    case 3931:
      HASH_INVOKE_FROM_EVAL(0x24F698A8A4B5AF5BLL, imagecolordeallocate);
      HASH_INVOKE_FROM_EVAL(0x76418F884500DF5BLL, stream_socket_enable_crypto);
      break;
    case 3933:
      HASH_INVOKE_FROM_EVAL(0x07FF92CF46DDFF5DLL, imagepsfreefont);
      break;
    case 3935:
      HASH_INVOKE_FROM_EVAL(0x703D339DD44E8F5FLL, dom_element_get_elements_by_tag_name);
      break;
    case 3936:
      HASH_INVOKE_FROM_EVAL(0x4F1D2858AD31AF60LL, imagecreatefromgd);
      break;
    case 3939:
      HASH_INVOKE_FROM_EVAL(0x1FFD204252F60F63LL, magicksetimageprofile);
      break;
    case 3940:
      HASH_INVOKE_FROM_EVAL(0x41EF51E62AD3DF64LL, pagelet_server_is_enabled);
      HASH_INVOKE_FROM_EVAL(0x280051555A21DF64LL, rename);
      break;
    case 3942:
      HASH_INVOKE_FROM_EVAL(0x6FFF1304EA444F66LL, drawsetstrokemiterlimit);
      break;
    case 3943:
      HASH_INVOKE_FROM_EVAL(0x319407AC92912F67LL, ereg);
      break;
    case 3946:
      HASH_INVOKE_FROM_EVAL(0x1670096FDE27AF6ALL, rewind);
      break;
    case 3947:
      HASH_INVOKE_FROM_EVAL(0x56EF59D6CB0A5F6BLL, dom_document_save_html_file);
      break;
    case 3948:
      HASH_INVOKE_FROM_EVAL(0x23D5E9E53D11BF6CLL, gmdate);
      break;
    case 3950:
      HASH_INVOKE_FROM_EVAL(0x3A56371CDDEA0F6ELL, gzgetc);
      break;
    case 3951:
      HASH_INVOKE_FROM_EVAL(0x42C4EC9D9F782F6FLL, htmlentities);
      break;
    case 3952:
      HASH_INVOKE_FROM_EVAL(0x68C257B62A36EF70LL, magicksetimagebackgroundcolor);
      HASH_INVOKE_FROM_EVAL(0x71557D108E5C0F70LL, xml_set_object);
      break;
    case 3954:
      HASH_INVOKE_FROM_EVAL(0x4B22EF06BAA83F72LL, version_compare);
      break;
    case 3956:
      HASH_INVOKE_FROM_EVAL(0x18BC9BF6D1E3CF74LL, magickpreviewimages);
      break;
    case 3961:
      HASH_INVOKE_FROM_EVAL(0x4BE9D91DD8624F79LL, money_format);
      break;
    case 3962:
      HASH_INVOKE_FROM_EVAL(0x7B0E6DB649084F7ALL, clearstatcache);
      break;
    case 3966:
      HASH_INVOKE_FROM_EVAL(0x7064BEBF508F3F7ELL, socket_read);
      break;
    case 3968:
      HASH_INVOKE_FROM_EVAL(0x63F18DE0DB807F80LL, magickqueryfonts);
      break;
    case 3972:
      HASH_INVOKE_FROM_EVAL(0x14402B01D00E9F84LL, magicksteganoimage);
      break;
    case 3973:
      HASH_INVOKE_FROM_EVAL(0x7EF68B9A55222F85LL, wandgetexceptionstring);
      break;
    case 3974:
      HASH_INVOKE_FROM_EVAL(0x44CE4DB1CE7E9F86LL, flock);
      break;
    case 3977:
      HASH_INVOKE_FROM_EVAL(0x13F52A829BAC0F89LL, timezone_identifiers_list);
      break;
    case 3979:
      HASH_INVOKE_FROM_EVAL(0x2755DD4112AA5F8BLL, magicksampleimage);
      HASH_INVOKE_FROM_EVAL(0x3703D22147C24F8BLL, pixelsetcyan);
      break;
    case 3982:
      HASH_INVOKE_FROM_EVAL(0x7A8F1104B0CCDF8ELL, phpcredits);
      break;
    case 3983:
      HASH_INVOKE_FROM_EVAL(0x4A6C46DC7FE29F8FLL, hphp_recursivedirectoryiterator_getchildren);
      break;
    case 3985:
      HASH_INVOKE_FROM_EVAL(0x78463112BE739F91LL, connection_timeout);
      break;
    case 3986:
      HASH_INVOKE_FROM_EVAL(0x288D61E7DE28AF92LL, ucwords);
      break;
    case 3988:
      HASH_INVOKE_FROM_EVAL(0x76B9D87BC7F02F94LL, preg_match);
      break;
    case 3989:
      HASH_INVOKE_FROM_EVAL(0x40D620CBA0D41F95LL, opendir);
      break;
    case 3991:
      HASH_INVOKE_FROM_EVAL(0x35117886C885DF97LL, hphp_recursivedirectoryiterator_getsubpathname);
      HASH_INVOKE_FROM_EVAL(0x6F9651265C096F97LL, magickreadimages);
      break;
    case 3992:
      HASH_INVOKE_FROM_EVAL(0x0293F60B46511F98LL, drawsetfontstretch);
      HASH_INVOKE_FROM_EVAL(0x66F1F0DB16C82F98LL, imagesavealpha);
      break;
    case 3994:
      HASH_INVOKE_FROM_EVAL(0x2B7CAC006AF27F9ALL, fflush);
      break;
    case 3995:
      HASH_INVOKE_FROM_EVAL(0x44244ECFB9F76F9BLL, dom_document_create_element_ns);
      break;
    case 3997:
      HASH_INVOKE_FROM_EVAL(0x0AD6DE8829773F9DLL, apc_compile_file);
      break;
    case 4004:
      HASH_INVOKE_FROM_EVAL(0x0E7E9AA21AE99FA4LL, hphp_recursiveiteratoriterator_current);
      break;
    case 4006:
      HASH_INVOKE_FROM_EVAL(0x0DEEA8C3E3A47FA6LL, read_exif_data);
      break;
    case 4014:
      HASH_INVOKE_FROM_EVAL(0x64D269A505D51FAELL, array_map);
      break;
    case 4015:
      HASH_INVOKE_FROM_EVAL(0x03979AACDBB24FAFLL, mailparse_msg_get_part);
      break;
    case 4016:
      HASH_INVOKE_FROM_EVAL(0x4A0B5F4676578FB0LL, imagecolorresolvealpha);
      break;
    case 4017:
      HASH_INVOKE_FROM_EVAL(0x0F78ECF42C30DFB1LL, array_chunk);
      break;
    case 4020:
      HASH_INVOKE_FROM_EVAL(0x3900FDF1C97BEFB4LL, drawrotate);
      break;
    case 4022:
      HASH_INVOKE_FROM_EVAL(0x56C0CCB57BB6EFB6LL, magicksetimageunits);
      HASH_INVOKE_FROM_EVAL(0x2B451EF5D52C4FB6LL, array_diff);
      break;
    case 4023:
      HASH_INVOKE_FROM_EVAL(0x6465CD999F4C5FB7LL, hphp_invoke_method);
      break;
    case 4024:
      HASH_INVOKE_FROM_EVAL(0x6DB2DB341ECF3FB8LL, file_exists);
      break;
    case 4026:
      HASH_INVOKE_FROM_EVAL(0x0664323CB1CC2FBALL, imagecolorset);
      break;
    case 4031:
      HASH_INVOKE_FROM_EVAL(0x70B38AB9EAE16FBFLL, ini_set);
      break;
    case 4033:
      HASH_INVOKE_FROM_EVAL(0x3FF9AAFF85DDDFC1LL, class_parents);
      break;
    case 4034:
      HASH_INVOKE_FROM_EVAL(0x6CA22E62D4762FC2LL, magickpainttransparentimage);
      HASH_INVOKE_FROM_EVAL(0x460470C490FAFFC2LL, dom_node_normalize);
      break;
    case 4037:
      HASH_INVOKE_FROM_EVAL(0x38498DD4C28D0FC5LL, hphp_splfileinfo_getatime);
      break;
    case 4043:
      HASH_INVOKE_FROM_EVAL(0x38237A4515F42FCBLL, array_pad);
      break;
    case 4045:
      HASH_INVOKE_FROM_EVAL(0x474566F3A2BE0FCDLL, mcrypt_enc_is_block_algorithm);
      break;
    case 4046:
      HASH_INVOKE_FROM_EVAL(0x042193C97C65FFCELL, magickwaveimage);
      break;
    case 4047:
      HASH_INVOKE_FROM_EVAL(0x3A3CFC1F001A6FCFLL, magickreadimagefile);
      break;
    case 4048:
      HASH_INVOKE_FROM_EVAL(0x21104CCA2942AFD0LL, fb_const_fetch);
      HASH_INVOKE_FROM_EVAL(0x2EAA47FA6C3FEFD0LL, drawgetstrokealpha);
      HASH_INVOKE_FROM_EVAL(0x53DB5D0490C51FD0LL, xhprof_sample_disable);
      break;
    case 4052:
      HASH_INVOKE_FROM_EVAL(0x4970B72A182E4FD4LL, readdir);
      break;
    case 4053:
      HASH_INVOKE_FROM_EVAL(0x751283FE764CAFD5LL, mysql_select_db);
      break;
    case 4054:
      HASH_INVOKE_FROM_EVAL(0x7FC00035D14B9FD6LL, apc_delete_file);
      break;
    case 4056:
      HASH_INVOKE_FROM_EVAL(0x4234F2B59531FFD8LL, posix_getlogin);
      break;
    case 4061:
      HASH_INVOKE_FROM_EVAL(0x4EDEDA4278CD3FDDLL, magickchopimage);
      break;
    case 4062:
      HASH_INVOKE_FROM_EVAL(0x7F5FC3CAF8CE9FDELL, gzcompress);
      HASH_INVOKE_FROM_EVAL(0x72925D2DF7E61FDELL, drawpathcurvetoquadraticbeziersmoothrelative);
      break;
    case 4071:
      HASH_INVOKE_FROM_EVAL(0x217067889854CFE7LL, xmlwriter_start_dtd);
      break;
    case 4072:
      HASH_INVOKE_FROM_EVAL(0x4D7AEC41CFD73FE8LL, hphp_recursivedirectoryiterator_getsubpath);
      break;
    case 4075:
      HASH_INVOKE_FROM_EVAL(0x67D1EE05DFE71FEBLL, hphp_splfileobject_getcvscontrol);
      break;
    case 4079:
      HASH_INVOKE_FROM_EVAL(0x00EEEE9C6CEA5FEFLL, xmlwriter_write_element_ns);
      break;
    case 4080:
      HASH_INVOKE_FROM_EVAL(0x1189B7C4F4874FF0LL, php_check_syntax);
      break;
    case 4085:
      HASH_INVOKE_FROM_EVAL(0x191ECE88E06E6FF5LL, dom_node_is_supported);
      break;
    case 4086:
      HASH_INVOKE_FROM_EVAL(0x25FCE64E12505FF6LL, magicksetimagerenderingintent);
      break;
    case 4087:
      HASH_INVOKE_FROM_EVAL(0x7883232CD1A7CFF7LL, dom_node_is_same_node);
      break;
    case 4090:
      HASH_INVOKE_FROM_EVAL(0x13EE24AF67113FFALL, ob_end_flush);
      break;
    case 4091:
      HASH_INVOKE_FROM_EVAL(0x63BE4CEF1FC47FFBLL, imagefill);
      break;
    case 4094:
      HASH_INVOKE_FROM_EVAL(0x32F8747E480CCFFELL, connection_status);
      break;
    default:
      break;
  }
  return invoke_failed(s, eval_get_params(env, caller), -1, fatal);
}
CallInfo ci_utf8_encode((void*)&i_utf8_encode, (void*)&ifa_utf8_encode, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject___construct((void*)&i_hphp_splfileobject___construct, (void*)&ifa_hphp_splfileobject___construct, 5, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_create_comment((void*)&i_dom_document_create_comment, (void*)&ifa_dom_document_create_comment, 2, 0, 0x0000000000000000LL);
CallInfo ci_func_get_args((void*)&i_func_get_args, (void*)&ifa_func_get_args, 0, 0, 0x0000000000000000LL);
CallInfo ci_php_uname((void*)&i_php_uname, (void*)&ifa_php_uname, 1, 0, 0x0000000000000000LL);
CallInfo ci_posix_uname((void*)&i_posix_uname, (void*)&ifa_posix_uname, 0, 0, 0x0000000000000000LL);
CallInfo ci_curl_multi_remove_handle((void*)&i_curl_multi_remove_handle, (void*)&ifa_curl_multi_remove_handle, 2, 0, 0x0000000000000000LL);
CallInfo ci_memcache_get_server_status((void*)&i_memcache_get_server_status, (void*)&ifa_memcache_get_server_status, 3, 0, 0x0000000000000000LL);
CallInfo ci_mysql_result((void*)&i_mysql_result, (void*)&ifa_mysql_result, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_current((void*)&i_hphp_splfileobject_current, (void*)&ifa_hphp_splfileobject_current, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getgroup((void*)&i_hphp_splfileinfo_getgroup, (void*)&ifa_hphp_splfileinfo_getgroup, 1, 0, 0x0000000000000000LL);
CallInfo ci_register_shutdown_function((void*)&i_register_shutdown_function, (void*)&ifa_register_shutdown_function, 1, 1, 0x0000000000000000LL);
CallInfo ci_pixelsetmagentaquantum((void*)&i_pixelsetmagentaquantum, (void*)&ifa_pixelsetmagentaquantum, 2, 0, 0x0000000000000000LL);
CallInfo ci_newmagickwand((void*)&i_newmagickwand, (void*)&ifa_newmagickwand, 0, 0, 0x0000000000000000LL);
CallInfo ci_natsort((void*)&i_natsort, (void*)&ifa_natsort, 1, 0, 0x0000000000000001LL);
CallInfo ci_socket_accept((void*)&i_socket_accept, (void*)&ifa_socket_accept, 1, 0, 0x0000000000000000LL);
CallInfo ci_vprintf((void*)&i_vprintf, (void*)&ifa_vprintf, 2, 0, 0x0000000000000000LL);
CallInfo ci_collator_set_attribute((void*)&i_collator_set_attribute, (void*)&ifa_collator_set_attribute, 3, 0, 0x0000000000000000LL);
CallInfo ci_ucwords((void*)&i_ucwords, (void*)&ifa_ucwords, 1, 0, 0x0000000000000000LL);
CallInfo ci_header((void*)&i_header, (void*)&ifa_header, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_has_attribute_ns((void*)&i_dom_element_has_attribute_ns, (void*)&ifa_dom_element_has_attribute_ns, 3, 0, 0x0000000000000000LL);
CallInfo ci_date_default_timezone_set((void*)&i_date_default_timezone_set, (void*)&ifa_date_default_timezone_set, 1, 0, 0x0000000000000000LL);
CallInfo ci_is_object((void*)&i_is_object, (void*)&ifa_is_object, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagebias((void*)&i_magicksetimagebias, (void*)&ifa_magicksetimagebias, 2, 0, 0x0000000000000000LL);
CallInfo ci_exif_imagetype((void*)&i_exif_imagetype, (void*)&ifa_exif_imagetype, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagegrabscreen((void*)&i_imagegrabscreen, (void*)&ifa_imagegrabscreen, 0, 0, 0x0000000000000000LL);
CallInfo ci_bcmod((void*)&i_bcmod, (void*)&ifa_bcmod, 2, 0, 0x0000000000000000LL);
CallInfo ci_chr((void*)&i_chr, (void*)&ifa_chr, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawsetfontstretch((void*)&i_drawsetfontstretch, (void*)&ifa_drawsetfontstretch, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_setsid((void*)&i_posix_setsid, (void*)&ifa_posix_setsid, 0, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_setfileclass((void*)&i_hphp_splfileinfo_setfileclass, (void*)&ifa_hphp_splfileinfo_setfileclass, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_getpwnam((void*)&i_posix_getpwnam, (void*)&ifa_posix_getpwnam, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_enc_get_supported_key_sizes((void*)&i_mcrypt_enc_get_supported_key_sizes, (void*)&ifa_mcrypt_enc_get_supported_key_sizes, 1, 0, 0x0000000000000000LL);
CallInfo ci_phpinfo((void*)&i_phpinfo, (void*)&ifa_phpinfo, 1, 0, 0x0000000000000000LL);
CallInfo ci_evhttp_async_get((void*)&i_evhttp_async_get, (void*)&ifa_evhttp_async_get, 3, 0, 0x0000000000000000LL);
CallInfo ci_ldap_parse_result((void*)&i_ldap_parse_result, (void*)&ifa_ldap_parse_result, 6, 0, 0x000000000000003CLL);
CallInfo ci_drawgettextantialias((void*)&i_drawgettextantialias, (void*)&ifa_drawgettextantialias, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_fill_keys((void*)&i_array_fill_keys, (void*)&ifa_array_fill_keys, 2, 0, 0x0000000000000000LL);
CallInfo ci_openssl_seal((void*)&i_openssl_seal, (void*)&ifa_openssl_seal, 4, 0, 0x0000000000000006LL);
CallInfo ci_socket_clear_error((void*)&i_socket_clear_error, (void*)&ifa_socket_clear_error, 1, 0, 0x0000000000000000LL);
CallInfo ci_die((void*)&i_die, (void*)&ifa_die, 1, 0, 0x0000000000000000LL);
CallInfo ci_diskfreespace((void*)&i_diskfreespace, (void*)&ifa_diskfreespace, 1, 0, 0x0000000000000000LL);
CallInfo ci_xml_set_start_namespace_decl_handler((void*)&i_xml_set_start_namespace_decl_handler, (void*)&ifa_xml_set_start_namespace_decl_handler, 2, 0, 0x0000000000000000LL);
CallInfo ci_decbin((void*)&i_decbin, (void*)&ifa_decbin, 1, 0, 0x0000000000000000LL);
CallInfo ci_sizeof((void*)&i_sizeof, (void*)&ifa_sizeof, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_convert_case((void*)&i_mb_convert_case, (void*)&ifa_mb_convert_case, 3, 0, 0x0000000000000000LL);
CallInfo ci_fb_set_taint((void*)&i_fb_set_taint, (void*)&ifa_fb_set_taint, 2, 0, 0x0000000000000001LL);
CallInfo ci_dir((void*)&i_dir, (void*)&ifa_dir, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_combine((void*)&i_array_combine, (void*)&ifa_array_combine, 2, 0, 0x0000000000000000LL);
CallInfo ci_strpos((void*)&i_strpos, (void*)&ifa_strpos, 3, 0, 0x0000000000000000LL);
CallInfo ci_array_reverse((void*)&i_array_reverse, (void*)&ifa_array_reverse, 2, 0, 0x0000000000000000LL);
CallInfo ci_strrev((void*)&i_strrev, (void*)&ifa_strrev, 1, 0, 0x0000000000000000LL);
CallInfo ci_msg_set_queue((void*)&i_msg_set_queue, (void*)&ifa_msg_set_queue, 2, 0, 0x0000000000000000LL);
CallInfo ci_cos((void*)&i_cos, (void*)&ifa_cos, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursivedirectoryiterator_valid((void*)&i_hphp_recursivedirectoryiterator_valid, (void*)&ifa_hphp_recursivedirectoryiterator_valid, 1, 0, 0x0000000000000000LL);
CallInfo ci_bcmul((void*)&i_bcmul, (void*)&ifa_bcmul, 3, 0, 0x0000000000000000LL);
CallInfo ci_openlog((void*)&i_openlog, (void*)&ifa_openlog, 3, 0, 0x0000000000000000LL);
CallInfo ci_get_include_path((void*)&i_get_include_path, (void*)&ifa_get_include_path, 0, 0, 0x0000000000000000LL);
CallInfo ci_socket_select((void*)&i_socket_select, (void*)&ifa_socket_select, 5, 0, 0x0000000000000007LL);
CallInfo ci_magickraiseimage((void*)&i_magickraiseimage, (void*)&ifa_magickraiseimage, 6, 0, 0x0000000000000000LL);
CallInfo ci_gzputs((void*)&i_gzputs, (void*)&ifa_gzputs, 3, 0, 0x0000000000000000LL);
CallInfo ci_strpbrk((void*)&i_strpbrk, (void*)&ifa_strpbrk, 2, 0, 0x0000000000000000LL);
CallInfo ci_shm_remove_var((void*)&i_shm_remove_var, (void*)&ifa_shm_remove_var, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_setuid((void*)&i_posix_setuid, (void*)&ifa_posix_setuid, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetyellow((void*)&i_pixelgetyellow, (void*)&ifa_pixelgetyellow, 1, 0, 0x0000000000000000LL);
CallInfo ci_convert_uudecode((void*)&i_convert_uudecode, (void*)&ifa_convert_uudecode, 1, 0, 0x0000000000000000LL);
CallInfo ci_htmlspecialchars_decode((void*)&i_htmlspecialchars_decode, (void*)&ifa_htmlspecialchars_decode, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_end_document((void*)&i_xmlwriter_end_document, (void*)&ifa_xmlwriter_end_document, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagehistogram((void*)&i_magickgetimagehistogram, (void*)&ifa_magickgetimagehistogram, 1, 0, 0x0000000000000000LL);
CallInfo ci_preg_last_error((void*)&i_preg_last_error, (void*)&ifa_preg_last_error, 0, 0, 0x0000000000000000LL);
CallInfo ci_end((void*)&i_end, (void*)&ifa_end, 1, 0, 0x0000000000000001LL);
CallInfo ci_stream_get_line((void*)&i_stream_get_line, (void*)&ifa_stream_get_line, 3, 0, 0x0000000000000000LL);
CallInfo ci_deg2rad((void*)&i_deg2rad, (void*)&ifa_deg2rad, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickrollimage((void*)&i_magickrollimage, (void*)&ifa_magickrollimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_ldap_sort((void*)&i_ldap_sort, (void*)&ifa_ldap_sort, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagetruecolortopalette((void*)&i_imagetruecolortopalette, (void*)&ifa_imagetruecolortopalette, 3, 0, 0x0000000000000000LL);
CallInfo ci_defined((void*)&i_defined, (void*)&ifa_defined, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageunits((void*)&i_magickgetimageunits, (void*)&ifa_magickgetimageunits, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimageblueprimary((void*)&i_magicksetimageblueprimary, (void*)&ifa_magicksetimageblueprimary, 3, 0, 0x0000000000000000LL);
CallInfo ci_session_name((void*)&i_session_name, (void*)&ifa_session_name, 1, 0, 0x0000000000000000LL);
CallInfo ci_get_class_vars((void*)&i_get_class_vars, (void*)&ifa_get_class_vars, 1, 0, 0x0000000000000000LL);
CallInfo ci_syslog((void*)&i_syslog, (void*)&ifa_syslog, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_unique((void*)&i_array_unique, (void*)&ifa_array_unique, 1, 0, 0x0000000000000000LL);
CallInfo ci_bcpow((void*)&i_bcpow, (void*)&ifa_bcpow, 3, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetopacityquantum((void*)&i_pixelgetopacityquantum, (void*)&ifa_pixelgetopacityquantum, 1, 0, 0x0000000000000000LL);
CallInfo ci_php_check_syntax((void*)&i_php_check_syntax, (void*)&ifa_php_check_syntax, 2, 0, 0x0000000000000002LL);
CallInfo ci_mysql_connect_with_db((void*)&i_mysql_connect_with_db, (void*)&ifa_mysql_connect_with_db, 8, 0, 0x0000000000000000LL);
CallInfo ci_drawgetstrokemiterlimit((void*)&i_drawgetstrokemiterlimit, (void*)&ifa_drawgetstrokemiterlimit, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_fpassthru((void*)&i_hphp_splfileobject_fpassthru, (void*)&ifa_hphp_splfileobject_fpassthru, 1, 0, 0x0000000000000000LL);
CallInfo ci_intl_error_name((void*)&i_intl_error_name, (void*)&ifa_intl_error_name, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetquantumcolor((void*)&i_pixelsetquantumcolor, (void*)&ifa_pixelsetquantumcolor, 5, 0, 0x0000000000000000LL);
CallInfo ci_gztell((void*)&i_gztell, (void*)&ifa_gztell, 1, 0, 0x0000000000000000LL);
CallInfo ci_strval((void*)&i_strval, (void*)&ifa_strval, 1, 0, 0x0000000000000000LL);
CallInfo ci_evhttp_recv((void*)&i_evhttp_recv, (void*)&ifa_evhttp_recv, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_replace_child((void*)&i_dom_node_replace_child, (void*)&ifa_dom_node_replace_child, 3, 0, 0x0000000000000000LL);
CallInfo ci_strspn((void*)&i_strspn, (void*)&ifa_strspn, 4, 0, 0x0000000000000000LL);
CallInfo ci_ini_restore((void*)&i_ini_restore, (void*)&ifa_ini_restore, 1, 0, 0x0000000000000000LL);
CallInfo ci_ldap_dn2ufn((void*)&i_ldap_dn2ufn, (void*)&ifa_ldap_dn2ufn, 1, 0, 0x0000000000000000LL);
CallInfo ci_ceil((void*)&i_ceil, (void*)&ifa_ceil, 1, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_end_dtd_attlist((void*)&i_xmlwriter_end_dtd_attlist, (void*)&ifa_xmlwriter_end_dtd_attlist, 1, 0, 0x0000000000000000LL);
CallInfo ci_phpversion((void*)&i_phpversion, (void*)&ifa_phpversion, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_filter_remove((void*)&i_stream_filter_remove, (void*)&ifa_stream_filter_remove, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_generic((void*)&i_mcrypt_generic, (void*)&ifa_mcrypt_generic, 2, 0, 0x0000000000000000LL);
CallInfo ci_is_file((void*)&i_is_file, (void*)&ifa_is_file, 1, 0, 0x0000000000000000LL);
CallInfo ci_xml_set_end_namespace_decl_handler((void*)&i_xml_set_end_namespace_decl_handler, (void*)&ifa_xml_set_end_namespace_decl_handler, 2, 0, 0x0000000000000000LL);
CallInfo ci_openssl_x509_export_to_file((void*)&i_openssl_x509_export_to_file, (void*)&ifa_openssl_x509_export_to_file, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagesetstyle((void*)&i_imagesetstyle, (void*)&ifa_imagesetstyle, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawcolor((void*)&i_drawcolor, (void*)&ifa_drawcolor, 4, 0, 0x0000000000000000LL);
CallInfo ci_get_headers((void*)&i_get_headers, (void*)&ifa_get_headers, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_drop_db((void*)&i_mysql_drop_db, (void*)&ifa_mysql_drop_db, 2, 0, 0x0000000000000000LL);
CallInfo ci_spl_object_hash((void*)&i_spl_object_hash, (void*)&ifa_spl_object_hash, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickresampleimage((void*)&i_magickresampleimage, (void*)&ifa_magickresampleimage, 5, 0, 0x0000000000000000LL);
CallInfo ci_i18n_loc_get_default((void*)&i_i18n_loc_get_default, (void*)&ifa_i18n_loc_get_default, 0, 0, 0x0000000000000000LL);
CallInfo ci_strtok((void*)&i_strtok, (void*)&ifa_strtok, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_key_exists((void*)&i_array_key_exists, (void*)&ifa_array_key_exists, 2, 0, 0x0000000000000000LL);
CallInfo ci_exp((void*)&i_exp, (void*)&ifa_exp, 1, 0, 0x0000000000000000LL);
CallInfo ci_strstr((void*)&i_strstr, (void*)&ifa_strstr, 2, 0, 0x0000000000000000LL);
CallInfo ci_realpath((void*)&i_realpath, (void*)&ifa_realpath, 1, 0, 0x0000000000000000LL);
CallInfo ci_memcache_setoptimeout((void*)&i_memcache_setoptimeout, (void*)&ifa_memcache_setoptimeout, 2, 0, 0x0000000000000000LL);
CallInfo ci_stream_filter_append((void*)&i_stream_filter_append, (void*)&ifa_stream_filter_append, 4, 0, 0x0000000000000000LL);
CallInfo ci_dom_characterdata_insert_data((void*)&i_dom_characterdata_insert_data, (void*)&ifa_dom_characterdata_insert_data, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_get_property((void*)&i_hphp_get_property, (void*)&ifa_hphp_get_property, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_characterdata_replace_data((void*)&i_dom_characterdata_replace_data, (void*)&ifa_dom_characterdata_replace_data, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickgetcharheight((void*)&i_magickgetcharheight, (void*)&ifa_magickgetcharheight, 4, 0, 0x0000000000000000LL);
CallInfo ci_imagerotate((void*)&i_imagerotate, (void*)&ifa_imagerotate, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickcompositeimage((void*)&i_magickcompositeimage, (void*)&ifa_magickcompositeimage, 5, 0, 0x0000000000000000LL);
CallInfo ci_openssl_sign((void*)&i_openssl_sign, (void*)&ifa_openssl_sign, 4, 0, 0x0000000000000002LL);
CallInfo ci_version_compare((void*)&i_version_compare, (void*)&ifa_version_compare, 3, 0, 0x0000000000000000LL);
CallInfo ci_timezone_name_get((void*)&i_timezone_name_get, (void*)&ifa_timezone_name_get, 1, 0, 0x0000000000000000LL);
CallInfo ci_posix_getpgid((void*)&i_posix_getpgid, (void*)&ifa_posix_getpgid, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_has_attributes((void*)&i_dom_node_has_attributes, (void*)&ifa_dom_node_has_attributes, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_text_is_whitespace_in_element_content((void*)&i_dom_text_is_whitespace_in_element_content, (void*)&ifa_dom_text_is_whitespace_in_element_content, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagestring((void*)&i_imagestring, (void*)&ifa_imagestring, 6, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_list_modes((void*)&i_mcrypt_list_modes, (void*)&ifa_mcrypt_list_modes, 1, 0, 0x0000000000000000LL);
CallInfo ci_session_unregister((void*)&i_session_unregister, (void*)&ifa_session_unregister, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_list_algorithms((void*)&i_mcrypt_list_algorithms, (void*)&ifa_mcrypt_list_algorithms, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_get_cipher_name((void*)&i_mcrypt_get_cipher_name, (void*)&ifa_mcrypt_get_cipher_name, 1, 0, 0x0000000000000000LL);
CallInfo ci_idn_to_unicode((void*)&i_idn_to_unicode, (void*)&ifa_idn_to_unicode, 2, 0, 0x0000000000000002LL);
CallInfo ci_lchown((void*)&i_lchown, (void*)&ifa_lchown, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawcomposite((void*)&i_drawcomposite, (void*)&ifa_drawcomposite, 7, 0, 0x0000000000000000LL);
CallInfo ci_dechex((void*)&i_dechex, (void*)&ifa_dechex, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecolortransparent((void*)&i_imagecolortransparent, (void*)&ifa_imagecolortransparent, 2, 0, 0x0000000000000000LL);
CallInfo ci_socket_get_option((void*)&i_socket_get_option, (void*)&ifa_socket_get_option, 3, 0, 0x0000000000000000LL);
CallInfo ci_stream_filter_register((void*)&i_stream_filter_register, (void*)&ifa_stream_filter_register, 2, 0, 0x0000000000000000LL);
CallInfo ci_apache_response_headers((void*)&i_apache_response_headers, (void*)&ifa_apache_response_headers, 0, 0, 0x0000000000000000LL);
CallInfo ci_array_merge((void*)&i_array_merge, (void*)&ifa_array_merge, 1, 1, 0x0000000000000000LL);
CallInfo ci_md5((void*)&i_md5, (void*)&ifa_md5, 2, 0, 0x0000000000000000LL);
CallInfo ci_session_write_close((void*)&i_session_write_close, (void*)&ifa_session_write_close, 0, 0, 0x0000000000000000LL);
CallInfo ci_dom_namednodemap_item((void*)&i_dom_namednodemap_item, (void*)&ifa_dom_namednodemap_item, 2, 0, 0x0000000000000000LL);
CallInfo ci_bcsub((void*)&i_bcsub, (void*)&ifa_bcsub, 3, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_flush((void*)&i_xmlwriter_flush, (void*)&ifa_xmlwriter_flush, 2, 0, 0x0000000000000000LL);
CallInfo ci_sha1_file((void*)&i_sha1_file, (void*)&ifa_sha1_file, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_ctermid((void*)&i_posix_ctermid, (void*)&ifa_posix_ctermid, 0, 0, 0x0000000000000000LL);
CallInfo ci_date((void*)&i_date, (void*)&ifa_date, 2, 0, 0x0000000000000000LL);
CallInfo ci_evhttp_post((void*)&i_evhttp_post, (void*)&ifa_evhttp_post, 4, 0, 0x0000000000000000LL);
CallInfo ci_ldap_connect((void*)&i_ldap_connect, (void*)&ifa_ldap_connect, 2, 0, 0x0000000000000000LL);
CallInfo ci_shuffle((void*)&i_shuffle, (void*)&ifa_shuffle, 1, 0, 0x0000000000000001LL);
CallInfo ci_mcrypt_module_get_algo_block_size((void*)&i_mcrypt_module_get_algo_block_size, (void*)&ifa_mcrypt_module_get_algo_block_size, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_ftruncate((void*)&i_hphp_splfileobject_ftruncate, (void*)&ifa_hphp_splfileobject_ftruncate, 2, 0, 0x0000000000000000LL);
CallInfo ci_key((void*)&i_key, (void*)&ifa_key, 1, 0, 0x0000000000000001LL);
CallInfo ci_xmlwriter_start_dtd_entity((void*)&i_xmlwriter_start_dtd_entity, (void*)&ifa_xmlwriter_start_dtd_entity, 3, 0, 0x0000000000000000LL);
CallInfo ci_readfile((void*)&i_readfile, (void*)&ifa_readfile, 3, 0, 0x0000000000000000LL);
CallInfo ci_atan((void*)&i_atan, (void*)&ifa_atan, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickmodulateimage((void*)&i_magickmodulateimage, (void*)&ifa_magickmodulateimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_mysql_set_charset((void*)&i_mysql_set_charset, (void*)&ifa_mysql_set_charset, 2, 0, 0x0000000000000000LL);
CallInfo ci_fb_unset_taint((void*)&i_fb_unset_taint, (void*)&ifa_fb_unset_taint, 2, 0, 0x0000000000000001LL);
CallInfo ci_dom_document_xinclude((void*)&i_dom_document_xinclude, (void*)&ifa_dom_document_xinclude, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawgetfontweight((void*)&i_drawgetfontweight, (void*)&ifa_drawgetfontweight, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageheight((void*)&i_magickgetimageheight, (void*)&ifa_magickgetimageheight, 1, 0, 0x0000000000000000LL);
CallInfo ci_posix_getpgrp((void*)&i_posix_getpgrp, (void*)&ifa_posix_getpgrp, 0, 0, 0x0000000000000000LL);
CallInfo ci_i18n_loc_get_error_code((void*)&i_i18n_loc_get_error_code, (void*)&ifa_i18n_loc_get_error_code, 0, 0, 0x0000000000000000LL);
CallInfo ci_hash_file((void*)&i_hash_file, (void*)&ifa_hash_file, 3, 0, 0x0000000000000000LL);
CallInfo ci_is_callable((void*)&i_is_callable, (void*)&ifa_is_callable, 3, 0, 0x0000000000000004LL);
CallInfo ci_asin((void*)&i_asin, (void*)&ifa_asin, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_public_encrypt((void*)&i_openssl_public_encrypt, (void*)&ifa_openssl_public_encrypt, 4, 0, 0x0000000000000002LL);
CallInfo ci_curl_multi_init((void*)&i_curl_multi_init, (void*)&ifa_curl_multi_init, 0, 0, 0x0000000000000000LL);
CallInfo ci_posix_getpwuid((void*)&i_posix_getpwuid, (void*)&ifa_posix_getpwuid, 1, 0, 0x0000000000000000LL);
CallInfo ci_json_encode((void*)&i_json_encode, (void*)&ifa_json_encode, 2, 0, 0x0000000000000000LL);
CallInfo ci_show_source((void*)&i_show_source, (void*)&ifa_show_source, 2, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_module_self_test((void*)&i_mcrypt_module_self_test, (void*)&ifa_mcrypt_module_self_test, 2, 0, 0x0000000000000000LL);
CallInfo ci_sscanf((void*)&i_sscanf, (void*)&ifa_sscanf, 2, 2, 0x0000000000000000LL);
CallInfo ci_chop((void*)&i_chop, (void*)&ifa_chop, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_convert_variables((void*)&i_mb_convert_variables, (void*)&ifa_mb_convert_variables, 3, 1, 0x0000000000000004LL);
CallInfo ci_hphp_recursivedirectoryiterator_getsubpathname((void*)&i_hphp_recursivedirectoryiterator_getsubpathname, (void*)&ifa_hphp_recursivedirectoryiterator_getsubpathname, 1, 0, 0x0000000000000000LL);
CallInfo ci_socket_close((void*)&i_socket_close, (void*)&ifa_socket_close, 1, 0, 0x0000000000000000LL);
CallInfo ci_max((void*)&i_max, (void*)&ifa_max, 1, 1, 0x0000000000000000LL);
CallInfo ci_magickadaptivethresholdimage((void*)&i_magickadaptivethresholdimage, (void*)&ifa_magickadaptivethresholdimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_each((void*)&i_each, (void*)&ifa_each, 1, 0, 0x0000000000000001LL);
CallInfo ci_magickremoveimageprofiles((void*)&i_magickremoveimageprofiles, (void*)&ifa_magickremoveimageprofiles, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawgettextalignment((void*)&i_drawgettextalignment, (void*)&ifa_drawgettextalignment, 1, 0, 0x0000000000000000LL);
CallInfo ci_xbox_send_message((void*)&i_xbox_send_message, (void*)&ifa_xbox_send_message, 4, 0, 0x0000000000000002LL);
CallInfo ci_thrift_protocol_write_binary((void*)&i_thrift_protocol_write_binary, (void*)&ifa_thrift_protocol_write_binary, 6, 0, 0x0000000000000000LL);
CallInfo ci_wandgetexceptiontype((void*)&i_wandgetexceptiontype, (void*)&ifa_wandgetexceptiontype, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawpathellipticarcabsolute((void*)&i_drawpathellipticarcabsolute, (void*)&ifa_drawpathellipticarcabsolute, 8, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetgreen((void*)&i_pixelsetgreen, (void*)&ifa_pixelsetgreen, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagecolorspace((void*)&i_magickgetimagecolorspace, (void*)&ifa_magickgetimagecolorspace, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetalphaquantum((void*)&i_pixelsetalphaquantum, (void*)&ifa_pixelsetalphaquantum, 2, 0, 0x0000000000000000LL);
CallInfo ci_stream_bucket_append((void*)&i_stream_bucket_append, (void*)&ifa_stream_bucket_append, 2, 0, 0x0000000000000000LL);
CallInfo ci_msg_stat_queue((void*)&i_msg_stat_queue, (void*)&ifa_msg_stat_queue, 1, 0, 0x0000000000000000LL);
CallInfo ci_system((void*)&i_system, (void*)&ifa_system, 2, 0, 0x0000000000000002LL);
CallInfo ci_mb_parse_str((void*)&i_mb_parse_str, (void*)&ifa_mb_parse_str, 2, 0, 0x0000000000000002LL);
CallInfo ci_dom_characterdata_append_data((void*)&i_dom_characterdata_append_data, (void*)&ifa_dom_characterdata_append_data, 2, 0, 0x0000000000000000LL);
CallInfo ci_log((void*)&i_log, (void*)&ifa_log, 2, 0, 0x0000000000000000LL);
CallInfo ci_memcache_decrement((void*)&i_memcache_decrement, (void*)&ifa_memcache_decrement, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawskewx((void*)&i_drawskewx, (void*)&ifa_drawskewx, 2, 0, 0x0000000000000000LL);
CallInfo ci_min((void*)&i_min, (void*)&ifa_min, 1, 1, 0x0000000000000000LL);
CallInfo ci_curl_multi_getcontent((void*)&i_curl_multi_getcontent, (void*)&ifa_curl_multi_getcontent, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawskewy((void*)&i_drawskewy, (void*)&ifa_drawskewy, 2, 0, 0x0000000000000000LL);
CallInfo ci_is_uploaded_file((void*)&i_is_uploaded_file, (void*)&ifa_is_uploaded_file, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetresourcelimit((void*)&i_magicksetresourcelimit, (void*)&ifa_magicksetresourcelimit, 2, 0, 0x0000000000000000LL);
CallInfo ci_date_timezone_get((void*)&i_date_timezone_get, (void*)&ifa_date_timezone_get, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_fwrite((void*)&i_hphp_splfileobject_fwrite, (void*)&ifa_hphp_splfileobject_fwrite, 3, 0, 0x0000000000000000LL);
CallInfo ci_apache_get_rewrite_rules((void*)&i_apache_get_rewrite_rules, (void*)&ifa_apache_get_rewrite_rules, 0, 0, 0x0000000000000000LL);
CallInfo ci_is_string((void*)&i_is_string, (void*)&ifa_is_string, 1, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_wtermsig((void*)&i_pcntl_wtermsig, (void*)&ifa_pcntl_wtermsig, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_context_get_default((void*)&i_stream_context_get_default, (void*)&ifa_stream_context_get_default, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawpathlinetorelative((void*)&i_drawpathlinetorelative, (void*)&ifa_drawpathlinetorelative, 3, 0, 0x0000000000000000LL);
CallInfo ci_urlencode((void*)&i_urlencode, (void*)&ifa_urlencode, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_preferred_mime_name((void*)&i_mb_preferred_mime_name, (void*)&ifa_mb_preferred_mime_name, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetgreenquantum((void*)&i_pixelgetgreenquantum, (void*)&ifa_pixelgetgreenquantum, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetfilename((void*)&i_magicksetfilename, (void*)&ifa_magicksetfilename, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickappendimages((void*)&i_magickappendimages, (void*)&ifa_magickappendimages, 2, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_wifstopped((void*)&i_pcntl_wifstopped, (void*)&ifa_pcntl_wifstopped, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_ereg_search((void*)&i_mb_ereg_search, (void*)&ifa_mb_ereg_search, 2, 0, 0x0000000000000000LL);
CallInfo ci_rewind((void*)&i_rewind, (void*)&ifa_rewind, 1, 0, 0x0000000000000000LL);
CallInfo ci_chunk_split((void*)&i_chunk_split, (void*)&ifa_chunk_split, 3, 0, 0x0000000000000000LL);
CallInfo ci_mb_list_encodings_alias_names((void*)&i_mb_list_encodings_alias_names, (void*)&ifa_mb_list_encodings_alias_names, 1, 0, 0x0000000000000000LL);
CallInfo ci_i18n_loc_set_attribute((void*)&i_i18n_loc_set_attribute, (void*)&ifa_i18n_loc_set_attribute, 2, 0, 0x0000000000000000LL);
CallInfo ci_pixelsynciterator((void*)&i_pixelsynciterator, (void*)&ifa_pixelsynciterator, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_error_string((void*)&i_openssl_error_string, (void*)&ifa_openssl_error_string, 0, 0, 0x0000000000000000LL);
CallInfo ci_ismagickwand((void*)&i_ismagickwand, (void*)&ifa_ismagickwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_has_attribute((void*)&i_dom_element_has_attribute, (void*)&ifa_dom_element_has_attribute, 2, 0, 0x0000000000000000LL);
CallInfo ci_strrchr((void*)&i_strrchr, (void*)&ifa_strrchr, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_start_dtd_element((void*)&i_xmlwriter_start_dtd_element, (void*)&ifa_xmlwriter_start_dtd_element, 2, 0, 0x0000000000000000LL);
CallInfo ci_str_ireplace((void*)&i_str_ireplace, (void*)&ifa_str_ireplace, 4, 0, 0x0000000000000008LL);
CallInfo ci_magickpainttransparentimage((void*)&i_magickpainttransparentimage, (void*)&ifa_magickpainttransparentimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_drawsettextundercolor((void*)&i_drawsettextundercolor, (void*)&ifa_drawsettextundercolor, 2, 0, 0x0000000000000000LL);
CallInfo ci_memcache_get_version((void*)&i_memcache_get_version, (void*)&ifa_memcache_get_version, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_getflags((void*)&i_hphp_splfileobject_getflags, (void*)&ifa_hphp_splfileobject_getflags, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursivedirectoryiterator_rewind((void*)&i_hphp_recursivedirectoryiterator_rewind, (void*)&ifa_hphp_recursivedirectoryiterator_rewind, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetstringwidth((void*)&i_magickgetstringwidth, (void*)&ifa_magickgetstringwidth, 4, 0, 0x0000000000000000LL);
CallInfo ci_echo((void*)&i_echo, (void*)&ifa_echo, 1, 1, 0x0000000000000000LL);
CallInfo ci_ldap_parse_reference((void*)&i_ldap_parse_reference, (void*)&ifa_ldap_parse_reference, 3, 0, 0x0000000000000004LL);
CallInfo ci_ctype_xdigit((void*)&i_ctype_xdigit, (void*)&ifa_ctype_xdigit, 1, 0, 0x0000000000000000LL);
CallInfo ci_gmstrftime((void*)&i_gmstrftime, (void*)&ifa_gmstrftime, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursiveiteratoriterator_next((void*)&i_hphp_recursiveiteratoriterator_next, (void*)&ifa_hphp_recursiveiteratoriterator_next, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_socket_get_name((void*)&i_stream_socket_get_name, (void*)&ifa_stream_socket_get_name, 2, 0, 0x0000000000000000LL);
CallInfo ci_socket_set_option((void*)&i_socket_set_option, (void*)&ifa_socket_set_option, 4, 0, 0x0000000000000000LL);
CallInfo ci_array_multisort((void*)&i_array_multisort, (void*)&ifa_array_multisort, 1, 2, 0x0000000000000001LL);
CallInfo ci_imagepsbbox((void*)&i_imagepsbbox, (void*)&ifa_imagepsbbox, 6, 0, 0x0000000000000000LL);
CallInfo ci_drawpathlinetoverticalabsolute((void*)&i_drawpathlinetoverticalabsolute, (void*)&ifa_drawpathlinetoverticalabsolute, 2, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_msg_get_structure((void*)&i_mailparse_msg_get_structure, (void*)&ifa_mailparse_msg_get_structure, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_ereg((void*)&i_mb_ereg, (void*)&ifa_mb_ereg, 3, 0, 0x0000000000000004LL);
CallInfo ci_decoct((void*)&i_decoct, (void*)&ifa_decoct, 1, 0, 0x0000000000000000LL);
CallInfo ci_xml_parse((void*)&i_xml_parse, (void*)&ifa_xml_parse, 3, 0, 0x0000000000000000LL);
CallInfo ci_xml_get_current_line_number((void*)&i_xml_get_current_line_number, (void*)&ifa_xml_get_current_line_number, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawaffine((void*)&i_drawaffine, (void*)&ifa_drawaffine, 7, 0, 0x0000000000000000LL);
CallInfo ci_session_destroy((void*)&i_session_destroy, (void*)&ifa_session_destroy, 0, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagewhitepoint((void*)&i_magicksetimagewhitepoint, (void*)&ifa_magicksetimagewhitepoint, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_get_elements_by_tag_name((void*)&i_dom_document_get_elements_by_tag_name, (void*)&ifa_dom_document_get_elements_by_tag_name, 2, 0, 0x0000000000000000LL);
CallInfo ci_gzclose((void*)&i_gzclose, (void*)&ifa_gzclose, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorat((void*)&i_imagecolorat, (void*)&ifa_imagecolorat, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageextrema((void*)&i_magickgetimageextrema, (void*)&ifa_magickgetimageextrema, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_insert_before((void*)&i_dom_node_insert_before, (void*)&ifa_dom_node_insert_before, 3, 0, 0x0000000000000000LL);
CallInfo ci_ord((void*)&i_ord, (void*)&ifa_ord, 1, 0, 0x0000000000000000LL);
CallInfo ci_mktime((void*)&i_mktime, (void*)&ifa_mktime, 6, 0, 0x0000000000000000LL);
CallInfo ci_sem_get((void*)&i_sem_get, (void*)&ifa_sem_get, 4, 0, 0x0000000000000000LL);
CallInfo ci_drawsetstrokelinejoin((void*)&i_drawsetstrokelinejoin, (void*)&ifa_drawsetstrokelinejoin, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_intersect((void*)&i_array_intersect, (void*)&ifa_array_intersect, 2, 1, 0x0000000000000000LL);
CallInfo ci_mailparse_msg_extract_whole_part_file((void*)&i_mailparse_msg_extract_whole_part_file, (void*)&ifa_mailparse_msg_extract_whole_part_file, 3, 0, 0x0000000000000000LL);
CallInfo ci_mb_strrichr((void*)&i_mb_strrichr, (void*)&ifa_mb_strrichr, 4, 0, 0x0000000000000000LL);
CallInfo ci_socket_sendto((void*)&i_socket_sendto, (void*)&ifa_socket_sendto, 6, 0, 0x0000000000000000LL);
CallInfo ci_memcache_flush((void*)&i_memcache_flush, (void*)&ifa_memcache_flush, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_output_handler((void*)&i_mb_output_handler, (void*)&ifa_mb_output_handler, 2, 0, 0x0000000000000000LL);
CallInfo ci_fclose((void*)&i_fclose, (void*)&ifa_fclose, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawpathcurvetoquadraticbeziersmoothabsolute((void*)&i_drawpathcurvetoquadraticbeziersmoothabsolute, (void*)&ifa_drawpathcurvetoquadraticbeziersmoothabsolute, 3, 0, 0x0000000000000000LL);
CallInfo ci_function_exists((void*)&i_function_exists, (void*)&ifa_function_exists, 1, 0, 0x0000000000000000LL);
CallInfo ci_ctype_alpha((void*)&i_ctype_alpha, (void*)&ifa_ctype_alpha, 1, 0, 0x0000000000000000LL);
CallInfo ci_pos((void*)&i_pos, (void*)&ifa_pos, 1, 0, 0x0000000000000001LL);
CallInfo ci_pagelet_server_is_enabled((void*)&i_pagelet_server_is_enabled, (void*)&ifa_pagelet_server_is_enabled, 0, 0, 0x0000000000000000LL);
CallInfo ci_xbox_get_thread_timeout((void*)&i_xbox_get_thread_timeout, (void*)&ifa_xbox_get_thread_timeout, 0, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorexactalpha((void*)&i_imagecolorexactalpha, (void*)&ifa_imagecolorexactalpha, 5, 0, 0x0000000000000000LL);
CallInfo ci_pow((void*)&i_pow, (void*)&ifa_pow, 2, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetredquantum((void*)&i_pixelgetredquantum, (void*)&ifa_pixelgetredquantum, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorsforindex((void*)&i_imagecolorsforindex, (void*)&ifa_imagecolorsforindex, 2, 0, 0x0000000000000000LL);
CallInfo ci_libxml_set_streams_context((void*)&i_libxml_set_streams_context, (void*)&ifa_libxml_set_streams_context, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_clone_node((void*)&i_dom_node_clone_node, (void*)&ifa_dom_node_clone_node, 2, 0, 0x0000000000000000LL);
CallInfo ci_image_type_to_mime_type((void*)&i_image_type_to_mime_type, (void*)&ifa_image_type_to_mime_type, 1, 0, 0x0000000000000000LL);
CallInfo ci_socket_create((void*)&i_socket_create, (void*)&ifa_socket_create, 3, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_pi((void*)&i_xmlwriter_write_pi, (void*)&ifa_xmlwriter_write_pi, 3, 0, 0x0000000000000000LL);
CallInfo ci_posix_getppid((void*)&i_posix_getppid, (void*)&ifa_posix_getppid, 0, 0, 0x0000000000000000LL);
CallInfo ci_mb_stripos((void*)&i_mb_stripos, (void*)&ifa_mb_stripos, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickpingimage((void*)&i_magickpingimage, (void*)&ifa_magickpingimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_bcpowmod((void*)&i_bcpowmod, (void*)&ifa_bcpowmod, 4, 0, 0x0000000000000000LL);
CallInfo ci_timezone_offset_get((void*)&i_timezone_offset_get, (void*)&ifa_timezone_offset_get, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_create_text_node((void*)&i_dom_document_create_text_node, (void*)&ifa_dom_document_create_text_node, 2, 0, 0x0000000000000000LL);
CallInfo ci_getrandmax((void*)&i_getrandmax, (void*)&ifa_getrandmax, 0, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_fseek((void*)&i_hphp_splfileobject_fseek, (void*)&ifa_hphp_splfileobject_fseek, 3, 0, 0x0000000000000000LL);
CallInfo ci_ctype_alnum((void*)&i_ctype_alnum, (void*)&ifa_ctype_alnum, 1, 0, 0x0000000000000000LL);
CallInfo ci_tan((void*)&i_tan, (void*)&ifa_tan, 1, 0, 0x0000000000000000LL);
CallInfo ci_set_exception_handler((void*)&i_set_exception_handler, (void*)&ifa_set_exception_handler, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagegrabwindow((void*)&i_imagegrabwindow, (void*)&ifa_imagegrabwindow, 2, 0, 0x0000000000000000LL);
CallInfo ci_memcache_add((void*)&i_memcache_add, (void*)&ifa_memcache_add, 5, 0, 0x0000000000000000LL);
CallInfo ci_magickstereoimage((void*)&i_magickstereoimage, (void*)&ifa_magickstereoimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagescene((void*)&i_magickgetimagescene, (void*)&ifa_magickgetimagescene, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_isfile((void*)&i_hphp_splfileinfo_isfile, (void*)&ifa_hphp_splfileinfo_isfile, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_csr_sign((void*)&i_openssl_csr_sign, (void*)&ifa_openssl_csr_sign, 6, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkcs12_export((void*)&i_openssl_pkcs12_export, (void*)&ifa_openssl_pkcs12_export, 5, 0, 0x0000000000000002LL);
CallInfo ci_magickgetquantumdepth((void*)&i_magickgetquantumdepth, (void*)&ifa_magickgetquantumdepth, 0, 0, 0x0000000000000000LL);
CallInfo ci_socket_listen((void*)&i_socket_listen, (void*)&ifa_socket_listen, 2, 0, 0x0000000000000000LL);
CallInfo ci_parse_str((void*)&i_parse_str, (void*)&ifa_parse_str, 2, 0, 0x0000000000000002LL);
CallInfo ci_sin((void*)&i_sin, (void*)&ifa_sin, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_append_child((void*)&i_dom_node_append_child, (void*)&ifa_dom_node_append_child, 2, 0, 0x0000000000000000LL);
CallInfo ci_cosh((void*)&i_cosh, (void*)&ifa_cosh, 1, 0, 0x0000000000000000LL);
CallInfo ci_copy((void*)&i_copy, (void*)&ifa_copy, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagechar((void*)&i_imagechar, (void*)&ifa_imagechar, 6, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagebackgroundcolor((void*)&i_magicksetimagebackgroundcolor, (void*)&ifa_magicksetimagebackgroundcolor, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_mod_add((void*)&i_ldap_mod_add, (void*)&ifa_ldap_mod_add, 3, 0, 0x0000000000000000LL);
CallInfo ci_fb_thrift_serialize((void*)&i_fb_thrift_serialize, (void*)&ifa_fb_thrift_serialize, 1, 0, 0x0000000000000000LL);
CallInfo ci_posix_ttyname((void*)&i_posix_ttyname, (void*)&ifa_posix_ttyname, 1, 0, 0x0000000000000000LL);
CallInfo ci_filectime((void*)&i_filectime, (void*)&ifa_filectime, 1, 0, 0x0000000000000000LL);
CallInfo ci_newpixelwand((void*)&i_newpixelwand, (void*)&ifa_newpixelwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_wait((void*)&i_pcntl_wait, (void*)&ifa_pcntl_wait, 2, 0, 0x0000000000000001LL);
CallInfo ci_hypot((void*)&i_hypot, (void*)&ifa_hypot, 2, 0, 0x0000000000000000LL);
CallInfo ci_parse_url((void*)&i_parse_url, (void*)&ifa_parse_url, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickreadimageblob((void*)&i_magickreadimageblob, (void*)&ifa_magickreadimageblob, 2, 0, 0x0000000000000000LL);
CallInfo ci_eregi((void*)&i_eregi, (void*)&ifa_eregi, 3, 0, 0x0000000000000004LL);
CallInfo ci_pixelsetcolorcount((void*)&i_pixelsetcolorcount, (void*)&ifa_pixelsetcolorcount, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawpathcurvetoquadraticbezierrelative((void*)&i_drawpathcurvetoquadraticbezierrelative, (void*)&ifa_drawpathcurvetoquadraticbezierrelative, 5, 0, 0x0000000000000000LL);
CallInfo ci_posix_getgroups((void*)&i_posix_getgroups, (void*)&ifa_posix_getgroups, 0, 0, 0x0000000000000000LL);
CallInfo ci_fileinode((void*)&i_fileinode, (void*)&ifa_fileinode, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetnumberimages((void*)&i_magickgetnumberimages, (void*)&ifa_magickgetnumberimages, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagesblob((void*)&i_magickgetimagesblob, (void*)&ifa_magickgetimagesblob, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickcontrastimage((void*)&i_magickcontrastimage, (void*)&ifa_magickcontrastimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_setpriority((void*)&i_pcntl_setpriority, (void*)&ifa_pcntl_setpriority, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawgetfontstretch((void*)&i_drawgetfontstretch, (void*)&ifa_drawgetfontstretch, 1, 0, 0x0000000000000000LL);
CallInfo ci_bcscale((void*)&i_bcscale, (void*)&ifa_bcscale, 1, 0, 0x0000000000000000LL);
CallInfo ci_imageconvolution((void*)&i_imageconvolution, (void*)&ifa_imageconvolution, 4, 0, 0x0000000000000000LL);
CallInfo ci_utf8_decode((void*)&i_utf8_decode, (void*)&ifa_utf8_decode, 1, 0, 0x0000000000000000LL);
CallInfo ci_ldap_unbind((void*)&i_ldap_unbind, (void*)&ifa_ldap_unbind, 1, 0, 0x0000000000000000LL);
CallInfo ci_newpixelregioniterator((void*)&i_newpixelregioniterator, (void*)&ifa_newpixelregioniterator, 5, 0, 0x0000000000000000LL);
CallInfo ci_array_intersect_assoc((void*)&i_array_intersect_assoc, (void*)&ifa_array_intersect_assoc, 2, 1, 0x0000000000000000LL);
CallInfo ci_ob_get_level((void*)&i_ob_get_level, (void*)&ifa_ob_get_level, 0, 0, 0x0000000000000000LL);
CallInfo ci_hebrev((void*)&i_hebrev, (void*)&ifa_hebrev, 2, 0, 0x0000000000000000LL);
CallInfo ci_socket_set_block((void*)&i_socket_set_block, (void*)&ifa_socket_set_block, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_module_close((void*)&i_mcrypt_module_close, (void*)&ifa_mcrypt_module_close, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_strwidth((void*)&i_mb_strwidth, (void*)&ifa_mb_strwidth, 2, 0, 0x0000000000000000LL);
CallInfo ci_clonemagickwand((void*)&i_clonemagickwand, (void*)&ifa_clonemagickwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetred((void*)&i_pixelgetred, (void*)&ifa_pixelgetred, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_create_processing_instruction((void*)&i_dom_document_create_processing_instruction, (void*)&ifa_dom_document_create_processing_instruction, 3, 0, 0x0000000000000000LL);
CallInfo ci_ip2long((void*)&i_ip2long, (void*)&ifa_ip2long, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_stristr((void*)&i_mb_stristr, (void*)&ifa_mb_stristr, 4, 0, 0x0000000000000000LL);
CallInfo ci_array_diff_ukey((void*)&i_array_diff_ukey, (void*)&ifa_array_diff_ukey, 3, 1, 0x0000000000000000LL);
CallInfo ci_isdrawingwand((void*)&i_isdrawingwand, (void*)&ifa_isdrawingwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagemattecolor((void*)&i_magicksetimagemattecolor, (void*)&ifa_magicksetimagemattecolor, 2, 0, 0x0000000000000000LL);
CallInfo ci_closedir((void*)&i_closedir, (void*)&ifa_closedir, 1, 0, 0x0000000000000000LL);
CallInfo ci_fb_call_user_func_safe_return((void*)&i_fb_call_user_func_safe_return, (void*)&ifa_fb_call_user_func_safe_return, 2, 1, 0x0000000000000000LL);
CallInfo ci_magickwriteimagesfile((void*)&i_magickwriteimagesfile, (void*)&ifa_magickwriteimagesfile, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickdescribeimage((void*)&i_magickdescribeimage, (void*)&ifa_magickdescribeimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_imageftbbox((void*)&i_imageftbbox, (void*)&ifa_imageftbbox, 5, 0, 0x0000000000000000LL);
CallInfo ci_magicksetlastiterator((void*)&i_magicksetlastiterator, (void*)&ifa_magicksetlastiterator, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_output_global_state((void*)&i_hphp_output_global_state, (void*)&ifa_hphp_output_global_state, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagefontheight((void*)&i_imagefontheight, (void*)&ifa_imagefontheight, 1, 0, 0x0000000000000000LL);
CallInfo ci_putenv((void*)&i_putenv, (void*)&ifa_putenv, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickedgeimage((void*)&i_magickedgeimage, (void*)&ifa_magickedgeimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_xml_error_string((void*)&i_xml_error_string, (void*)&ifa_xml_error_string, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_rand((void*)&i_array_rand, (void*)&ifa_array_rand, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_mod_del((void*)&i_ldap_mod_del, (void*)&ifa_ldap_mod_del, 3, 0, 0x0000000000000000LL);
CallInfo ci_range((void*)&i_range, (void*)&ifa_range, 3, 0, 0x0000000000000000LL);
CallInfo ci_levenshtein((void*)&i_levenshtein, (void*)&ifa_levenshtein, 5, 0, 0x0000000000000000LL);
CallInfo ci_curl_multi_close((void*)&i_curl_multi_close, (void*)&ifa_curl_multi_close, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawgetfillalpha((void*)&i_drawgetfillalpha, (void*)&ifa_drawgetfillalpha, 1, 0, 0x0000000000000000LL);
CallInfo ci_hash_hmac((void*)&i_hash_hmac, (void*)&ifa_hash_hmac, 4, 0, 0x0000000000000000LL);
CallInfo ci_get_html_translation_table((void*)&i_get_html_translation_table, (void*)&ifa_get_html_translation_table, 2, 0, 0x0000000000000000LL);
CallInfo ci_user_error((void*)&i_user_error, (void*)&ifa_user_error, 2, 0, 0x0000000000000000LL);
CallInfo ci_feof((void*)&i_feof, (void*)&ifa_feof, 1, 0, 0x0000000000000000LL);
CallInfo ci_filemtime((void*)&i_filemtime, (void*)&ifa_filemtime, 1, 0, 0x0000000000000000LL);
CallInfo ci_microtime((void*)&i_microtime, (void*)&ifa_microtime, 1, 0, 0x0000000000000000LL);
CallInfo ci_zend_version((void*)&i_zend_version, (void*)&ifa_zend_version, 0, 0, 0x0000000000000000LL);
CallInfo ci_openssl_x509_free((void*)&i_openssl_x509_free, (void*)&ifa_openssl_x509_free, 1, 0, 0x0000000000000000LL);
CallInfo ci_fb_call_user_func_safe((void*)&i_fb_call_user_func_safe, (void*)&ifa_fb_call_user_func_safe, 1, 1, 0x0000000000000000LL);
CallInfo ci_var_export((void*)&i_var_export, (void*)&ifa_var_export, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_strcut((void*)&i_mb_strcut, (void*)&ifa_mb_strcut, 4, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_end_comment((void*)&i_xmlwriter_end_comment, (void*)&ifa_xmlwriter_end_comment, 1, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_end_dtd_element((void*)&i_xmlwriter_end_dtd_element, (void*)&ifa_xmlwriter_end_dtd_element, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_text_split_text((void*)&i_dom_text_split_text, (void*)&ifa_dom_text_split_text, 2, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkey_export_to_file((void*)&i_openssl_pkey_export_to_file, (void*)&ifa_openssl_pkey_export_to_file, 4, 0, 0x0000000000000000LL);
CallInfo ci_hphp_get_original_class_name((void*)&i_hphp_get_original_class_name, (void*)&ifa_hphp_get_original_class_name, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorclosesthwb((void*)&i_imagecolorclosesthwb, (void*)&ifa_imagecolorclosesthwb, 4, 0, 0x0000000000000000LL);
CallInfo ci_ldap_get_attributes((void*)&i_ldap_get_attributes, (void*)&ifa_ldap_get_attributes, 2, 0, 0x0000000000000000LL);
CallInfo ci_date_modify((void*)&i_date_modify, (void*)&ifa_date_modify, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_setinfoclass((void*)&i_hphp_splfileinfo_setinfoclass, (void*)&ifa_hphp_splfileinfo_setinfoclass, 2, 0, 0x0000000000000000LL);
CallInfo ci_umask((void*)&i_umask, (void*)&ifa_umask, 1, 0, 0x0000000000000000LL);
CallInfo ci_xml_get_current_column_number((void*)&i_xml_get_current_column_number, (void*)&ifa_xml_get_current_column_number, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetblue((void*)&i_pixelsetblue, (void*)&ifa_pixelsetblue, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_http_output((void*)&i_mb_http_output, (void*)&ifa_mb_http_output, 1, 0, 0x0000000000000000LL);
CallInfo ci_flock((void*)&i_flock, (void*)&ifa_flock, 3, 0, 0x0000000000000004LL);
CallInfo ci_hphp_splfileobject_ftell((void*)&i_hphp_splfileobject_ftell, (void*)&ifa_hphp_splfileobject_ftell, 1, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_wifexited((void*)&i_pcntl_wifexited, (void*)&ifa_pcntl_wifexited, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetformat((void*)&i_magicksetformat, (void*)&ifa_magicksetformat, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_map((void*)&i_array_map, (void*)&ifa_array_map, 2, 1, 0x0000000000000000LL);
CallInfo ci_magicksharpenimage((void*)&i_magicksharpenimage, (void*)&ifa_magicksharpenimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_is_infinite((void*)&i_is_infinite, (void*)&ifa_is_infinite, 1, 0, 0x0000000000000000LL);
CallInfo ci_date_timezone_set((void*)&i_date_timezone_set, (void*)&ifa_date_timezone_set, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_ereg_search_init((void*)&i_mb_ereg_search_init, (void*)&ifa_mb_ereg_search_init, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawcircle((void*)&i_drawcircle, (void*)&ifa_drawcircle, 5, 0, 0x0000000000000000LL);
CallInfo ci_is_readable((void*)&i_is_readable, (void*)&ifa_is_readable, 1, 0, 0x0000000000000000LL);
CallInfo ci_image_type_to_extension((void*)&i_image_type_to_extension, (void*)&ifa_image_type_to_extension, 2, 0, 0x0000000000000000LL);
CallInfo ci_printf((void*)&i_printf, (void*)&ifa_printf, 1, 1, 0x0000000000000000LL);
CallInfo ci_magicksetimagecompression((void*)&i_magicksetimagecompression, (void*)&ifa_magicksetimagecompression, 2, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_decrypt((void*)&i_mcrypt_decrypt, (void*)&ifa_mcrypt_decrypt, 5, 0, 0x0000000000000000LL);
CallInfo ci_hphp_directoryiterator_next((void*)&i_hphp_directoryiterator_next, (void*)&ifa_hphp_directoryiterator_next, 1, 0, 0x0000000000000000LL);
CallInfo ci_natcasesort((void*)&i_natcasesort, (void*)&ifa_natcasesort, 1, 0, 0x0000000000000001LL);
CallInfo ci_intl_get_error_message((void*)&i_intl_get_error_message, (void*)&ifa_intl_get_error_message, 0, 0, 0x0000000000000000LL);
CallInfo ci_memcache_get((void*)&i_memcache_get, (void*)&ifa_memcache_get, 3, 0, 0x0000000000000004LL);
CallInfo ci_array_chunk((void*)&i_array_chunk, (void*)&ifa_array_chunk, 3, 0, 0x0000000000000000LL);
CallInfo ci_collator_asort((void*)&i_collator_asort, (void*)&ifa_collator_asort, 3, 0, 0x0000000000000002LL);
CallInfo ci_imagefilledpolygon((void*)&i_imagefilledpolygon, (void*)&ifa_imagefilledpolygon, 4, 0, 0x0000000000000000LL);
CallInfo ci_drawpoppattern((void*)&i_drawpoppattern, (void*)&ifa_drawpoppattern, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagewidth((void*)&i_magickgetimagewidth, (void*)&ifa_magickgetimagewidth, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawgetfontfamily((void*)&i_drawgetfontfamily, (void*)&ifa_drawgetfontfamily, 1, 0, 0x0000000000000000LL);
CallInfo ci_dl((void*)&i_dl, (void*)&ifa_dl, 1, 0, 0x0000000000000000LL);
CallInfo ci_touch((void*)&i_touch, (void*)&ifa_touch, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursivedirectoryiterator___tostring((void*)&i_hphp_recursivedirectoryiterator___tostring, (void*)&ifa_hphp_recursivedirectoryiterator___tostring, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagebordercolor((void*)&i_magicksetimagebordercolor, (void*)&ifa_magicksetimagebordercolor, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_directoryiterator_rewind((void*)&i_hphp_directoryiterator_rewind, (void*)&ifa_hphp_directoryiterator_rewind, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickspliceimage((void*)&i_magickspliceimage, (void*)&ifa_magickspliceimage, 5, 0, 0x0000000000000000LL);
CallInfo ci_define((void*)&i_define, (void*)&ifa_define, 3, 0, 0x0000000000000000LL);
CallInfo ci_headers_sent((void*)&i_headers_sent, (void*)&ifa_headers_sent, 2, 0, 0x0000000000000003LL);
CallInfo ci_stream_context_get_options((void*)&i_stream_context_get_options, (void*)&ifa_stream_context_get_options, 1, 0, 0x0000000000000000LL);
CallInfo ci_file((void*)&i_file, (void*)&ifa_file, 3, 0, 0x0000000000000000LL);
CallInfo ci_memcache_get_extended_stats((void*)&i_memcache_get_extended_stats, (void*)&ifa_memcache_get_extended_stats, 4, 0, 0x0000000000000000LL);
CallInfo ci_hphp_crash_log((void*)&i_hphp_crash_log, (void*)&ifa_hphp_crash_log, 2, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorresolvealpha((void*)&i_imagecolorresolvealpha, (void*)&ifa_imagecolorresolvealpha, 5, 0, 0x0000000000000000LL);
CallInfo ci_strtr((void*)&i_strtr, (void*)&ifa_strtr, 3, 0, 0x0000000000000000LL);
CallInfo ci_posix_strerror((void*)&i_posix_strerror, (void*)&ifa_posix_strerror, 1, 0, 0x0000000000000000LL);
CallInfo ci_libxml_use_internal_errors((void*)&i_libxml_use_internal_errors, (void*)&ifa_libxml_use_internal_errors, 1, 0, 0x0000000000000000LL);
CallInfo ci_end_user_func_async((void*)&i_end_user_func_async, (void*)&ifa_end_user_func_async, 3, 0, 0x0000000000000000LL);
CallInfo ci_openssl_get_publickey((void*)&i_openssl_get_publickey, (void*)&ifa_openssl_get_publickey, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_lookup_prefix((void*)&i_dom_node_lookup_prefix, (void*)&ifa_dom_node_lookup_prefix, 2, 0, 0x0000000000000000LL);
CallInfo ci_time_nanosleep((void*)&i_time_nanosleep, (void*)&ifa_time_nanosleep, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimageunits((void*)&i_magicksetimageunits, (void*)&ifa_magicksetimageunits, 2, 0, 0x0000000000000000LL);
CallInfo ci_floor((void*)&i_floor, (void*)&ifa_floor, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_pad((void*)&i_array_pad, (void*)&ifa_array_pad, 3, 0, 0x0000000000000000LL);
CallInfo ci_sem_release((void*)&i_sem_release, (void*)&ifa_sem_release, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getctime((void*)&i_hphp_splfileinfo_getctime, (void*)&ifa_hphp_splfileinfo_getctime, 1, 0, 0x0000000000000000LL);
CallInfo ci_highlight_string((void*)&i_highlight_string, (void*)&ifa_highlight_string, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_invoke((void*)&i_hphp_invoke, (void*)&ifa_hphp_invoke, 2, 0, 0x0000000000000000LL);
CallInfo ci_imageloadfont((void*)&i_imageloadfont, (void*)&ifa_imageloadfont, 1, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_start_element((void*)&i_xmlwriter_start_element, (void*)&ifa_xmlwriter_start_element, 2, 0, 0x0000000000000000LL);
CallInfo ci_localeconv((void*)&i_localeconv, (void*)&ifa_localeconv, 0, 0, 0x0000000000000000LL);
CallInfo ci_exif_thumbnail((void*)&i_exif_thumbnail, (void*)&ifa_exif_thumbnail, 4, 0, 0x000000000000000ELL);
CallInfo ci_collator_get_error_message((void*)&i_collator_get_error_message, (void*)&ifa_collator_get_error_message, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_get_proto_info((void*)&i_mysql_get_proto_info, (void*)&ifa_mysql_get_proto_info, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagefontwidth((void*)&i_imagefontwidth, (void*)&ifa_imagefontwidth, 1, 0, 0x0000000000000000LL);
CallInfo ci_substr_compare((void*)&i_substr_compare, (void*)&ifa_substr_compare, 5, 0, 0x0000000000000000LL);
CallInfo ci_xbox_post_message((void*)&i_xbox_post_message, (void*)&ifa_xbox_post_message, 2, 0, 0x0000000000000000LL);
CallInfo ci_fb_rename_function((void*)&i_fb_rename_function, (void*)&ifa_fb_rename_function, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_walk_recursive((void*)&i_array_walk_recursive, (void*)&ifa_array_walk_recursive, 3, 0, 0x0000000000000001LL);
CallInfo ci_mysql_list_processes((void*)&i_mysql_list_processes, (void*)&ifa_mysql_list_processes, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagedashedline((void*)&i_imagedashedline, (void*)&ifa_imagedashedline, 6, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagedelay((void*)&i_magickgetimagedelay, (void*)&ifa_magickgetimagedelay, 1, 0, 0x0000000000000000LL);
CallInfo ci_pi((void*)&i_pi, (void*)&ifa_pi, 0, 0, 0x0000000000000000LL);
CallInfo ci_mb_substr_count((void*)&i_mb_substr_count, (void*)&ifa_mb_substr_count, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getinode((void*)&i_hphp_splfileinfo_getinode, (void*)&ifa_hphp_splfileinfo_getinode, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgettextdescent((void*)&i_magickgettextdescent, (void*)&ifa_magickgettextdescent, 4, 0, 0x0000000000000000LL);
CallInfo ci_drawsetstrokealpha((void*)&i_drawsetstrokealpha, (void*)&ifa_drawsetstrokealpha, 2, 0, 0x0000000000000000LL);
CallInfo ci_apc_delete_file((void*)&i_apc_delete_file, (void*)&ifa_apc_delete_file, 2, 0, 0x0000000000000000LL);
CallInfo ci_strrpos((void*)&i_strrpos, (void*)&ifa_strrpos, 3, 0, 0x0000000000000000LL);
CallInfo ci_array_diff_assoc((void*)&i_array_diff_assoc, (void*)&ifa_array_diff_assoc, 2, 1, 0x0000000000000000LL);
CallInfo ci_magickclippathimage((void*)&i_magickclippathimage, (void*)&ifa_magickclippathimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_element((void*)&i_xmlwriter_write_element, (void*)&ifa_xmlwriter_write_element, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_schema_validate_xml((void*)&i_dom_document_schema_validate_xml, (void*)&ifa_dom_document_schema_validate_xml, 2, 0, 0x0000000000000000LL);
CallInfo ci_ereg((void*)&i_ereg, (void*)&ifa_ereg, 3, 0, 0x0000000000000004LL);
CallInfo ci_curl_multi_info_read((void*)&i_curl_multi_info_read, (void*)&ifa_curl_multi_info_read, 2, 0, 0x0000000000000002LL);
CallInfo ci_magickthresholdimage((void*)&i_magickthresholdimage, (void*)&ifa_magickthresholdimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_msg_remove_queue((void*)&i_msg_remove_queue, (void*)&ifa_msg_remove_queue, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_strlen((void*)&i_mb_strlen, (void*)&ifa_mb_strlen, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawgetclippath((void*)&i_drawgetclippath, (void*)&ifa_drawgetclippath, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecopy((void*)&i_imagecopy, (void*)&ifa_imagecopy, 8, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetcolor((void*)&i_pixelsetcolor, (void*)&ifa_pixelsetcolor, 2, 0, 0x0000000000000000LL);
CallInfo ci_time_sleep_until((void*)&i_time_sleep_until, (void*)&ifa_time_sleep_until, 1, 0, 0x0000000000000000LL);
CallInfo ci_session_unset((void*)&i_session_unset, (void*)&ifa_session_unset, 0, 0, 0x0000000000000000LL);
CallInfo ci_mb_ereg_replace((void*)&i_mb_ereg_replace, (void*)&ifa_mb_ereg_replace, 4, 0, 0x0000000000000000LL);
CallInfo ci_openssl_csr_get_public_key((void*)&i_openssl_csr_get_public_key, (void*)&ifa_openssl_csr_get_public_key, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickfximage((void*)&i_magickfximage, (void*)&ifa_magickfximage, 3, 0, 0x0000000000000000LL);
CallInfo ci_tmpfile((void*)&i_tmpfile, (void*)&ifa_tmpfile, 0, 0, 0x0000000000000000LL);
CallInfo ci_hash((void*)&i_hash, (void*)&ifa_hash, 3, 0, 0x0000000000000000LL);
CallInfo ci_uasort((void*)&i_uasort, (void*)&ifa_uasort, 2, 0, 0x0000000000000001LL);
CallInfo ci_pixelgetalpha((void*)&i_pixelgetalpha, (void*)&ifa_pixelgetalpha, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawsettextencoding((void*)&i_drawsettextencoding, (void*)&ifa_drawsettextencoding, 2, 0, 0x0000000000000000LL);
CallInfo ci_apache_request_headers((void*)&i_apache_request_headers, (void*)&ifa_apache_request_headers, 0, 0, 0x0000000000000000LL);
CallInfo ci_is_subclass_of((void*)&i_is_subclass_of, (void*)&ifa_is_subclass_of, 2, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetmagentaquantum((void*)&i_pixelgetmagentaquantum, (void*)&ifa_pixelgetmagentaquantum, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_get_static_property((void*)&i_hphp_get_static_property, (void*)&ifa_hphp_get_static_property, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_pop((void*)&i_array_pop, (void*)&ifa_array_pop, 1, 0, 0x0000000000000001LL);
CallInfo ci_magickgetimagecolors((void*)&i_magickgetimagecolors, (void*)&ifa_magickgetimagecolors, 1, 0, 0x0000000000000000LL);
CallInfo ci_session_regenerate_id((void*)&i_session_regenerate_id, (void*)&ifa_session_regenerate_id, 1, 0, 0x0000000000000000LL);
CallInfo ci_class_exists((void*)&i_class_exists, (void*)&ifa_class_exists, 2, 0, 0x0000000000000000LL);
CallInfo ci_getallheaders((void*)&i_getallheaders, (void*)&ifa_getallheaders, 0, 0, 0x0000000000000000LL);
CallInfo ci_get_extension_funcs((void*)&i_get_extension_funcs, (void*)&ifa_get_extension_funcs, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecolordeallocate((void*)&i_imagecolordeallocate, (void*)&ifa_imagecolordeallocate, 2, 0, 0x0000000000000000LL);
CallInfo ci_closelog((void*)&i_closelog, (void*)&ifa_closelog, 0, 0, 0x0000000000000000LL);
CallInfo ci_drawpathlinetoabsolute((void*)&i_drawpathlinetoabsolute, (void*)&ifa_drawpathlinetoabsolute, 3, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_enc_get_iv_size((void*)&i_mcrypt_enc_get_iv_size, (void*)&ifa_mcrypt_enc_get_iv_size, 1, 0, 0x0000000000000000LL);
CallInfo ci_json_decode((void*)&i_json_decode, (void*)&ifa_json_decode, 3, 0, 0x0000000000000000LL);
CallInfo ci_preg_replace((void*)&i_preg_replace, (void*)&ifa_preg_replace, 5, 0, 0x0000000000000010LL);
CallInfo ci_hphp_splfileinfo_getmtime((void*)&i_hphp_splfileinfo_getmtime, (void*)&ifa_hphp_splfileinfo_getmtime, 1, 0, 0x0000000000000000LL);
CallInfo ci_fmod((void*)&i_fmod, (void*)&ifa_fmod, 2, 0, 0x0000000000000000LL);
CallInfo ci_curl_errno((void*)&i_curl_errno, (void*)&ifa_curl_errno, 1, 0, 0x0000000000000000LL);
CallInfo ci_pagelet_server_task_start((void*)&i_pagelet_server_task_start, (void*)&ifa_pagelet_server_task_start, 3, 0, 0x0000000000000000LL);
CallInfo ci_hash_init((void*)&i_hash_init, (void*)&ifa_hash_init, 3, 0, 0x0000000000000000LL);
CallInfo ci_mb_strripos((void*)&i_mb_strripos, (void*)&ifa_mb_strripos, 4, 0, 0x0000000000000000LL);
CallInfo ci_mysql_fetch_row((void*)&i_mysql_fetch_row, (void*)&ifa_mysql_fetch_row, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_setcsvcontrol((void*)&i_hphp_splfileobject_setcsvcontrol, (void*)&ifa_hphp_splfileobject_setcsvcontrol, 4, 0, 0x0000000000000000LL);
CallInfo ci_ob_get_flush((void*)&i_ob_get_flush, (void*)&ifa_ob_get_flush, 0, 0, 0x0000000000000000LL);
CallInfo ci_curl_error((void*)&i_curl_error, (void*)&ifa_curl_error, 1, 0, 0x0000000000000000LL);
CallInfo ci_set_magic_quotes_runtime((void*)&i_set_magic_quotes_runtime, (void*)&ifa_set_magic_quotes_runtime, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickcharcoalimage((void*)&i_magickcharcoalimage, (void*)&ifa_magickcharcoalimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_scandir((void*)&i_scandir, (void*)&ifa_scandir, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickmosaicimages((void*)&i_magickmosaicimages, (void*)&ifa_magickmosaicimages, 1, 0, 0x0000000000000000LL);
CallInfo ci_timezone_transitions_get((void*)&i_timezone_transitions_get, (void*)&ifa_timezone_transitions_get, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawsetfontweight((void*)&i_drawsetfontweight, (void*)&ifa_drawsetfontweight, 2, 0, 0x0000000000000000LL);
CallInfo ci_popdrawingwand((void*)&i_popdrawingwand, (void*)&ifa_popdrawingwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_collator_sort_with_sort_keys((void*)&i_collator_sort_with_sort_keys, (void*)&ifa_collator_sort_with_sort_keys, 2, 0, 0x0000000000000002LL);
CallInfo ci_socket_shutdown((void*)&i_socket_shutdown, (void*)&ifa_socket_shutdown, 2, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_create_iv((void*)&i_mcrypt_create_iv, (void*)&ifa_mcrypt_create_iv, 2, 0, 0x0000000000000000LL);
CallInfo ci_eval((void*)&i_eval, (void*)&ifa_eval, 1, 0, 0x0000000000000000LL);
CallInfo ci_bindec((void*)&i_bindec, (void*)&ifa_bindec, 1, 0, 0x0000000000000000LL);
CallInfo ci_fileperms((void*)&i_fileperms, (void*)&ifa_fileperms, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_fstat((void*)&i_hphp_splfileobject_fstat, (void*)&ifa_hphp_splfileobject_fstat, 1, 0, 0x0000000000000000LL);
CallInfo ci_unserialize((void*)&i_unserialize, (void*)&ifa_unserialize, 1, 0, 0x0000000000000000LL);
CallInfo ci_urldecode((void*)&i_urldecode, (void*)&ifa_urldecode, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickannotateimage((void*)&i_magickannotateimage, (void*)&ifa_magickannotateimage, 6, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_msg_create((void*)&i_mailparse_msg_create, (void*)&ifa_mailparse_msg_create, 0, 0, 0x0000000000000000LL);
CallInfo ci_session_set_cookie_params((void*)&i_session_set_cookie_params, (void*)&ifa_session_set_cookie_params, 5, 0, 0x0000000000000000LL);
CallInfo ci_drawellipse((void*)&i_drawellipse, (void*)&ifa_drawellipse, 7, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_element_ns((void*)&i_xmlwriter_write_element_ns, (void*)&ifa_xmlwriter_write_element_ns, 5, 0, 0x0000000000000000LL);
CallInfo ci_magicksetcompressionquality((void*)&i_magicksetcompressionquality, (void*)&ifa_magicksetcompressionquality, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickaddnoiseimage((void*)&i_magickaddnoiseimage, (void*)&ifa_magickaddnoiseimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagewhitepoint((void*)&i_magickgetimagewhitepoint, (void*)&ifa_magickgetimagewhitepoint, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickseparateimagechannel((void*)&i_magickseparateimagechannel, (void*)&ifa_magickseparateimagechannel, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_push((void*)&i_array_push, (void*)&ifa_array_push, 2, 1, 0x0000000000000001LL);
CallInfo ci_flush((void*)&i_flush, (void*)&ifa_flush, 0, 0, 0x0000000000000000LL);
CallInfo ci_connection_aborted((void*)&i_connection_aborted, (void*)&ifa_connection_aborted, 0, 0, 0x0000000000000000LL);
CallInfo ci_uksort((void*)&i_uksort, (void*)&ifa_uksort, 2, 0, 0x0000000000000001LL);
CallInfo ci_mysql_set_timeout((void*)&i_mysql_set_timeout, (void*)&ifa_mysql_set_timeout, 2, 0, 0x0000000000000000LL);
CallInfo ci_hash_update_stream((void*)&i_hash_update_stream, (void*)&ifa_hash_update_stream, 3, 0, 0x0000000000000000LL);
CallInfo ci_ob_start((void*)&i_ob_start, (void*)&ifa_ob_start, 3, 0, 0x0000000000000000LL);
CallInfo ci_mysql_get_host_info((void*)&i_mysql_get_host_info, (void*)&ifa_mysql_get_host_info, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_language((void*)&i_mb_language, (void*)&ifa_mb_language, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetnextiteratorrow((void*)&i_pixelgetnextiteratorrow, (void*)&ifa_pixelgetnextiteratorrow, 1, 0, 0x0000000000000000LL);
CallInfo ci_ldap_next_reference((void*)&i_ldap_next_reference, (void*)&ifa_ldap_next_reference, 2, 0, 0x0000000000000000LL);
CallInfo ci_socket_get_status((void*)&i_socket_get_status, (void*)&ifa_socket_get_status, 1, 0, 0x0000000000000000LL);
CallInfo ci_checkdnsrr((void*)&i_checkdnsrr, (void*)&ifa_checkdnsrr, 2, 0, 0x0000000000000000LL);
CallInfo ci_openssl_verify((void*)&i_openssl_verify, (void*)&ifa_openssl_verify, 4, 0, 0x0000000000000000LL);
CallInfo ci_curl_exec((void*)&i_curl_exec, (void*)&ifa_curl_exec, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetexceptiontype((void*)&i_magickgetexceptiontype, (void*)&ifa_magickgetexceptiontype, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_sum((void*)&i_array_sum, (void*)&ifa_array_sum, 1, 0, 0x0000000000000000LL);
CallInfo ci_unregister_tick_function((void*)&i_unregister_tick_function, (void*)&ifa_unregister_tick_function, 1, 0, 0x0000000000000000LL);
CallInfo ci_newpixelwandarray((void*)&i_newpixelwandarray, (void*)&ifa_newpixelwandarray, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetversion((void*)&i_magickgetversion, (void*)&ifa_magickgetversion, 0, 0, 0x0000000000000000LL);
CallInfo ci_imagelayereffect((void*)&i_imagelayereffect, (void*)&ifa_imagelayereffect, 2, 0, 0x0000000000000000LL);
CallInfo ci_glob((void*)&i_glob, (void*)&ifa_glob, 2, 0, 0x0000000000000000LL);
CallInfo ci_exec((void*)&i_exec, (void*)&ifa_exec, 3, 0, 0x0000000000000006LL);
CallInfo ci_apd_continue((void*)&i_apd_continue, (void*)&ifa_apd_continue, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagedepth((void*)&i_magickgetimagedepth, (void*)&ifa_magickgetimagedepth, 2, 0, 0x0000000000000000LL);
CallInfo ci_pclose((void*)&i_pclose, (void*)&ifa_pclose, 1, 0, 0x0000000000000000LL);
CallInfo ci_get_parent_class((void*)&i_get_parent_class, (void*)&ifa_get_parent_class, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_strpos((void*)&i_mb_strpos, (void*)&ifa_mb_strpos, 4, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_dtd_attlist((void*)&i_xmlwriter_write_dtd_attlist, (void*)&ifa_xmlwriter_write_dtd_attlist, 3, 0, 0x0000000000000000LL);
CallInfo ci_xml_set_element_handler((void*)&i_xml_set_element_handler, (void*)&ifa_xml_set_element_handler, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawgetstrokeopacity((void*)&i_drawgetstrokeopacity, (void*)&ifa_drawgetstrokeopacity, 1, 0, 0x0000000000000000LL);
CallInfo ci_ldap_get_entries((void*)&i_ldap_get_entries, (void*)&ifa_ldap_get_entries, 2, 0, 0x0000000000000000LL);
CallInfo ci_ob_iconv_handler((void*)&i_ob_iconv_handler, (void*)&ifa_ob_iconv_handler, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_throw_fatal_error((void*)&i_hphp_throw_fatal_error, (void*)&ifa_hphp_throw_fatal_error, 1, 0, 0x0000000000000000LL);
CallInfo ci_pathinfo((void*)&i_pathinfo, (void*)&ifa_pathinfo, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickaffinetransformimage((void*)&i_magickaffinetransformimage, (void*)&ifa_magickaffinetransformimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_fb_stubout_intercept_handler((void*)&i_fb_stubout_intercept_handler, (void*)&ifa_fb_stubout_intercept_handler, 5, 0, 0x0000000000000010LL);
CallInfo ci_ob_get_status((void*)&i_ob_get_status, (void*)&ifa_ob_get_status, 1, 0, 0x0000000000000000LL);
CallInfo ci_collator_create((void*)&i_collator_create, (void*)&ifa_collator_create, 1, 0, 0x0000000000000000LL);
CallInfo ci_exit((void*)&i_exit, (void*)&ifa_exit, 1, 0, 0x0000000000000000LL);
CallInfo ci_memcache_debug((void*)&i_memcache_debug, (void*)&ifa_memcache_debug, 1, 0, 0x0000000000000000LL);
CallInfo ci_apc_sma_info((void*)&i_apc_sma_info, (void*)&ifa_apc_sma_info, 1, 0, 0x0000000000000000LL);
CallInfo ci_ldap_bind((void*)&i_ldap_bind, (void*)&ifa_ldap_bind, 3, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetbluequantum((void*)&i_pixelsetbluequantum, (void*)&ifa_pixelsetbluequantum, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickreadimagefile((void*)&i_magickreadimagefile, (void*)&ifa_magickreadimagefile, 2, 0, 0x0000000000000000LL);
CallInfo ci_session_is_registered((void*)&i_session_is_registered, (void*)&ifa_session_is_registered, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_real_escape_string((void*)&i_mysql_real_escape_string, (void*)&ifa_mysql_real_escape_string, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickframeimage((void*)&i_magickframeimage, (void*)&ifa_magickframeimage, 6, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetblue((void*)&i_pixelgetblue, (void*)&ifa_pixelgetblue, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagefill((void*)&i_imagefill, (void*)&ifa_imagefill, 4, 0, 0x0000000000000000LL);
CallInfo ci_hphp_set_property((void*)&i_hphp_set_property, (void*)&ifa_hphp_set_property, 4, 0, 0x0000000000000000LL);
CallInfo ci_readgzfile((void*)&i_readgzfile, (void*)&ifa_readgzfile, 2, 0, 0x0000000000000000LL);
CallInfo ci_memcache_set((void*)&i_memcache_set, (void*)&ifa_memcache_set, 5, 0, 0x0000000000000000LL);
CallInfo ci_magicksampleimage((void*)&i_magicksampleimage, (void*)&ifa_magicksampleimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_mysql_escape_string((void*)&i_mysql_escape_string, (void*)&ifa_mysql_escape_string, 1, 0, 0x0000000000000000LL);
CallInfo ci_idn_to_utf8((void*)&i_idn_to_utf8, (void*)&ifa_idn_to_utf8, 2, 0, 0x0000000000000002LL);
CallInfo ci_sql_regcase((void*)&i_sql_regcase, (void*)&ifa_sql_regcase, 1, 0, 0x0000000000000000LL);
CallInfo ci_in_array((void*)&i_in_array, (void*)&ifa_in_array, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawpathcurvetoquadraticbezierabsolute((void*)&i_drawpathcurvetoquadraticbezierabsolute, (void*)&ifa_drawpathcurvetoquadraticbezierabsolute, 5, 0, 0x0000000000000000LL);
CallInfo ci_socket_set_timeout((void*)&i_socket_set_timeout, (void*)&ifa_socket_set_timeout, 3, 0, 0x0000000000000000LL);
CallInfo ci_bin2hex((void*)&i_bin2hex, (void*)&ifa_bin2hex, 1, 0, 0x0000000000000000LL);
CallInfo ci_error_get_last((void*)&i_error_get_last, (void*)&ifa_error_get_last, 0, 0, 0x0000000000000000LL);
CallInfo ci_is_link((void*)&i_is_link, (void*)&ifa_is_link, 1, 0, 0x0000000000000000LL);
CallInfo ci_set_file_buffer((void*)&i_set_file_buffer, (void*)&ifa_set_file_buffer, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimageredprimary((void*)&i_magicksetimageredprimary, (void*)&ifa_magicksetimageredprimary, 3, 0, 0x0000000000000000LL);
CallInfo ci_i18n_loc_set_default((void*)&i_i18n_loc_set_default, (void*)&ifa_i18n_loc_set_default, 1, 0, 0x0000000000000000LL);
CallInfo ci_ftok((void*)&i_ftok, (void*)&ifa_ftok, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_list_fields((void*)&i_mysql_list_fields, (void*)&ifa_mysql_list_fields, 3, 0, 0x0000000000000000LL);
CallInfo ci_stream_wrapper_register((void*)&i_stream_wrapper_register, (void*)&ifa_stream_wrapper_register, 2, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetredquantum((void*)&i_pixelsetredquantum, (void*)&ifa_pixelsetredquantum, 2, 0, 0x0000000000000000LL);
CallInfo ci_xhprof_disable((void*)&i_xhprof_disable, (void*)&ifa_xhprof_disable, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickgammaimage((void*)&i_magickgammaimage, (void*)&ifa_magickgammaimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetcyan((void*)&i_pixelsetcyan, (void*)&ifa_pixelsetcyan, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_decode_mimeheader((void*)&i_mb_decode_mimeheader, (void*)&ifa_mb_decode_mimeheader, 1, 0, 0x0000000000000000LL);
CallInfo ci_key_exists((void*)&i_key_exists, (void*)&ifa_key_exists, 2, 0, 0x0000000000000000LL);
CallInfo ci_htmlentities((void*)&i_htmlentities, (void*)&ifa_htmlentities, 4, 0, 0x0000000000000000LL);
CallInfo ci_rad2deg((void*)&i_rad2deg, (void*)&ifa_rad2deg, 1, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_start_dtd((void*)&i_xmlwriter_start_dtd, (void*)&ifa_xmlwriter_start_dtd, 4, 0, 0x0000000000000000LL);
CallInfo ci_drawpathstart((void*)&i_drawpathstart, (void*)&ifa_drawpathstart, 1, 0, 0x0000000000000000LL);
CallInfo ci_proc_nice((void*)&i_proc_nice, (void*)&ifa_proc_nice, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_thread_is_warmup_enabled((void*)&i_hphp_thread_is_warmup_enabled, (void*)&ifa_hphp_thread_is_warmup_enabled, 0, 0, 0x0000000000000000LL);
CallInfo ci_mysql_pconnect_with_db((void*)&i_mysql_pconnect_with_db, (void*)&ifa_mysql_pconnect_with_db, 7, 0, 0x0000000000000000LL);
CallInfo ci_imagepsslantfont((void*)&i_imagepsslantfont, (void*)&ifa_imagepsslantfont, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagemattecolor((void*)&i_magickgetimagemattecolor, (void*)&ifa_magickgetimagemattecolor, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_strstr((void*)&i_mb_strstr, (void*)&ifa_mb_strstr, 4, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetblack((void*)&i_pixelgetblack, (void*)&ifa_pixelgetblack, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_field_table((void*)&i_mysql_field_table, (void*)&ifa_mysql_field_table, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagescene((void*)&i_magicksetimagescene, (void*)&ifa_magicksetimagescene, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagerenderingintent((void*)&i_magickgetimagerenderingintent, (void*)&ifa_magickgetimagerenderingintent, 1, 0, 0x0000000000000000LL);
CallInfo ci_setlocale((void*)&i_setlocale, (void*)&ifa_setlocale, 2, 1, 0x0000000000000000LL);
CallInfo ci_drawpushclippath((void*)&i_drawpushclippath, (void*)&ifa_drawpushclippath, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawpopclippath((void*)&i_drawpopclippath, (void*)&ifa_drawpopclippath, 1, 0, 0x0000000000000000LL);
CallInfo ci_nl2br((void*)&i_nl2br, (void*)&ifa_nl2br, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getperms((void*)&i_hphp_splfileinfo_getperms, (void*)&ifa_hphp_splfileinfo_getperms, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawsetfillopacity((void*)&i_drawsetfillopacity, (void*)&ifa_drawsetfillopacity, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_substitute_character((void*)&i_mb_substitute_character, (void*)&ifa_mb_substitute_character, 1, 0, 0x0000000000000000LL);
CallInfo ci_setrawcookie((void*)&i_setrawcookie, (void*)&ifa_setrawcookie, 7, 0, 0x0000000000000000LL);
CallInfo ci_evhttp_get((void*)&i_evhttp_get, (void*)&ifa_evhttp_get, 3, 0, 0x0000000000000000LL);
CallInfo ci_getimagesize((void*)&i_getimagesize, (void*)&ifa_getimagesize, 2, 0, 0x0000000000000002LL);
CallInfo ci_ldap_modify((void*)&i_ldap_modify, (void*)&ifa_ldap_modify, 3, 0, 0x0000000000000000LL);
CallInfo ci_ldap_search((void*)&i_ldap_search, (void*)&ifa_ldap_search, 8, 0, 0x0000000000000000LL);
CallInfo ci_strcasecmp((void*)&i_strcasecmp, (void*)&ifa_strcasecmp, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagesignature((void*)&i_magickgetimagesignature, (void*)&ifa_magickgetimagesignature, 1, 0, 0x0000000000000000LL);
CallInfo ci_get_class_methods((void*)&i_get_class_methods, (void*)&ifa_get_class_methods, 1, 0, 0x0000000000000000LL);
CallInfo ci_fopen((void*)&i_fopen, (void*)&ifa_fopen, 4, 0, 0x0000000000000000LL);
CallInfo ci_fb_const_fetch((void*)&i_fb_const_fetch, (void*)&ifa_fb_const_fetch, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_generic_end((void*)&i_mcrypt_generic_end, (void*)&ifa_mcrypt_generic_end, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkey_free((void*)&i_openssl_pkey_free, (void*)&ifa_openssl_pkey_free, 1, 0, 0x0000000000000000LL);
CallInfo ci_readlink((void*)&i_readlink, (void*)&ifa_readlink, 1, 0, 0x0000000000000000LL);
CallInfo ci_header_remove((void*)&i_header_remove, (void*)&ifa_header_remove, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickechoimagesblob((void*)&i_magickechoimagesblob, (void*)&ifa_magickechoimagesblob, 1, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_msg_parse((void*)&i_mailparse_msg_parse, (void*)&ifa_mailparse_msg_parse, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_text((void*)&i_xmlwriter_text, (void*)&ifa_xmlwriter_text, 2, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetindex((void*)&i_pixelsetindex, (void*)&ifa_pixelsetindex, 2, 0, 0x0000000000000000LL);
CallInfo ci_php_sapi_name((void*)&i_php_sapi_name, (void*)&ifa_php_sapi_name, 0, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_enc_get_key_size((void*)&i_mcrypt_enc_get_key_size, (void*)&ifa_mcrypt_enc_get_key_size, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_num_fields((void*)&i_mysql_num_fields, (void*)&ifa_mysql_num_fields, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_xpath_register_php_functions((void*)&i_dom_xpath_register_php_functions, (void*)&ifa_dom_xpath_register_php_functions, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicksteganoimage((void*)&i_magicksteganoimage, (void*)&ifa_magicksteganoimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_magicksetfirstiterator((void*)&i_magicksetfirstiterator, (void*)&ifa_magicksetfirstiterator, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetcolorasstring((void*)&i_pixelgetcolorasstring, (void*)&ifa_pixelgetcolorasstring, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickremoveimage((void*)&i_magickremoveimage, (void*)&ifa_magickremoveimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_file_exists((void*)&i_file_exists, (void*)&ifa_file_exists, 1, 0, 0x0000000000000000LL);
CallInfo ci_call_user_func_array((void*)&i_call_user_func_array, (void*)&ifa_call_user_func_array, 2, 0, 0x0000000000000000LL);
CallInfo ci_restore_include_path((void*)&i_restore_include_path, (void*)&ifa_restore_include_path, 0, 0, 0x0000000000000000LL);
CallInfo ci_memcache_set_compress_threshold((void*)&i_memcache_set_compress_threshold, (void*)&ifa_memcache_set_compress_threshold, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_set_id_attribute_ns((void*)&i_dom_element_set_id_attribute_ns, (void*)&ifa_dom_element_set_id_attribute_ns, 4, 0, 0x0000000000000000LL);
CallInfo ci_drawgettextundercolor((void*)&i_drawgettextundercolor, (void*)&ifa_drawgettextundercolor, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_shift((void*)&i_array_shift, (void*)&ifa_array_shift, 1, 0, 0x0000000000000001LL);
CallInfo ci_magicksetimageformat((void*)&i_magicksetimageformat, (void*)&ifa_magicksetimageformat, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_open_memory((void*)&i_xmlwriter_open_memory, (void*)&ifa_xmlwriter_open_memory, 0, 0, 0x0000000000000000LL);
CallInfo ci_drawsetstrokemiterlimit((void*)&i_drawsetstrokemiterlimit, (void*)&ifa_drawsetstrokemiterlimit, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_convert_kana((void*)&i_mb_convert_kana, (void*)&ifa_mb_convert_kana, 3, 0, 0x0000000000000000LL);
CallInfo ci_token_name((void*)&i_token_name, (void*)&ifa_token_name, 1, 0, 0x0000000000000000LL);
CallInfo ci_preg_quote((void*)&i_preg_quote, (void*)&ifa_preg_quote, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_service_thread_started((void*)&i_hphp_service_thread_started, (void*)&ifa_hphp_service_thread_started, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickconvolveimage((void*)&i_magickconvolveimage, (void*)&ifa_magickconvolveimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_curl_getinfo((void*)&i_curl_getinfo, (void*)&ifa_curl_getinfo, 2, 0, 0x0000000000000000LL);
CallInfo ci_pfsockopen((void*)&i_pfsockopen, (void*)&ifa_pfsockopen, 5, 0, 0x000000000000000CLL);
CallInfo ci_dom_element_get_elements_by_tag_name_ns((void*)&i_dom_element_get_elements_by_tag_name_ns, (void*)&ifa_dom_element_get_elements_by_tag_name_ns, 3, 0, 0x0000000000000000LL);
CallInfo ci_ucfirst((void*)&i_ucfirst, (void*)&ifa_ucfirst, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_isreadable((void*)&i_hphp_splfileinfo_isreadable, (void*)&ifa_hphp_splfileinfo_isreadable, 1, 0, 0x0000000000000000LL);
CallInfo ci_chroot((void*)&i_chroot, (void*)&ifa_chroot, 1, 0, 0x0000000000000000LL);
CallInfo ci_chdir((void*)&i_chdir, (void*)&ifa_chdir, 1, 0, 0x0000000000000000LL);
CallInfo ci_socket_write((void*)&i_socket_write, (void*)&ifa_socket_write, 3, 0, 0x0000000000000000LL);
CallInfo ci_forward_static_call_array((void*)&i_forward_static_call_array, (void*)&ifa_forward_static_call_array, 2, 0, 0x0000000000000000LL);
CallInfo ci_stream_bucket_new((void*)&i_stream_bucket_new, (void*)&ifa_stream_bucket_new, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickflipimage((void*)&i_magickflipimage, (void*)&ifa_magickflipimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_timezone_identifiers_list((void*)&i_timezone_identifiers_list, (void*)&ifa_timezone_identifiers_list, 0, 0, 0x0000000000000000LL);
CallInfo ci_array_diff_key((void*)&i_array_diff_key, (void*)&ifa_array_diff_key, 2, 1, 0x0000000000000000LL);
CallInfo ci_session_encode((void*)&i_session_encode, (void*)&ifa_session_encode, 0, 0, 0x0000000000000000LL);
CallInfo ci_fread((void*)&i_fread, (void*)&ifa_fread, 2, 0, 0x0000000000000000LL);
CallInfo ci_override_function((void*)&i_override_function, (void*)&ifa_override_function, 3, 0, 0x0000000000000000LL);
CallInfo ci_is_long((void*)&i_is_long, (void*)&ifa_is_long, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetred((void*)&i_pixelsetred, (void*)&ifa_pixelsetred, 2, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_uudecode_all((void*)&i_mailparse_uudecode_all, (void*)&ifa_mailparse_uudecode_all, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawsetvectorgraphics((void*)&i_drawsetvectorgraphics, (void*)&ifa_drawsetvectorgraphics, 2, 0, 0x0000000000000000LL);
CallInfo ci_ctype_upper((void*)&i_ctype_upper, (void*)&ifa_ctype_upper, 1, 0, 0x0000000000000000LL);
CallInfo ci_get_declared_classes((void*)&i_get_declared_classes, (void*)&ifa_get_declared_classes, 0, 0, 0x0000000000000000LL);
CallInfo ci_drawgetstrokelinejoin((void*)&i_drawgetstrokelinejoin, (void*)&ifa_drawgetstrokelinejoin, 1, 0, 0x0000000000000000LL);
CallInfo ci_popen((void*)&i_popen, (void*)&ifa_popen, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_next_entry((void*)&i_ldap_next_entry, (void*)&ifa_ldap_next_entry, 2, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_msg_parse_file((void*)&i_mailparse_msg_parse_file, (void*)&ifa_mailparse_msg_parse_file, 1, 0, 0x0000000000000000LL);
CallInfo ci_get_loaded_extensions((void*)&i_get_loaded_extensions, (void*)&ifa_get_loaded_extensions, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickdrawimage((void*)&i_magickdrawimage, (void*)&ifa_magickdrawimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_cbc((void*)&i_mcrypt_cbc, (void*)&ifa_mcrypt_cbc, 5, 0, 0x0000000000000000LL);
CallInfo ci_session_set_save_handler((void*)&i_session_set_save_handler, (void*)&ifa_session_set_save_handler, 6, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_get_attribute((void*)&i_dom_element_get_attribute, (void*)&ifa_dom_element_get_attribute, 2, 0, 0x0000000000000000LL);
CallInfo ci_imagecreatetruecolor((void*)&i_imagecreatetruecolor, (void*)&ifa_imagecreatetruecolor, 2, 0, 0x0000000000000000LL);
CallInfo ci_intl_is_failure((void*)&i_intl_is_failure, (void*)&ifa_intl_is_failure, 1, 0, 0x0000000000000000LL);
CallInfo ci_inet_ntop((void*)&i_inet_ntop, (void*)&ifa_inet_ntop, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickreadimage((void*)&i_magickreadimage, (void*)&ifa_magickreadimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_is_default_namespace((void*)&i_dom_node_is_default_namespace, (void*)&ifa_dom_node_is_default_namespace, 2, 0, 0x0000000000000000LL);
CallInfo ci_curl_init((void*)&i_curl_init, (void*)&ifa_curl_init, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_cfb((void*)&i_mcrypt_cfb, (void*)&ifa_mcrypt_cfb, 5, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_create_document_fragment((void*)&i_dom_document_create_document_fragment, (void*)&ifa_dom_document_create_document_fragment, 1, 0, 0x0000000000000000LL);
CallInfo ci_set_time_limit((void*)&i_set_time_limit, (void*)&ifa_set_time_limit, 1, 0, 0x0000000000000000LL);
CallInfo ci_libxml_get_errors((void*)&i_libxml_get_errors, (void*)&ifa_libxml_get_errors, 0, 0, 0x0000000000000000LL);
CallInfo ci_get_magic_quotes_gpc((void*)&i_get_magic_quotes_gpc, (void*)&ifa_get_magic_quotes_gpc, 0, 0, 0x0000000000000000LL);
CallInfo ci_proc_get_status((void*)&i_proc_get_status, (void*)&ifa_proc_get_status, 1, 0, 0x0000000000000000LL);
CallInfo ci_log10((void*)&i_log10, (void*)&ifa_log10, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_directoryiterator_seek((void*)&i_hphp_directoryiterator_seek, (void*)&ifa_hphp_directoryiterator_seek, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_get_values((void*)&i_ldap_get_values, (void*)&ifa_ldap_get_values, 3, 0, 0x0000000000000000LL);
CallInfo ci_is_soap_fault((void*)&i_is_soap_fault, (void*)&ifa_is_soap_fault, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagechannelmean((void*)&i_magickgetimagechannelmean, (void*)&ifa_magickgetimagechannelmean, 2, 0, 0x0000000000000000LL);
CallInfo ci_disk_total_space((void*)&i_disk_total_space, (void*)&ifa_disk_total_space, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagegd((void*)&i_imagegd, (void*)&ifa_imagegd, 2, 0, 0x0000000000000000LL);
CallInfo ci_socket_set_blocking((void*)&i_socket_set_blocking, (void*)&ifa_socket_set_blocking, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_get_elements_by_tag_name((void*)&i_dom_element_get_elements_by_tag_name, (void*)&ifa_dom_element_get_elements_by_tag_name, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_mknod((void*)&i_posix_mknod, (void*)&ifa_posix_mknod, 4, 0, 0x0000000000000000LL);
CallInfo ci_apc_define_constants((void*)&i_apc_define_constants, (void*)&ifa_apc_define_constants, 4, 0, 0x0000000000000000LL);
CallInfo ci_posix_kill((void*)&i_posix_kill, (void*)&ifa_posix_kill, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawgetstrokealpha((void*)&i_drawgetstrokealpha, (void*)&ifa_drawgetstrokealpha, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_get_block_size((void*)&i_mcrypt_get_block_size, (void*)&ifa_mcrypt_get_block_size, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickmorphimages((void*)&i_magickmorphimages, (void*)&ifa_magickmorphimages, 2, 0, 0x0000000000000000LL);
CallInfo ci_getlastmod((void*)&i_getlastmod, (void*)&ifa_getlastmod, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickquantizeimage((void*)&i_magickquantizeimage, (void*)&ifa_magickquantizeimage, 6, 0, 0x0000000000000000LL);
CallInfo ci_imagesavealpha((void*)&i_imagesavealpha, (void*)&ifa_imagesavealpha, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawsetfontfamily((void*)&i_drawsetfontfamily, (void*)&ifa_drawsetfontfamily, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawsettextantialias((void*)&i_drawsettextantialias, (void*)&ifa_drawsettextantialias, 2, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetgreenquantum((void*)&i_pixelsetgreenquantum, (void*)&ifa_pixelsetgreenquantum, 2, 0, 0x0000000000000000LL);
CallInfo ci_bcsqrt((void*)&i_bcsqrt, (void*)&ifa_bcsqrt, 2, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_signal((void*)&i_pcntl_signal, (void*)&ifa_pcntl_signal, 3, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_ecb((void*)&i_mcrypt_ecb, (void*)&ifa_mcrypt_ecb, 5, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetcyanquantum((void*)&i_pixelsetcyanquantum, (void*)&ifa_pixelsetcyanquantum, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_walk((void*)&i_array_walk, (void*)&ifa_array_walk, 3, 0, 0x0000000000000001LL);
CallInfo ci_getmxrr((void*)&i_getmxrr, (void*)&ifa_getmxrr, 3, 0, 0x0000000000000006LL);
CallInfo ci_magickqueryfonts((void*)&i_magickqueryfonts, (void*)&ifa_magickqueryfonts, 1, 0, 0x0000000000000000LL);
CallInfo ci_floatval((void*)&i_floatval, (void*)&ifa_floatval, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_get_attribute_node_ns((void*)&i_dom_element_get_attribute_node_ns, (void*)&ifa_dom_element_get_attribute_node_ns, 3, 0, 0x0000000000000000LL);
CallInfo ci_xml_set_object((void*)&i_xml_set_object, (void*)&ifa_xml_set_object, 2, 0, 0x0000000000000002LL);
CallInfo ci_ctype_print((void*)&i_ctype_print, (void*)&ifa_ctype_print, 1, 0, 0x0000000000000000LL);
CallInfo ci_gzwrite((void*)&i_gzwrite, (void*)&ifa_gzwrite, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo___tostring((void*)&i_hphp_splfileinfo___tostring, (void*)&ifa_hphp_splfileinfo___tostring, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickaddimage((void*)&i_magickaddimage, (void*)&ifa_magickaddimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_clearstatcache((void*)&i_clearstatcache, (void*)&ifa_clearstatcache, 0, 0, 0x0000000000000000LL);
CallInfo ci_chgrp((void*)&i_chgrp, (void*)&ifa_chgrp, 2, 0, 0x0000000000000000LL);
CallInfo ci_virtual((void*)&i_virtual, (void*)&ifa_virtual, 1, 0, 0x0000000000000000LL);
CallInfo ci_reset((void*)&i_reset, (void*)&ifa_reset, 1, 0, 0x0000000000000001LL);
CallInfo ci_set_include_path((void*)&i_set_include_path, (void*)&ifa_set_include_path, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursivedirectoryiterator_next((void*)&i_hphp_recursivedirectoryiterator_next, (void*)&ifa_hphp_recursivedirectoryiterator_next, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_x509_export((void*)&i_openssl_x509_export, (void*)&ifa_openssl_x509_export, 3, 0, 0x0000000000000002LL);
CallInfo ci_magickcolorizeimage((void*)&i_magickcolorizeimage, (void*)&ifa_magickcolorizeimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagettftext((void*)&i_imagettftext, (void*)&ifa_imagettftext, 8, 0, 0x0000000000000000LL);
CallInfo ci_mb_strrchr((void*)&i_mb_strrchr, (void*)&ifa_mb_strrchr, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageprofile((void*)&i_magickgetimageprofile, (void*)&ifa_magickgetimageprofile, 2, 0, 0x0000000000000000LL);
CallInfo ci_file_put_contents((void*)&i_file_put_contents, (void*)&ifa_file_put_contents, 4, 0, 0x0000000000000000LL);
CallInfo ci_iconv_mime_encode((void*)&i_iconv_mime_encode, (void*)&ifa_iconv_mime_encode, 3, 0, 0x0000000000000000LL);
CallInfo ci_log1p((void*)&i_log1p, (void*)&ifa_log1p, 1, 0, 0x0000000000000000LL);
CallInfo ci_fwrite((void*)&i_fwrite, (void*)&ifa_fwrite, 3, 0, 0x0000000000000000LL);
CallInfo ci_atan2((void*)&i_atan2, (void*)&ifa_atan2, 2, 0, 0x0000000000000000LL);
CallInfo ci_is_a((void*)&i_is_a, (void*)&ifa_is_a, 2, 0, 0x0000000000000000LL);
CallInfo ci_idate((void*)&i_idate, (void*)&ifa_idate, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_initgroups((void*)&i_posix_initgroups, (void*)&ifa_posix_initgroups, 2, 0, 0x0000000000000000LL);
CallInfo ci_arsort((void*)&i_arsort, (void*)&ifa_arsort, 3, 0, 0x0000000000000001LL);
CallInfo ci_dom_characterdata_substring_data((void*)&i_dom_characterdata_substring_data, (void*)&ifa_dom_characterdata_substring_data, 3, 0, 0x0000000000000000LL);
CallInfo ci_gethostbyaddr((void*)&i_gethostbyaddr, (void*)&ifa_gethostbyaddr, 1, 0, 0x0000000000000000LL);
CallInfo ci_apc_delete((void*)&i_apc_delete, (void*)&ifa_apc_delete, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicklevelimage((void*)&i_magicklevelimage, (void*)&ifa_magicklevelimage, 5, 0, 0x0000000000000000LL);
CallInfo ci_openssl_x509_parse((void*)&i_openssl_x509_parse, (void*)&ifa_openssl_x509_parse, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_nodelist_item((void*)&i_dom_nodelist_item, (void*)&ifa_dom_nodelist_item, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickcommentimage((void*)&i_magickcommentimage, (void*)&ifa_magickcommentimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_islink((void*)&i_hphp_splfileinfo_islink, (void*)&ifa_hphp_splfileinfo_islink, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagedelay((void*)&i_magicksetimagedelay, (void*)&ifa_magicksetimagedelay, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickposterizeimage((void*)&i_magickposterizeimage, (void*)&ifa_magickposterizeimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_namednodemap_get_named_item((void*)&i_dom_namednodemap_get_named_item, (void*)&ifa_dom_namednodemap_get_named_item, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_get_attribute_ns((void*)&i_dom_element_get_attribute_ns, (void*)&ifa_dom_element_get_attribute_ns, 3, 0, 0x0000000000000000LL);
CallInfo ci_stream_socket_accept((void*)&i_stream_socket_accept, (void*)&ifa_stream_socket_accept, 3, 0, 0x0000000000000004LL);
CallInfo ci_magickqueryconfigureoption((void*)&i_magickqueryconfigureoption, (void*)&ifa_magickqueryconfigureoption, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickevaluateimage((void*)&i_magickevaluateimage, (void*)&ifa_magickevaluateimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_imagesx((void*)&i_imagesx, (void*)&ifa_imagesx, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagesy((void*)&i_imagesy, (void*)&ifa_imagesy, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_get_client_info((void*)&i_mysql_get_client_info, (void*)&ifa_mysql_get_client_info, 0, 0, 0x0000000000000000LL);
CallInfo ci_fb_crossall_query((void*)&i_fb_crossall_query, (void*)&ifa_fb_crossall_query, 6, 0, 0x0000000000000000LL);
CallInfo ci_fseek((void*)&i_fseek, (void*)&ifa_fseek, 3, 0, 0x0000000000000000LL);
CallInfo ci_call_user_func_array_async((void*)&i_call_user_func_array_async, (void*)&ifa_call_user_func_array_async, 2, 0, 0x0000000000000000LL);
CallInfo ci_apc_compile_file((void*)&i_apc_compile_file, (void*)&ifa_apc_compile_file, 3, 0, 0x0000000000000000LL);
CallInfo ci_memcache_set_server_params((void*)&i_memcache_set_server_params, (void*)&ifa_memcache_set_server_params, 7, 0, 0x0000000000000000LL);
CallInfo ci_magicksetpassphrase((void*)&i_magicksetpassphrase, (void*)&ifa_magicksetpassphrase, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_info((void*)&i_mysql_info, (void*)&ifa_mysql_info, 1, 0, 0x0000000000000000LL);
CallInfo ci_is_writable((void*)&i_is_writable, (void*)&ifa_is_writable, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickrotateimage((void*)&i_magickrotateimage, (void*)&ifa_magickrotateimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_fgetcsv((void*)&i_fgetcsv, (void*)&ifa_fgetcsv, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickcolorfloodfillimage((void*)&i_magickcolorfloodfillimage, (void*)&ifa_magickcolorfloodfillimage, 6, 0, 0x0000000000000000LL);
CallInfo ci_atanh((void*)&i_atanh, (void*)&ifa_atanh, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecopyresized((void*)&i_imagecopyresized, (void*)&ifa_imagecopyresized, 10, 0, 0x0000000000000000LL);
CallInfo ci_fpassthru((void*)&i_fpassthru, (void*)&ifa_fpassthru, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickblackthresholdimage((void*)&i_magickblackthresholdimage, (void*)&ifa_magickblackthresholdimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_encrypt((void*)&i_mcrypt_encrypt, (void*)&ifa_mcrypt_encrypt, 5, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagegreenprimary((void*)&i_magicksetimagegreenprimary, (void*)&ifa_magicksetimagegreenprimary, 3, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_start_attribute_ns((void*)&i_xmlwriter_start_attribute_ns, (void*)&ifa_xmlwriter_start_attribute_ns, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageinterlacescheme((void*)&i_magickgetimageinterlacescheme, (void*)&ifa_magickgetimageinterlacescheme, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_merge_recursive((void*)&i_array_merge_recursive, (void*)&ifa_array_merge_recursive, 1, 1, 0x0000000000000000LL);
CallInfo ci_array_uintersect((void*)&i_array_uintersect, (void*)&ifa_array_uintersect, 3, 1, 0x0000000000000000LL);
CallInfo ci_xml_set_unparsed_entity_decl_handler((void*)&i_xml_set_unparsed_entity_decl_handler, (void*)&ifa_xml_set_unparsed_entity_decl_handler, 2, 0, 0x0000000000000000LL);
CallInfo ci_ob_get_contents((void*)&i_ob_get_contents, (void*)&ifa_ob_get_contents, 0, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetcyan((void*)&i_pixelgetcyan, (void*)&ifa_pixelgetcyan, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_select((void*)&i_stream_select, (void*)&ifa_stream_select, 5, 0, 0x0000000000000007LL);
CallInfo ci_get_resource_type((void*)&i_get_resource_type, (void*)&ifa_get_resource_type, 1, 0, 0x0000000000000000LL);
CallInfo ci_dangling_server_proxy_old_request((void*)&i_dangling_server_proxy_old_request, (void*)&ifa_dangling_server_proxy_old_request, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagefilename((void*)&i_magickgetimagefilename, (void*)&ifa_magickgetimagefilename, 1, 0, 0x0000000000000000LL);
CallInfo ci_exif_tagname((void*)&i_exif_tagname, (void*)&ifa_exif_tagname, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_create_attribute_ns((void*)&i_dom_document_create_attribute_ns, (void*)&ifa_dom_document_create_attribute_ns, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawsetfillalpha((void*)&i_drawsetfillalpha, (void*)&ifa_drawsetfillalpha, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_convert_encoding((void*)&i_mb_convert_encoding, (void*)&ifa_mb_convert_encoding, 3, 0, 0x0000000000000000LL);
CallInfo ci_wandgetexceptionstring((void*)&i_wandgetexceptionstring, (void*)&ifa_wandgetexceptionstring, 1, 0, 0x0000000000000000LL);
CallInfo ci_proc_open((void*)&i_proc_open, (void*)&ifa_proc_open, 6, 0, 0x0000000000000004LL);
CallInfo ci_hphp_splfileobject_fgetss((void*)&i_hphp_splfileobject_fgetss, (void*)&ifa_hphp_splfileobject_fgetss, 2, 0, 0x0000000000000000LL);
CallInfo ci_clearpixeliterator((void*)&i_clearpixeliterator, (void*)&ifa_clearpixeliterator, 1, 0, 0x0000000000000000LL);
CallInfo ci_socket_server((void*)&i_socket_server, (void*)&ifa_socket_server, 4, 0, 0x000000000000000CLL);
CallInfo ci_magickremoveimageprofile((void*)&i_magickremoveimageprofile, (void*)&ifa_magickremoveimageprofile, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_dtd_element((void*)&i_xmlwriter_write_dtd_element, (void*)&ifa_xmlwriter_write_dtd_element, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawpushdefs((void*)&i_drawpushdefs, (void*)&ifa_drawpushdefs, 1, 0, 0x0000000000000000LL);
CallInfo ci_image2wbmp((void*)&i_image2wbmp, (void*)&ifa_image2wbmp, 3, 0, 0x0000000000000000LL);
CallInfo ci_join((void*)&i_join, (void*)&ifa_join, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimage((void*)&i_magicksetimage, (void*)&ifa_magicksetimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_openssl_free_key((void*)&i_openssl_free_key, (void*)&ifa_openssl_free_key, 1, 0, 0x0000000000000000LL);
CallInfo ci_preg_grep((void*)&i_preg_grep, (void*)&ifa_preg_grep, 3, 0, 0x0000000000000000LL);
CallInfo ci_is_float((void*)&i_is_float, (void*)&ifa_is_float, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_socket_pair((void*)&i_stream_socket_pair, (void*)&ifa_stream_socket_pair, 3, 0, 0x0000000000000000LL);
CallInfo ci_get_required_files((void*)&i_get_required_files, (void*)&ifa_get_required_files, 0, 0, 0x0000000000000000LL);
CallInfo ci_mysql_fetch_field((void*)&i_mysql_fetch_field, (void*)&ifa_mysql_fetch_field, 2, 0, 0x0000000000000000LL);
CallInfo ci_chmod((void*)&i_chmod, (void*)&ifa_chmod, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgettextascent((void*)&i_magickgettextascent, (void*)&ifa_magickgettextascent, 4, 0, 0x0000000000000000LL);
CallInfo ci_mb_regex_encoding((void*)&i_mb_regex_encoding, (void*)&ifa_mb_regex_encoding, 1, 0, 0x0000000000000000LL);
CallInfo ci_mail((void*)&i_mail, (void*)&ifa_mail, 5, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_enc_self_test((void*)&i_mcrypt_enc_self_test, (void*)&ifa_mcrypt_enc_self_test, 1, 0, 0x0000000000000000LL);
CallInfo ci_ignore_user_abort((void*)&i_ignore_user_abort, (void*)&ifa_ignore_user_abort, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagesetthickness((void*)&i_imagesetthickness, (void*)&ifa_imagesetthickness, 2, 0, 0x0000000000000000LL);
CallInfo ci_str_pad((void*)&i_str_pad, (void*)&ifa_str_pad, 4, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkcs7_decrypt((void*)&i_openssl_pkcs7_decrypt, (void*)&ifa_openssl_pkcs7_decrypt, 4, 0, 0x0000000000000000LL);
CallInfo ci_pagelet_server_task_result((void*)&i_pagelet_server_task_result, (void*)&ifa_pagelet_server_task_result, 3, 0, 0x0000000000000006LL);
CallInfo ci_asinh((void*)&i_asinh, (void*)&ifa_asinh, 1, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_msg_extract_part((void*)&i_mailparse_msg_extract_part, (void*)&ifa_mailparse_msg_extract_part, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagecompose((void*)&i_magickgetimagecompose, (void*)&ifa_magickgetimagecompose, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getpath((void*)&i_hphp_splfileinfo_getpath, (void*)&ifa_hphp_splfileinfo_getpath, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickcropimage((void*)&i_magickcropimage, (void*)&ifa_magickcropimage, 5, 0, 0x0000000000000000LL);
CallInfo ci_ob_gzhandler((void*)&i_ob_gzhandler, (void*)&ifa_ob_gzhandler, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_normalize_document((void*)&i_dom_document_normalize_document, (void*)&ifa_dom_document_normalize_document, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawcomment((void*)&i_drawcomment, (void*)&ifa_drawcomment, 2, 0, 0x0000000000000000LL);
CallInfo ci_call_user_method((void*)&i_call_user_method, (void*)&ifa_call_user_method, 2, 1, 0x0000000000000002LL);
CallInfo ci_parse_hdf_file((void*)&i_parse_hdf_file, (void*)&ifa_parse_hdf_file, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_split((void*)&i_mb_split, (void*)&ifa_mb_split, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagepolygon((void*)&i_imagepolygon, (void*)&ifa_imagepolygon, 4, 0, 0x0000000000000000LL);
CallInfo ci_mysql_field_name((void*)&i_mysql_field_name, (void*)&ifa_mysql_field_name, 2, 0, 0x0000000000000000LL);
CallInfo ci_fputs((void*)&i_fputs, (void*)&ifa_fputs, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorallocatealpha((void*)&i_imagecolorallocatealpha, (void*)&ifa_imagecolorallocatealpha, 5, 0, 0x0000000000000000LL);
CallInfo ci_substr_count((void*)&i_substr_count, (void*)&ifa_substr_count, 4, 0, 0x0000000000000000LL);
CallInfo ci_ldap_first_reference((void*)&i_ldap_first_reference, (void*)&ifa_ldap_first_reference, 2, 0, 0x0000000000000000LL);
CallInfo ci_clock_settime((void*)&i_clock_settime, (void*)&ifa_clock_settime, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_namednodemap_get_named_item_ns((void*)&i_dom_namednodemap_get_named_item_ns, (void*)&ifa_dom_namednodemap_get_named_item_ns, 3, 0, 0x0000000000000000LL);
CallInfo ci_ftruncate((void*)&i_ftruncate, (void*)&ifa_ftruncate, 2, 0, 0x0000000000000000LL);
CallInfo ci_curl_version((void*)&i_curl_version, (void*)&ifa_curl_version, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetbluequantum((void*)&i_pixelgetbluequantum, (void*)&ifa_pixelgetbluequantum, 1, 0, 0x0000000000000000LL);
CallInfo ci_print((void*)&i_print, (void*)&ifa_print, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_unbuffered_query((void*)&i_mysql_unbuffered_query, (void*)&ifa_mysql_unbuffered_query, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_characterdata_delete_data((void*)&i_dom_characterdata_delete_data, (void*)&ifa_dom_characterdata_delete_data, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursiveiteratoriterator___construct((void*)&i_hphp_recursiveiteratoriterator___construct, (void*)&ifa_hphp_recursiveiteratoriterator___construct, 4, 0, 0x0000000000000000LL);
CallInfo ci_hash_final((void*)&i_hash_final, (void*)&ifa_hash_final, 2, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorresolve((void*)&i_imagecolorresolve, (void*)&ifa_imagecolorresolve, 4, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_import_node((void*)&i_dom_document_import_node, (void*)&ifa_dom_document_import_node, 3, 0, 0x0000000000000000LL);
CallInfo ci_date_date_set((void*)&i_date_date_set, (void*)&ifa_date_date_set, 4, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetyellow((void*)&i_pixelsetyellow, (void*)&ifa_pixelsetyellow, 2, 0, 0x0000000000000000LL);
CallInfo ci_furchash_hphp_ext_supported((void*)&i_furchash_hphp_ext_supported, (void*)&ifa_furchash_hphp_ext_supported, 0, 0, 0x0000000000000000LL);
CallInfo ci_inet_pton((void*)&i_inet_pton, (void*)&ifa_inet_pton, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_get_key_size((void*)&i_mcrypt_get_key_size, (void*)&ifa_mcrypt_get_key_size, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawsettextalignment((void*)&i_drawsettextalignment, (void*)&ifa_drawsettextalignment, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageredprimary((void*)&i_magickgetimageredprimary, (void*)&ifa_magickgetimageredprimary, 1, 0, 0x0000000000000000LL);
CallInfo ci_addslashes((void*)&i_addslashes, (void*)&ifa_addslashes, 1, 0, 0x0000000000000000LL);
CallInfo ci_ldap_count_entries((void*)&i_ldap_count_entries, (void*)&ifa_ldap_count_entries, 2, 0, 0x0000000000000000LL);
CallInfo ci_ereg_replace((void*)&i_ereg_replace, (void*)&ifa_ereg_replace, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursivedirectoryiterator_getchildren((void*)&i_hphp_recursivedirectoryiterator_getchildren, (void*)&ifa_hphp_recursivedirectoryiterator_getchildren, 1, 0, 0x0000000000000000LL);
CallInfo ci_call_user_func_async((void*)&i_call_user_func_async, (void*)&ifa_call_user_func_async, 1, 2, 0x0000000000000000LL);
CallInfo ci_drawrender((void*)&i_drawrender, (void*)&ifa_drawrender, 1, 0, 0x0000000000000000LL);
CallInfo ci_fb_rpc_intercept_handler((void*)&i_fb_rpc_intercept_handler, (void*)&ifa_fb_rpc_intercept_handler, 5, 0, 0x0000000000000010LL);
CallInfo ci_fb_intercept((void*)&i_fb_intercept, (void*)&ifa_fb_intercept, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickgetversionnumber((void*)&i_magickgetversionnumber, (void*)&ifa_magickgetversionnumber, 0, 0, 0x0000000000000000LL);
CallInfo ci_array_splice((void*)&i_array_splice, (void*)&ifa_array_splice, 4, 0, 0x0000000000000001LL);
CallInfo ci_ftell((void*)&i_ftell, (void*)&ifa_ftell, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagedepth((void*)&i_magicksetimagedepth, (void*)&ifa_magicksetimagedepth, 3, 0, 0x0000000000000000LL);
CallInfo ci_apc_load_constants((void*)&i_apc_load_constants, (void*)&ifa_apc_load_constants, 3, 0, 0x0000000000000000LL);
CallInfo ci___halt_compiler((void*)&i___halt_compiler, (void*)&ifa___halt_compiler, 0, 0, 0x0000000000000000LL);
CallInfo ci_magicklabelimage((void*)&i_magicklabelimage, (void*)&ifa_magicklabelimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_log((void*)&i_hphp_log, (void*)&ifa_hphp_log, 2, 0, 0x0000000000000000LL);
CallInfo ci_stream_get_contents((void*)&i_stream_get_contents, (void*)&ifa_stream_get_contents, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagecreatefromjpeg((void*)&i_imagecreatefromjpeg, (void*)&ifa_imagecreatefromjpeg, 1, 0, 0x0000000000000000LL);
CallInfo ci_chown((void*)&i_chown, (void*)&ifa_chown, 2, 0, 0x0000000000000000LL);
CallInfo ci_hash_hmac_file((void*)&i_hash_hmac_file, (void*)&ifa_hash_hmac_file, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickechoimageblob((void*)&i_magickechoimageblob, (void*)&ifa_magickechoimageblob, 1, 0, 0x0000000000000000LL);
CallInfo ci_link((void*)&i_link, (void*)&ifa_link, 2, 0, 0x0000000000000000LL);
CallInfo ci_fb_utf8ize((void*)&i_fb_utf8ize, (void*)&ifa_fb_utf8ize, 1, 0, 0x0000000000000001LL);
CallInfo ci_drawsetfillpatternurl((void*)&i_drawsetfillpatternurl, (void*)&ifa_drawsetfillpatternurl, 2, 0, 0x0000000000000000LL);
CallInfo ci_iconv((void*)&i_iconv, (void*)&ifa_iconv, 3, 0, 0x0000000000000000LL);
CallInfo ci_highlight_file((void*)&i_highlight_file, (void*)&ifa_highlight_file, 2, 0, 0x0000000000000000LL);
CallInfo ci_iconv_mime_decode_headers((void*)&i_iconv_mime_decode_headers, (void*)&ifa_iconv_mime_decode_headers, 3, 0, 0x0000000000000000LL);
CallInfo ci_ini_get_all((void*)&i_ini_get_all, (void*)&ifa_ini_get_all, 1, 0, 0x0000000000000000LL);
CallInfo ci_collator_get_strength((void*)&i_collator_get_strength, (void*)&ifa_collator_get_strength, 1, 0, 0x0000000000000000LL);
CallInfo ci_ldap_get_values_len((void*)&i_ldap_get_values_len, (void*)&ifa_ldap_get_values_len, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getrealpath((void*)&i_hphp_splfileinfo_getrealpath, (void*)&ifa_hphp_splfileinfo_getrealpath, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkcs7_verify((void*)&i_openssl_pkcs7_verify, (void*)&ifa_openssl_pkcs7_verify, 6, 0, 0x0000000000000000LL);
CallInfo ci_hphp_directoryiterator_current((void*)&i_hphp_directoryiterator_current, (void*)&ifa_hphp_directoryiterator_current, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_fgetcsv((void*)&i_hphp_splfileobject_fgetcsv, (void*)&ifa_hphp_splfileobject_fgetcsv, 4, 0, 0x0000000000000000LL);
CallInfo ci_furchash_hphp_ext((void*)&i_furchash_hphp_ext, (void*)&ifa_furchash_hphp_ext, 3, 0, 0x0000000000000000LL);
CallInfo ci_stream_socket_recvfrom((void*)&i_stream_socket_recvfrom, (void*)&ifa_stream_socket_recvfrom, 4, 0, 0x0000000000000000LL);
CallInfo ci_drawgetcliprule((void*)&i_drawgetcliprule, (void*)&ifa_drawgetcliprule, 1, 0, 0x0000000000000000LL);
CallInfo ci_apc_filehits((void*)&i_apc_filehits, (void*)&ifa_apc_filehits, 0, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetexceptionstring((void*)&i_pixelgetexceptionstring, (void*)&ifa_pixelgetexceptionstring, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_ofb((void*)&i_mcrypt_ofb, (void*)&ifa_mcrypt_ofb, 5, 0, 0x0000000000000000LL);
CallInfo ci_imageantialias((void*)&i_imageantialias, (void*)&ifa_imageantialias, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_openfile((void*)&i_hphp_splfileinfo_openfile, (void*)&ifa_hphp_splfileinfo_openfile, 4, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_validate((void*)&i_dom_document_validate, (void*)&ifa_dom_document_validate, 1, 0, 0x0000000000000000LL);
CallInfo ci_idn_to_ascii((void*)&i_idn_to_ascii, (void*)&ifa_idn_to_ascii, 2, 0, 0x0000000000000002LL);
CallInfo ci_error_log((void*)&i_error_log, (void*)&ifa_error_log, 4, 0, 0x0000000000000000LL);
CallInfo ci_hash_update((void*)&i_hash_update, (void*)&ifa_hash_update, 2, 0, 0x0000000000000000LL);
CallInfo ci_ob_flush((void*)&i_ob_flush, (void*)&ifa_ob_flush, 0, 0, 0x0000000000000000LL);
CallInfo ci_md5_file((void*)&i_md5_file, (void*)&ifa_md5_file, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawgetexception((void*)&i_drawgetexception, (void*)&ifa_drawgetexception, 1, 0, 0x0000000000000000LL);
CallInfo ci_file_get_contents((void*)&i_file_get_contents, (void*)&ifa_file_get_contents, 5, 0, 0x0000000000000000LL);
CallInfo ci_uniqid((void*)&i_uniqid, (void*)&ifa_uniqid, 2, 0, 0x0000000000000000LL);
CallInfo ci_strncasecmp((void*)&i_strncasecmp, (void*)&ifa_strncasecmp, 3, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagepixels((void*)&i_magicksetimagepixels, (void*)&ifa_magicksetimagepixels, 8, 0, 0x0000000000000000LL);
CallInfo ci_drawgetfillopacity((void*)&i_drawgetfillopacity, (void*)&ifa_drawgetfillopacity, 1, 0, 0x0000000000000000LL);
CallInfo ci_xml_parser_create_ns((void*)&i_xml_parser_create_ns, (void*)&ifa_xml_parser_create_ns, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_delete((void*)&i_ldap_delete, (void*)&ifa_ldap_delete, 2, 0, 0x0000000000000000LL);
CallInfo ci_fnmatch((void*)&i_fnmatch, (void*)&ifa_fnmatch, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_eof((void*)&i_hphp_splfileobject_eof, (void*)&ifa_hphp_splfileobject_eof, 1, 0, 0x0000000000000000LL);
CallInfo ci_metaphone((void*)&i_metaphone, (void*)&ifa_metaphone, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_errno((void*)&i_mysql_errno, (void*)&ifa_mysql_errno, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_wrapper_unregister((void*)&i_stream_wrapper_unregister, (void*)&ifa_stream_wrapper_unregister, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickcyclecolormapimage((void*)&i_magickcyclecolormapimage, (void*)&ifa_magickcyclecolormapimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursiveiteratoriterator_current((void*)&i_hphp_recursiveiteratoriterator_current, (void*)&ifa_hphp_recursiveiteratoriterator_current, 1, 0, 0x0000000000000000LL);
CallInfo ci_restore_error_handler((void*)&i_restore_error_handler, (void*)&ifa_restore_error_handler, 0, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursivedirectoryiterator___construct((void*)&i_hphp_recursivedirectoryiterator___construct, (void*)&ifa_hphp_recursivedirectoryiterator___construct, 3, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagevirtualpixelmethod((void*)&i_magicksetimagevirtualpixelmethod, (void*)&ifa_magicksetimagevirtualpixelmethod, 2, 0, 0x0000000000000000LL);
CallInfo ci_socket_getpeername((void*)&i_socket_getpeername, (void*)&ifa_socket_getpeername, 3, 0, 0x0000000000000006LL);
CallInfo ci_memcache_close((void*)&i_memcache_close, (void*)&ifa_memcache_close, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_error((void*)&i_mysql_error, (void*)&ifa_mysql_error, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawtranslate((void*)&i_drawtranslate, (void*)&ifa_drawtranslate, 3, 0, 0x0000000000000000LL);
CallInfo ci_mysql_list_dbs((void*)&i_mysql_list_dbs, (void*)&ifa_mysql_list_dbs, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagefilter((void*)&i_imagefilter, (void*)&ifa_imagefilter, 6, 0, 0x0000000000000000LL);
CallInfo ci_base64_encode((void*)&i_base64_encode, (void*)&ifa_base64_encode, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_xpath_query((void*)&i_dom_xpath_query, (void*)&ifa_dom_xpath_query, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphpd_install_user_command((void*)&i_hphpd_install_user_command, (void*)&ifa_hphpd_install_user_command, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_set_id_attribute_node((void*)&i_dom_element_set_id_attribute_node, (void*)&ifa_dom_element_set_id_attribute_node, 3, 0, 0x0000000000000000LL);
CallInfo ci_is_null((void*)&i_is_null, (void*)&ifa_is_null, 1, 0, 0x0000000000000000LL);
CallInfo ci_octdec((void*)&i_octdec, (void*)&ifa_octdec, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawsetclippath((void*)&i_drawsetclippath, (void*)&ifa_drawsetclippath, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickconstituteimage((void*)&i_magickconstituteimage, (void*)&ifa_magickconstituteimage, 6, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_wexitstatus((void*)&i_pcntl_wexitstatus, (void*)&ifa_pcntl_wexitstatus, 1, 0, 0x0000000000000000LL);
CallInfo ci_iterator_apply((void*)&i_iterator_apply, (void*)&ifa_iterator_apply, 3, 0, 0x0000000000000000LL);
CallInfo ci_apache_setenv((void*)&i_apache_setenv, (void*)&ifa_apache_setenv, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_is_same_node((void*)&i_dom_node_is_same_node, (void*)&ifa_dom_node_is_same_node, 2, 0, 0x0000000000000000LL);
CallInfo ci_clonedrawingwand((void*)&i_clonedrawingwand, (void*)&ifa_clonedrawingwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_ob_get_clean((void*)&i_ob_get_clean, (void*)&ifa_ob_get_clean, 0, 0, 0x0000000000000000LL);
CallInfo ci_expm1((void*)&i_expm1, (void*)&ifa_expm1, 1, 0, 0x0000000000000000LL);
CallInfo ci_ldap_first_entry((void*)&i_ldap_first_entry, (void*)&ifa_ldap_first_entry, 2, 0, 0x0000000000000000LL);
CallInfo ci_curl_multi_select((void*)&i_curl_multi_select, (void*)&ifa_curl_multi_select, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickswirlimage((void*)&i_magickswirlimage, (void*)&ifa_magickswirlimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_ereg_search_regs((void*)&i_mb_ereg_search_regs, (void*)&ifa_mb_ereg_search_regs, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_errno((void*)&i_ldap_errno, (void*)&ifa_ldap_errno, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_get_server_info((void*)&i_mysql_get_server_info, (void*)&ifa_mysql_get_server_info, 1, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_rfc822_parse_addresses((void*)&i_mailparse_rfc822_parse_addresses, (void*)&ifa_mailparse_rfc822_parse_addresses, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagemimetype((void*)&i_magickgetimagemimetype, (void*)&ifa_magickgetimagemimetype, 1, 0, 0x0000000000000000LL);
CallInfo ci_soundex((void*)&i_soundex, (void*)&ifa_soundex, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageformat((void*)&i_magickgetimageformat, (void*)&ifa_magickgetimageformat, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_module_get_supported_key_sizes((void*)&i_mcrypt_module_get_supported_key_sizes, (void*)&ifa_mcrypt_module_get_supported_key_sizes, 2, 0, 0x0000000000000000LL);
CallInfo ci_preg_replace_callback((void*)&i_preg_replace_callback, (void*)&ifa_preg_replace_callback, 5, 0, 0x0000000000000010LL);
CallInfo ci_dom_document_create_element((void*)&i_dom_document_create_element, (void*)&ifa_dom_document_create_element, 3, 0, 0x0000000000000000LL);
CallInfo ci_ldap_error((void*)&i_ldap_error, (void*)&ifa_ldap_error, 1, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_full_end_element((void*)&i_xmlwriter_full_end_element, (void*)&ifa_xmlwriter_full_end_element, 1, 0, 0x0000000000000000LL);
CallInfo ci_ctype_graph((void*)&i_ctype_graph, (void*)&ifa_ctype_graph, 1, 0, 0x0000000000000000LL);
CallInfo ci_session_register((void*)&i_session_register, (void*)&ifa_session_register, 1, 1, 0x0000000000000000LL);
CallInfo ci_asort((void*)&i_asort, (void*)&ifa_asort, 3, 0, 0x0000000000000001LL);
CallInfo ci_apd_echo((void*)&i_apd_echo, (void*)&ifa_apd_echo, 1, 0, 0x0000000000000000LL);
CallInfo ci_rewinddir((void*)&i_rewinddir, (void*)&ifa_rewinddir, 1, 0, 0x0000000000000000LL);
CallInfo ci_ob_implicit_flush((void*)&i_ob_implicit_flush, (void*)&ifa_ob_implicit_flush, 1, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_signal_dispatch((void*)&i_pcntl_signal_dispatch, (void*)&ifa_pcntl_signal_dispatch, 0, 0, 0x0000000000000000LL);
CallInfo ci_session_get_cookie_params((void*)&i_session_get_cookie_params, (void*)&ifa_session_get_cookie_params, 0, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetiteratorexceptionstring((void*)&i_pixelgetiteratorexceptionstring, (void*)&ifa_pixelgetiteratorexceptionstring, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_socket_client((void*)&i_stream_socket_client, (void*)&ifa_stream_socket_client, 6, 0, 0x0000000000000006LL);
CallInfo ci_drawsetstrokedasharray((void*)&i_drawsetstrokedasharray, (void*)&ifa_drawsetstrokedasharray, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_free_result((void*)&i_mysql_free_result, (void*)&ifa_mysql_free_result, 1, 0, 0x0000000000000000LL);
CallInfo ci_is_real((void*)&i_is_real, (void*)&ifa_is_real, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_enc_is_block_algorithm_mode((void*)&i_mcrypt_enc_is_block_algorithm_mode, (void*)&ifa_mcrypt_enc_is_block_algorithm_mode, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_slice((void*)&i_array_slice, (void*)&ifa_array_slice, 4, 0, 0x0000000000000000LL);
CallInfo ci_count_chars((void*)&i_count_chars, (void*)&ifa_count_chars, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_getmaxlinelen((void*)&i_hphp_splfileobject_getmaxlinelen, (void*)&ifa_hphp_splfileobject_getmaxlinelen, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_uintersect_uassoc((void*)&i_array_uintersect_uassoc, (void*)&ifa_array_uintersect_uassoc, 4, 1, 0x0000000000000000LL);
CallInfo ci_drawsetstrokewidth((void*)&i_drawsetstrokewidth, (void*)&ifa_drawsetstrokewidth, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_mkfifo((void*)&i_posix_mkfifo, (void*)&ifa_posix_mkfifo, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_count_values((void*)&i_array_count_values, (void*)&ifa_array_count_values, 1, 0, 0x0000000000000000LL);
CallInfo ci_memcache_connect((void*)&i_memcache_connect, (void*)&ifa_memcache_connect, 4, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetexception((void*)&i_pixelgetexception, (void*)&ifa_pixelgetexception, 1, 0, 0x0000000000000000LL);
CallInfo ci_mkdir((void*)&i_mkdir, (void*)&ifa_mkdir, 4, 0, 0x0000000000000000LL);
CallInfo ci_magicksetsize((void*)&i_magicksetsize, (void*)&ifa_magicksetsize, 3, 0, 0x0000000000000000LL);
CallInfo ci_debug_zval_dump((void*)&i_debug_zval_dump, (void*)&ifa_debug_zval_dump, 1, 0, 0x0000000000000000LL);
CallInfo ci_iconv_substr((void*)&i_iconv_substr, (void*)&ifa_iconv_substr, 4, 0, 0x0000000000000000LL);
CallInfo ci_xml_set_external_entity_ref_handler((void*)&i_xml_set_external_entity_ref_handler, (void*)&ifa_xml_set_external_entity_ref_handler, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_decode_numericentity((void*)&i_mb_decode_numericentity, (void*)&ifa_mb_decode_numericentity, 3, 0, 0x0000000000000000LL);
CallInfo ci_ldap_next_attribute((void*)&i_ldap_next_attribute, (void*)&ifa_ldap_next_attribute, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_fflush((void*)&i_hphp_splfileobject_fflush, (void*)&ifa_hphp_splfileobject_fflush, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagejpeg((void*)&i_imagejpeg, (void*)&ifa_imagejpeg, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagesetbrush((void*)&i_imagesetbrush, (void*)&ifa_imagesetbrush, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_strtoupper((void*)&i_mb_strtoupper, (void*)&ifa_mb_strtoupper, 2, 0, 0x0000000000000000LL);
CallInfo ci_usleep((void*)&i_usleep, (void*)&ifa_usleep, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_strrpos((void*)&i_mb_strrpos, (void*)&ifa_mb_strrpos, 4, 0, 0x0000000000000000LL);
CallInfo ci_collator_compare((void*)&i_collator_compare, (void*)&ifa_collator_compare, 3, 0, 0x0000000000000000LL);
CallInfo ci_extract((void*)&i_extract, (void*)&ifa_extract, 3, 0, 0x0000000000000000LL);
CallInfo ci_session_decode((void*)&i_session_decode, (void*)&ifa_session_decode, 1, 0, 0x0000000000000000LL);
CallInfo ci_get_browser((void*)&i_get_browser, (void*)&ifa_get_browser, 2, 0, 0x0000000000000000LL);
CallInfo ci_html_entity_decode((void*)&i_html_entity_decode, (void*)&ifa_html_entity_decode, 3, 0, 0x0000000000000000LL);
CallInfo ci_spl_classes((void*)&i_spl_classes, (void*)&ifa_spl_classes, 0, 0, 0x0000000000000000LL);
CallInfo ci_preg_split((void*)&i_preg_split, (void*)&ifa_preg_split, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickpreviewimages((void*)&i_magickpreviewimages, (void*)&ifa_magickpreviewimages, 2, 0, 0x0000000000000000LL);
CallInfo ci_zend_logo_guid((void*)&i_zend_logo_guid, (void*)&ifa_zend_logo_guid, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagesize((void*)&i_magickgetimagesize, (void*)&ifa_magickgetimagesize, 1, 0, 0x0000000000000000LL);
CallInfo ci_apd_set_browser_trace((void*)&i_apd_set_browser_trace, (void*)&ifa_apd_set_browser_trace, 0, 0, 0x0000000000000000LL);
CallInfo ci_xhprof_sample_enable((void*)&i_xhprof_sample_enable, (void*)&ifa_xhprof_sample_enable, 0, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_key((void*)&i_hphp_splfileobject_key, (void*)&ifa_hphp_splfileobject_key, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_http_input((void*)&i_mb_http_input, (void*)&ifa_mb_http_input, 1, 0, 0x0000000000000000LL);
CallInfo ci_gzinflate((void*)&i_gzinflate, (void*)&ifa_gzinflate, 2, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkcs7_sign((void*)&i_openssl_pkcs7_sign, (void*)&ifa_openssl_pkcs7_sign, 7, 0, 0x0000000000000000LL);
CallInfo ci_assert((void*)&i_assert, (void*)&ifa_assert, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_get_wrappers((void*)&i_stream_get_wrappers, (void*)&ifa_stream_get_wrappers, 0, 0, 0x0000000000000000LL);
CallInfo ci_gzfile((void*)&i_gzfile, (void*)&ifa_gzfile, 2, 0, 0x0000000000000000LL);
CallInfo ci_session_id((void*)&i_session_id, (void*)&ifa_session_id, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_socket_sendto((void*)&i_stream_socket_sendto, (void*)&ifa_stream_socket_sendto, 4, 0, 0x0000000000000000LL);
CallInfo ci_gzpassthru((void*)&i_gzpassthru, (void*)&ifa_gzpassthru, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_bucket_make_writeable((void*)&i_stream_bucket_make_writeable, (void*)&ifa_stream_bucket_make_writeable, 1, 0, 0x0000000000000000LL);
CallInfo ci_posix_setegid((void*)&i_posix_setegid, (void*)&ifa_posix_setegid, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawgetexceptionstring((void*)&i_drawgetexceptionstring, (void*)&ifa_drawgetexceptionstring, 1, 0, 0x0000000000000000LL);
CallInfo ci_hash_algos((void*)&i_hash_algos, (void*)&ifa_hash_algos, 0, 0, 0x0000000000000000LL);
CallInfo ci_drawsetstrokeantialias((void*)&i_drawsetstrokeantialias, (void*)&ifa_drawsetstrokeantialias, 2, 0, 0x0000000000000000LL);
CallInfo ci_destroypixelwand((void*)&i_destroypixelwand, (void*)&ifa_destroypixelwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_fstat((void*)&i_fstat, (void*)&ifa_fstat, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimageresolution((void*)&i_magicksetimageresolution, (void*)&ifa_magicksetimageresolution, 3, 0, 0x0000000000000000LL);
CallInfo ci_mysql_db_name((void*)&i_mysql_db_name, (void*)&ifa_mysql_db_name, 3, 0, 0x0000000000000000LL);
CallInfo ci_is_finite((void*)&i_is_finite, (void*)&ifa_is_finite, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetyellowquantum((void*)&i_pixelgetyellowquantum, (void*)&ifa_pixelgetyellowquantum, 1, 0, 0x0000000000000000LL);
CallInfo ci_ksort((void*)&i_ksort, (void*)&ifa_ksort, 2, 0, 0x0000000000000001LL);
CallInfo ci_thrift_protocol_read_binary((void*)&i_thrift_protocol_read_binary, (void*)&ifa_thrift_protocol_read_binary, 3, 0, 0x0000000000000000LL);
CallInfo ci_get_included_files((void*)&i_get_included_files, (void*)&ifa_get_included_files, 0, 0, 0x0000000000000000LL);
CallInfo ci_strip_tags((void*)&i_strip_tags, (void*)&ifa_strip_tags, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_ereg_search_getpos((void*)&i_mb_ereg_search_getpos, (void*)&ifa_mb_ereg_search_getpos, 0, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetcyanquantum((void*)&i_pixelgetcyanquantum, (void*)&ifa_pixelgetcyanquantum, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetexception((void*)&i_magickgetexception, (void*)&ifa_magickgetexception, 1, 0, 0x0000000000000000LL);
CallInfo ci_ctype_punct((void*)&i_ctype_punct, (void*)&ifa_ctype_punct, 1, 0, 0x0000000000000000LL);
CallInfo ci_next((void*)&i_next, (void*)&ifa_next, 1, 0, 0x0000000000000001LL);
CallInfo ci_shm_detach((void*)&i_shm_detach, (void*)&ifa_shm_detach, 1, 0, 0x0000000000000000LL);
CallInfo ci_shm_attach((void*)&i_shm_attach, (void*)&ifa_shm_attach, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickflattenimages((void*)&i_magickflattenimages, (void*)&ifa_magickflattenimages, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_save_html_file((void*)&i_dom_document_save_html_file, (void*)&ifa_dom_document_save_html_file, 2, 0, 0x0000000000000000LL);
CallInfo ci_similar_text((void*)&i_similar_text, (void*)&ifa_similar_text, 3, 0, 0x0000000000000004LL);
CallInfo ci_hphp_get_thread_id((void*)&i_hphp_get_thread_id, (void*)&ifa_hphp_get_thread_id, 0, 0, 0x0000000000000000LL);
CallInfo ci_imagecreatefromgd2part((void*)&i_imagecreatefromgd2part, (void*)&ifa_imagecreatefromgd2part, 5, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_set_attribute((void*)&i_dom_element_set_attribute, (void*)&ifa_dom_element_set_attribute, 3, 0, 0x0000000000000000LL);
CallInfo ci_iterator_to_array((void*)&i_iterator_to_array, (void*)&ifa_iterator_to_array, 2, 0, 0x0000000000000000LL);
CallInfo ci_iconv_get_encoding((void*)&i_iconv_get_encoding, (void*)&ifa_iconv_get_encoding, 1, 0, 0x0000000000000000LL);
CallInfo ci_getmyinode((void*)&i_getmyinode, (void*)&ifa_getmyinode, 0, 0, 0x0000000000000000LL);
CallInfo ci_gzgetc((void*)&i_gzgetc, (void*)&ifa_gzgetc, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_set_static_property((void*)&i_hphp_set_static_property, (void*)&ifa_hphp_set_static_property, 3, 0, 0x0000000000000000LL);
CallInfo ci_unlink((void*)&i_unlink, (void*)&ifa_unlink, 2, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_module_open((void*)&i_mcrypt_module_open, (void*)&ifa_mcrypt_module_open, 4, 0, 0x0000000000000000LL);
CallInfo ci_token_get_all((void*)&i_token_get_all, (void*)&ifa_token_get_all, 1, 0, 0x0000000000000000LL);
CallInfo ci_base_convert((void*)&i_base_convert, (void*)&ifa_base_convert, 3, 0, 0x0000000000000000LL);
CallInfo ci_gethostbynamel((void*)&i_gethostbynamel, (void*)&ifa_gethostbynamel, 1, 0, 0x0000000000000000LL);
CallInfo ci_var_dump((void*)&i_var_dump, (void*)&ifa_var_dump, 1, 1, 0x0000000000000000LL);
CallInfo ci_xmlwriter_start_attribute((void*)&i_xmlwriter_start_attribute, (void*)&ifa_xmlwriter_start_attribute, 2, 0, 0x0000000000000000LL);
CallInfo ci_pack((void*)&i_pack, (void*)&ifa_pack, 1, 1, 0x0000000000000000LL);
CallInfo ci_gzgets((void*)&i_gzgets, (void*)&ifa_gzgets, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_intersect_uassoc((void*)&i_array_intersect_uassoc, (void*)&ifa_array_intersect_uassoc, 3, 1, 0x0000000000000000LL);
CallInfo ci_basename((void*)&i_basename, (void*)&ifa_basename, 2, 0, 0x0000000000000000LL);
CallInfo ci_krsort((void*)&i_krsort, (void*)&ifa_krsort, 2, 0, 0x0000000000000001LL);
CallInfo ci_clock_gettime((void*)&i_clock_gettime, (void*)&ifa_clock_gettime, 3, 0, 0x0000000000000006LL);
CallInfo ci_pushdrawingwand((void*)&i_pushdrawingwand, (void*)&ifa_pushdrawingwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_imageline((void*)&i_imageline, (void*)&ifa_imageline, 6, 0, 0x0000000000000000LL);
CallInfo ci_socket_read((void*)&i_socket_read, (void*)&ifa_socket_read, 3, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_dtd_entity((void*)&i_xmlwriter_write_dtd_entity, (void*)&ifa_xmlwriter_write_dtd_entity, 7, 0, 0x0000000000000000LL);
CallInfo ci_mysql_tablename((void*)&i_mysql_tablename, (void*)&ifa_mysql_tablename, 2, 0, 0x0000000000000000LL);
CallInfo ci_collator_sort((void*)&i_collator_sort, (void*)&ifa_collator_sort, 3, 0, 0x0000000000000002LL);
CallInfo ci_magickwriteimage((void*)&i_magickwriteimage, (void*)&ifa_magickwriteimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_module_get_algo_key_size((void*)&i_mcrypt_module_get_algo_key_size, (void*)&ifa_mcrypt_module_get_algo_key_size, 2, 0, 0x0000000000000000LL);
CallInfo ci_hash_update_file((void*)&i_hash_update_file, (void*)&ifa_hash_update_file, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickembossimage((void*)&i_magickembossimage, (void*)&ifa_magickembossimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_forward_static_call((void*)&i_forward_static_call, (void*)&ifa_forward_static_call, 1, 2, 0x0000000000000000LL);
CallInfo ci_gzencode((void*)&i_gzencode, (void*)&ifa_gzencode, 3, 0, 0x0000000000000000LL);
CallInfo ci_checkdate((void*)&i_checkdate, (void*)&ifa_checkdate, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickimplodeimage((void*)&i_magickimplodeimage, (void*)&ifa_magickimplodeimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageindex((void*)&i_magickgetimageindex, (void*)&ifa_magickgetimageindex, 1, 0, 0x0000000000000000LL);
CallInfo ci_ctype_lower((void*)&i_ctype_lower, (void*)&ifa_ctype_lower, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagepsloadfont((void*)&i_imagepsloadfont, (void*)&ifa_imagepsloadfont, 1, 0, 0x0000000000000000LL);
CallInfo ci_iconv_mime_decode((void*)&i_iconv_mime_decode, (void*)&ifa_iconv_mime_decode, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursiveiteratoriterator_key((void*)&i_hphp_recursiveiteratoriterator_key, (void*)&ifa_hphp_recursiveiteratoriterator_key, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_module_is_block_algorithm((void*)&i_mcrypt_module_is_block_algorithm, (void*)&ifa_mcrypt_module_is_block_algorithm, 2, 0, 0x0000000000000000LL);
CallInfo ci_wandgetexception((void*)&i_wandgetexception, (void*)&ifa_wandgetexception, 1, 0, 0x0000000000000000LL);
CallInfo ci_fsockopen((void*)&i_fsockopen, (void*)&ifa_fsockopen, 5, 0, 0x000000000000000CLL);
CallInfo ci_usort((void*)&i_usort, (void*)&ifa_usort, 2, 0, 0x0000000000000001LL);
CallInfo ci_pixelsetiteratorrow((void*)&i_pixelsetiteratorrow, (void*)&ifa_pixelsetiteratorrow, 2, 0, 0x0000000000000000LL);
CallInfo ci_call_user_func_serialized((void*)&i_call_user_func_serialized, (void*)&ifa_call_user_func_serialized, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_iswritable((void*)&i_hphp_splfileinfo_iswritable, (void*)&ifa_hphp_splfileinfo_iswritable, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_create_attribute((void*)&i_dom_document_create_attribute, (void*)&ifa_dom_document_create_attribute, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_get_option((void*)&i_ldap_get_option, (void*)&ifa_ldap_get_option, 3, 0, 0x0000000000000004LL);
CallInfo ci_socket_recv((void*)&i_socket_recv, (void*)&ifa_socket_recv, 4, 0, 0x0000000000000002LL);
CallInfo ci_sys_getloadavg((void*)&i_sys_getloadavg, (void*)&ifa_sys_getloadavg, 0, 0, 0x0000000000000000LL);
CallInfo ci_evhttp_async_post((void*)&i_evhttp_async_post, (void*)&ifa_evhttp_async_post, 4, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursivedirectoryiterator_seek((void*)&i_hphp_recursivedirectoryiterator_seek, (void*)&ifa_hphp_recursivedirectoryiterator_seek, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_values((void*)&i_array_values, (void*)&ifa_array_values, 1, 0, 0x0000000000000000LL);
CallInfo ci_ctype_digit((void*)&i_ctype_digit, (void*)&ifa_ctype_digit, 1, 0, 0x0000000000000000LL);
CallInfo ci_ob_get_length((void*)&i_ob_get_length, (void*)&ifa_ob_get_length, 0, 0, 0x0000000000000000LL);
CallInfo ci_magicksolarizeimage((void*)&i_magicksolarizeimage, (void*)&ifa_magicksolarizeimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_ob_list_handlers((void*)&i_ob_list_handlers, (void*)&ifa_ob_list_handlers, 0, 0, 0x0000000000000000LL);
CallInfo ci_array_uintersect_assoc((void*)&i_array_uintersect_assoc, (void*)&ifa_array_uintersect_assoc, 3, 1, 0x0000000000000000LL);
CallInfo ci_openssl_x509_read((void*)&i_openssl_x509_read, (void*)&ifa_openssl_x509_read, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagecolormapcolor((void*)&i_magickgetimagecolormapcolor, (void*)&ifa_magickgetimagecolormapcolor, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_getcvscontrol((void*)&i_hphp_splfileobject_getcvscontrol, (void*)&ifa_hphp_splfileobject_getcvscontrol, 1, 0, 0x0000000000000000LL);
CallInfo ci_settype((void*)&i_settype, (void*)&ifa_settype, 2, 0, 0x0000000000000001LL);
CallInfo ci_posix_access((void*)&i_posix_access, (void*)&ifa_posix_access, 2, 0, 0x0000000000000000LL);
CallInfo ci_explode((void*)&i_explode, (void*)&ifa_explode, 3, 0, 0x0000000000000000LL);
CallInfo ci_fb_load_local_databases((void*)&i_fb_load_local_databases, (void*)&ifa_fb_load_local_databases, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecreatefromgd((void*)&i_imagecreatefromgd, (void*)&ifa_imagecreatefromgd, 1, 0, 0x0000000000000000LL);
CallInfo ci_proc_close((void*)&i_proc_close, (void*)&ifa_proc_close, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgaussianblurimage((void*)&i_magickgaussianblurimage, (void*)&ifa_magickgaussianblurimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_apd_set_session_trace_socket((void*)&i_apd_set_session_trace_socket, (void*)&ifa_apd_set_session_trace_socket, 4, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkcs12_export_to_file((void*)&i_openssl_pkcs12_export_to_file, (void*)&ifa_openssl_pkcs12_export_to_file, 5, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_msg_free((void*)&i_mailparse_msg_free, (void*)&ifa_mailparse_msg_free, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_private_decrypt((void*)&i_openssl_private_decrypt, (void*)&ifa_openssl_private_decrypt, 4, 0, 0x0000000000000002LL);
CallInfo ci_dom_document_save((void*)&i_dom_document_save, (void*)&ifa_dom_document_save, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_get_extension_info((void*)&i_hphp_get_extension_info, (void*)&ifa_hphp_get_extension_info, 1, 0, 0x0000000000000000LL);
CallInfo ci_output_add_rewrite_var((void*)&i_output_add_rewrite_var, (void*)&ifa_output_add_rewrite_var, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_cdata((void*)&i_xmlwriter_write_cdata, (void*)&ifa_xmlwriter_write_cdata, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_list_mime_names((void*)&i_mb_list_mime_names, (void*)&ifa_mb_list_mime_names, 1, 0, 0x0000000000000000LL);
CallInfo ci_ispixelwand((void*)&i_ispixelwand, (void*)&ifa_ispixelwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_end_dtd((void*)&i_xmlwriter_end_dtd, (void*)&ifa_xmlwriter_end_dtd, 1, 0, 0x0000000000000000LL);
CallInfo ci_curl_close((void*)&i_curl_close, (void*)&ifa_curl_close, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_udiff((void*)&i_array_udiff, (void*)&ifa_array_udiff, 3, 1, 0x0000000000000000LL);
CallInfo ci_session_cache_limiter((void*)&i_session_cache_limiter, (void*)&ifa_session_cache_limiter, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_context_create((void*)&i_stream_context_create, (void*)&ifa_stream_context_create, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawgetstrokedashoffset((void*)&i_drawgetstrokedashoffset, (void*)&ifa_drawgetstrokedashoffset, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkey_get_public((void*)&i_openssl_pkey_get_public, (void*)&ifa_openssl_pkey_get_public, 1, 0, 0x0000000000000000LL);
CallInfo ci_interface_exists((void*)&i_interface_exists, (void*)&ifa_interface_exists, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_directoryiterator___construct((void*)&i_hphp_directoryiterator___construct, (void*)&ifa_hphp_directoryiterator___construct, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawpathmovetorelative((void*)&i_drawpathmovetorelative, (void*)&ifa_drawpathmovetorelative, 3, 0, 0x0000000000000000LL);
CallInfo ci_apache_get_config((void*)&i_apache_get_config, (void*)&ifa_apache_get_config, 0, 0, 0x0000000000000000LL);
CallInfo ci_curl_copy_handle((void*)&i_curl_copy_handle, (void*)&ifa_curl_copy_handle, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawgetvectorgraphics((void*)&i_drawgetvectorgraphics, (void*)&ifa_drawgetvectorgraphics, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawpathfinish((void*)&i_drawpathfinish, (void*)&ifa_drawpathfinish, 1, 0, 0x0000000000000000LL);
CallInfo ci_png2wbmp((void*)&i_png2wbmp, (void*)&ifa_png2wbmp, 5, 0, 0x0000000000000000LL);
CallInfo ci_drawmatte((void*)&i_drawmatte, (void*)&ifa_drawmatte, 4, 0, 0x0000000000000000LL);
CallInfo ci_imagecolormatch((void*)&i_imagecolormatch, (void*)&ifa_imagecolormatch, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawrectangle((void*)&i_drawrectangle, (void*)&ifa_drawrectangle, 5, 0, 0x0000000000000000LL);
CallInfo ci_fb_parallel_query((void*)&i_fb_parallel_query, (void*)&ifa_fb_parallel_query, 7, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_create_entity_reference((void*)&i_dom_document_create_entity_reference, (void*)&ifa_dom_document_create_entity_reference, 2, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_enc_get_block_size((void*)&i_mcrypt_enc_get_block_size, (void*)&ifa_mcrypt_enc_get_block_size, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_context_set_option((void*)&i_stream_context_set_option, (void*)&ifa_stream_context_set_option, 4, 0, 0x0000000000000000LL);
CallInfo ci_drawpathcurvetorelative((void*)&i_drawpathcurvetorelative, (void*)&ifa_drawpathcurvetorelative, 7, 0, 0x0000000000000000LL);
CallInfo ci_phpcredits((void*)&i_phpcredits, (void*)&ifa_phpcredits, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawgetfillrule((void*)&i_drawgetfillrule, (void*)&ifa_drawgetfillrule, 1, 0, 0x0000000000000000LL);
CallInfo ci_parse_hdf_string((void*)&i_parse_hdf_string, (void*)&ifa_parse_hdf_string, 1, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_end_cdata((void*)&i_xmlwriter_end_cdata, (void*)&ifa_xmlwriter_end_cdata, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetversionstring((void*)&i_magickgetversionstring, (void*)&ifa_magickgetversionstring, 0, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_fork((void*)&i_pcntl_fork, (void*)&ifa_pcntl_fork, 0, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_normalize((void*)&i_dom_node_normalize, (void*)&ifa_dom_node_normalize, 1, 0, 0x0000000000000000LL);
CallInfo ci_doubleval((void*)&i_doubleval, (void*)&ifa_doubleval, 1, 0, 0x0000000000000000LL);
CallInfo ci_assert_options((void*)&i_assert_options, (void*)&ifa_assert_options, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickhasnextimage((void*)&i_magickhasnextimage, (void*)&ifa_magickhasnextimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_rmdir((void*)&i_rmdir, (void*)&ifa_rmdir, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawgetstrokelinecap((void*)&i_drawgetstrokelinecap, (void*)&ifa_drawgetstrokelinecap, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_clear_unflushed((void*)&i_hphp_clear_unflushed, (void*)&ifa_hphp_clear_unflushed, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickscaleimage((void*)&i_magickscaleimage, (void*)&ifa_magickscaleimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetblackquantum((void*)&i_pixelgetblackquantum, (void*)&ifa_pixelgetblackquantum, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicknewimage((void*)&i_magicknewimage, (void*)&ifa_magicknewimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_destroypixelwands((void*)&i_destroypixelwands, (void*)&ifa_destroypixelwands, 1, 0, 0x0000000000000000LL);
CallInfo ci_shm_remove((void*)&i_shm_remove, (void*)&ifa_shm_remove, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_setflags((void*)&i_hphp_splfileobject_setflags, (void*)&ifa_hphp_splfileobject_setflags, 2, 0, 0x0000000000000000LL);
CallInfo ci_date_sun_info((void*)&i_date_sun_info, (void*)&ifa_date_sun_info, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_directoryiterator_valid((void*)&i_hphp_directoryiterator_valid, (void*)&ifa_hphp_directoryiterator_valid, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickresizeimage((void*)&i_magickresizeimage, (void*)&ifa_magickresizeimage, 5, 0, 0x0000000000000000LL);
CallInfo ci_parse_ini_file((void*)&i_parse_ini_file, (void*)&ifa_parse_ini_file, 3, 0, 0x0000000000000000LL);
CallInfo ci_stream_get_meta_data((void*)&i_stream_get_meta_data, (void*)&ifa_stream_get_meta_data, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagepsencodefont((void*)&i_imagepsencodefont, (void*)&ifa_imagepsencodefont, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_set_option((void*)&i_ldap_set_option, (void*)&ifa_ldap_set_option, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickgetsize((void*)&i_magickgetsize, (void*)&ifa_magickgetsize, 1, 0, 0x0000000000000000LL);
CallInfo ci_memory_get_peak_usage((void*)&i_memory_get_peak_usage, (void*)&ifa_memory_get_peak_usage, 1, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_exec((void*)&i_pcntl_exec, (void*)&ifa_pcntl_exec, 3, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_set_indent_string((void*)&i_xmlwriter_set_indent_string, (void*)&ifa_xmlwriter_set_indent_string, 2, 0, 0x0000000000000000LL);
CallInfo ci_php_strip_whitespace((void*)&i_php_strip_whitespace, (void*)&ifa_php_strip_whitespace, 1, 0, 0x0000000000000000LL);
CallInfo ci_strcoll((void*)&i_strcoll, (void*)&ifa_strcoll, 2, 0, 0x0000000000000000LL);
CallInfo ci_write_hdf_file((void*)&i_write_hdf_file, (void*)&ifa_write_hdf_file, 2, 0, 0x0000000000000000LL);
CallInfo ci_socket_send((void*)&i_socket_send, (void*)&ifa_socket_send, 4, 0, 0x0000000000000000LL);
CallInfo ci_zlib_get_coding_type((void*)&i_zlib_get_coding_type, (void*)&ifa_zlib_get_coding_type, 0, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_fscanf((void*)&i_hphp_splfileobject_fscanf, (void*)&ifa_hphp_splfileobject_fscanf, 4, 0, 0x0000000000000000LL);
CallInfo ci_mb_ereg_search_getregs((void*)&i_mb_ereg_search_getregs, (void*)&ifa_mb_ereg_search_getregs, 0, 0, 0x0000000000000000LL);
CallInfo ci_mb_eregi((void*)&i_mb_eregi, (void*)&ifa_mb_eregi, 3, 0, 0x0000000000000004LL);
CallInfo ci_pixelgetgreen((void*)&i_pixelgetgreen, (void*)&ifa_pixelgetgreen, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_client_encoding((void*)&i_mysql_client_encoding, (void*)&ifa_mysql_client_encoding, 1, 0, 0x0000000000000000LL);
CallInfo ci_zend_thread_id((void*)&i_zend_thread_id, (void*)&ifa_zend_thread_id, 0, 0, 0x0000000000000000LL);
CallInfo ci_ldap_mod_replace((void*)&i_ldap_mod_replace, (void*)&ifa_ldap_mod_replace, 3, 0, 0x0000000000000000LL);
CallInfo ci_collator_get_error_code((void*)&i_collator_get_error_code, (void*)&ifa_collator_get_error_code, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_filter_prepend((void*)&i_stream_filter_prepend, (void*)&ifa_stream_filter_prepend, 4, 0, 0x0000000000000000LL);
CallInfo ci_substr((void*)&i_substr, (void*)&ifa_substr, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickcombineimages((void*)&i_magickcombineimages, (void*)&ifa_magickcombineimages, 2, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetexceptiontype((void*)&i_pixelgetexceptiontype, (void*)&ifa_pixelgetexceptiontype, 1, 0, 0x0000000000000000LL);
CallInfo ci_unpack((void*)&i_unpack, (void*)&ifa_unpack, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_isdir((void*)&i_hphp_splfileinfo_isdir, (void*)&ifa_hphp_splfileinfo_isdir, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagepixels((void*)&i_magickgetimagepixels, (void*)&ifa_magickgetimagepixels, 7, 0, 0x0000000000000000LL);
CallInfo ci_array_product((void*)&i_array_product, (void*)&ifa_array_product, 1, 0, 0x0000000000000000LL);
CallInfo ci_substr_replace((void*)&i_substr_replace, (void*)&ifa_substr_replace, 4, 0, 0x0000000000000000LL);
CallInfo ci_xbox_get_thread_time((void*)&i_xbox_get_thread_time, (void*)&ifa_xbox_get_thread_time, 0, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_dtd((void*)&i_xmlwriter_write_dtd, (void*)&ifa_xmlwriter_write_dtd, 5, 0, 0x0000000000000000LL);
CallInfo ci_mysql_select_db((void*)&i_mysql_select_db, (void*)&ifa_mysql_select_db, 2, 0, 0x0000000000000000LL);
CallInfo ci_fb_get_taint((void*)&i_fb_get_taint, (void*)&ifa_fb_get_taint, 1, 0, 0x0000000000000000LL);
CallInfo ci_use_soap_error_handler((void*)&i_use_soap_error_handler, (void*)&ifa_use_soap_error_handler, 1, 0, 0x0000000000000000LL);
CallInfo ci_debug_backtrace((void*)&i_debug_backtrace, (void*)&ifa_debug_backtrace, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawpathcurvetosmoothrelative((void*)&i_drawpathcurvetosmoothrelative, (void*)&ifa_drawpathcurvetosmoothrelative, 5, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_determine_best_xfer_encoding((void*)&i_mailparse_determine_best_xfer_encoding, (void*)&ifa_mailparse_determine_best_xfer_encoding, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagettfbbox((void*)&i_imagettfbbox, (void*)&ifa_imagettfbbox, 4, 0, 0x0000000000000000LL);
CallInfo ci_mb_internal_encoding((void*)&i_mb_internal_encoding, (void*)&ifa_mb_internal_encoding, 1, 0, 0x0000000000000000LL);
CallInfo ci_msg_get_queue((void*)&i_msg_get_queue, (void*)&ifa_msg_get_queue, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_getegid((void*)&i_posix_getegid, (void*)&ifa_posix_getegid, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickmedianfilterimage((void*)&i_magickmedianfilterimage, (void*)&ifa_magickmedianfilterimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_xbox_task_result((void*)&i_xbox_task_result, (void*)&ifa_xbox_task_result, 3, 0, 0x0000000000000004LL);
CallInfo ci_mcrypt_generic_deinit((void*)&i_mcrypt_generic_deinit, (void*)&ifa_mcrypt_generic_deinit, 1, 0, 0x0000000000000000LL);
CallInfo ci_method_exists((void*)&i_method_exists, (void*)&ifa_method_exists, 2, 0, 0x0000000000000000LL);
CallInfo ci_money_format((void*)&i_money_format, (void*)&ifa_money_format, 2, 0, 0x0000000000000000LL);
CallInfo ci_clearmagickwand((void*)&i_clearmagickwand, (void*)&ifa_clearmagickwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_remove_attribute_node((void*)&i_dom_element_remove_attribute_node, (void*)&ifa_dom_element_remove_attribute_node, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_udiff_assoc((void*)&i_array_udiff_assoc, (void*)&ifa_array_udiff_assoc, 3, 1, 0x0000000000000000LL);
CallInfo ci_xml_parser_free((void*)&i_xml_parser_free, (void*)&ifa_xml_parser_free, 1, 0, 0x0000000000000000LL);
CallInfo ci_is_resource((void*)&i_is_resource, (void*)&ifa_is_resource, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getsize((void*)&i_hphp_splfileinfo_getsize, (void*)&ifa_hphp_splfileinfo_getsize, 1, 0, 0x0000000000000000LL);
CallInfo ci_posix_seteuid((void*)&i_posix_seteuid, (void*)&ifa_posix_seteuid, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetinterlacescheme((void*)&i_magicksetinterlacescheme, (void*)&ifa_magicksetinterlacescheme, 2, 0, 0x0000000000000000LL);
CallInfo ci_str_shuffle((void*)&i_str_shuffle, (void*)&ifa_str_shuffle, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_enc_is_block_algorithm((void*)&i_mcrypt_enc_is_block_algorithm, (void*)&ifa_mcrypt_enc_is_block_algorithm, 1, 0, 0x0000000000000000LL);
CallInfo ci_call_user_func_array_rpc((void*)&i_call_user_func_array_rpc, (void*)&ifa_call_user_func_array_rpc, 6, 0, 0x0000000000000000LL);
CallInfo ci_fb_serialize((void*)&i_fb_serialize, (void*)&ifa_fb_serialize, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetcopyright((void*)&i_magickgetcopyright, (void*)&ifa_magickgetcopyright, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickstripimage((void*)&i_magickstripimage, (void*)&ifa_magickstripimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_base64_decode((void*)&i_base64_decode, (void*)&ifa_base64_decode, 2, 0, 0x0000000000000000LL);
CallInfo ci_rand((void*)&i_rand, (void*)&ifa_rand, 2, 0, 0x0000000000000000LL);
CallInfo ci_crc32((void*)&i_crc32, (void*)&ifa_crc32, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_encoding((void*)&i_stream_encoding, (void*)&ifa_stream_encoding, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawgetstrokedasharray((void*)&i_drawgetstrokedasharray, (void*)&ifa_drawgetstrokedasharray, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagedispose((void*)&i_magickgetimagedispose, (void*)&ifa_magickgetimagedispose, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawpopdefs((void*)&i_drawpopdefs, (void*)&ifa_drawpopdefs, 1, 0, 0x0000000000000000LL);
CallInfo ci_xml_parser_create((void*)&i_xml_parser_create, (void*)&ifa_xml_parser_create, 1, 0, 0x0000000000000000LL);
CallInfo ci_session_save_path((void*)&i_session_save_path, (void*)&ifa_session_save_path, 1, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_wifsignaled((void*)&i_pcntl_wifsignaled, (void*)&ifa_pcntl_wifsignaled, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkcs7_encrypt((void*)&i_openssl_pkcs7_encrypt, (void*)&ifa_openssl_pkcs7_encrypt, 6, 0, 0x0000000000000000LL);
CallInfo ci_read_exif_data((void*)&i_read_exif_data, (void*)&ifa_read_exif_data, 4, 0, 0x0000000000000000LL);
CallInfo ci_drawsetstrokeopacity((void*)&i_drawsetstrokeopacity, (void*)&ifa_drawsetstrokeopacity, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawroundrectangle((void*)&i_drawroundrectangle, (void*)&ifa_drawroundrectangle, 7, 0, 0x0000000000000000LL);
CallInfo ci_hphp_directoryiterator_isdot((void*)&i_hphp_directoryiterator_isdot, (void*)&ifa_hphp_directoryiterator_isdot, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawgetstrokewidth((void*)&i_drawgetstrokewidth, (void*)&ifa_drawgetstrokewidth, 1, 0, 0x0000000000000000LL);
CallInfo ci_date_create((void*)&i_date_create, (void*)&ifa_date_create, 2, 0, 0x0000000000000000LL);
CallInfo ci_strcspn((void*)&i_strcspn, (void*)&ifa_strcspn, 4, 0, 0x0000000000000000LL);
CallInfo ci_drawgetclipunits((void*)&i_drawgetclipunits, (void*)&ifa_drawgetclipunits, 1, 0, 0x0000000000000000LL);
CallInfo ci_sem_acquire((void*)&i_sem_acquire, (void*)&ifa_sem_acquire, 1, 0, 0x0000000000000000LL);
CallInfo ci_socket_strerror((void*)&i_socket_strerror, (void*)&ifa_socket_strerror, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetstringheight((void*)&i_magickgetstringheight, (void*)&ifa_magickgetstringheight, 4, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_relaxng_validate_xml((void*)&i_dom_document_relaxng_validate_xml, (void*)&ifa_dom_document_relaxng_validate_xml, 2, 0, 0x0000000000000000LL);
CallInfo ci_rawurlencode((void*)&i_rawurlencode, (void*)&ifa_rawurlencode, 1, 0, 0x0000000000000000LL);
CallInfo ci_strtotime((void*)&i_strtotime, (void*)&ifa_strtotime, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_set_id_attribute((void*)&i_dom_element_set_id_attribute, (void*)&ifa_dom_element_set_id_attribute, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursivedirectoryiterator_getsubpath((void*)&i_hphp_recursivedirectoryiterator_getsubpath, (void*)&ifa_hphp_recursivedirectoryiterator_getsubpath, 1, 0, 0x0000000000000000LL);
CallInfo ci_apc_clear_cache((void*)&i_apc_clear_cache, (void*)&ifa_apc_clear_cache, 1, 0, 0x0000000000000000LL);
CallInfo ci_dirname((void*)&i_dirname, (void*)&ifa_dirname, 1, 0, 0x0000000000000000LL);
CallInfo ci_strnatcasecmp((void*)&i_strnatcasecmp, (void*)&ifa_strnatcasecmp, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicksetsamplingfactors((void*)&i_magicksetsamplingfactors, (void*)&ifa_magicksetsamplingfactors, 3, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkey_get_private((void*)&i_openssl_pkey_get_private, (void*)&ifa_openssl_pkey_get_private, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickaverageimages((void*)&i_magickaverageimages, (void*)&ifa_magickaverageimages, 1, 0, 0x0000000000000000LL);
CallInfo ci_iconv_strrpos((void*)&i_iconv_strrpos, (void*)&ifa_iconv_strrpos, 3, 0, 0x0000000000000000LL);
CallInfo ci_collator_get_locale((void*)&i_collator_get_locale, (void*)&ifa_collator_get_locale, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawsetviewbox((void*)&i_drawsetviewbox, (void*)&ifa_drawsetviewbox, 5, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagecompressionquality((void*)&i_magicksetimagecompressionquality, (void*)&ifa_magicksetimagecompressionquality, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_ping((void*)&i_mysql_ping, (void*)&ifa_mysql_ping, 1, 0, 0x0000000000000000LL);
CallInfo ci_xml_get_current_byte_index((void*)&i_xml_get_current_byte_index, (void*)&ifa_xml_get_current_byte_index, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicktransformimage((void*)&i_magicktransformimage, (void*)&ifa_magicktransformimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawgetstrokeantialias((void*)&i_drawgetstrokeantialias, (void*)&ifa_drawgetstrokeantialias, 1, 0, 0x0000000000000000LL);
CallInfo ci_ini_alter((void*)&i_ini_alter, (void*)&ifa_ini_alter, 2, 0, 0x0000000000000000LL);
CallInfo ci_get_class((void*)&i_get_class, (void*)&ifa_get_class, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimageprofile((void*)&i_magicksetimageprofile, (void*)&ifa_magicksetimageprofile, 3, 0, 0x0000000000000000LL);
CallInfo ci_mysql_field_seek((void*)&i_mysql_field_seek, (void*)&ifa_mysql_field_seek, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawgetfontsize((void*)&i_drawgetfontsize, (void*)&ifa_drawgetfontsize, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_num_rows((void*)&i_mysql_num_rows, (void*)&ifa_mysql_num_rows, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursiveiteratoriterator_rewind((void*)&i_hphp_recursiveiteratoriterator_rewind, (void*)&ifa_hphp_recursiveiteratoriterator_rewind, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageresolution((void*)&i_magickgetimageresolution, (void*)&ifa_magickgetimageresolution, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_diff((void*)&i_array_diff, (void*)&ifa_array_diff, 2, 1, 0x0000000000000000LL);
CallInfo ci_xmlwriter_open_uri((void*)&i_xmlwriter_open_uri, (void*)&ifa_xmlwriter_open_uri, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagetype((void*)&i_magickgetimagetype, (void*)&ifa_magickgetimagetype, 1, 0, 0x0000000000000000LL);
CallInfo ci_simplexml_load_string((void*)&i_simplexml_load_string, (void*)&ifa_simplexml_load_string, 5, 0, 0x0000000000000000LL);
CallInfo ci_magickunsharpmaskimage((void*)&i_magickunsharpmaskimage, (void*)&ifa_magickunsharpmaskimage, 6, 0, 0x0000000000000000LL);
CallInfo ci_quoted_printable_encode((void*)&i_quoted_printable_encode, (void*)&ifa_quoted_printable_encode, 1, 0, 0x0000000000000000LL);
CallInfo ci_gettype((void*)&i_gettype, (void*)&ifa_gettype, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagebackgroundcolor((void*)&i_magickgetimagebackgroundcolor, (void*)&ifa_magickgetimagebackgroundcolor, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_setmaxlinelen((void*)&i_hphp_splfileobject_setmaxlinelen, (void*)&ifa_hphp_splfileobject_setmaxlinelen, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_intersect_key((void*)&i_array_intersect_key, (void*)&ifa_array_intersect_key, 2, 1, 0x0000000000000000LL);
CallInfo ci_array_change_key_case((void*)&i_array_change_key_case, (void*)&ifa_array_change_key_case, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_first_attribute((void*)&i_ldap_first_attribute, (void*)&ifa_ldap_first_attribute, 2, 0, 0x0000000000000000LL);
CallInfo ci_gettimeofday((void*)&i_gettimeofday, (void*)&ifa_gettimeofday, 1, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_end_element((void*)&i_xmlwriter_end_element, (void*)&ifa_xmlwriter_end_element, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawpoint((void*)&i_drawpoint, (void*)&ifa_drawpoint, 3, 0, 0x0000000000000000LL);
CallInfo ci_strnatcmp((void*)&i_strnatcmp, (void*)&ifa_strnatcmp, 2, 0, 0x0000000000000000LL);
CallInfo ci_property_exists((void*)&i_property_exists, (void*)&ifa_property_exists, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_affected_rows((void*)&i_mysql_affected_rows, (void*)&ifa_mysql_affected_rows, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickdespeckleimage((void*)&i_magickdespeckleimage, (void*)&ifa_magickdespeckleimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecopymergegray((void*)&i_imagecopymergegray, (void*)&ifa_imagecopymergegray, 9, 0, 0x0000000000000000LL);
CallInfo ci_ctype_cntrl((void*)&i_ctype_cntrl, (void*)&ifa_ctype_cntrl, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_next((void*)&i_hphp_splfileobject_next, (void*)&ifa_hphp_splfileobject_next, 1, 0, 0x0000000000000000LL);
CallInfo ci_is_array((void*)&i_is_array, (void*)&ifa_is_array, 1, 0, 0x0000000000000000LL);
CallInfo ci_rename((void*)&i_rename, (void*)&ifa_rename, 3, 0, 0x0000000000000000LL);
CallInfo ci_date_format((void*)&i_date_format, (void*)&ifa_date_format, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_fgetc((void*)&i_hphp_splfileobject_fgetc, (void*)&ifa_hphp_splfileobject_fgetc, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickshaveimage((void*)&i_magickshaveimage, (void*)&ifa_magickshaveimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_set_attribute_node_ns((void*)&i_dom_element_set_attribute_node_ns, (void*)&ifa_dom_element_set_attribute_node_ns, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_output_memory((void*)&i_xmlwriter_output_memory, (void*)&ifa_xmlwriter_output_memory, 2, 0, 0x0000000000000000LL);
CallInfo ci_ob_end_flush((void*)&i_ob_end_flush, (void*)&ifa_ob_end_flush, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickwhitethresholdimage((void*)&i_magickwhitethresholdimage, (void*)&ifa_magickwhitethresholdimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawpolyline((void*)&i_drawpolyline, (void*)&ifa_drawpolyline, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_fgets((void*)&i_hphp_splfileobject_fgets, (void*)&ifa_hphp_splfileobject_fgets, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_get_function_info((void*)&i_hphp_get_function_info, (void*)&ifa_hphp_get_function_info, 1, 0, 0x0000000000000000LL);
CallInfo ci_prev((void*)&i_prev, (void*)&ifa_prev, 1, 0, 0x0000000000000001LL);
CallInfo ci_imagegammacorrect((void*)&i_imagegammacorrect, (void*)&ifa_imagegammacorrect, 3, 0, 0x0000000000000000LL);
CallInfo ci_str_replace((void*)&i_str_replace, (void*)&ifa_str_replace, 4, 0, 0x0000000000000008LL);
CallInfo ci_dom_node_lookup_namespace_uri((void*)&i_dom_node_lookup_namespace_uri, (void*)&ifa_dom_node_lookup_namespace_uri, 2, 0, 0x0000000000000000LL);
CallInfo ci_fb_unserialize((void*)&i_fb_unserialize, (void*)&ifa_fb_unserialize, 3, 0, 0x0000000000000006LL);
CallInfo ci_clock_getres((void*)&i_clock_getres, (void*)&ifa_clock_getres, 3, 0, 0x0000000000000006LL);
CallInfo ci_magicktrimimage((void*)&i_magicktrimimage, (void*)&ifa_magicktrimimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getpathinfo((void*)&i_hphp_splfileinfo_getpathinfo, (void*)&ifa_hphp_splfileinfo_getpathinfo, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagegamma((void*)&i_magickgetimagegamma, (void*)&ifa_magickgetimagegamma, 1, 0, 0x0000000000000000LL);
CallInfo ci_newdrawingwand((void*)&i_newdrawingwand, (void*)&ifa_newdrawingwand, 0, 0, 0x0000000000000000LL);
CallInfo ci_gzrewind((void*)&i_gzrewind, (void*)&ifa_gzrewind, 1, 0, 0x0000000000000000LL);
CallInfo ci_ldap_explode_dn((void*)&i_ldap_explode_dn, (void*)&ifa_ldap_explode_dn, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_times((void*)&i_posix_times, (void*)&ifa_posix_times, 0, 0, 0x0000000000000000LL);
CallInfo ci_drawgetfillcolor((void*)&i_drawgetfillcolor, (void*)&ifa_drawgetfillcolor, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_save_html((void*)&i_dom_document_save_html, (void*)&ifa_dom_document_save_html, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_strtolower((void*)&i_mb_strtolower, (void*)&ifa_mb_strtolower, 2, 0, 0x0000000000000000LL);
CallInfo ci_localtime((void*)&i_localtime, (void*)&ifa_localtime, 2, 0, 0x0000000000000000LL);
CallInfo ci_fb_thrift_unserialize((void*)&i_fb_thrift_unserialize, (void*)&ifa_fb_thrift_unserialize, 3, 0, 0x0000000000000006LL);
CallInfo ci_sha1((void*)&i_sha1, (void*)&ifa_sha1, 2, 0, 0x0000000000000000LL);
CallInfo ci_collator_set_strength((void*)&i_collator_set_strength, (void*)&ifa_collator_set_strength, 2, 0, 0x0000000000000000LL);
CallInfo ci_implode((void*)&i_implode, (void*)&ifa_implode, 2, 0, 0x0000000000000000LL);
CallInfo ci_date_isodate_set((void*)&i_date_isodate_set, (void*)&ifa_date_isodate_set, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickpaintopaqueimage((void*)&i_magickpaintopaqueimage, (void*)&ifa_magickpaintopaqueimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_mb_strimwidth((void*)&i_mb_strimwidth, (void*)&ifa_mb_strimwidth, 5, 0, 0x0000000000000000LL);
CallInfo ci_drawsetfont((void*)&i_drawsetfont, (void*)&ifa_drawsetfont, 2, 0, 0x0000000000000000LL);
CallInfo ci_xml_set_default_handler((void*)&i_xml_set_default_handler, (void*)&ifa_xml_set_default_handler, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickchopimage((void*)&i_magickchopimage, (void*)&ifa_magickchopimage, 5, 0, 0x0000000000000000LL);
CallInfo ci_wordwrap((void*)&i_wordwrap, (void*)&ifa_wordwrap, 4, 0, 0x0000000000000000LL);
CallInfo ci_gzgetss((void*)&i_gzgetss, (void*)&ifa_gzgetss, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagevirtualpixelmethod((void*)&i_magickgetimagevirtualpixelmethod, (void*)&ifa_magickgetimagevirtualpixelmethod, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagedestroy((void*)&i_imagedestroy, (void*)&ifa_imagedestroy, 1, 0, 0x0000000000000000LL);
CallInfo ci_timezone_open((void*)&i_timezone_open, (void*)&ifa_timezone_open, 1, 0, 0x0000000000000000LL);
CallInfo ci_ob_clean((void*)&i_ob_clean, (void*)&ifa_ob_clean, 0, 0, 0x0000000000000000LL);
CallInfo ci_mb_ereg_search_pos((void*)&i_mb_ereg_search_pos, (void*)&ifa_mb_ereg_search_pos, 2, 0, 0x0000000000000000LL);
CallInfo ci_bccomp((void*)&i_bccomp, (void*)&ifa_bccomp, 3, 0, 0x0000000000000000LL);
CallInfo ci_gzdecode((void*)&i_gzdecode, (void*)&ifa_gzdecode, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagecompose((void*)&i_magicksetimagecompose, (void*)&ifa_magicksetimagecompose, 2, 0, 0x0000000000000000LL);
CallInfo ci_apc_bin_dump((void*)&i_apc_bin_dump, (void*)&ifa_apc_bin_dump, 2, 0, 0x0000000000000000LL);
CallInfo ci_ini_get((void*)&i_ini_get, (void*)&ifa_ini_get, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_ereg_search_setpos((void*)&i_mb_ereg_search_setpos, (void*)&ifa_mb_ereg_search_setpos, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_copy_to_stream((void*)&i_stream_copy_to_stream, (void*)&ifa_stream_copy_to_stream, 4, 0, 0x0000000000000000LL);
CallInfo ci_xml_get_error_code((void*)&i_xml_get_error_code, (void*)&ifa_xml_get_error_code, 1, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_alarm((void*)&i_pcntl_alarm, (void*)&ifa_pcntl_alarm, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawpolygon((void*)&i_drawpolygon, (void*)&ifa_drawpolygon, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_connect((void*)&i_mysql_connect, (void*)&ifa_mysql_connect, 7, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_raw((void*)&i_xmlwriter_write_raw, (void*)&ifa_xmlwriter_write_raw, 2, 0, 0x0000000000000000LL);
CallInfo ci_fgetss((void*)&i_fgetss, (void*)&ifa_fgetss, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawarc((void*)&i_drawarc, (void*)&ifa_drawarc, 7, 0, 0x0000000000000000LL);
CallInfo ci_set_error_handler((void*)&i_set_error_handler, (void*)&ifa_set_error_handler, 2, 0, 0x0000000000000000LL);
CallInfo ci_str_word_count((void*)&i_str_word_count, (void*)&ifa_str_word_count, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawsetcliprule((void*)&i_drawsetcliprule, (void*)&ifa_drawsetcliprule, 2, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkcs12_read((void*)&i_openssl_pkcs12_read, (void*)&ifa_openssl_pkcs12_read, 3, 0, 0x0000000000000002LL);
CallInfo ci_ldap_list((void*)&i_ldap_list, (void*)&ifa_ldap_list, 8, 0, 0x0000000000000000LL);
CallInfo ci_func_num_args((void*)&i_func_num_args, (void*)&ifa_func_num_args, 0, 0, 0x0000000000000000LL);
CallInfo ci_drawsettextdecoration((void*)&i_drawsettextdecoration, (void*)&ifa_drawsettextdecoration, 2, 0, 0x0000000000000000LL);
CallInfo ci_str_rot13((void*)&i_str_rot13, (void*)&ifa_str_rot13, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkey_new((void*)&i_openssl_pkey_new, (void*)&ifa_openssl_pkey_new, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimageindex((void*)&i_magicksetimageindex, (void*)&ifa_magicksetimageindex, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_rename((void*)&i_ldap_rename, (void*)&ifa_ldap_rename, 5, 0, 0x0000000000000000LL);
CallInfo ci_ldap_start_tls((void*)&i_ldap_start_tls, (void*)&ifa_ldap_start_tls, 1, 0, 0x0000000000000000LL);
CallInfo ci_tanh((void*)&i_tanh, (void*)&ifa_tanh, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawscale((void*)&i_drawscale, (void*)&ifa_drawscale, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawrotate((void*)&i_drawrotate, (void*)&ifa_drawrotate, 2, 0, 0x0000000000000000LL);
CallInfo ci_getservbyname((void*)&i_getservbyname, (void*)&ifa_getservbyname, 2, 0, 0x0000000000000000LL);
CallInfo ci_compact((void*)&i_compact, (void*)&ifa_compact, 1, 1, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_valid((void*)&i_hphp_splfileobject_valid, (void*)&ifa_hphp_splfileobject_valid, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorclosest((void*)&i_imagecolorclosest, (void*)&ifa_imagecolorclosest, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickwriteimages((void*)&i_magickwriteimages, (void*)&ifa_magickwriteimages, 3, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetalpha((void*)&i_pixelsetalpha, (void*)&ifa_pixelsetalpha, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimageiterations((void*)&i_magicksetimageiterations, (void*)&ifa_magicksetimageiterations, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawpathmovetoabsolute((void*)&i_drawpathmovetoabsolute, (void*)&ifa_drawpathmovetoabsolute, 3, 0, 0x0000000000000000LL);
CallInfo ci_quotemeta((void*)&i_quotemeta, (void*)&ifa_quotemeta, 1, 0, 0x0000000000000000LL);
CallInfo ci_parse_ini_string((void*)&i_parse_ini_string, (void*)&ifa_parse_ini_string, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagefilltoborder((void*)&i_imagefilltoborder, (void*)&ifa_imagefilltoborder, 5, 0, 0x0000000000000000LL);
CallInfo ci_xml_set_notation_decl_handler((void*)&i_xml_set_notation_decl_handler, (void*)&ifa_xml_set_notation_decl_handler, 2, 0, 0x0000000000000000LL);
CallInfo ci_is_writeable((void*)&i_is_writeable, (void*)&ifa_is_writeable, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetwandsize((void*)&i_magickgetwandsize, (void*)&ifa_magickgetwandsize, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_directoryiterator___tostring((void*)&i_hphp_directoryiterator___tostring, (void*)&ifa_hphp_directoryiterator___tostring, 1, 0, 0x0000000000000000LL);
CallInfo ci_memcache_add_server((void*)&i_memcache_add_server, (void*)&ifa_memcache_add_server, 10, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_remove_child((void*)&i_dom_node_remove_child, (void*)&ifa_dom_node_remove_child, 2, 0, 0x0000000000000000LL);
CallInfo ci_imageinterlace((void*)&i_imageinterlace, (void*)&ifa_imageinterlace, 2, 0, 0x0000000000000000LL);
CallInfo ci_preg_match_all((void*)&i_preg_match_all, (void*)&ifa_preg_match_all, 5, 0, 0x0000000000000004LL);
CallInfo ci_proc_terminate((void*)&i_proc_terminate, (void*)&ifa_proc_terminate, 2, 0, 0x0000000000000000LL);
CallInfo ci_apc_bin_loadfile((void*)&i_apc_bin_loadfile, (void*)&ifa_apc_bin_loadfile, 4, 0, 0x0000000000000000LL);
CallInfo ci_posix_getcwd((void*)&i_posix_getcwd, (void*)&ifa_posix_getcwd, 0, 0, 0x0000000000000000LL);
CallInfo ci_drawpathcurvetoabsolute((void*)&i_drawpathcurvetoabsolute, (void*)&ifa_drawpathcurvetoabsolute, 7, 0, 0x0000000000000000LL);
CallInfo ci_hphp_set_error_page((void*)&i_hphp_set_error_page, (void*)&ifa_hphp_set_error_page, 1, 0, 0x0000000000000000LL);
CallInfo ci_preg_match((void*)&i_preg_match, (void*)&ifa_preg_match, 5, 0, 0x0000000000000004LL);
CallInfo ci_timezone_abbreviations_list((void*)&i_timezone_abbreviations_list, (void*)&ifa_timezone_abbreviations_list, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickradialblurimage((void*)&i_magickradialblurimage, (void*)&ifa_magickradialblurimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_geteuid((void*)&i_posix_geteuid, (void*)&ifa_posix_geteuid, 0, 0, 0x0000000000000000LL);
CallInfo ci_mysql_fetch_lengths((void*)&i_mysql_fetch_lengths, (void*)&ifa_mysql_fetch_lengths, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickwriteimagefile((void*)&i_magickwriteimagefile, (void*)&ifa_magickwriteimagefile, 2, 0, 0x0000000000000000LL);
CallInfo ci_serialize((void*)&i_serialize, (void*)&ifa_serialize, 1, 0, 0x0000000000000000LL);
CallInfo ci_exif_read_data((void*)&i_exif_read_data, (void*)&ifa_exif_read_data, 4, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetiteratorexceptiontype((void*)&i_pixelgetiteratorexceptiontype, (void*)&ifa_pixelgetiteratorexceptiontype, 1, 0, 0x0000000000000000LL);
CallInfo ci_destroydrawingwand((void*)&i_destroydrawingwand, (void*)&ifa_destroydrawingwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_lstat((void*)&i_lstat, (void*)&ifa_lstat, 1, 0, 0x0000000000000000LL);
CallInfo ci_apache_note((void*)&i_apache_note, (void*)&ifa_apache_note, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawgetexceptiontype((void*)&i_drawgetexceptiontype, (void*)&ifa_drawgetexceptiontype, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawbezier((void*)&i_drawbezier, (void*)&ifa_drawbezier, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_start_comment((void*)&i_xmlwriter_start_comment, (void*)&ifa_xmlwriter_start_comment, 1, 0, 0x0000000000000000LL);
CallInfo ci_ldap_set_rebind_proc((void*)&i_ldap_set_rebind_proc, (void*)&ifa_ldap_set_rebind_proc, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawsetstrokecolor((void*)&i_drawsetstrokecolor, (void*)&ifa_drawsetstrokecolor, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawpathlinetohorizontalrelative((void*)&i_drawpathlinetohorizontalrelative, (void*)&ifa_drawpathlinetohorizontalrelative, 2, 0, 0x0000000000000000LL);
CallInfo ci_gmmktime((void*)&i_gmmktime, (void*)&ifa_gmmktime, 6, 0, 0x0000000000000000LL);
CallInfo ci_gmdate((void*)&i_gmdate, (void*)&ifa_gmdate, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_getgid((void*)&i_posix_getgid, (void*)&ifa_posix_getgid, 0, 0, 0x0000000000000000LL);
CallInfo ci_sinh((void*)&i_sinh, (void*)&ifa_sinh, 1, 0, 0x0000000000000000LL);
CallInfo ci_apc_fetch((void*)&i_apc_fetch, (void*)&ifa_apc_fetch, 3, 0, 0x0000000000000002LL);
CallInfo ci_fileowner((void*)&i_fileowner, (void*)&ifa_fileowner, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecopymerge((void*)&i_imagecopymerge, (void*)&ifa_imagecopymerge, 9, 0, 0x0000000000000000LL);
CallInfo ci_magickclipimage((void*)&i_magickclipimage, (void*)&ifa_magickclipimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_intl_get_error_code((void*)&i_intl_get_error_code, (void*)&ifa_intl_get_error_code, 0, 0, 0x0000000000000000LL);
CallInfo ci_imagestringup((void*)&i_imagestringup, (void*)&ifa_imagestringup, 6, 0, 0x0000000000000000LL);
CallInfo ci_mt_getrandmax((void*)&i_mt_getrandmax, (void*)&ifa_mt_getrandmax, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickgetresourcelimit((void*)&i_magickgetresourcelimit, (void*)&ifa_magickgetresourcelimit, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getlinktarget((void*)&i_hphp_splfileinfo_getlinktarget, (void*)&ifa_hphp_splfileinfo_getlinktarget, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorexact((void*)&i_imagecolorexact, (void*)&ifa_imagecolorexact, 4, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursivedirectoryiterator_current((void*)&i_hphp_recursivedirectoryiterator_current, (void*)&ifa_hphp_recursivedirectoryiterator_current, 1, 0, 0x0000000000000000LL);
CallInfo ci_setcookie((void*)&i_setcookie, (void*)&ifa_setcookie, 7, 0, 0x0000000000000000LL);
CallInfo ci_fileatime((void*)&i_fileatime, (void*)&ifa_fileatime, 1, 0, 0x0000000000000000LL);
CallInfo ci_apd_stop_trace((void*)&i_apd_stop_trace, (void*)&ifa_apd_stop_trace, 0, 0, 0x0000000000000000LL);
CallInfo ci_hphpd_break((void*)&i_hphpd_break, (void*)&ifa_hphpd_break, 1, 0, 0x0000000000000000LL);
CallInfo ci_addcslashes((void*)&i_addcslashes, (void*)&ifa_addcslashes, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimageoption((void*)&i_magicksetimageoption, (void*)&ifa_magicksetimageoption, 4, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_comment((void*)&i_xmlwriter_write_comment, (void*)&ifa_xmlwriter_write_comment, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawgetfontstyle((void*)&i_drawgetfontstyle, (void*)&ifa_drawgetfontstyle, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_set_attribute_ns((void*)&i_dom_element_set_attribute_ns, (void*)&ifa_dom_element_set_attribute_ns, 4, 0, 0x0000000000000000LL);
CallInfo ci_dom_xpath_evaluate((void*)&i_dom_xpath_evaluate, (void*)&ifa_dom_xpath_evaluate, 3, 0, 0x0000000000000000LL);
CallInfo ci_strtoupper((void*)&i_strtoupper, (void*)&ifa_strtoupper, 1, 0, 0x0000000000000000LL);
CallInfo ci_xml_set_processing_instruction_handler((void*)&i_xml_set_processing_instruction_handler, (void*)&ifa_xml_set_processing_instruction_handler, 2, 0, 0x0000000000000000LL);
CallInfo ci_apd_breakpoint((void*)&i_apd_breakpoint, (void*)&ifa_apd_breakpoint, 0, 0, 0x0000000000000000LL);
CallInfo ci_memcache_delete((void*)&i_memcache_delete, (void*)&ifa_memcache_delete, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageblueprimary((void*)&i_magickgetimageblueprimary, (void*)&ifa_magickgetimageblueprimary, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickspreadimage((void*)&i_magickspreadimage, (void*)&ifa_magickspreadimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_fill((void*)&i_array_fill, (void*)&ifa_array_fill, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_set_attribute_node((void*)&i_dom_element_set_attribute_node, (void*)&ifa_dom_element_set_attribute_node, 2, 0, 0x0000000000000000LL);
CallInfo ci_memcache_replace((void*)&i_memcache_replace, (void*)&ifa_memcache_replace, 5, 0, 0x0000000000000000LL);
CallInfo ci_stream_set_write_buffer((void*)&i_stream_set_write_buffer, (void*)&ifa_stream_set_write_buffer, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_list_encodings((void*)&i_mb_list_encodings, (void*)&ifa_mb_list_encodings, 0, 0, 0x0000000000000000LL);
CallInfo ci_sleep((void*)&i_sleep, (void*)&ifa_sleep, 1, 0, 0x0000000000000000LL);
CallInfo ci_cleardrawingwand((void*)&i_cleardrawingwand, (void*)&ifa_cleardrawingwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorset((void*)&i_imagecolorset, (void*)&ifa_imagecolorset, 5, 0, 0x0000000000000000LL);
CallInfo ci_openssl_x509_checkpurpose((void*)&i_openssl_x509_checkpurpose, (void*)&ifa_openssl_x509_checkpurpose, 4, 0, 0x0000000000000000LL);
CallInfo ci_drawpathcurvetosmoothabsolute((void*)&i_drawpathcurvetosmoothabsolute, (void*)&ifa_drawpathcurvetosmoothabsolute, 5, 0, 0x0000000000000000LL);
CallInfo ci_array_intersect_ukey((void*)&i_array_intersect_ukey, (void*)&ifa_array_intersect_ukey, 3, 1, 0x0000000000000000LL);
CallInfo ci_timezone_name_from_abbr((void*)&i_timezone_name_from_abbr, (void*)&ifa_timezone_name_from_abbr, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagefilledellipse((void*)&i_imagefilledellipse, (void*)&ifa_imagefilledellipse, 6, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_wstopsig((void*)&i_pcntl_wstopsig, (void*)&ifa_pcntl_wstopsig, 1, 0, 0x0000000000000000LL);
CallInfo ci_get_defined_vars((void*)&i_get_defined_vars, (void*)&ifa_get_defined_vars, 0, 0, 0x0000000000000000LL);
CallInfo ci_memory_get_usage((void*)&i_memory_get_usage, (void*)&ifa_memory_get_usage, 1, 0, 0x0000000000000000LL);
CallInfo ci_intval((void*)&i_intval, (void*)&ifa_intval, 2, 0, 0x0000000000000000LL);
CallInfo ci_pagelet_server_task_status((void*)&i_pagelet_server_task_status, (void*)&ifa_pagelet_server_task_status, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_get_elements_by_tag_name_ns((void*)&i_dom_document_get_elements_by_tag_name_ns, (void*)&ifa_dom_document_get_elements_by_tag_name_ns, 3, 0, 0x0000000000000000LL);
CallInfo ci_iconv_set_encoding((void*)&i_iconv_set_encoding, (void*)&ifa_iconv_set_encoding, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickmattefloodfillimage((void*)&i_magickmattefloodfillimage, (void*)&ifa_magickmattefloodfillimage, 6, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_msg_get_part((void*)&i_mailparse_msg_get_part, (void*)&ifa_mailparse_msg_get_part, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_check_encoding((void*)&i_mb_check_encoding, (void*)&ifa_mb_check_encoding, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_get_dn((void*)&i_ldap_get_dn, (void*)&ifa_ldap_get_dn, 2, 0, 0x0000000000000000LL);
CallInfo ci_newpixeliterator((void*)&i_newpixeliterator, (void*)&ifa_newpixeliterator, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagefilename((void*)&i_magicksetimagefilename, (void*)&ifa_magicksetimagefilename, 2, 0, 0x0000000000000000LL);
CallInfo ci_call_user_func((void*)&i_call_user_func, (void*)&ifa_call_user_func, 1, 2, 0x0000000000000000LL);
CallInfo ci_mysql_list_tables((void*)&i_mysql_list_tables, (void*)&ifa_mysql_list_tables, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetinterlacescheme((void*)&i_magickgetinterlacescheme, (void*)&ifa_magickgetinterlacescheme, 1, 0, 0x0000000000000000LL);
CallInfo ci_ltrim((void*)&i_ltrim, (void*)&ifa_ltrim, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicktextureimage((void*)&i_magicktextureimage, (void*)&ifa_magicktextureimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_ereg_match((void*)&i_mb_ereg_match, (void*)&ifa_mb_ereg_match, 3, 0, 0x0000000000000000LL);
CallInfo ci_mt_srand((void*)&i_mt_srand, (void*)&ifa_mt_srand, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorallocate((void*)&i_imagecolorallocate, (void*)&ifa_imagecolorallocate, 4, 0, 0x0000000000000000LL);
CallInfo ci_define_syslog_variables((void*)&i_define_syslog_variables, (void*)&ifa_define_syslog_variables, 0, 0, 0x0000000000000000LL);
CallInfo ci_fb_get_code_coverage((void*)&i_fb_get_code_coverage, (void*)&ifa_fb_get_code_coverage, 0, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_enc_get_modes_name((void*)&i_mcrypt_enc_get_modes_name, (void*)&ifa_mcrypt_enc_get_modes_name, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_flip((void*)&i_array_flip, (void*)&ifa_array_flip, 1, 0, 0x0000000000000000LL);
CallInfo ci_count((void*)&i_count, (void*)&ifa_count, 2, 0, 0x0000000000000000LL);
CallInfo ci_lcg_value((void*)&i_lcg_value, (void*)&ifa_lcg_value, 0, 0, 0x0000000000000000LL);
CallInfo ci_php_logo_guid((void*)&i_php_logo_guid, (void*)&ifa_php_logo_guid, 0, 0, 0x0000000000000000LL);
CallInfo ci_time((void*)&i_time, (void*)&ifa_time, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickcoalesceimages((void*)&i_magickcoalesceimages, (void*)&ifa_magickcoalesceimages, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetquantumcolor((void*)&i_pixelgetquantumcolor, (void*)&ifa_pixelgetquantumcolor, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_private_encrypt((void*)&i_openssl_private_encrypt, (void*)&ifa_openssl_private_encrypt, 4, 0, 0x0000000000000002LL);
CallInfo ci_xhprof_enable((void*)&i_xhprof_enable, (void*)&ifa_xhprof_enable, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_gettype((void*)&i_hphp_splfileinfo_gettype, (void*)&ifa_hphp_splfileinfo_gettype, 1, 0, 0x0000000000000000LL);
CallInfo ci_xhprof_run_trace((void*)&i_xhprof_run_trace, (void*)&ifa_xhprof_run_trace, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_start_document((void*)&i_xmlwriter_start_document, (void*)&ifa_xmlwriter_start_document, 4, 0, 0x0000000000000000LL);
CallInfo ci_libxml_clear_errors((void*)&i_libxml_clear_errors, (void*)&ifa_libxml_clear_errors, 0, 0, 0x0000000000000000LL);
CallInfo ci_magicknormalizeimage((void*)&i_magicknormalizeimage, (void*)&ifa_magicknormalizeimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetformat((void*)&i_magickgetformat, (void*)&ifa_magickgetformat, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_get_class_info((void*)&i_hphp_get_class_info, (void*)&ifa_hphp_get_class_info, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_remove_attribute_ns((void*)&i_dom_element_remove_attribute_ns, (void*)&ifa_dom_element_remove_attribute_ns, 3, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_msg_get_part_data((void*)&i_mailparse_msg_get_part_data, (void*)&ifa_mailparse_msg_get_part_data, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_csr_new((void*)&i_openssl_csr_new, (void*)&ifa_openssl_csr_new, 4, 0, 0x0000000000000002LL);
CallInfo ci_xbox_task_start((void*)&i_xbox_task_start, (void*)&ifa_xbox_task_start, 1, 0, 0x0000000000000000LL);
CallInfo ci_getcwd((void*)&i_getcwd, (void*)&ifa_getcwd, 0, 0, 0x0000000000000000LL);
CallInfo ci_posix_getrlimit((void*)&i_posix_getrlimit, (void*)&ifa_posix_getrlimit, 0, 0, 0x0000000000000000LL);
CallInfo ci_mb_get_info((void*)&i_mb_get_info, (void*)&ifa_mb_get_info, 1, 0, 0x0000000000000000LL);
CallInfo ci_newpixelwands((void*)&i_newpixelwands, (void*)&ifa_newpixelwands, 1, 0, 0x0000000000000000LL);
CallInfo ci_fputcsv((void*)&i_fputcsv, (void*)&ifa_fputcsv, 4, 0, 0x0000000000000000LL);
CallInfo ci_stream_bucket_prepend((void*)&i_stream_bucket_prepend, (void*)&ifa_stream_bucket_prepend, 2, 0, 0x0000000000000000LL);
CallInfo ci_apache_get_scoreboard((void*)&i_apache_get_scoreboard, (void*)&ifa_apache_get_scoreboard, 0, 0, 0x0000000000000000LL);
CallInfo ci_sprintf((void*)&i_sprintf, (void*)&ifa_sprintf, 1, 1, 0x0000000000000000LL);
CallInfo ci_ldap_err2str((void*)&i_ldap_err2str, (void*)&ifa_ldap_err2str, 1, 0, 0x0000000000000000LL);
CallInfo ci_memcache_get_stats((void*)&i_memcache_get_stats, (void*)&ifa_memcache_get_stats, 4, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_end_attribute((void*)&i_xmlwriter_end_attribute, (void*)&ifa_xmlwriter_end_attribute, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecharup((void*)&i_imagecharup, (void*)&ifa_imagecharup, 6, 0, 0x0000000000000000LL);
CallInfo ci_fflush((void*)&i_fflush, (void*)&ifa_fflush, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickwaveimage((void*)&i_magickwaveimage, (void*)&ifa_magickwaveimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagepsfreefont((void*)&i_imagepsfreefont, (void*)&ifa_imagepsfreefont, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_is_supported((void*)&i_dom_node_is_supported, (void*)&ifa_dom_node_is_supported, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickgetsamplingfactors((void*)&i_magickgetsamplingfactors, (void*)&ifa_magickgetsamplingfactors, 1, 0, 0x0000000000000000LL);
CallInfo ci_mt_rand((void*)&i_mt_rand, (void*)&ifa_mt_rand, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getpathname((void*)&i_hphp_splfileinfo_getpathname, (void*)&ifa_hphp_splfileinfo_getpathname, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickflopimage((void*)&i_magickflopimage, (void*)&ifa_magickflopimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_register_cleanup_function((void*)&i_register_cleanup_function, (void*)&ifa_register_cleanup_function, 1, 1, 0x0000000000000000LL);
CallInfo ci_getenv((void*)&i_getenv, (void*)&ifa_getenv, 1, 0, 0x0000000000000000LL);
CallInfo ci_is_dir((void*)&i_is_dir, (void*)&ifa_is_dir, 1, 0, 0x0000000000000000LL);
CallInfo ci_get_defined_functions((void*)&i_get_defined_functions, (void*)&ifa_get_defined_functions, 0, 0, 0x0000000000000000LL);
CallInfo ci_stream_set_timeout((void*)&i_stream_set_timeout, (void*)&ifa_stream_set_timeout, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickenhanceimage((void*)&i_magickenhanceimage, (void*)&ifa_magickenhanceimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_memcache_increment((void*)&i_memcache_increment, (void*)&ifa_memcache_increment, 3, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetblack((void*)&i_pixelsetblack, (void*)&ifa_pixelsetblack, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetcharwidth((void*)&i_magickgetcharwidth, (void*)&ifa_magickgetcharwidth, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickshearimage((void*)&i_magickshearimage, (void*)&ifa_magickshearimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_stream_socket_enable_crypto((void*)&i_stream_socket_enable_crypto, (void*)&ifa_stream_socket_enable_crypto, 4, 0, 0x0000000000000000LL);
CallInfo ci_stream_socket_server((void*)&i_stream_socket_server, (void*)&ifa_stream_socket_server, 5, 0, 0x0000000000000006LL);
CallInfo ci_apd_set_pprof_trace((void*)&i_apd_set_pprof_trace, (void*)&ifa_apd_set_pprof_trace, 2, 0, 0x0000000000000000LL);
CallInfo ci_ini_set((void*)&i_ini_set, (void*)&ifa_ini_set, 2, 0, 0x0000000000000000LL);
CallInfo ci_sort((void*)&i_sort, (void*)&ifa_sort, 3, 0, 0x0000000000000001LL);
CallInfo ci_drawgetfont((void*)&i_drawgetfont, (void*)&ifa_drawgetfont, 1, 0, 0x0000000000000000LL);
CallInfo ci_readdir((void*)&i_readdir, (void*)&ifa_readdir, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_close((void*)&i_mysql_close, (void*)&ifa_mysql_close, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagerenderingintent((void*)&i_magicksetimagerenderingintent, (void*)&ifa_magicksetimagerenderingintent, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickreducenoiseimage((void*)&i_magickreducenoiseimage, (void*)&ifa_magickreducenoiseimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickblurimage((void*)&i_magickblurimage, (void*)&ifa_magickblurimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_hphpd_get_user_commands((void*)&i_hphpd_get_user_commands, (void*)&ifa_hphpd_get_user_commands, 0, 0, 0x0000000000000000LL);
CallInfo ci_magicktintimage((void*)&i_magicktintimage, (void*)&ifa_magicktintimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_rawurldecode((void*)&i_rawurldecode, (void*)&ifa_rawurldecode, 1, 0, 0x0000000000000000LL);
CallInfo ci_strftime((void*)&i_strftime, (void*)&ifa_strftime, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_start_element_ns((void*)&i_xmlwriter_start_element_ns, (void*)&ifa_xmlwriter_start_element_ns, 4, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorstotal((void*)&i_imagecolorstotal, (void*)&ifa_imagecolorstotal, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getowner((void*)&i_hphp_splfileinfo_getowner, (void*)&ifa_hphp_splfileinfo_getowner, 1, 0, 0x0000000000000000LL);
CallInfo ci_write_hdf_string((void*)&i_write_hdf_string, (void*)&ifa_write_hdf_string, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_node_has_child_nodes((void*)&i_dom_node_has_child_nodes, (void*)&ifa_dom_node_has_child_nodes, 1, 0, 0x0000000000000000LL);
CallInfo ci_apc_bin_dumpfile((void*)&i_apc_bin_dumpfile, (void*)&ifa_apc_bin_dumpfile, 5, 0, 0x0000000000000000LL);
CallInfo ci_xml_parse_into_struct((void*)&i_xml_parse_into_struct, (void*)&ifa_xml_parse_into_struct, 4, 0, 0x000000000000000CLL);
CallInfo ci_icu_transliterate((void*)&i_icu_transliterate, (void*)&ifa_icu_transliterate, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_eregi_replace((void*)&i_mb_eregi_replace, (void*)&ifa_mb_eregi_replace, 4, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getatime((void*)&i_hphp_splfileinfo_getatime, (void*)&ifa_hphp_splfileinfo_getatime, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_unshift((void*)&i_array_unshift, (void*)&ifa_array_unshift, 2, 1, 0x0000000000000001LL);
CallInfo ci_stat((void*)&i_stat, (void*)&ifa_stat, 1, 0, 0x0000000000000000LL);
CallInfo ci_posix_getpid((void*)&i_posix_getpid, (void*)&ifa_posix_getpid, 0, 0, 0x0000000000000000LL);
CallInfo ci_hphp_directoryiterator_key((void*)&i_hphp_directoryiterator_key, (void*)&ifa_hphp_directoryiterator_key, 1, 0, 0x0000000000000000LL);
CallInfo ci_get_current_user((void*)&i_get_current_user, (void*)&ifa_get_current_user, 0, 0, 0x0000000000000000LL);
CallInfo ci_filesize((void*)&i_filesize, (void*)&ifa_filesize, 1, 0, 0x0000000000000000LL);
CallInfo ci_round((void*)&i_round, (void*)&ifa_round, 2, 0, 0x0000000000000000LL);
CallInfo ci_pdo_drivers((void*)&i_pdo_drivers, (void*)&ifa_pdo_drivers, 0, 0, 0x0000000000000000LL);
CallInfo ci_sqrt((void*)&i_sqrt, (void*)&ifa_sqrt, 1, 0, 0x0000000000000000LL);
CallInfo ci_ldap_close((void*)&i_ldap_close, (void*)&ifa_ldap_close, 1, 0, 0x0000000000000000LL);
CallInfo ci_memcache_pconnect((void*)&i_memcache_pconnect, (void*)&ifa_memcache_pconnect, 4, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_enc_get_algorithms_name((void*)&i_mcrypt_enc_get_algorithms_name, (void*)&ifa_mcrypt_enc_get_algorithms_name, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_rewind((void*)&i_hphp_splfileobject_rewind, (void*)&ifa_hphp_splfileobject_rewind, 1, 0, 0x0000000000000000LL);
CallInfo ci_fprintf((void*)&i_fprintf, (void*)&ifa_fprintf, 2, 1, 0x0000000000000000LL);
CallInfo ci_extension_loaded((void*)&i_extension_loaded, (void*)&ifa_extension_loaded, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_detect_order((void*)&i_mb_detect_order, (void*)&ifa_mb_detect_order, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickmapimage((void*)&i_magickmapimage, (void*)&ifa_magickmapimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_get_magic_quotes_runtime((void*)&i_get_magic_quotes_runtime, (void*)&ifa_get_magic_quotes_runtime, 0, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetopacityquantum((void*)&i_pixelsetopacityquantum, (void*)&ifa_pixelsetopacityquantum, 2, 0, 0x0000000000000000LL);
CallInfo ci_ctype_space((void*)&i_ctype_space, (void*)&ifa_ctype_space, 1, 0, 0x0000000000000000LL);
CallInfo ci_destroymagickwand((void*)&i_destroymagickwand, (void*)&ifa_destroymagickwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_generic_init((void*)&i_mcrypt_generic_init, (void*)&ifa_mcrypt_generic_init, 3, 0, 0x0000000000000000LL);
CallInfo ci_quoted_printable_decode((void*)&i_quoted_printable_decode, (void*)&ifa_quoted_printable_decode, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getfileinfo((void*)&i_hphp_splfileinfo_getfileinfo, (void*)&ifa_hphp_splfileinfo_getfileinfo, 2, 0, 0x0000000000000000LL);
CallInfo ci_get_cfg_var((void*)&i_get_cfg_var, (void*)&ifa_get_cfg_var, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagerectangle((void*)&i_imagerectangle, (void*)&ifa_imagerectangle, 6, 0, 0x0000000000000000LL);
CallInfo ci_call_user_func_rpc((void*)&i_call_user_func_rpc, (void*)&ifa_call_user_func_rpc, 5, 2, 0x0000000000000000LL);
CallInfo ci_pixelgetalphaquantum((void*)&i_pixelgetalphaquantum, (void*)&ifa_pixelgetalphaquantum, 1, 0, 0x0000000000000000LL);
CallInfo ci_fb_renamed_functions((void*)&i_fb_renamed_functions, (void*)&ifa_fb_renamed_functions, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagepsextendfont((void*)&i_imagepsextendfont, (void*)&ifa_imagepsextendfont, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageblob((void*)&i_magickgetimageblob, (void*)&ifa_magickgetimageblob, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_get_filters((void*)&i_stream_get_filters, (void*)&ifa_stream_get_filters, 0, 0, 0x0000000000000000LL);
CallInfo ci_magickqueryfontmetrics((void*)&i_magickqueryfontmetrics, (void*)&ifa_magickqueryfontmetrics, 4, 0, 0x0000000000000000LL);
CallInfo ci_ispixeliterator((void*)&i_ispixeliterator, (void*)&ifa_ispixeliterator, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagefilledarc((void*)&i_imagefilledarc, (void*)&ifa_imagefilledarc, 9, 0, 0x0000000000000000LL);
CallInfo ci_getdate((void*)&i_getdate, (void*)&ifa_getdate, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_debug_caller_info((void*)&i_hphp_debug_caller_info, (void*)&ifa_hphp_debug_caller_info, 0, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_attribute((void*)&i_xmlwriter_write_attribute, (void*)&ifa_xmlwriter_write_attribute, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagearc((void*)&i_imagearc, (void*)&ifa_imagearc, 8, 0, 0x0000000000000000LL);
CallInfo ci_magickreadimages((void*)&i_magickreadimages, (void*)&ifa_magickreadimages, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawgetgravity((void*)&i_drawgetgravity, (void*)&ifa_drawgetgravity, 1, 0, 0x0000000000000000LL);
CallInfo ci_connection_status((void*)&i_connection_status, (void*)&ifa_connection_status, 0, 0, 0x0000000000000000LL);
CallInfo ci_imagecreatefromgd2((void*)&i_imagecreatefromgd2, (void*)&ifa_imagecreatefromgd2, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_socket_shutdown((void*)&i_stream_socket_shutdown, (void*)&ifa_stream_socket_shutdown, 2, 0, 0x0000000000000000LL);
CallInfo ci_pixelresetiterator((void*)&i_pixelresetiterator, (void*)&ifa_pixelresetiterator, 1, 0, 0x0000000000000000LL);
CallInfo ci_msg_send((void*)&i_msg_send, (void*)&ifa_msg_send, 6, 0, 0x0000000000000020LL);
CallInfo ci_getmygid((void*)&i_getmygid, (void*)&ifa_getmygid, 0, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_get_element_by_id((void*)&i_dom_document_get_element_by_id, (void*)&ifa_dom_document_get_element_by_id, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_udiff_uassoc((void*)&i_array_udiff_uassoc, (void*)&ifa_array_udiff_uassoc, 4, 1, 0x0000000000000000LL);
CallInfo ci_strptime((void*)&i_strptime, (void*)&ifa_strptime, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_diff_uassoc((void*)&i_array_diff_uassoc, (void*)&ifa_array_diff_uassoc, 3, 1, 0x0000000000000000LL);
CallInfo ci_xml_set_character_data_handler((void*)&i_xml_set_character_data_handler, (void*)&ifa_xml_set_character_data_handler, 2, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_waitpid((void*)&i_pcntl_waitpid, (void*)&ifa_pcntl_waitpid, 3, 0, 0x0000000000000002LL);
CallInfo ci_array_replace_recursive((void*)&i_array_replace_recursive, (void*)&ifa_array_replace_recursive, 1, 1, 0x0000000000000000LL);
CallInfo ci_gd_info((void*)&i_gd_info, (void*)&ifa_gd_info, 0, 0, 0x0000000000000000LL);
CallInfo ci_stream_get_transports((void*)&i_stream_get_transports, (void*)&ifa_stream_get_transports, 0, 0, 0x0000000000000000LL);
CallInfo ci_drawsetstrokepatternurl((void*)&i_drawsetstrokepatternurl, (void*)&ifa_drawsetstrokepatternurl, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_add((void*)&i_ldap_add, (void*)&ifa_ldap_add, 3, 0, 0x0000000000000000LL);
CallInfo ci_acosh((void*)&i_acosh, (void*)&ifa_acosh, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawsetfillrule((void*)&i_drawsetfillrule, (void*)&ifa_drawsetfillrule, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_getlogin((void*)&i_posix_getlogin, (void*)&ifa_posix_getlogin, 0, 0, 0x0000000000000000LL);
CallInfo ci_posix_getsid((void*)&i_posix_getsid, (void*)&ifa_posix_getsid, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagegd2((void*)&i_imagegd2, (void*)&ifa_imagegd2, 4, 0, 0x0000000000000000LL);
CallInfo ci_imagecreate((void*)&i_imagecreate, (void*)&ifa_imagecreate, 2, 0, 0x0000000000000000LL);
CallInfo ci_socket_create_pair((void*)&i_socket_create_pair, (void*)&ifa_socket_create_pair, 4, 0, 0x0000000000000008LL);
CallInfo ci_openssl_x509_check_private_key((void*)&i_openssl_x509_check_private_key, (void*)&ifa_openssl_x509_check_private_key, 2, 0, 0x0000000000000000LL);
CallInfo ci_collator_get_attribute((void*)&i_collator_get_attribute, (void*)&ifa_collator_get_attribute, 2, 0, 0x0000000000000000LL);
CallInfo ci_shm_put_var((void*)&i_shm_put_var, (void*)&ifa_shm_put_var, 3, 0, 0x0000000000000000LL);
CallInfo ci_debug_print_backtrace((void*)&i_debug_print_backtrace, (void*)&ifa_debug_print_backtrace, 0, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_seek((void*)&i_hphp_splfileobject_seek, (void*)&ifa_hphp_splfileobject_seek, 2, 0, 0x0000000000000000LL);
CallInfo ci_stream_set_blocking((void*)&i_stream_set_blocking, (void*)&ifa_stream_set_blocking, 2, 0, 0x0000000000000000LL);
CallInfo ci_ezmlm_hash((void*)&i_ezmlm_hash, (void*)&ifa_ezmlm_hash, 1, 0, 0x0000000000000000LL);
CallInfo ci_xml_parser_get_option((void*)&i_xml_parser_get_option, (void*)&ifa_xml_parser_get_option, 2, 0, 0x0000000000000000LL);
CallInfo ci_array_search((void*)&i_array_search, (void*)&ifa_array_search, 3, 0, 0x0000000000000000LL);
CallInfo ci_is_int((void*)&i_is_int, (void*)&ifa_is_int, 1, 0, 0x0000000000000000LL);
CallInfo ci_dangling_server_proxy_new_request((void*)&i_dangling_server_proxy_new_request, (void*)&ifa_dangling_server_proxy_new_request, 1, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_end_dtd_entity((void*)&i_xmlwriter_end_dtd_entity, (void*)&ifa_xmlwriter_end_dtd_entity, 1, 0, 0x0000000000000000LL);
CallInfo ci_trim((void*)&i_trim, (void*)&ifa_trim, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawpathclose((void*)&i_drawpathclose, (void*)&ifa_drawpathclose, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickprofileimage((void*)&i_magickprofileimage, (void*)&ifa_magickprofileimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_connection_timeout((void*)&i_connection_timeout, (void*)&ifa_connection_timeout, 0, 0, 0x0000000000000000LL);
CallInfo ci_mysql_data_seek((void*)&i_mysql_data_seek, (void*)&ifa_mysql_data_seek, 2, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetindex((void*)&i_pixelgetindex, (void*)&ifa_pixelgetindex, 1, 0, 0x0000000000000000LL);
CallInfo ci_class_implements((void*)&i_class_implements, (void*)&ifa_class_implements, 2, 0, 0x0000000000000000LL);
CallInfo ci_hebrevc((void*)&i_hebrevc, (void*)&ifa_hebrevc, 2, 0, 0x0000000000000000LL);
CallInfo ci_get_meta_tags((void*)&i_get_meta_tags, (void*)&ifa_get_meta_tags, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicknextimage((void*)&i_magicknextimage, (void*)&ifa_magicknextimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursivedirectoryiterator_key((void*)&i_hphp_recursivedirectoryiterator_key, (void*)&ifa_hphp_recursivedirectoryiterator_key, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_create_db((void*)&i_mysql_create_db, (void*)&ifa_mysql_create_db, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_stat((void*)&i_mysql_stat, (void*)&ifa_mysql_stat, 1, 0, 0x0000000000000000LL);
CallInfo ci_get_object_vars((void*)&i_get_object_vars, (void*)&ifa_get_object_vars, 1, 0, 0x0000000000000000LL);
CallInfo ci_msg_receive((void*)&i_msg_receive, (void*)&ifa_msg_receive, 8, 0, 0x0000000000000094LL);
CallInfo ci_is_integer((void*)&i_is_integer, (void*)&ifa_is_integer, 1, 0, 0x0000000000000000LL);
CallInfo ci_posix_getuid((void*)&i_posix_getuid, (void*)&ifa_posix_getuid, 0, 0, 0x0000000000000000LL);
CallInfo ci_imagecreatefromgif((void*)&i_imagecreatefromgif, (void*)&ifa_imagecreatefromgif, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_send_mail((void*)&i_mb_send_mail, (void*)&ifa_mb_send_mail, 5, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo___construct((void*)&i_hphp_splfileinfo___construct, (void*)&ifa_hphp_splfileinfo___construct, 2, 0, 0x0000000000000000LL);
CallInfo ci_register_postsend_function((void*)&i_register_postsend_function, (void*)&ifa_register_postsend_function, 1, 1, 0x0000000000000000LL);
CallInfo ci_getrusage((void*)&i_getrusage, (void*)&ifa_getrusage, 1, 0, 0x0000000000000000LL);
CallInfo ci_long2ip((void*)&i_long2ip, (void*)&ifa_long2ip, 1, 0, 0x0000000000000000LL);
CallInfo ci_evhttp_set_cache((void*)&i_evhttp_set_cache, (void*)&ifa_evhttp_set_cache, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickoilpaintimage((void*)&i_magickoilpaintimage, (void*)&ifa_magickoilpaintimage, 2, 0, 0x0000000000000000LL);
CallInfo ci_strripos((void*)&i_strripos, (void*)&ifa_strripos, 3, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagecolormapcolor((void*)&i_magicksetimagecolormapcolor, (void*)&ifa_magicksetimagecolormapcolor, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickgetfilename((void*)&i_magickgetfilename, (void*)&ifa_magickgetfilename, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagegamma((void*)&i_magicksetimagegamma, (void*)&ifa_magicksetimagegamma, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_pconnect((void*)&i_mysql_pconnect, (void*)&ifa_mysql_pconnect, 6, 0, 0x0000000000000000LL);
CallInfo ci_stripos((void*)&i_stripos, (void*)&ifa_stripos, 3, 0, 0x0000000000000000LL);
CallInfo ci_http_build_query((void*)&i_http_build_query, (void*)&ifa_http_build_query, 3, 0, 0x0000000000000000LL);
CallInfo ci_apc_add((void*)&i_apc_add, (void*)&ifa_apc_add, 4, 0, 0x0000000000000000LL);
CallInfo ci_iconv_strlen((void*)&i_iconv_strlen, (void*)&ifa_iconv_strlen, 2, 0, 0x0000000000000000LL);
CallInfo ci_vsprintf((void*)&i_vsprintf, (void*)&ifa_vsprintf, 2, 0, 0x0000000000000000LL);
CallInfo ci_imageistruecolor((void*)&i_imageistruecolor, (void*)&ifa_imageistruecolor, 1, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_msg_extract_part_file((void*)&i_mailparse_msg_extract_part_file, (void*)&ifa_mailparse_msg_extract_part_file, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_xpath_register_ns((void*)&i_dom_xpath_register_ns, (void*)&ifa_dom_xpath_register_ns, 3, 0, 0x0000000000000000LL);
CallInfo ci_is_nan((void*)&i_is_nan, (void*)&ifa_is_nan, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagegif((void*)&i_imagegif, (void*)&ifa_imagegif, 2, 0, 0x0000000000000000LL);
CallInfo ci_eregi_replace((void*)&i_eregi_replace, (void*)&ifa_eregi_replace, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimageiterations((void*)&i_magickgetimageiterations, (void*)&ifa_magickgetimageiterations, 1, 0, 0x0000000000000000LL);
CallInfo ci_register_tick_function((void*)&i_register_tick_function, (void*)&ifa_register_tick_function, 1, 1, 0x0000000000000000LL);
CallInfo ci_pixelsetblackquantum((void*)&i_pixelsetblackquantum, (void*)&ifa_pixelsetblackquantum, 2, 0, 0x0000000000000000LL);
CallInfo ci_jpeg2wbmp((void*)&i_jpeg2wbmp, (void*)&ifa_jpeg2wbmp, 5, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_get_iv_size((void*)&i_mcrypt_get_iv_size, (void*)&ifa_mcrypt_get_iv_size, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_fetch_array((void*)&i_mysql_fetch_array, (void*)&ifa_mysql_fetch_array, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickpreviousimage((void*)&i_magickpreviousimage, (void*)&ifa_magickpreviousimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickborderimage((void*)&i_magickborderimage, (void*)&ifa_magickborderimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_module_is_block_mode((void*)&i_mcrypt_module_is_block_mode, (void*)&ifa_mcrypt_module_is_block_mode, 2, 0, 0x0000000000000000LL);
CallInfo ci_mb_substr((void*)&i_mb_substr, (void*)&ifa_mb_substr, 4, 0, 0x0000000000000000LL);
CallInfo ci_get_defined_constants((void*)&i_get_defined_constants, (void*)&ifa_get_defined_constants, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_enc_is_block_mode((void*)&i_mcrypt_enc_is_block_mode, (void*)&ifa_mcrypt_enc_is_block_mode, 1, 0, 0x0000000000000000LL);
CallInfo ci_mailparse_stream_encode((void*)&i_mailparse_stream_encode, (void*)&ifa_mailparse_stream_encode, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawsetstrokedashoffset((void*)&i_drawsetstrokedashoffset, (void*)&ifa_drawsetstrokedashoffset, 2, 0, 0x0000000000000000LL);
CallInfo ci_php_ini_scanned_files((void*)&i_php_ini_scanned_files, (void*)&ifa_php_ini_scanned_files, 0, 0, 0x0000000000000000LL);
CallInfo ci_disk_free_space((void*)&i_disk_free_space, (void*)&ifa_disk_free_space, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetyellowquantum((void*)&i_pixelsetyellowquantum, (void*)&ifa_pixelsetyellowquantum, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_create_element_ns((void*)&i_dom_document_create_element_ns, (void*)&ifa_dom_document_create_element_ns, 4, 0, 0x0000000000000000LL);
CallInfo ci_openssl_public_decrypt((void*)&i_openssl_public_decrypt, (void*)&ifa_openssl_public_decrypt, 4, 0, 0x0000000000000002LL);
CallInfo ci_convert_uuencode((void*)&i_convert_uuencode, (void*)&ifa_convert_uuencode, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickequalizeimage((void*)&i_magickequalizeimage, (void*)&ifa_magickequalizeimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_field_len((void*)&i_mysql_field_len, (void*)&ifa_mysql_field_len, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawsetclipunits((void*)&i_drawsetclipunits, (void*)&ifa_drawsetclipunits, 2, 0, 0x0000000000000000LL);
CallInfo ci_mdecrypt_generic((void*)&i_mdecrypt_generic, (void*)&ifa_mdecrypt_generic, 2, 0, 0x0000000000000000LL);
CallInfo ci_getprotobyname((void*)&i_getprotobyname, (void*)&ifa_getprotobyname, 1, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_start_pi((void*)&i_xmlwriter_start_pi, (void*)&ifa_xmlwriter_start_pi, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_field_type((void*)&i_mysql_field_type, (void*)&ifa_mysql_field_type, 2, 0, 0x0000000000000000LL);
CallInfo ci_apc_cas((void*)&i_apc_cas, (void*)&ifa_apc_cas, 4, 0, 0x0000000000000000LL);
CallInfo ci_getopt((void*)&i_getopt, (void*)&ifa_getopt, 2, 0, 0x0000000000000000LL);
CallInfo ci_clearpixelwand((void*)&i_clearpixelwand, (void*)&ifa_clearpixelwand, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawsetgravity((void*)&i_drawsetgravity, (void*)&ifa_drawsetgravity, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagecompressionquality((void*)&i_magickgetimagecompressionquality, (void*)&ifa_magickgetimagecompressionquality, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickquantizeimages((void*)&i_magickquantizeimages, (void*)&ifa_magickquantizeimages, 6, 0, 0x0000000000000000LL);
CallInfo ci_mysql_insert_id((void*)&i_mysql_insert_id, (void*)&ifa_mysql_insert_id, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_thread_set_warmup_enabled((void*)&i_hphp_thread_set_warmup_enabled, (void*)&ifa_hphp_thread_set_warmup_enabled, 0, 0, 0x0000000000000000LL);
CallInfo ci_stream_context_set_param((void*)&i_stream_context_set_param, (void*)&ifa_stream_context_set_param, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawpathlinetohorizontalabsolute((void*)&i_drawpathlinetohorizontalabsolute, (void*)&ifa_drawpathlinetohorizontalabsolute, 2, 0, 0x0000000000000000LL);
CallInfo ci_openssl_csr_export((void*)&i_openssl_csr_export, (void*)&ifa_openssl_csr_export, 3, 0, 0x0000000000000002LL);
CallInfo ci_socket_connect((void*)&i_socket_connect, (void*)&ifa_socket_connect, 3, 0, 0x0000000000000000LL);
CallInfo ci_stripslashes((void*)&i_stripslashes, (void*)&ifa_stripslashes, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickhaspreviousimage((void*)&i_magickhaspreviousimage, (void*)&ifa_magickhaspreviousimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawgetstrokecolor((void*)&i_drawgetstrokecolor, (void*)&ifa_drawgetstrokecolor, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecreatefromwbmp((void*)&i_imagecreatefromwbmp, (void*)&ifa_imagecreatefromwbmp, 1, 0, 0x0000000000000000LL);
CallInfo ci_str_repeat((void*)&i_str_repeat, (void*)&ifa_str_repeat, 2, 0, 0x0000000000000000LL);
CallInfo ci_stream_resolve_include_path((void*)&i_stream_resolve_include_path, (void*)&ifa_stream_resolve_include_path, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_read((void*)&i_ldap_read, (void*)&ifa_ldap_read, 8, 0, 0x0000000000000000LL);
CallInfo ci_apc_dec((void*)&i_apc_dec, (void*)&ifa_apc_dec, 4, 0, 0x0000000000000004LL);
CallInfo ci_posix_get_last_error((void*)&i_posix_get_last_error, (void*)&ifa_posix_get_last_error, 0, 0, 0x0000000000000000LL);
CallInfo ci_iptcparse((void*)&i_iptcparse, (void*)&ifa_iptcparse, 1, 0, 0x0000000000000000LL);
CallInfo ci_iterator_count((void*)&i_iterator_count, (void*)&ifa_iterator_count, 1, 0, 0x0000000000000000LL);
CallInfo ci_curl_setopt_array((void*)&i_curl_setopt_array, (void*)&ifa_curl_setopt_array, 2, 0, 0x0000000000000000LL);
CallInfo ci_socket_recvfrom((void*)&i_socket_recvfrom, (void*)&ifa_socket_recvfrom, 6, 0, 0x0000000000000032LL);
CallInfo ci_imagepstext((void*)&i_imagepstext, (void*)&ifa_imagepstext, 12, 0, 0x0000000000000000LL);
CallInfo ci_mb_encode_mimeheader((void*)&i_mb_encode_mimeheader, (void*)&ifa_mb_encode_mimeheader, 5, 0, 0x0000000000000000LL);
CallInfo ci_socket_getsockname((void*)&i_socket_getsockname, (void*)&ifa_socket_getsockname, 3, 0, 0x0000000000000006LL);
CallInfo ci_imagecreatefromstring((void*)&i_imagecreatefromstring, (void*)&ifa_imagecreatefromstring, 1, 0, 0x0000000000000000LL);
CallInfo ci_vfprintf((void*)&i_vfprintf, (void*)&ifa_vfprintf, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickcompareimages((void*)&i_magickcompareimages, (void*)&ifa_magickcompareimages, 4, 0, 0x0000000000000000LL);
CallInfo ci_fscanf((void*)&i_fscanf, (void*)&ifa_fscanf, 2, 2, 0x0000000000000000LL);
CallInfo ci_stristr((void*)&i_stristr, (void*)&ifa_stristr, 2, 0, 0x0000000000000000LL);
CallInfo ci_xml_parser_set_option((void*)&i_xml_parser_set_option, (void*)&ifa_xml_parser_set_option, 3, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_schema_validate_file((void*)&i_dom_document_schema_validate_file, (void*)&ifa_dom_document_schema_validate_file, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimageinterlacescheme((void*)&i_magicksetimageinterlacescheme, (void*)&ifa_magicksetimageinterlacescheme, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_get_attribute_node((void*)&i_dom_element_get_attribute_node, (void*)&ifa_dom_element_get_attribute_node, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_create_cdatasection((void*)&i_dom_document_create_cdatasection, (void*)&ifa_dom_document_create_cdatasection, 2, 0, 0x0000000000000000LL);
CallInfo ci_destroypixeliterator((void*)&i_destroypixeliterator, (void*)&ifa_destroypixeliterator, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagetype((void*)&i_magicksetimagetype, (void*)&ifa_magicksetimagetype, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursiveiteratoriterator_getinneriterator((void*)&i_hphp_recursiveiteratoriterator_getinneriterator, (void*)&ifa_hphp_recursiveiteratoriterator_getinneriterator, 1, 0, 0x0000000000000000LL);
CallInfo ci_date_sunrise((void*)&i_date_sunrise, (void*)&ifa_date_sunrise, 6, 0, 0x0000000000000000LL);
CallInfo ci_magickgethomeurl((void*)&i_magickgethomeurl, (void*)&ifa_magickgethomeurl, 0, 0, 0x0000000000000000LL);
CallInfo ci_mb_detect_encoding((void*)&i_mb_detect_encoding, (void*)&ifa_mb_detect_encoding, 3, 0, 0x0000000000000000LL);
CallInfo ci_wandhasexception((void*)&i_wandhasexception, (void*)&ifa_wandhasexception, 1, 0, 0x0000000000000000LL);
CallInfo ci_error_reporting((void*)&i_error_reporting, (void*)&ifa_error_reporting, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagepalettecopy((void*)&i_imagepalettecopy, (void*)&ifa_imagepalettecopy, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_isexecutable((void*)&i_hphp_splfileinfo_isexecutable, (void*)&ifa_hphp_splfileinfo_isexecutable, 1, 0, 0x0000000000000000LL);
CallInfo ci_rename_function((void*)&i_rename_function, (void*)&ifa_rename_function, 2, 0, 0x0000000000000000LL);
CallInfo ci_gzcompress((void*)&i_gzcompress, (void*)&ifa_gzcompress, 2, 0, 0x0000000000000000LL);
CallInfo ci_gzeof((void*)&i_gzeof, (void*)&ifa_gzeof, 1, 0, 0x0000000000000000LL);
CallInfo ci_bcadd((void*)&i_bcadd, (void*)&ifa_bcadd, 3, 0, 0x0000000000000000LL);
CallInfo ci_curl_setopt((void*)&i_curl_setopt, (void*)&ifa_curl_setopt, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagealphablending((void*)&i_imagealphablending, (void*)&ifa_imagealphablending, 2, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetmagenta((void*)&i_pixelgetmagenta, (void*)&ifa_pixelgetmagenta, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawannotation((void*)&i_drawannotation, (void*)&ifa_drawannotation, 4, 0, 0x0000000000000000LL);
CallInfo ci_getmypid((void*)&i_getmypid, (void*)&ifa_getmypid, 0, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagedispose((void*)&i_magicksetimagedispose, (void*)&ifa_magicksetimagedispose, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawsetfontsize((void*)&i_drawsetfontsize, (void*)&ifa_drawsetfontsize, 2, 0, 0x0000000000000000LL);
CallInfo ci_gethostbyname((void*)&i_gethostbyname, (void*)&ifa_gethostbyname, 1, 0, 0x0000000000000000LL);
CallInfo ci_stream_wrapper_restore((void*)&i_stream_wrapper_restore, (void*)&ifa_stream_wrapper_restore, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagecompression((void*)&i_magickgetimagecompression, (void*)&ifa_magickgetimagecompression, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_invoke_method((void*)&i_hphp_invoke_method, (void*)&ifa_hphp_invoke_method, 4, 0, 0x0000000000000000LL);
CallInfo ci_xbox_schedule_thread_reset((void*)&i_xbox_schedule_thread_reset, (void*)&ifa_xbox_schedule_thread_reset, 0, 0, 0x0000000000000000LL);
CallInfo ci_date_offset_get((void*)&i_date_offset_get, (void*)&ifa_date_offset_get, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetiteratorexception((void*)&i_pixelgetiteratorexception, (void*)&ifa_pixelgetiteratorexception, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_field_flags((void*)&i_mysql_field_flags, (void*)&ifa_mysql_field_flags, 2, 0, 0x0000000000000000LL);
CallInfo ci_linkinfo((void*)&i_linkinfo, (void*)&ifa_linkinfo, 1, 0, 0x0000000000000000LL);
CallInfo ci_strchr((void*)&i_strchr, (void*)&ifa_strchr, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickqueryformats((void*)&i_magickqueryformats, (void*)&ifa_magickqueryformats, 1, 0, 0x0000000000000000LL);
CallInfo ci_class_parents((void*)&i_class_parents, (void*)&ifa_class_parents, 2, 0, 0x0000000000000000LL);
CallInfo ci_date_time_set((void*)&i_date_time_set, (void*)&ifa_date_time_set, 4, 0, 0x0000000000000000LL);
CallInfo ci_iconv_strpos((void*)&i_iconv_strpos, (void*)&ifa_iconv_strpos, 4, 0, 0x0000000000000000LL);
CallInfo ci_i18n_loc_set_strength((void*)&i_i18n_loc_set_strength, (void*)&ifa_i18n_loc_set_strength, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagebordercolor((void*)&i_magickgetimagebordercolor, (void*)&ifa_magickgetimagebordercolor, 1, 0, 0x0000000000000000LL);
CallInfo ci_ob_end_clean((void*)&i_ob_end_clean, (void*)&ifa_ob_end_clean, 0, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_savexml((void*)&i_dom_document_savexml, (void*)&ifa_dom_document_savexml, 3, 0, 0x0000000000000000LL);
CallInfo ci_trigger_error((void*)&i_trigger_error, (void*)&ifa_trigger_error, 2, 0, 0x0000000000000000LL);
CallInfo ci_pcntl_getpriority((void*)&i_pcntl_getpriority, (void*)&ifa_pcntl_getpriority, 2, 0, 0x0000000000000000LL);
CallInfo ci_date_default_timezone_get((void*)&i_date_default_timezone_get, (void*)&ifa_date_default_timezone_get, 0, 0, 0x0000000000000000LL);
CallInfo ci_strcmp((void*)&i_strcmp, (void*)&ifa_strcmp, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursivedirectoryiterator_haschildren((void*)&i_hphp_recursivedirectoryiterator_haschildren, (void*)&ifa_hphp_recursivedirectoryiterator_haschildren, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_instanceof((void*)&i_hphp_instanceof, (void*)&ifa_hphp_instanceof, 2, 0, 0x0000000000000000LL);
CallInfo ci_import_request_variables((void*)&i_import_request_variables, (void*)&ifa_import_request_variables, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetpackagename((void*)&i_magickgetpackagename, (void*)&ifa_magickgetpackagename, 0, 0, 0x0000000000000000LL);
CallInfo ci_destroypixelwandarray((void*)&i_destroypixelwandarray, (void*)&ifa_destroypixelwandarray, 1, 0, 0x0000000000000000LL);
CallInfo ci_spliti((void*)&i_spliti, (void*)&ifa_spliti, 3, 0, 0x0000000000000000LL);
CallInfo ci_posix_setgid((void*)&i_posix_setgid, (void*)&ifa_posix_setgid, 1, 0, 0x0000000000000000LL);
CallInfo ci_is_double((void*)&i_is_double, (void*)&ifa_is_double, 1, 0, 0x0000000000000000LL);
CallInfo ci_output_reset_rewrite_vars((void*)&i_output_reset_rewrite_vars, (void*)&ifa_output_reset_rewrite_vars, 0, 0, 0x0000000000000000LL);
CallInfo ci_get_declared_interfaces((void*)&i_get_declared_interfaces, (void*)&ifa_get_declared_interfaces, 0, 0, 0x0000000000000000LL);
CallInfo ci_passthru((void*)&i_passthru, (void*)&ifa_passthru, 2, 0, 0x0000000000000002LL);
CallInfo ci_magickmontageimage((void*)&i_magickmontageimage, (void*)&ifa_magickmontageimage, 6, 0, 0x0000000000000000LL);
CallInfo ci_session_commit((void*)&i_session_commit, (void*)&ifa_session_commit, 0, 0, 0x0000000000000000LL);
CallInfo ci_apc_cache_info((void*)&i_apc_cache_info, (void*)&ifa_apc_cache_info, 2, 0, 0x0000000000000000LL);
CallInfo ci_convert_cyr_string((void*)&i_convert_cyr_string, (void*)&ifa_convert_cyr_string, 3, 0, 0x0000000000000000LL);
CallInfo ci_sys_get_temp_dir((void*)&i_sys_get_temp_dir, (void*)&ifa_sys_get_temp_dir, 0, 0, 0x0000000000000000LL);
CallInfo ci_libxml_get_last_error((void*)&i_libxml_get_last_error, (void*)&ifa_libxml_get_last_error, 0, 0, 0x0000000000000000LL);
CallInfo ci_drawline((void*)&i_drawline, (void*)&ifa_drawline, 5, 0, 0x0000000000000000LL);
CallInfo ci_drawsetfillcolor((void*)&i_drawsetfillcolor, (void*)&ifa_drawsetfillcolor, 2, 0, 0x0000000000000000LL);
CallInfo ci_gzopen((void*)&i_gzopen, (void*)&ifa_gzopen, 3, 0, 0x0000000000000000LL);
CallInfo ci_getservbyport((void*)&i_getservbyport, (void*)&ifa_getservbyport, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getfilename((void*)&i_hphp_splfileinfo_getfilename, (void*)&ifa_hphp_splfileinfo_getfilename, 1, 0, 0x0000000000000000LL);
CallInfo ci_stripcslashes((void*)&i_stripcslashes, (void*)&ifa_stripcslashes, 1, 0, 0x0000000000000000LL);
CallInfo ci_curl_multi_add_handle((void*)&i_curl_multi_add_handle, (void*)&ifa_curl_multi_add_handle, 2, 0, 0x0000000000000000LL);
CallInfo ci_ldap_free_result((void*)&i_ldap_free_result, (void*)&ifa_ldap_free_result, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_replace((void*)&i_array_replace, (void*)&ifa_array_replace, 1, 1, 0x0000000000000000LL);
CallInfo ci_xmlwriter_end_pi((void*)&i_xmlwriter_end_pi, (void*)&ifa_xmlwriter_end_pi, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagewbmp((void*)&i_imagewbmp, (void*)&ifa_imagewbmp, 3, 0, 0x0000000000000000LL);
CallInfo ci_shm_get_var((void*)&i_shm_get_var, (void*)&ifa_shm_get_var, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetmimetype((void*)&i_magickgetmimetype, (void*)&ifa_magickgetmimetype, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_fetch_assoc((void*)&i_mysql_fetch_assoc, (void*)&ifa_mysql_fetch_assoc, 1, 0, 0x0000000000000000LL);
CallInfo ci_socket_set_nonblock((void*)&i_socket_set_nonblock, (void*)&ifa_socket_set_nonblock, 1, 0, 0x0000000000000000LL);
CallInfo ci_array_filter((void*)&i_array_filter, (void*)&ifa_array_filter, 2, 0, 0x0000000000000000LL);
CallInfo ci_mysql_query((void*)&i_mysql_query, (void*)&ifa_mysql_query, 2, 0, 0x0000000000000000LL);
CallInfo ci_crypt((void*)&i_crypt, (void*)&ifa_crypt, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_start_cdata((void*)&i_xmlwriter_start_cdata, (void*)&ifa_xmlwriter_start_cdata, 1, 0, 0x0000000000000000LL);
CallInfo ci_fgetc((void*)&i_fgetc, (void*)&ifa_fgetc, 1, 0, 0x0000000000000000LL);
CallInfo ci_move_uploaded_file((void*)&i_move_uploaded_file, (void*)&ifa_move_uploaded_file, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileobject_flock((void*)&i_hphp_splfileobject_flock, (void*)&ifa_hphp_splfileobject_flock, 2, 0, 0x0000000000000002LL);
CallInfo ci_imagecopyresampled((void*)&i_imagecopyresampled, (void*)&ifa_imagecopyresampled, 10, 0, 0x0000000000000000LL);
CallInfo ci_imagecreatefrompng((void*)&i_imagecreatefrompng, (void*)&ifa_imagecreatefrompng, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimage((void*)&i_magickgetimage, (void*)&ifa_magickgetimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagesettile((void*)&i_imagesettile, (void*)&ifa_imagesettile, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_recursiveiteratoriterator_valid((void*)&i_hphp_recursiveiteratoriterator_valid, (void*)&ifa_hphp_recursiveiteratoriterator_valid, 1, 0, 0x0000000000000000LL);
CallInfo ci_fgets((void*)&i_fgets, (void*)&ifa_fgets, 2, 0, 0x0000000000000000LL);
CallInfo ci_tempnam((void*)&i_tempnam, (void*)&ifa_tempnam, 2, 0, 0x0000000000000000LL);
CallInfo ci_bcdiv((void*)&i_bcdiv, (void*)&ifa_bcdiv, 3, 0, 0x0000000000000000LL);
CallInfo ci_hphp_splfileinfo_getbasename((void*)&i_hphp_splfileinfo_getbasename, (void*)&ifa_hphp_splfileinfo_getbasename, 2, 0, 0x0000000000000000LL);
CallInfo ci_rsort((void*)&i_rsort, (void*)&ifa_rsort, 3, 0, 0x0000000000000001LL);
CallInfo ci_drawgettextdecoration((void*)&i_drawgettextdecoration, (void*)&ifa_drawgettextdecoration, 1, 0, 0x0000000000000000LL);
CallInfo ci_strtolower((void*)&i_strtolower, (void*)&ifa_strtolower, 1, 0, 0x0000000000000000LL);
CallInfo ci_posix_getgrgid((void*)&i_posix_getgrgid, (void*)&ifa_posix_getgrgid, 1, 0, 0x0000000000000000LL);
CallInfo ci_apc_inc((void*)&i_apc_inc, (void*)&ifa_apc_inc, 4, 0, 0x0000000000000004LL);
CallInfo ci_hphp_create_object((void*)&i_hphp_create_object, (void*)&ifa_hphp_create_object, 2, 0, 0x0000000000000000LL);
CallInfo ci_hexdec((void*)&i_hexdec, (void*)&ifa_hexdec, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagefttext((void*)&i_imagefttext, (void*)&ifa_imagefttext, 9, 0, 0x0000000000000000LL);
CallInfo ci_xhprof_sample_disable((void*)&i_xhprof_sample_disable, (void*)&ifa_xhprof_sample_disable, 0, 0, 0x0000000000000000LL);
CallInfo ci_ldap_compare((void*)&i_ldap_compare, (void*)&ifa_ldap_compare, 4, 0, 0x0000000000000000LL);
CallInfo ci_dns_get_record((void*)&i_dns_get_record, (void*)&ifa_dns_get_record, 4, 0, 0x000000000000000CLL);
CallInfo ci_openssl_get_privatekey((void*)&i_openssl_get_privatekey, (void*)&ifa_openssl_get_privatekey, 2, 0, 0x0000000000000000LL);
CallInfo ci_imagepng((void*)&i_imagepng, (void*)&ifa_imagepng, 4, 0, 0x0000000000000000LL);
CallInfo ci_socket_bind((void*)&i_socket_bind, (void*)&ifa_socket_bind, 3, 0, 0x0000000000000000LL);
CallInfo ci_getmyuid((void*)&i_getmyuid, (void*)&ifa_getmyuid, 0, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetopacity((void*)&i_pixelgetopacity, (void*)&ifa_pixelgetopacity, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawsetstrokelinecap((void*)&i_drawsetstrokelinecap, (void*)&ifa_drawsetstrokelinecap, 2, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_write_attribute_ns((void*)&i_xmlwriter_write_attribute_ns, (void*)&ifa_xmlwriter_write_attribute_ns, 5, 0, 0x0000000000000000LL);
CallInfo ci_array_keys((void*)&i_array_keys, (void*)&ifa_array_keys, 3, 0, 0x0000000000000000LL);
CallInfo ci_call_user_method_array((void*)&i_call_user_method_array, (void*)&ifa_call_user_method_array, 3, 0, 0x0000000000000002LL);
CallInfo ci_magickmagnifyimage((void*)&i_magickmagnifyimage, (void*)&ifa_magickmagnifyimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_is_bool((void*)&i_is_bool, (void*)&ifa_is_bool, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickgetimagegreenprimary((void*)&i_magickgetimagegreenprimary, (void*)&ifa_magickgetimagegreenprimary, 1, 0, 0x0000000000000000LL);
CallInfo ci_session_start((void*)&i_session_start, (void*)&ifa_session_start, 0, 0, 0x0000000000000000LL);
CallInfo ci_filegroup((void*)&i_filegroup, (void*)&ifa_filegroup, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_attr_is_id((void*)&i_dom_attr_is_id, (void*)&ifa_dom_attr_is_id, 1, 0, 0x0000000000000000LL);
CallInfo ci_gzread((void*)&i_gzread, (void*)&ifa_gzread, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawpathellipticarcrelative((void*)&i_drawpathellipticarcrelative, (void*)&ifa_drawpathellipticarcrelative, 8, 0, 0x0000000000000000LL);
CallInfo ci_openssl_csr_export_to_file((void*)&i_openssl_csr_export_to_file, (void*)&ifa_openssl_csr_export_to_file, 3, 0, 0x0000000000000000LL);
CallInfo ci_magicksetimagecolorspace((void*)&i_magicksetimagecolorspace, (void*)&ifa_magicksetimagecolorspace, 2, 0, 0x0000000000000000LL);
CallInfo ci_nl_langinfo((void*)&i_nl_langinfo, (void*)&ifa_nl_langinfo, 1, 0, 0x0000000000000000LL);
CallInfo ci_hphp_get_stats((void*)&i_hphp_get_stats, (void*)&ifa_hphp_get_stats, 1, 0, 0x0000000000000000LL);
CallInfo ci_strncmp((void*)&i_strncmp, (void*)&ifa_strncmp, 3, 0, 0x0000000000000000LL);
CallInfo ci_mb_regex_set_options((void*)&i_mb_regex_set_options, (void*)&ifa_mb_regex_set_options, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetmagenta((void*)&i_pixelsetmagenta, (void*)&ifa_pixelsetmagenta, 2, 0, 0x0000000000000000LL);
CallInfo ci_dom_element_remove_attribute((void*)&i_dom_element_remove_attribute, (void*)&ifa_dom_element_remove_attribute, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickdeconstructimages((void*)&i_magickdeconstructimages, (void*)&ifa_magickdeconstructimages, 1, 0, 0x0000000000000000LL);
CallInfo ci_xbox_task_status((void*)&i_xbox_task_status, (void*)&ifa_xbox_task_status, 1, 0, 0x0000000000000000LL);
CallInfo ci_openssl_open((void*)&i_openssl_open, (void*)&ifa_openssl_open, 4, 0, 0x0000000000000002LL);
CallInfo ci_apc_bin_load((void*)&i_apc_bin_load, (void*)&ifa_apc_bin_load, 3, 0, 0x0000000000000000LL);
CallInfo ci_current((void*)&i_current, (void*)&ifa_current, 1, 0, 0x0000000000000001LL);
CallInfo ci_stream_register_wrapper((void*)&i_stream_register_wrapper, (void*)&ifa_stream_register_wrapper, 2, 0, 0x0000000000000000LL);
CallInfo ci_hphp_stats((void*)&i_hphp_stats, (void*)&ifa_hphp_stats, 2, 0, 0x0000000000000000LL);
CallInfo ci_opendir((void*)&i_opendir, (void*)&ifa_opendir, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickgetexceptionstring((void*)&i_magickgetexceptionstring, (void*)&ifa_magickgetexceptionstring, 1, 0, 0x0000000000000000LL);
CallInfo ci_mcrypt_module_is_block_algorithm_mode((void*)&i_mcrypt_module_is_block_algorithm_mode, (void*)&ifa_mcrypt_module_is_block_algorithm_mode, 2, 0, 0x0000000000000000LL);
CallInfo ci_posix_setpgid((void*)&i_posix_setpgid, (void*)&ifa_posix_setpgid, 2, 0, 0x0000000000000000LL);
CallInfo ci_dns_get_mx((void*)&i_dns_get_mx, (void*)&ifa_dns_get_mx, 3, 0, 0x0000000000000006LL);
CallInfo ci_headers_list((void*)&i_headers_list, (void*)&ifa_headers_list, 0, 0, 0x0000000000000000LL);
CallInfo ci_escapeshellarg((void*)&i_escapeshellarg, (void*)&ifa_escapeshellarg, 1, 0, 0x0000000000000000LL);
CallInfo ci_is_scalar((void*)&i_is_scalar, (void*)&ifa_is_scalar, 1, 0, 0x0000000000000000LL);
CallInfo ci_acos((void*)&i_acos, (void*)&ifa_acos, 1, 0, 0x0000000000000000LL);
CallInfo ci_drawgettextencoding((void*)&i_drawgettextencoding, (void*)&ifa_drawgettextencoding, 1, 0, 0x0000000000000000LL);
CallInfo ci_filetype((void*)&i_filetype, (void*)&ifa_filetype, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetresolution((void*)&i_magicksetresolution, (void*)&ifa_magicksetresolution, 3, 0, 0x0000000000000000LL);
CallInfo ci_posix_isatty((void*)&i_posix_isatty, (void*)&ifa_posix_isatty, 1, 0, 0x0000000000000000LL);
CallInfo ci_dom_document_relaxng_validate_file((void*)&i_dom_document_relaxng_validate_file, (void*)&ifa_dom_document_relaxng_validate_file, 2, 0, 0x0000000000000000LL);
CallInfo ci_escapeshellcmd((void*)&i_escapeshellcmd, (void*)&ifa_escapeshellcmd, 1, 0, 0x0000000000000000LL);
CallInfo ci_apc_store((void*)&i_apc_store, (void*)&ifa_apc_store, 4, 0, 0x0000000000000000LL);
CallInfo ci_magickresetiterator((void*)&i_magickresetiterator, (void*)&ifa_magickresetiterator, 1, 0, 0x0000000000000000LL);
CallInfo ci_libxml_disable_entity_loader((void*)&i_libxml_disable_entity_loader, (void*)&ifa_libxml_disable_entity_loader, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickmotionblurimage((void*)&i_magickmotionblurimage, (void*)&ifa_magickmotionblurimage, 4, 0, 0x0000000000000000LL);
CallInfo ci_session_cache_expire((void*)&i_session_cache_expire, (void*)&ifa_session_cache_expire, 1, 0, 0x0000000000000000LL);
CallInfo ci_magicksetwandsize((void*)&i_magicksetwandsize, (void*)&ifa_magicksetwandsize, 3, 0, 0x0000000000000000LL);
CallInfo ci_number_format((void*)&i_number_format, (void*)&ifa_number_format, 4, 0, 0x0000000000000000LL);
CallInfo ci_array_reduce((void*)&i_array_reduce, (void*)&ifa_array_reduce, 3, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_start_dtd_attlist((void*)&i_xmlwriter_start_dtd_attlist, (void*)&ifa_xmlwriter_start_dtd_attlist, 2, 0, 0x0000000000000000LL);
CallInfo ci_constant((void*)&i_constant, (void*)&ifa_constant, 1, 0, 0x0000000000000000LL);
CallInfo ci_strlen((void*)&i_strlen, (void*)&ifa_strlen, 1, 0, 0x0000000000000000LL);
CallInfo ci_srand((void*)&i_srand, (void*)&ifa_srand, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_fetch_object((void*)&i_mysql_fetch_object, (void*)&ifa_mysql_fetch_object, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawpathlinetoverticalrelative((void*)&i_drawpathlinetoverticalrelative, (void*)&ifa_drawpathlinetoverticalrelative, 2, 0, 0x0000000000000000LL);
CallInfo ci_magickminifyimage((void*)&i_magickminifyimage, (void*)&ifa_magickminifyimage, 1, 0, 0x0000000000000000LL);
CallInfo ci_date_sunset((void*)&i_date_sunset, (void*)&ifa_date_sunset, 6, 0, 0x0000000000000000LL);
CallInfo ci_symlink((void*)&i_symlink, (void*)&ifa_symlink, 2, 0, 0x0000000000000000LL);
CallInfo ci_imagesetpixel((void*)&i_imagesetpixel, (void*)&ifa_imagesetpixel, 4, 0, 0x0000000000000000LL);
CallInfo ci_session_module_name((void*)&i_session_module_name, (void*)&ifa_session_module_name, 1, 0, 0x0000000000000000LL);
CallInfo ci_split((void*)&i_split, (void*)&ifa_split, 3, 0, 0x0000000000000000LL);
CallInfo ci_drawsetfontstyle((void*)&i_drawsetfontstyle, (void*)&ifa_drawsetfontstyle, 2, 0, 0x0000000000000000LL);
CallInfo ci_imagecreatefromxbm((void*)&i_imagecreatefromxbm, (void*)&ifa_imagecreatefromxbm, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_db_query((void*)&i_mysql_db_query, (void*)&ifa_mysql_db_query, 3, 0, 0x0000000000000000LL);
CallInfo ci_imagecolorclosestalpha((void*)&i_imagecolorclosestalpha, (void*)&ifa_imagecolorclosestalpha, 5, 0, 0x0000000000000000LL);
CallInfo ci_gzuncompress((void*)&i_gzuncompress, (void*)&ifa_gzuncompress, 2, 0, 0x0000000000000000LL);
CallInfo ci_is_executable((void*)&i_is_executable, (void*)&ifa_is_executable, 1, 0, 0x0000000000000000LL);
CallInfo ci_socket_create_listen((void*)&i_socket_create_listen, (void*)&ifa_socket_create_listen, 2, 0, 0x0000000000000000LL);
CallInfo ci_pixelgetcolorcount((void*)&i_pixelgetcolorcount, (void*)&ifa_pixelgetcolorcount, 1, 0, 0x0000000000000000LL);
CallInfo ci_magickqueryconfigureoptions((void*)&i_magickqueryconfigureoptions, (void*)&ifa_magickqueryconfigureoptions, 1, 0, 0x0000000000000000LL);
CallInfo ci_iptcembed((void*)&i_iptcembed, (void*)&ifa_iptcembed, 3, 0, 0x0000000000000000LL);
CallInfo ci_posix_getgrnam((void*)&i_posix_getgrnam, (void*)&ifa_posix_getgrnam, 1, 0, 0x0000000000000000LL);
CallInfo ci_rtrim((void*)&i_rtrim, (void*)&ifa_rtrim, 2, 0, 0x0000000000000000LL);
CallInfo ci_print_r((void*)&i_print_r, (void*)&ifa_print_r, 2, 0, 0x0000000000000000LL);
CallInfo ci_drawpathcurvetoquadraticbeziersmoothrelative((void*)&i_drawpathcurvetoquadraticbeziersmoothrelative, (void*)&ifa_drawpathcurvetoquadraticbeziersmoothrelative, 3, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkey_export((void*)&i_openssl_pkey_export, (void*)&ifa_openssl_pkey_export, 4, 0, 0x0000000000000002LL);
CallInfo ci_abs((void*)&i_abs, (void*)&ifa_abs, 1, 0, 0x0000000000000000LL);
CallInfo ci_restore_exception_handler((void*)&i_restore_exception_handler, (void*)&ifa_restore_exception_handler, 0, 0, 0x0000000000000000LL);
CallInfo ci_shell_exec((void*)&i_shell_exec, (void*)&ifa_shell_exec, 1, 0, 0x0000000000000000LL);
CallInfo ci_curl_multi_exec((void*)&i_curl_multi_exec, (void*)&ifa_curl_multi_exec, 2, 0, 0x0000000000000002LL);
CallInfo ci_htmlspecialchars((void*)&i_htmlspecialchars, (void*)&ifa_htmlspecialchars, 4, 0, 0x0000000000000000LL);
CallInfo ci_imagexbm((void*)&i_imagexbm, (void*)&ifa_imagexbm, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickgetreleasedate((void*)&i_magickgetreleasedate, (void*)&ifa_magickgetreleasedate, 0, 0, 0x0000000000000000LL);
CallInfo ci_xbox_set_thread_timeout((void*)&i_xbox_set_thread_timeout, (void*)&ifa_xbox_set_thread_timeout, 1, 0, 0x0000000000000000LL);
CallInfo ci_sem_remove((void*)&i_sem_remove, (void*)&ifa_sem_remove, 1, 0, 0x0000000000000000LL);
CallInfo ci_imageellipse((void*)&i_imageellipse, (void*)&ifa_imageellipse, 6, 0, 0x0000000000000000LL);
CallInfo ci_getprotobynumber((void*)&i_getprotobynumber, (void*)&ifa_getprotobynumber, 1, 0, 0x0000000000000000LL);
CallInfo ci_pixelsetopacity((void*)&i_pixelsetopacity, (void*)&ifa_pixelsetopacity, 2, 0, 0x0000000000000000LL);
CallInfo ci_lchgrp((void*)&i_lchgrp, (void*)&ifa_lchgrp, 2, 0, 0x0000000000000000LL);
CallInfo ci_simplexml_load_file((void*)&i_simplexml_load_file, (void*)&ifa_simplexml_load_file, 5, 0, 0x0000000000000000LL);
CallInfo ci_openssl_pkey_get_details((void*)&i_openssl_pkey_get_details, (void*)&ifa_openssl_pkey_get_details, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagetypes((void*)&i_imagetypes, (void*)&ifa_imagetypes, 0, 0, 0x0000000000000000LL);
CallInfo ci_gzseek((void*)&i_gzseek, (void*)&ifa_gzseek, 3, 0, 0x0000000000000000LL);
CallInfo ci_magickgetmaxtextadvance((void*)&i_magickgetmaxtextadvance, (void*)&ifa_magickgetmaxtextadvance, 4, 0, 0x0000000000000000LL);
CallInfo ci_func_get_arg((void*)&i_func_get_arg, (void*)&ifa_func_get_arg, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagefilledrectangle((void*)&i_imagefilledrectangle, (void*)&ifa_imagefilledrectangle, 6, 0, 0x0000000000000000LL);
CallInfo ci_drawpushpattern((void*)&i_drawpushpattern, (void*)&ifa_drawpushpattern, 6, 0, 0x0000000000000000LL);
CallInfo ci_xmlwriter_set_indent((void*)&i_xmlwriter_set_indent, (void*)&ifa_xmlwriter_set_indent, 2, 0, 0x0000000000000000LL);
CallInfo ci_openssl_csr_get_subject((void*)&i_openssl_csr_get_subject, (void*)&ifa_openssl_csr_get_subject, 2, 0, 0x0000000000000000LL);
CallInfo ci_is_numeric((void*)&i_is_numeric, (void*)&ifa_is_numeric, 1, 0, 0x0000000000000000LL);
CallInfo ci_gzdeflate((void*)&i_gzdeflate, (void*)&ifa_gzdeflate, 2, 0, 0x0000000000000000LL);
CallInfo ci_dns_check_record((void*)&i_dns_check_record, (void*)&ifa_dns_check_record, 2, 0, 0x0000000000000000LL);
CallInfo ci_magicknegateimage((void*)&i_magicknegateimage, (void*)&ifa_magicknegateimage, 3, 0, 0x0000000000000000LL);
CallInfo ci_socket_last_error((void*)&i_socket_last_error, (void*)&ifa_socket_last_error, 1, 0, 0x0000000000000000LL);
CallInfo ci_create_function((void*)&i_create_function, (void*)&ifa_create_function, 2, 0, 0x0000000000000000LL);
CallInfo ci_str_split((void*)&i_str_split, (void*)&ifa_str_split, 2, 0, 0x0000000000000000LL);
CallInfo ci_date_parse((void*)&i_date_parse, (void*)&ifa_date_parse, 1, 0, 0x0000000000000000LL);
CallInfo ci_imagecreatefromxpm((void*)&i_imagecreatefromxpm, (void*)&ifa_imagecreatefromxpm, 1, 0, 0x0000000000000000LL);
CallInfo ci_mysql_thread_id((void*)&i_mysql_thread_id, (void*)&ifa_mysql_thread_id, 1, 0, 0x0000000000000000LL);
CallInfo ci_mb_encode_numericentity((void*)&i_mb_encode_numericentity, (void*)&ifa_mb_encode_numericentity, 3, 0, 0x0000000000000000LL);
CallInfo ci_fb_call_user_func_array_safe((void*)&i_fb_call_user_func_array_safe, (void*)&ifa_fb_call_user_func_array_safe, 2, 0, 0x0000000000000000LL);
bool get_call_info_builtin(const CallInfo *&ci, void *&extra, const char *s, int64 hash) {
  extra = NULL;
  if (hash < 0) hash = hash_string(s);
  switch (hash & 4095) {
    case 1:
      HASH_GUARD(0x4F7230DC25F0E001LL, magicknormalizeimage) {
        ci = &ci_magicknormalizeimage;
        return true;
      }
      break;
    case 2:
      HASH_GUARD(0x76C320EDB9B6E002LL, xmlwriter_flush) {
        ci = &ci_xmlwriter_flush;
        return true;
      }
      break;
    case 3:
      HASH_GUARD(0x7E0EC3E131BCA003LL, token_name) {
        ci = &ci_token_name;
        return true;
      }
      break;
    case 5:
      HASH_GUARD(0x20D579E7E4131005LL, imagecolorclosest) {
        ci = &ci_imagecolorclosest;
        return true;
      }
      HASH_GUARD(0x18A0F1EE8E249005LL, msg_send) {
        ci = &ci_msg_send;
        return true;
      }
      break;
    case 10:
      HASH_GUARD(0x555D7A3FB939300ALL, apache_setenv) {
        ci = &ci_apache_setenv;
        return true;
      }
      break;
    case 11:
      HASH_GUARD(0x4FDCCE1C7754600BLL, ob_iconv_handler) {
        ci = &ci_ob_iconv_handler;
        return true;
      }
      break;
    case 13:
      HASH_GUARD(0x40FA17130FA7100DLL, openssl_seal) {
        ci = &ci_openssl_seal;
        return true;
      }
      break;
    case 22:
      HASH_GUARD(0x5623A698A728F016LL, getlastmod) {
        ci = &ci_getlastmod;
        return true;
      }
      break;
    case 24:
      HASH_GUARD(0x4C915E3480E94018LL, mb_substr_count) {
        ci = &ci_mb_substr_count;
        return true;
      }
      break;
    case 26:
      HASH_GUARD(0x03834225EBBC101ALL, drawsettextundercolor) {
        ci = &ci_drawsettextundercolor;
        return true;
      }
      break;
    case 34:
      HASH_GUARD(0x145D42B2AB55D022LL, drawmatte) {
        ci = &ci_drawmatte;
        return true;
      }
      break;
    case 35:
      HASH_GUARD(0x35C74650867B7023LL, imagesetpixel) {
        ci = &ci_imagesetpixel;
        return true;
      }
      break;
    case 40:
      HASH_GUARD(0x601C5152277AE028LL, readfile) {
        ci = &ci_readfile;
        return true;
      }
      break;
    case 44:
      HASH_GUARD(0x464EB9B1F955202CLL, apc_add) {
        ci = &ci_apc_add;
        return true;
      }
      break;
    case 45:
      HASH_GUARD(0x3BE730D90618202DLL, collator_sort_with_sort_keys) {
        ci = &ci_collator_sort_with_sort_keys;
        return true;
      }
      break;
    case 51:
      HASH_GUARD(0x48F35DFD653D7033LL, pclose) {
        ci = &ci_pclose;
        return true;
      }
      break;
    case 54:
      HASH_GUARD(0x32F23F206C394036LL, curl_setopt_array) {
        ci = &ci_curl_setopt_array;
        return true;
      }
      break;
    case 55:
      HASH_GUARD(0x418D937957ECE037LL, tanh) {
        ci = &ci_tanh;
        return true;
      }
      break;
    case 59:
      HASH_GUARD(0x40329F2A6B84D03BLL, dom_node_lookup_prefix) {
        ci = &ci_dom_node_lookup_prefix;
        return true;
      }
      break;
    case 62:
      HASH_GUARD(0x32E6E5D3CCE3703ELL, magickgetimagewidth) {
        ci = &ci_magickgetimagewidth;
        return true;
      }
      HASH_GUARD(0x43461C4D9130103ELL, exit) {
        ci = &ci_exit;
        return true;
      }
      HASH_GUARD(0x67C1ED9B816E503ELL, md5_file) {
        ci = &ci_md5_file;
        return true;
      }
      HASH_GUARD(0x497E31C70409603ELL, timezone_name_from_abbr) {
        ci = &ci_timezone_name_from_abbr;
        return true;
      }
      break;
    case 63:
      HASH_GUARD(0x24206A195B9C203FLL, ucfirst) {
        ci = &ci_ucfirst;
        return true;
      }
      break;
    case 65:
      HASH_GUARD(0x65B39B11F5D7C041LL, array_unique) {
        ci = &ci_array_unique;
        return true;
      }
      break;
    case 67:
      HASH_GUARD(0x5ACCF9166CD9D043LL, ftruncate) {
        ci = &ci_ftruncate;
        return true;
      }
      break;
    case 68:
      HASH_GUARD(0x378A73FF98B60044LL, curl_init) {
        ci = &ci_curl_init;
        return true;
      }
      break;
    case 73:
      HASH_GUARD(0x047A8BF04DB51049LL, range) {
        ci = &ci_range;
        return true;
      }
      HASH_GUARD(0x4282E0231F600049LL, fseek) {
        ci = &ci_fseek;
        return true;
      }
      break;
    case 75:
      HASH_GUARD(0x17CD0E68E778C04BLL, drawsetstrokelinejoin) {
        ci = &ci_drawsetstrokelinejoin;
        return true;
      }
      HASH_GUARD(0x6370CF455EA8604BLL, socket_create) {
        ci = &ci_socket_create;
        return true;
      }
      break;
    case 76:
      HASH_GUARD(0x7848970191D5A04CLL, mysql_connect_with_db) {
        ci = &ci_mysql_connect_with_db;
        return true;
      }
      HASH_GUARD(0x03047FD5FC67204CLL, exif_read_data) {
        ci = &ci_exif_read_data;
        return true;
      }
      break;
    case 83:
      HASH_GUARD(0x15A9EB33DA6E9053LL, getimagesize) {
        ci = &ci_getimagesize;
        return true;
      }
      HASH_GUARD(0x07EB5C3A3BEA3053LL, acosh) {
        ci = &ci_acosh;
        return true;
      }
      break;
    case 87:
      HASH_GUARD(0x12B22A2E6B344057LL, ldap_sort) {
        ci = &ci_ldap_sort;
        return true;
      }
      break;
    case 90:
      HASH_GUARD(0x271AB768D202F05ALL, mcrypt_module_is_block_algorithm) {
        ci = &ci_mcrypt_module_is_block_algorithm;
        return true;
      }
      break;
    case 92:
      HASH_GUARD(0x2B7532A070BF605CLL, openssl_get_privatekey) {
        ci = &ci_openssl_get_privatekey;
        return true;
      }
      break;
    case 95:
      HASH_GUARD(0x4B70746F965E705FLL, preg_last_error) {
        ci = &ci_preg_last_error;
        return true;
      }
      break;
    case 98:
      HASH_GUARD(0x745910AD5C922062LL, magickgetmimetype) {
        ci = &ci_magickgetmimetype;
        return true;
      }
      break;
    case 100:
      HASH_GUARD(0x5CC8BA5ADFAC0064LL, imagegrabscreen) {
        ci = &ci_imagegrabscreen;
        return true;
      }
      break;
    case 101:
      HASH_GUARD(0x777FE52584FAE065LL, apc_bin_dump) {
        ci = &ci_apc_bin_dump;
        return true;
      }
      break;
    case 103:
      HASH_GUARD(0x0CE1918B30DF5067LL, sys_getloadavg) {
        ci = &ci_sys_getloadavg;
        return true;
      }
      HASH_GUARD(0x4512BD5EA7076067LL, openssl_csr_export_to_file) {
        ci = &ci_openssl_csr_export_to_file;
        return true;
      }
      break;
    case 111:
      HASH_GUARD(0x4C6FD8808A62506FLL, session_set_save_handler) {
        ci = &ci_session_set_save_handler;
        return true;
      }
      break;
    case 112:
      HASH_GUARD(0x3C466098FF7B5070LL, mb_check_encoding) {
        ci = &ci_mb_check_encoding;
        return true;
      }
      break;
    case 120:
      HASH_GUARD(0x6B268C26E21C1078LL, arsort) {
        ci = &ci_arsort;
        return true;
      }
      HASH_GUARD(0x01AE1DE8FA116078LL, call_user_func_array_async) {
        ci = &ci_call_user_func_array_async;
        return true;
      }
      break;
    case 121:
      HASH_GUARD(0x08AA4EA901C9B079LL, session_encode) {
        ci = &ci_session_encode;
        return true;
      }
      break;
    case 122:
      HASH_GUARD(0x5F9DDC342A83807ALL, date_default_timezone_get) {
        ci = &ci_date_default_timezone_get;
        return true;
      }
      break;
    case 131:
      HASH_GUARD(0x1A90213EE1A56083LL, array_pop) {
        ci = &ci_array_pop;
        return true;
      }
      break;
    case 132:
      HASH_GUARD(0x53FD8C9AC3F4D084LL, dangling_server_proxy_new_request) {
        ci = &ci_dangling_server_proxy_new_request;
        return true;
      }
      break;
    case 135:
      HASH_GUARD(0x255D919D501C5087LL, dom_characterdata_delete_data) {
        ci = &ci_dom_characterdata_delete_data;
        return true;
      }
      break;
    case 137:
      HASH_GUARD(0x4AD554CBAB9CC089LL, call_user_method_array) {
        ci = &ci_call_user_method_array;
        return true;
      }
      break;
    case 140:
      HASH_GUARD(0x4F1D1ED7B087208CLL, exec) {
        ci = &ci_exec;
        return true;
      }
      HASH_GUARD(0x3A0B58797E8FE08CLL, xml_set_external_entity_ref_handler) {
        ci = &ci_xml_set_external_entity_ref_handler;
        return true;
      }
      break;
    case 141:
      HASH_GUARD(0x200864F8F053C08DLL, magickgetversionstring) {
        ci = &ci_magickgetversionstring;
        return true;
      }
      break;
    case 142:
      HASH_GUARD(0x3E4AE974AFA9708ELL, pixelsetquantumcolor) {
        ci = &ci_pixelsetquantumcolor;
        return true;
      }
      break;
    case 145:
      HASH_GUARD(0x3E5CF6378A49C091LL, ldap_get_attributes) {
        ci = &ci_ldap_get_attributes;
        return true;
      }
      HASH_GUARD(0x673B36244DC87091LL, closelog) {
        ci = &ci_closelog;
        return true;
      }
      HASH_GUARD(0x1C32BB63986C8091LL, socket_strerror) {
        ci = &ci_socket_strerror;
        return true;
      }
      break;
    case 147:
      HASH_GUARD(0x3B5E32078E37A093LL, imagedestroy) {
        ci = &ci_imagedestroy;
        return true;
      }
      break;
    case 158:
      HASH_GUARD(0x4AF87BA91163D09ELL, mysql_db_name) {
        ci = &ci_mysql_db_name;
        return true;
      }
      HASH_GUARD(0x74F0D6D8F1F2709ELL, drawsetstrokedashoffset) {
        ci = &ci_drawsetstrokedashoffset;
        return true;
      }
      break;
    case 159:
      HASH_GUARD(0x2B130322DEC4B09FLL, pixelgetopacityquantum) {
        ci = &ci_pixelgetopacityquantum;
        return true;
      }
      break;
    case 161:
      HASH_GUARD(0x0DF945F12533F0A1LL, abs) {
        ci = &ci_abs;
        return true;
      }
      break;
    case 162:
      HASH_GUARD(0x10DF7941C3F3E0A2LL, socket_bind) {
        ci = &ci_socket_bind;
        return true;
      }
      break;
    case 163:
      HASH_GUARD(0x54242D2846BC60A3LL, magickunsharpmaskimage) {
        ci = &ci_magickunsharpmaskimage;
        return true;
      }
      break;
    case 167:
      HASH_GUARD(0x74C787060F7290A7LL, icu_transliterate) {
        ci = &ci_icu_transliterate;
        return true;
      }
      break;
    case 168:
      HASH_GUARD(0x6E8C61326DCE40A8LL, var_export) {
        ci = &ci_var_export;
        return true;
      }
      break;
    case 171:
      HASH_GUARD(0x439DF153FC32D0ABLL, printf) {
        ci = &ci_printf;
        return true;
      }
      HASH_GUARD(0x5B1D9F56698A40ABLL, html_entity_decode) {
        ci = &ci_html_entity_decode;
        return true;
      }
      break;
    case 172:
      HASH_GUARD(0x6E27DC1E74C5B0ACLL, drawpathstart) {
        ci = &ci_drawpathstart;
        return true;
      }
      break;
    case 173:
      HASH_GUARD(0x4C9252FB9C3300ADLL, pixelsetalphaquantum) {
        ci = &ci_pixelsetalphaquantum;
        return true;
      }
      break;
    case 174:
      HASH_GUARD(0x47AB4A08446BD0AELL, bcmod) {
        ci = &ci_bcmod;
        return true;
      }
      HASH_GUARD(0x4BBD5D8A6E0110AELL, error_log) {
        ci = &ci_error_log;
        return true;
      }
      break;
    case 175:
      HASH_GUARD(0x3954FFED1E0650AFLL, stream_register_wrapper) {
        ci = &ci_stream_register_wrapper;
        return true;
      }
      break;
    case 176:
      HASH_GUARD(0x5B9F8B3E1D8330B0LL, stream_socket_sendto) {
        ci = &ci_stream_socket_sendto;
        return true;
      }
      break;
    case 177:
      HASH_GUARD(0x191B5F1B190BC0B1LL, dom_xpath_register_ns) {
        ci = &ci_dom_xpath_register_ns;
        return true;
      }
      break;
    case 178:
      HASH_GUARD(0x48BBFB59FB7F90B2LL, iconv_strlen) {
        ci = &ci_iconv_strlen;
        return true;
      }
      break;
    case 184:
      HASH_GUARD(0x05A4C165810A30B8LL, gzread) {
        ci = &ci_gzread;
        return true;
      }
      break;
    case 185:
      HASH_GUARD(0x5C659372B2CD80B9LL, imagecolorstotal) {
        ci = &ci_imagecolorstotal;
        return true;
      }
      break;
    case 187:
      HASH_GUARD(0x331E7DFBE6E240BBLL, libxml_get_errors) {
        ci = &ci_libxml_get_errors;
        return true;
      }
      break;
    case 188:
      HASH_GUARD(0x3900350CD9D990BCLL, imagecreatefromjpeg) {
        ci = &ci_imagecreatefromjpeg;
        return true;
      }
      break;
    case 192:
      HASH_GUARD(0x6EDC1E7A8D5710C0LL, memcache_add_server) {
        ci = &ci_memcache_add_server;
        return true;
      }
      break;
    case 197:
      HASH_GUARD(0x7424946F7ED520C5LL, magickgetimagefilename) {
        ci = &ci_magickgetimagefilename;
        return true;
      }
      HASH_GUARD(0x6B477F3B9CDB10C5LL, base64_decode) {
        ci = &ci_base64_decode;
        return true;
      }
      break;
    case 199:
      HASH_GUARD(0x677F33E78342A0C7LL, function_exists) {
        ci = &ci_function_exists;
        return true;
      }
      break;
    case 200:
      HASH_GUARD(0x30AB38D851C440C8LL, magickgetimagebackgroundcolor) {
        ci = &ci_magickgetimagebackgroundcolor;
        return true;
      }
      break;
    case 202:
      HASH_GUARD(0x2EE0967F6EB5A0CALL, date_format) {
        ci = &ci_date_format;
        return true;
      }
      HASH_GUARD(0x4C67DEE74080E0CALL, magicksetimagecompose) {
        ci = &ci_magicksetimagecompose;
        return true;
      }
      break;
    case 206:
      HASH_GUARD(0x64E390E5F2FDC0CELL, ismagickwand) {
        ci = &ci_ismagickwand;
        return true;
      }
      break;
    case 210:
      HASH_GUARD(0x7D1FAF3322A360D2LL, hphp_splfileobject___construct) {
        ci = &ci_hphp_splfileobject___construct;
        return true;
      }
      HASH_GUARD(0x5365BD7509BE60D2LL, ldap_dn2ufn) {
        ci = &ci_ldap_dn2ufn;
        return true;
      }
      HASH_GUARD(0x3E4DAD592CD0A0D2LL, magickdescribeimage) {
        ci = &ci_magickdescribeimage;
        return true;
      }
      break;
    case 213:
      HASH_GUARD(0x3BF44C6DECD790D5LL, xmlwriter_start_dtd_entity) {
        ci = &ci_xmlwriter_start_dtd_entity;
        return true;
      }
      break;
    case 216:
      HASH_GUARD(0x79F2E516A3B070D8LL, libxml_disable_entity_loader) {
        ci = &ci_libxml_disable_entity_loader;
        return true;
      }
      break;
    case 217:
      HASH_GUARD(0x08F6B727D60670D9LL, magicksetimagedepth) {
        ci = &ci_magicksetimagedepth;
        return true;
      }
      break;
    case 218:
      HASH_GUARD(0x6F242340B2E930DALL, hphp_splfileinfo_setfileclass) {
        ci = &ci_hphp_splfileinfo_setfileclass;
        return true;
      }
      break;
    case 219:
      HASH_GUARD(0x3801923AD84670DBLL, apc_inc) {
        ci = &ci_apc_inc;
        return true;
      }
      break;
    case 224:
      HASH_GUARD(0x2E4612DF112010E0LL, imagecopyresized) {
        ci = &ci_imagecopyresized;
        return true;
      }
      break;
    case 228:
      HASH_GUARD(0x2B9425038D4230E4LL, imagecreatefromxpm) {
        ci = &ci_imagecreatefromxpm;
        return true;
      }
      break;
    case 231:
      HASH_GUARD(0x79E6FD78989B10E7LL, tmpfile) {
        ci = &ci_tmpfile;
        return true;
      }
      HASH_GUARD(0x59DE3A26AFF570E7LL, magickshaveimage) {
        ci = &ci_magickshaveimage;
        return true;
      }
      break;
    case 232:
      HASH_GUARD(0x476F4B6CC987E0E8LL, magickframeimage) {
        ci = &ci_magickframeimage;
        return true;
      }
      HASH_GUARD(0x17CB328F55FDF0E8LL, drawsetstrokeantialias) {
        ci = &ci_drawsetstrokeantialias;
        return true;
      }
      break;
    case 234:
      HASH_GUARD(0x53BA3992F8C240EALL, imagegrabwindow) {
        ci = &ci_imagegrabwindow;
        return true;
      }
      break;
    case 243:
      HASH_GUARD(0x315CCBC8C5C7D0F3LL, xmlwriter_write_raw) {
        ci = &ci_xmlwriter_write_raw;
        return true;
      }
      break;
    case 249:
      HASH_GUARD(0x480797DB7165A0F9LL, xmlwriter_set_indent) {
        ci = &ci_xmlwriter_set_indent;
        return true;
      }
      break;
    case 259:
      HASH_GUARD(0x1FFCBCF1927D7103LL, posix_setpgid) {
        ci = &ci_posix_setpgid;
        return true;
      }
      break;
    case 261:
      HASH_GUARD(0x71E3372AA1AD0105LL, is_infinite) {
        ci = &ci_is_infinite;
        return true;
      }
      HASH_GUARD(0x509B763CDAD9D105LL, gethostbyaddr) {
        ci = &ci_gethostbyaddr;
        return true;
      }
      break;
    case 264:
      HASH_GUARD(0x60B8B61133F59108LL, quoted_printable_decode) {
        ci = &ci_quoted_printable_decode;
        return true;
      }
      break;
    case 267:
      HASH_GUARD(0x7DE1BEE0C35D010BLL, pcntl_signal) {
        ci = &ci_pcntl_signal;
        return true;
      }
      break;
    case 272:
      HASH_GUARD(0x16B481D0DEA32110LL, call_user_func_async) {
        ci = &ci_call_user_func_async;
        return true;
      }
      break;
    case 273:
      HASH_GUARD(0x3A9A5D4FEE79A111LL, getmxrr) {
        ci = &ci_getmxrr;
        return true;
      }
      break;
    case 274:
      HASH_GUARD(0x0B1BA48B0CFB1112LL, strval) {
        ci = &ci_strval;
        return true;
      }
      HASH_GUARD(0x28C44527BD59D112LL, is_link) {
        ci = &ci_is_link;
        return true;
      }
      break;
    case 276:
      HASH_GUARD(0x02A4724E6A881114LL, mb_decode_numericentity) {
        ci = &ci_mb_decode_numericentity;
        return true;
      }
      break;
    case 281:
      HASH_GUARD(0x3AB82455A70F5119LL, imagecolortransparent) {
        ci = &ci_imagecolortransparent;
        return true;
      }
      HASH_GUARD(0x2B31A877824A1119LL, stristr) {
        ci = &ci_stristr;
        return true;
      }
      break;
    case 284:
      HASH_GUARD(0x070A63F6A0B8711CLL, array_walk_recursive) {
        ci = &ci_array_walk_recursive;
        return true;
      }
      break;
    case 285:
      HASH_GUARD(0x291088666B8BF11DLL, drawsetfontfamily) {
        ci = &ci_drawsetfontfamily;
        return true;
      }
      break;
    case 286:
      HASH_GUARD(0x658444BB4E29E11ELL, openssl_free_key) {
        ci = &ci_openssl_free_key;
        return true;
      }
      break;
    case 287:
      HASH_GUARD(0x4C70C24C84F5511FLL, magicksetimagegamma) {
        ci = &ci_magicksetimagegamma;
        return true;
      }
      break;
    case 291:
      HASH_GUARD(0x3669138315204123LL, mcrypt_module_get_algo_key_size) {
        ci = &ci_mcrypt_module_get_algo_key_size;
        return true;
      }
      break;
    case 292:
      HASH_GUARD(0x7D4D28D561392124LL, drawsettextalignment) {
        ci = &ci_drawsettextalignment;
        return true;
      }
      break;
    case 293:
      HASH_GUARD(0x7A8B3EC0235EF125LL, magickprofileimage) {
        ci = &ci_magickprofileimage;
        return true;
      }
      break;
    case 301:
      HASH_GUARD(0x7579DBE83CE5812DLL, imagerectangle) {
        ci = &ci_imagerectangle;
        return true;
      }
      break;
    case 307:
      HASH_GUARD(0x6A7E0B15FF689133LL, mb_ereg_search_init) {
        ci = &ci_mb_ereg_search_init;
        return true;
      }
      break;
    case 311:
      HASH_GUARD(0x5666016FA3C0F137LL, socket_clear_error) {
        ci = &ci_socket_clear_error;
        return true;
      }
      break;
    case 312:
      HASH_GUARD(0x2676902697E37138LL, xmlwriter_start_comment) {
        ci = &ci_xmlwriter_start_comment;
        return true;
      }
      break;
    case 314:
      HASH_GUARD(0x2A57E5D29D73D13ALL, register_tick_function) {
        ci = &ci_register_tick_function;
        return true;
      }
      break;
    case 315:
      HASH_GUARD(0x1F61AFCDC510413BLL, imagefilter) {
        ci = &ci_imagefilter;
        return true;
      }
      break;
    case 319:
      HASH_GUARD(0x5BFDE63106CE713FLL, dom_element_get_attribute) {
        ci = &ci_dom_element_get_attribute;
        return true;
      }
      break;
    case 323:
      HASH_GUARD(0x296C739F28D6C143LL, drawsetfontsize) {
        ci = &ci_drawsetfontsize;
        return true;
      }
      break;
    case 335:
      HASH_GUARD(0x61A61E91C477514FLL, chop) {
        ci = &ci_chop;
        return true;
      }
      HASH_GUARD(0x7863294A8F33D14FLL, file) {
        ci = &ci_file;
        return true;
      }
      break;
    case 337:
      HASH_GUARD(0x3044E9F91628E151LL, mb_strlen) {
        ci = &ci_mb_strlen;
        return true;
      }
      break;
    case 338:
      HASH_GUARD(0x5D170BCBBBA02152LL, system) {
        ci = &ci_system;
        return true;
      }
      HASH_GUARD(0x26DD46D8C1F47152LL, ldap_bind) {
        ci = &ci_ldap_bind;
        return true;
      }
      break;
    case 341:
      HASH_GUARD(0x2623917110168155LL, fclose) {
        ci = &ci_fclose;
        return true;
      }
      HASH_GUARD(0x4F43FE32079C0155LL, magickgetimagesblob) {
        ci = &ci_magickgetimagesblob;
        return true;
      }
      break;
    case 347:
      HASH_GUARD(0x3711AF36391EA15BLL, mysql_list_tables) {
        ci = &ci_mysql_list_tables;
        return true;
      }
      break;
    case 348:
      HASH_GUARD(0x6CD7466174B9A15CLL, pixelsetredquantum) {
        ci = &ci_pixelsetredquantum;
        return true;
      }
      break;
    case 349:
      HASH_GUARD(0x517941D034E3015DLL, iterator_to_array) {
        ci = &ci_iterator_to_array;
        return true;
      }
      break;
    case 353:
      HASH_GUARD(0x309E780586D6C161LL, socket_set_nonblock) {
        ci = &ci_socket_set_nonblock;
        return true;
      }
      break;
    case 355:
      HASH_GUARD(0x36D6B73D289DD163LL, date_sunset) {
        ci = &ci_date_sunset;
        return true;
      }
      break;
    case 360:
      HASH_GUARD(0x14E46EA3CBCFB168LL, magickgetsamplingfactors) {
        ci = &ci_magickgetsamplingfactors;
        return true;
      }
      break;
    case 361:
      HASH_GUARD(0x4983571BFEAE6169LL, magickaffinetransformimage) {
        ci = &ci_magickaffinetransformimage;
        return true;
      }
      HASH_GUARD(0x1612E331D1726169LL, drawsetstrokecolor) {
        ci = &ci_drawsetstrokecolor;
        return true;
      }
      break;
    case 366:
      HASH_GUARD(0x15B61E061268B16ELL, magickenhanceimage) {
        ci = &ci_magickenhanceimage;
        return true;
      }
      HASH_GUARD(0x0125F8B9428E416ELL, hphp_create_object) {
        ci = &ci_hphp_create_object;
        return true;
      }
      break;
    case 370:
      HASH_GUARD(0x59FE6A862E1CB172LL, get_browser) {
        ci = &ci_get_browser;
        return true;
      }
      break;
    case 372:
      HASH_GUARD(0x345E070844E3F174LL, create_function) {
        ci = &ci_create_function;
        return true;
      }
      break;
    case 375:
      HASH_GUARD(0x174DB93CAF0D1177LL, hphp_splfileinfo___tostring) {
        ci = &ci_hphp_splfileinfo___tostring;
        return true;
      }
      break;
    case 377:
      HASH_GUARD(0x6884FAF0D1EF3179LL, posix_mknod) {
        ci = &ci_posix_mknod;
        return true;
      }
      break;
    case 379:
      HASH_GUARD(0x59594143EFC7617BLL, mcrypt_module_open) {
        ci = &ci_mcrypt_module_open;
        return true;
      }
      break;
    case 380:
      HASH_GUARD(0x3E1343B4A3AD717CLL, magickgettextascent) {
        ci = &ci_magickgettextascent;
        return true;
      }
      break;
    case 383:
      HASH_GUARD(0x4EF9496D16F9D17FLL, xmlwriter_start_element_ns) {
        ci = &ci_xmlwriter_start_element_ns;
        return true;
      }
      break;
    case 385:
      HASH_GUARD(0x2227E30BAB23B181LL, dom_xpath_query) {
        ci = &ci_dom_xpath_query;
        return true;
      }
      HASH_GUARD(0x1CBD3B58296C8181LL, xmlwriter_write_dtd) {
        ci = &ci_xmlwriter_write_dtd;
        return true;
      }
      break;
    case 386:
      HASH_GUARD(0x7BB7C27B2C118182LL, get_magic_quotes_gpc) {
        ci = &ci_get_magic_quotes_gpc;
        return true;
      }
      HASH_GUARD(0x130B62A8C77F3182LL, mb_ereg_search_getregs) {
        ci = &ci_mb_ereg_search_getregs;
        return true;
      }
      break;
    case 389:
      HASH_GUARD(0x13E90F8874839185LL, ob_get_status) {
        ci = &ci_ob_get_status;
        return true;
      }
      HASH_GUARD(0x54DB5DC6A069A185LL, hphp_get_class_info) {
        ci = &ci_hphp_get_class_info;
        return true;
      }
      break;
    case 390:
      HASH_GUARD(0x5DB5E45860801186LL, openssl_csr_export) {
        ci = &ci_openssl_csr_export;
        return true;
      }
      break;
    case 391:
      HASH_GUARD(0x1BC448670BA4E187LL, iconv_strpos) {
        ci = &ci_iconv_strpos;
        return true;
      }
      break;
    case 393:
      HASH_GUARD(0x0CC53B2F0D38D189LL, timezone_offset_get) {
        ci = &ci_timezone_offset_get;
        return true;
      }
      break;
    case 402:
      HASH_GUARD(0x07B5BF934F6EA192LL, imagesettile) {
        ci = &ci_imagesettile;
        return true;
      }
      break;
    case 407:
      HASH_GUARD(0x15AD9CE061C75197LL, timezone_transitions_get) {
        ci = &ci_timezone_transitions_get;
        return true;
      }
      break;
    case 409:
      HASH_GUARD(0x0CE71BC3B75D8199LL, mb_strimwidth) {
        ci = &ci_mb_strimwidth;
        return true;
      }
      break;
    case 411:
      HASH_GUARD(0x7FF6C2A693CE119BLL, magickcyclecolormapimage) {
        ci = &ci_magickcyclecolormapimage;
        return true;
      }
      HASH_GUARD(0x74F20C284227219BLL, similar_text) {
        ci = &ci_similar_text;
        return true;
      }
      break;
    case 416:
      HASH_GUARD(0x6FB5104FC97A31A0LL, drawpathcurvetorelative) {
        ci = &ci_drawpathcurvetorelative;
        return true;
      }
      break;
    case 418:
      HASH_GUARD(0x6DFC0765EBAB81A2LL, mcrypt_decrypt) {
        ci = &ci_mcrypt_decrypt;
        return true;
      }
      HASH_GUARD(0x2A9015499A2EB1A2LL, fnmatch) {
        ci = &ci_fnmatch;
        return true;
      }
      HASH_GUARD(0x615723D21421A1A2LL, sem_remove) {
        ci = &ci_sem_remove;
        return true;
      }
      break;
    case 419:
      HASH_GUARD(0x735B81C45C2971A3LL, drawgetfillopacity) {
        ci = &ci_drawgetfillopacity;
        return true;
      }
      break;
    case 422:
      HASH_GUARD(0x37B4612178EF91A6LL, memcache_get_version) {
        ci = &ci_memcache_get_version;
        return true;
      }
      break;
    case 425:
      HASH_GUARD(0x740DC7FFAD8BB1A9LL, imagecolorat) {
        ci = &ci_imagecolorat;
        return true;
      }
      HASH_GUARD(0x0DDFE3B1F6EEE1A9LL, array_reduce) {
        ci = &ci_array_reduce;
        return true;
      }
      break;
    case 426:
      HASH_GUARD(0x11A5C66A3D0711AALL, apc_sma_info) {
        ci = &ci_apc_sma_info;
        return true;
      }
      break;
    case 429:
      HASH_GUARD(0x5A6EFF8C71A431ADLL, socket_get_status) {
        ci = &ci_socket_get_status;
        return true;
      }
      HASH_GUARD(0x50538F37398AF1ADLL, ldap_get_option) {
        ci = &ci_ldap_get_option;
        return true;
      }
      break;
    case 431:
      HASH_GUARD(0x5B1F9C2E9FE111AFLL, fb_utf8ize) {
        ci = &ci_fb_utf8ize;
        return true;
      }
      break;
    case 434:
      HASH_GUARD(0x4B96F870584541B2LL, hphp_splfileobject_setflags) {
        ci = &ci_hphp_splfileobject_setflags;
        return true;
      }
      break;
    case 438:
      HASH_GUARD(0x33BD672B4AC301B6LL, mt_rand) {
        ci = &ci_mt_rand;
        return true;
      }
      break;
    case 445:
      HASH_GUARD(0x589F7316EDC581BDLL, fb_serialize) {
        ci = &ci_fb_serialize;
        return true;
      }
      HASH_GUARD(0x4B3F35310DEA31BDLL, socket_create_pair) {
        ci = &ci_socket_create_pair;
        return true;
      }
      break;
    case 447:
      HASH_GUARD(0x0E88ACEB15A581BFLL, magickgetimageextrema) {
        ci = &ci_magickgetimageextrema;
        return true;
      }
      HASH_GUARD(0x681CD0E7D9DB71BFLL, pow) {
        ci = &ci_pow;
        return true;
      }
      break;
    case 450:
      HASH_GUARD(0x02103322F88C71C2LL, pixelgetcolorcount) {
        ci = &ci_pixelgetcolorcount;
        return true;
      }
      break;
    case 452:
      HASH_GUARD(0x3617DAE43A23D1C4LL, xml_parser_set_option) {
        ci = &ci_xml_parser_set_option;
        return true;
      }
      break;
    case 454:
      HASH_GUARD(0x188D37410B6051C6LL, session_unregister) {
        ci = &ci_session_unregister;
        return true;
      }
      break;
    case 455:
      HASH_GUARD(0x5AE12CB1FFDC21C7LL, drawellipse) {
        ci = &ci_drawellipse;
        return true;
      }
      break;
    case 456:
      HASH_GUARD(0x11C0B5DA066891C8LL, preg_match_all) {
        ci = &ci_preg_match_all;
        return true;
      }
      break;
    case 458:
      HASH_GUARD(0x75CA86838D24A1CALL, hash_algos) {
        ci = &ci_hash_algos;
        return true;
      }
      break;
    case 460:
      HASH_GUARD(0x3DF488365DAAF1CCLL, drawgettextencoding) {
        ci = &ci_drawgettextencoding;
        return true;
      }
      break;
    case 461:
      HASH_GUARD(0x37340B707E7CD1CDLL, magickgetimagebordercolor) {
        ci = &ci_magickgetimagebordercolor;
        return true;
      }
      break;
    case 462:
      HASH_GUARD(0x2E7741B5440FB1CELL, magicksetlastiterator) {
        ci = &ci_magicksetlastiterator;
        return true;
      }
      break;
    case 464:
      HASH_GUARD(0x03012F3DDD7AB1D0LL, getservbyport) {
        ci = &ci_getservbyport;
        return true;
      }
      break;
    case 468:
      HASH_GUARD(0x219F3257BA3371D4LL, decbin) {
        ci = &ci_decbin;
        return true;
      }
      break;
    case 470:
      HASH_GUARD(0x78831282736801D6LL, stream_context_get_default) {
        ci = &ci_stream_context_get_default;
        return true;
      }
      break;
    case 472:
      HASH_GUARD(0x60E9E392663921D8LL, readlink) {
        ci = &ci_readlink;
        return true;
      }
      break;
    case 473:
      HASH_GUARD(0x7A69D0078F4F31D9LL, ldap_start_tls) {
        ci = &ci_ldap_start_tls;
        return true;
      }
      break;
    case 474:
      HASH_GUARD(0x0482E069503A91DALL, posix_setgid) {
        ci = &ci_posix_setgid;
        return true;
      }
      break;
    case 475:
      HASH_GUARD(0x3FEBBC0DA79F31DBLL, fb_call_user_func_safe) {
        ci = &ci_fb_call_user_func_safe;
        return true;
      }
      break;
    case 476:
      HASH_GUARD(0x14FB46333D6D11DCLL, xml_set_default_handler) {
        ci = &ci_xml_set_default_handler;
        return true;
      }
      HASH_GUARD(0x5B3A4A72846B21DCLL, current) {
        ci = &ci_current;
        return true;
      }
      break;
    case 477:
      HASH_GUARD(0x04666D6F67C7A1DDLL, mysql_list_processes) {
        ci = &ci_mysql_list_processes;
        return true;
      }
      HASH_GUARD(0x03A183D73942B1DDLL, apc_filehits) {
        ci = &ci_apc_filehits;
        return true;
      }
      break;
    case 478:
      HASH_GUARD(0x44563CC8FA9B11DELL, memcache_set_server_params) {
        ci = &ci_memcache_set_server_params;
        return true;
      }
      break;
    case 479:
      HASH_GUARD(0x7403251412E931DFLL, syslog) {
        ci = &ci_syslog;
        return true;
      }
      break;
    case 480:
      HASH_GUARD(0x5932D2750A8A91E0LL, magickgetpackagename) {
        ci = &ci_magickgetpackagename;
        return true;
      }
      break;
    case 481:
      HASH_GUARD(0x2771C632A60371E1LL, ftok) {
        ci = &ci_ftok;
        return true;
      }
      HASH_GUARD(0x0ED729A444C611E1LL, openssl_x509_read) {
        ci = &ci_openssl_x509_read;
        return true;
      }
      break;
    case 482:
      HASH_GUARD(0x67D4BA8513BF41E2LL, newpixelwand) {
        ci = &ci_newpixelwand;
        return true;
      }
      break;
    case 483:
      HASH_GUARD(0x131D11F79A8801E3LL, mb_http_output) {
        ci = &ci_mb_http_output;
        return true;
      }
      HASH_GUARD(0x406BDC51A3FD81E3LL, pcntl_waitpid) {
        ci = &ci_pcntl_waitpid;
        return true;
      }
      break;
    case 484:
      HASH_GUARD(0x08F7A6C37FC7B1E4LL, shm_get_var) {
        ci = &ci_shm_get_var;
        return true;
      }
      break;
    case 488:
      HASH_GUARD(0x7F843353646391E8LL, rad2deg) {
        ci = &ci_rad2deg;
        return true;
      }
      break;
    case 493:
      HASH_GUARD(0x1B09A9A533FFA1EDLL, drawgetexceptiontype) {
        ci = &ci_drawgetexceptiontype;
        return true;
      }
      HASH_GUARD(0x19932EEC5CAE01EDLL, hphp_splfileinfo_getfileinfo) {
        ci = &ci_hphp_splfileinfo_getfileinfo;
        return true;
      }
      break;
    case 497:
      HASH_GUARD(0x02BCE5B0FBED61F1LL, strlen) {
        ci = &ci_strlen;
        return true;
      }
      break;
    case 498:
      HASH_GUARD(0x46AFE55982B371F2LL, posix_geteuid) {
        ci = &ci_posix_geteuid;
        return true;
      }
      break;
    case 499:
      HASH_GUARD(0x582D10141D5601F3LL, stream_context_set_option) {
        ci = &ci_stream_context_set_option;
        return true;
      }
      HASH_GUARD(0x11BB3CDC5E4971F3LL, xmlwriter_end_pi) {
        ci = &ci_xmlwriter_end_pi;
        return true;
      }
      break;
    case 501:
      HASH_GUARD(0x542FBDCF960031F5LL, fprintf) {
        ci = &ci_fprintf;
        return true;
      }
      HASH_GUARD(0x02ABC00C046291F5LL, imageellipse) {
        ci = &ci_imageellipse;
        return true;
      }
      break;
    case 502:
      HASH_GUARD(0x06DAF95935D221F6LL, dom_namednodemap_item) {
        ci = &ci_dom_namednodemap_item;
        return true;
      }
      break;
    case 506:
      HASH_GUARD(0x135D5CBF936B11FALL, msg_receive) {
        ci = &ci_msg_receive;
        return true;
      }
      break;
    case 509:
      HASH_GUARD(0x5304E6B47ED0B1FDLL, srand) {
        ci = &ci_srand;
        return true;
      }
      break;
    case 514:
      HASH_GUARD(0x16699E33370A8202LL, idn_to_unicode) {
        ci = &ci_idn_to_unicode;
        return true;
      }
      break;
    case 515:
      HASH_GUARD(0x5B3C354575BB8203LL, mysql_free_result) {
        ci = &ci_mysql_free_result;
        return true;
      }
      break;
    case 520:
      HASH_GUARD(0x7B525920E026C208LL, gztell) {
        ci = &ci_gztell;
        return true;
      }
      break;
    case 523:
      HASH_GUARD(0x2F5144AB3647C20BLL, dom_text_is_whitespace_in_element_content) {
        ci = &ci_dom_text_is_whitespace_in_element_content;
        return true;
      }
      break;
    case 524:
      HASH_GUARD(0x41B15671649A320CLL, curl_multi_getcontent) {
        ci = &ci_curl_multi_getcontent;
        return true;
      }
      HASH_GUARD(0x257BEA4D6DC9920CLL, ctype_alnum) {
        ci = &ci_ctype_alnum;
        return true;
      }
      break;
    case 525:
      HASH_GUARD(0x5C0DECC8CC67E20DLL, magickwriteimagesfile) {
        ci = &ci_magickwriteimagesfile;
        return true;
      }
      break;
    case 526:
      HASH_GUARD(0x533642044A00520ELL, pixelgetmagentaquantum) {
        ci = &ci_pixelgetmagentaquantum;
        return true;
      }
      break;
    case 527:
      HASH_GUARD(0x08DC8BF3ADAE520FLL, getallheaders) {
        ci = &ci_getallheaders;
        return true;
      }
      HASH_GUARD(0x53631CF3A937320FLL, get_class_methods) {
        ci = &ci_get_class_methods;
        return true;
      }
      break;
    case 528:
      HASH_GUARD(0x15EF510022CAF210LL, xml_parser_create_ns) {
        ci = &ci_xml_parser_create_ns;
        return true;
      }
      HASH_GUARD(0x2D41D7F8F4113210LL, sinh) {
        ci = &ci_sinh;
        return true;
      }
      break;
    case 529:
      HASH_GUARD(0x438CD1A0327A8211LL, apc_define_constants) {
        ci = &ci_apc_define_constants;
        return true;
      }
      break;
    case 532:
      HASH_GUARD(0x7D85E9FACB92D214LL, magickgetimageblob) {
        ci = &ci_magickgetimageblob;
        return true;
      }
      break;
    case 535:
      HASH_GUARD(0x4BC4B81CC5F32217LL, dom_node_append_child) {
        ci = &ci_dom_node_append_child;
        return true;
      }
      break;
    case 536:
      HASH_GUARD(0x56C95225813A5218LL, memory_get_usage) {
        ci = &ci_memory_get_usage;
        return true;
      }
      HASH_GUARD(0x4D63F2C9AAB79218LL, fb_renamed_functions) {
        ci = &ci_fb_renamed_functions;
        return true;
      }
      break;
    case 538:
      HASH_GUARD(0x72C0C89D897E721ALL, magicksetimagetype) {
        ci = &ci_magicksetimagetype;
        return true;
      }
      break;
    case 539:
      HASH_GUARD(0x3A90CC67D58A021BLL, hash_hmac_file) {
        ci = &ci_hash_hmac_file;
        return true;
      }
      break;
    case 545:
      HASH_GUARD(0x345E2BAE171FA221LL, date_sunrise) {
        ci = &ci_date_sunrise;
        return true;
      }
      break;
    case 546:
      HASH_GUARD(0x39E4E0175FADC222LL, drawskewx) {
        ci = &ci_drawskewx;
        return true;
      }
      break;
    case 547:
      HASH_GUARD(0x5208E8B08455E223LL, dom_node_has_child_nodes) {
        ci = &ci_dom_node_has_child_nodes;
        return true;
      }
      break;
    case 550:
      HASH_GUARD(0x007B6BD94D767226LL, hphp_splfileobject_fpassthru) {
        ci = &ci_hphp_splfileobject_fpassthru;
        return true;
      }
      break;
    case 551:
      HASH_GUARD(0x5A26F00A81BA5227LL, xmlwriter_start_attribute_ns) {
        ci = &ci_xmlwriter_start_attribute_ns;
        return true;
      }
      break;
    case 552:
      HASH_GUARD(0x44911AEE34D63228LL, time_sleep_until) {
        ci = &ci_time_sleep_until;
        return true;
      }
      HASH_GUARD(0x7CD3C6F6495D3228LL, memcache_get_stats) {
        ci = &ci_memcache_get_stats;
        return true;
      }
      break;
    case 556:
      HASH_GUARD(0x4129FFBF3548E22CLL, mb_strpos) {
        ci = &ci_mb_strpos;
        return true;
      }
      break;
    case 558:
      HASH_GUARD(0x0B7559F53F31D22ELL, fb_stubout_intercept_handler) {
        ci = &ci_fb_stubout_intercept_handler;
        return true;
      }
      break;
    case 560:
      HASH_GUARD(0x036A5935D9936230LL, hphp_splfileinfo_openfile) {
        ci = &ci_hphp_splfileinfo_openfile;
        return true;
      }
      break;
    case 561:
      HASH_GUARD(0x61A192D10C004231LL, magickconvolveimage) {
        ci = &ci_magickconvolveimage;
        return true;
      }
      HASH_GUARD(0x7C07D66F70E43231LL, mailparse_determine_best_xfer_encoding) {
        ci = &ci_mailparse_determine_best_xfer_encoding;
        return true;
      }
      break;
    case 564:
      HASH_GUARD(0x23C478B2D95F3234LL, dom_element_has_attribute_ns) {
        ci = &ci_dom_element_has_attribute_ns;
        return true;
      }
      HASH_GUARD(0x422C51C95928A234LL, str_replace) {
        ci = &ci_str_replace;
        return true;
      }
      break;
    case 566:
      HASH_GUARD(0x5542AABF33A2F236LL, stream_filter_remove) {
        ci = &ci_stream_filter_remove;
        return true;
      }
      break;
    case 568:
      HASH_GUARD(0x695AC59F79E2A238LL, mb_encode_mimeheader) {
        ci = &ci_mb_encode_mimeheader;
        return true;
      }
      break;
    case 570:
      HASH_GUARD(0x679ABBE5A08C523ALL, xml_parse_into_struct) {
        ci = &ci_xml_parse_into_struct;
        return true;
      }
      break;
    case 574:
      HASH_GUARD(0x5E54CE856B78223ELL, array_flip) {
        ci = &ci_array_flip;
        return true;
      }
      break;
    case 576:
      HASH_GUARD(0x0DB9DD4AE24B0240LL, base64_encode) {
        ci = &ci_base64_encode;
        return true;
      }
      break;
    case 579:
      HASH_GUARD(0x78183A24F2ACB243LL, strtotime) {
        ci = &ci_strtotime;
        return true;
      }
      break;
    case 584:
      HASH_GUARD(0x7071BB6F0591E248LL, serialize) {
        ci = &ci_serialize;
        return true;
      }
      break;
    case 589:
      HASH_GUARD(0x5E73B9F3B7C8224DLL, parse_hdf_string) {
        ci = &ci_parse_hdf_string;
        return true;
      }
      break;
    case 591:
      HASH_GUARD(0x1D8FE8E68F7EA24FLL, pixelsetiteratorrow) {
        ci = &ci_pixelsetiteratorrow;
        return true;
      }
      break;
    case 592:
      HASH_GUARD(0x30747B708DA1D250LL, pushdrawingwand) {
        ci = &ci_pushdrawingwand;
        return true;
      }
      break;
    case 598:
      HASH_GUARD(0x0384346A8857D256LL, clonemagickwand) {
        ci = &ci_clonemagickwand;
        return true;
      }
      break;
    case 600:
      HASH_GUARD(0x32C51FFF185F4258LL, memcache_set) {
        ci = &ci_memcache_set;
        return true;
      }
      break;
    case 603:
      HASH_GUARD(0x2F8F40E95EDF925BLL, sizeof) {
        ci = &ci_sizeof;
        return true;
      }
      break;
    case 605:
      HASH_GUARD(0x7E6024E53AEEE25DLL, apc_delete) {
        ci = &ci_apc_delete;
        return true;
      }
      break;
    case 608:
      HASH_GUARD(0x71D2D4757B7E4260LL, apache_request_headers) {
        ci = &ci_apache_request_headers;
        return true;
      }
      break;
    case 609:
      HASH_GUARD(0x48305E8ABB8BC261LL, hphp_instanceof) {
        ci = &ci_hphp_instanceof;
        return true;
      }
      break;
    case 610:
      HASH_GUARD(0x63AC0EED6D946262LL, pcntl_fork) {
        ci = &ci_pcntl_fork;
        return true;
      }
      break;
    case 612:
      HASH_GUARD(0x261F403C4174D264LL, posix_getsid) {
        ci = &ci_posix_getsid;
        return true;
      }
      break;
    case 613:
      HASH_GUARD(0x561DB8F1DC0BC265LL, magickseparateimagechannel) {
        ci = &ci_magickseparateimagechannel;
        return true;
      }
      break;
    case 615:
      HASH_GUARD(0x50C5488E19492267LL, mb_list_encodings_alias_names) {
        ci = &ci_mb_list_encodings_alias_names;
        return true;
      }
      HASH_GUARD(0x38B376B9D9091267LL, xmlwriter_write_attribute) {
        ci = &ci_xmlwriter_write_attribute;
        return true;
      }
      break;
    case 620:
      HASH_GUARD(0x188DF1EB5FD1B26CLL, mailparse_msg_parse_file) {
        ci = &ci_mailparse_msg_parse_file;
        return true;
      }
      break;
    case 622:
      HASH_GUARD(0x5672949384A4F26ELL, stream_filter_register) {
        ci = &ci_stream_filter_register;
        return true;
      }
      break;
    case 626:
      HASH_GUARD(0x1C65F32FF28BC272LL, pathinfo) {
        ci = &ci_pathinfo;
        return true;
      }
      break;
    case 627:
      HASH_GUARD(0x61C991F216E85273LL, inet_ntop) {
        ci = &ci_inet_ntop;
        return true;
      }
      HASH_GUARD(0x08CC1E49661DB273LL, dom_element_get_attribute_ns) {
        ci = &ci_dom_element_get_attribute_ns;
        return true;
      }
      break;
    case 634:
      HASH_GUARD(0x39E05F957C7DD27ALL, magickgetimagedepth) {
        ci = &ci_magickgetimagedepth;
        return true;
      }
      break;
    case 636:
      HASH_GUARD(0x0F7E33D551E0727CLL, posix_getpid) {
        ci = &ci_posix_getpid;
        return true;
      }
      break;
    case 637:
      HASH_GUARD(0x7DB57C59E607627DLL, mcrypt_generic_deinit) {
        ci = &ci_mcrypt_generic_deinit;
        return true;
      }
      break;
    case 638:
      HASH_GUARD(0x4111669F4862E27ELL, drawpathlinetoverticalrelative) {
        ci = &ci_drawpathlinetoverticalrelative;
        return true;
      }
      break;
    case 639:
      HASH_GUARD(0x5B94A6962F1EC27FLL, magickechoimagesblob) {
        ci = &ci_magickechoimagesblob;
        return true;
      }
      HASH_GUARD(0x57E8781CF111727FLL, fileowner) {
        ci = &ci_fileowner;
        return true;
      }
      break;
    case 640:
      HASH_GUARD(0x2E54EF1891172280LL, hphp_splfileinfo_isexecutable) {
        ci = &ci_hphp_splfileinfo_isexecutable;
        return true;
      }
      break;
    case 641:
      HASH_GUARD(0x1765A2E5186DE281LL, socket_write) {
        ci = &ci_socket_write;
        return true;
      }
      HASH_GUARD(0x0881440DCF5D3281LL, magickflattenimages) {
        ci = &ci_magickflattenimages;
        return true;
      }
      break;
    case 643:
      HASH_GUARD(0x4C83B098C8BDA283LL, posix_setsid) {
        ci = &ci_posix_setsid;
        return true;
      }
      break;
    case 645:
      HASH_GUARD(0x5F7DC3612050A285LL, drawsetfontweight) {
        ci = &ci_drawsetfontweight;
        return true;
      }
      HASH_GUARD(0x1A895A2307126285LL, openssl_pkcs7_decrypt) {
        ci = &ci_openssl_pkcs7_decrypt;
        return true;
      }
      break;
    case 646:
      HASH_GUARD(0x3A2E2C40B019E286LL, is_a) {
        ci = &ci_is_a;
        return true;
      }
      HASH_GUARD(0x4F028FA6AAEEC286LL, call_user_method) {
        ci = &ci_call_user_method;
        return true;
      }
      break;
    case 647:
      HASH_GUARD(0x27698DDEDAD6E287LL, openssl_pkey_new) {
        ci = &ci_openssl_pkey_new;
        return true;
      }
      HASH_GUARD(0x23A1E13930E44287LL, xbox_schedule_thread_reset) {
        ci = &ci_xbox_schedule_thread_reset;
        return true;
      }
      break;
    case 656:
      HASH_GUARD(0x04C11602C720A290LL, convert_cyr_string) {
        ci = &ci_convert_cyr_string;
        return true;
      }
      break;
    case 660:
      HASH_GUARD(0x4D05DD57E4052294LL, xmlwriter_output_memory) {
        ci = &ci_xmlwriter_output_memory;
        return true;
      }
      break;
    case 661:
      HASH_GUARD(0x69868C648BC12295LL, apc_store) {
        ci = &ci_apc_store;
        return true;
      }
      break;
    case 665:
      HASH_GUARD(0x22D380E06E67E299LL, stream_encoding) {
        ci = &ci_stream_encoding;
        return true;
      }
      HASH_GUARD(0x5665CB664C38A299LL, parse_ini_string) {
        ci = &ci_parse_ini_string;
        return true;
      }
      break;
    case 666:
      HASH_GUARD(0x68272A37CC9E729ALL, mb_strtolower) {
        ci = &ci_mb_strtolower;
        return true;
      }
      HASH_GUARD(0x24BD9EBDC721E29ALL, hphp_debug_caller_info) {
        ci = &ci_hphp_debug_caller_info;
        return true;
      }
      break;
    case 667:
      HASH_GUARD(0x4A09634AE6DFF29BLL, fileperms) {
        ci = &ci_fileperms;
        return true;
      }
      break;
    case 668:
      HASH_GUARD(0x0F71D3E47044E29CLL, drawpathcurvetosmoothrelative) {
        ci = &ci_drawpathcurvetosmoothrelative;
        return true;
      }
      break;
    case 674:
      HASH_GUARD(0x1FBF8A270331C2A2LL, write_hdf_file) {
        ci = &ci_write_hdf_file;
        return true;
      }
      break;
    case 675:
      HASH_GUARD(0x10E7B5A0E29CF2A3LL, bcscale) {
        ci = &ci_bcscale;
        return true;
      }
      HASH_GUARD(0x743EA4BF2CC8F2A3LL, mysql_field_type) {
        ci = &ci_mysql_field_type;
        return true;
      }
      break;
    case 678:
      HASH_GUARD(0x73EF3A19F76872A6LL, iconv_strrpos) {
        ci = &ci_iconv_strrpos;
        return true;
      }
      break;
    case 680:
      HASH_GUARD(0x5409127FEDE332A8LL, exif_imagetype) {
        ci = &ci_exif_imagetype;
        return true;
      }
      break;
    case 685:
      HASH_GUARD(0x35D259398CDDA2ADLL, pixelgetredquantum) {
        ci = &ci_pixelgetredquantum;
        return true;
      }
      HASH_GUARD(0x00AB6FC4E9EE62ADLL, imagefilledrectangle) {
        ci = &ci_imagefilledrectangle;
        return true;
      }
      break;
    case 686:
      HASH_GUARD(0x36AB9E6AA687F2AELL, xmlwriter_start_dtd_element) {
        ci = &ci_xmlwriter_start_dtd_element;
        return true;
      }
      break;
    case 691:
      HASH_GUARD(0x44530C37F2B522B3LL, drawgetstrokedasharray) {
        ci = &ci_drawgetstrokedasharray;
        return true;
      }
      HASH_GUARD(0x59BB7B8078AC22B3LL, tempnam) {
        ci = &ci_tempnam;
        return true;
      }
      break;
    case 694:
      HASH_GUARD(0x0C4B98B47B0862B6LL, apd_echo) {
        ci = &ci_apd_echo;
        return true;
      }
      HASH_GUARD(0x0E9C9B409F94B2B6LL, setcookie) {
        ci = &ci_setcookie;
        return true;
      }
      break;
    case 696:
      HASH_GUARD(0x3C6D50F3BB8102B8LL, next) {
        ci = &ci_next;
        return true;
      }
      break;
    case 698:
      HASH_GUARD(0x4A3D2113D3DFD2BALL, newpixelwandarray) {
        ci = &ci_newpixelwandarray;
        return true;
      }
      break;
    case 700:
      HASH_GUARD(0x33E08846F3EB42BCLL, ldap_get_values) {
        ci = &ci_ldap_get_values;
        return true;
      }
      HASH_GUARD(0x41F7E2214DDE12BCLL, mcrypt_enc_self_test) {
        ci = &ci_mcrypt_enc_self_test;
        return true;
      }
      break;
    case 701:
      HASH_GUARD(0x327C865E52FD12BDLL, ldap_get_values_len) {
        ci = &ci_ldap_get_values_len;
        return true;
      }
      break;
    case 702:
      HASH_GUARD(0x72D6F9B3661AB2BELL, magickgetimage) {
        ci = &ci_magickgetimage;
        return true;
      }
      break;
    case 704:
      HASH_GUARD(0x5B7C1B74BA3452C0LL, newpixelregioniterator) {
        ci = &ci_newpixelregioniterator;
        return true;
      }
      break;
    case 707:
      HASH_GUARD(0x446D76A95365D2C3LL, pixelgetyellow) {
        ci = &ci_pixelgetyellow;
        return true;
      }
      break;
    case 708:
      HASH_GUARD(0x6018C9F7DF40C2C4LL, xml_get_current_column_number) {
        ci = &ci_xml_get_current_column_number;
        return true;
      }
      HASH_GUARD(0x1C7B8161F3C412C4LL, dom_document_create_document_fragment) {
        ci = &ci_dom_document_create_document_fragment;
        return true;
      }
      break;
    case 716:
      HASH_GUARD(0x407EF03C23BF92CCLL, drawpathellipticarcabsolute) {
        ci = &ci_drawpathellipticarcabsolute;
        return true;
      }
      HASH_GUARD(0x44273F8BA3F542CCLL, imagesx) {
        ci = &ci_imagesx;
        return true;
      }
      break;
    case 718:
      HASH_GUARD(0x1922D51F3E1522CELL, xmlwriter_end_dtd_attlist) {
        ci = &ci_xmlwriter_end_dtd_attlist;
        return true;
      }
      break;
    case 719:
      HASH_GUARD(0x4ACE27EC476632CFLL, apc_bin_dumpfile) {
        ci = &ci_apc_bin_dumpfile;
        return true;
      }
      break;
    case 722:
      HASH_GUARD(0x4D9A87BD0CF742D2LL, imagepsextendfont) {
        ci = &ci_imagepsextendfont;
        return true;
      }
      break;
    case 725:
      HASH_GUARD(0x4D04C580CF9212D5LL, posix_getgroups) {
        ci = &ci_posix_getgroups;
        return true;
      }
      break;
    case 726:
      HASH_GUARD(0x06E9C984B5F0B2D6LL, furchash_hphp_ext) {
        ci = &ci_furchash_hphp_ext;
        return true;
      }
      break;
    case 728:
      HASH_GUARD(0x56C4896BA2FF52D8LL, drawsetstrokeopacity) {
        ci = &ci_drawsetstrokeopacity;
        return true;
      }
      break;
    case 730:
      HASH_GUARD(0x5C6A85B448C352DALL, posix_uname) {
        ci = &ci_posix_uname;
        return true;
      }
      break;
    case 733:
      HASH_GUARD(0x5F585DF7CB82E2DDLL, hphp_splfileinfo_iswritable) {
        ci = &ci_hphp_splfileinfo_iswritable;
        return true;
      }
      break;
    case 738:
      HASH_GUARD(0x4AEC19D75BF652E2LL, magickremoveimage) {
        ci = &ci_magickremoveimage;
        return true;
      }
      break;
    case 739:
      HASH_GUARD(0x45382D0BA5B262E3LL, mysql_get_proto_info) {
        ci = &ci_mysql_get_proto_info;
        return true;
      }
      break;
    case 749:
      HASH_GUARD(0x1B9FC9E27B8AB2EDLL, memcache_flush) {
        ci = &ci_memcache_flush;
        return true;
      }
      HASH_GUARD(0x215E0E2EFA7422EDLL, drawgetstrokeantialias) {
        ci = &ci_drawgetstrokeantialias;
        return true;
      }
      break;
    case 750:
      HASH_GUARD(0x5D43C0E4868EC2EELL, forward_static_call) {
        ci = &ci_forward_static_call;
        return true;
      }
      HASH_GUARD(0x2884B7B3252B02EELL, imagealphablending) {
        ci = &ci_imagealphablending;
        return true;
      }
      break;
    case 752:
      HASH_GUARD(0x25CA0794823AA2F0LL, openssl_csr_get_public_key) {
        ci = &ci_openssl_csr_get_public_key;
        return true;
      }
      break;
    case 754:
      HASH_GUARD(0x2EE56D216BB832F2LL, time_nanosleep) {
        ci = &ci_time_nanosleep;
        return true;
      }
      break;
    case 756:
      HASH_GUARD(0x418EC805C5FD32F4LL, mcrypt_get_key_size) {
        ci = &ci_mcrypt_get_key_size;
        return true;
      }
      break;
    case 761:
      HASH_GUARD(0x00CFD56391DF82F9LL, mysql_data_seek) {
        ci = &ci_mysql_data_seek;
        return true;
      }
      HASH_GUARD(0x319EF52B36AAB2F9LL, posix_isatty) {
        ci = &ci_posix_isatty;
        return true;
      }
      break;
    case 763:
      HASH_GUARD(0x4D393D30CE1112FBLL, drawpathmovetoabsolute) {
        ci = &ci_drawpathmovetoabsolute;
        return true;
      }
      break;
    case 764:
      HASH_GUARD(0x66D59E4DBC7382FCLL, drawscale) {
        ci = &ci_drawscale;
        return true;
      }
      break;
    case 766:
      HASH_GUARD(0x208B66A8731F72FELL, sem_get) {
        ci = &ci_sem_get;
        return true;
      }
      HASH_GUARD(0x755A9950B65472FELL, drawgetgravity) {
        ci = &ci_drawgetgravity;
        return true;
      }
      break;
    case 770:
      HASH_GUARD(0x0103FE1E2C307302LL, socket_recvfrom) {
        ci = &ci_socket_recvfrom;
        return true;
      }
      break;
    case 772:
      HASH_GUARD(0x33A532FDB8EAC304LL, memcache_delete) {
        ci = &ci_memcache_delete;
        return true;
      }
      break;
    case 773:
      HASH_GUARD(0x65D40C6B4842F305LL, clearpixelwand) {
        ci = &ci_clearpixelwand;
        return true;
      }
      break;
    case 774:
      HASH_GUARD(0x689D60184DD81306LL, htmlspecialchars_decode) {
        ci = &ci_htmlspecialchars_decode;
        return true;
      }
      break;
    case 777:
      HASH_GUARD(0x414038596F552309LL, magickgetversionnumber) {
        ci = &ci_magickgetversionnumber;
        return true;
      }
      HASH_GUARD(0x47CB27E8FDB60309LL, array_fill) {
        ci = &ci_array_fill;
        return true;
      }
      break;
    case 779:
      HASH_GUARD(0x0C6F751411F5E30BLL, strrev) {
        ci = &ci_strrev;
        return true;
      }
      HASH_GUARD(0x65F586C35A88030BLL, magickresizeimage) {
        ci = &ci_magickresizeimage;
        return true;
      }
      HASH_GUARD(0x2D2BC1125ECA930BLL, dom_document_relaxng_validate_file) {
        ci = &ci_dom_document_relaxng_validate_file;
        return true;
      }
      break;
    case 780:
      HASH_GUARD(0x553940FCE453330CLL, hphp_splfileobject_getmaxlinelen) {
        ci = &ci_hphp_splfileobject_getmaxlinelen;
        return true;
      }
      break;
    case 785:
      HASH_GUARD(0x141EDCAE1D155311LL, xbox_get_thread_time) {
        ci = &ci_xbox_get_thread_time;
        return true;
      }
      break;
    case 789:
      HASH_GUARD(0x4F1E663AE18FD315LL, msg_remove_queue) {
        ci = &ci_msg_remove_queue;
        return true;
      }
      break;
    case 798:
      HASH_GUARD(0x27FF9DB54420531ELL, xml_error_string) {
        ci = &ci_xml_error_string;
        return true;
      }
      break;
    case 804:
      HASH_GUARD(0x5E5E4F998C8E7324LL, pcntl_wifexited) {
        ci = &ci_pcntl_wifexited;
        return true;
      }
      break;
    case 808:
      HASH_GUARD(0x73FEB3BF75FFB328LL, ctype_space) {
        ci = &ci_ctype_space;
        return true;
      }
      break;
    case 811:
      HASH_GUARD(0x2BDB1EE3869E132BLL, restore_error_handler) {
        ci = &ci_restore_error_handler;
        return true;
      }
      break;
    case 815:
      HASH_GUARD(0x7DD6461A6290B32FLL, mysql_real_escape_string) {
        ci = &ci_mysql_real_escape_string;
        return true;
      }
      break;
    case 816:
      HASH_GUARD(0x300F758BB0E16330LL, mysql_num_rows) {
        ci = &ci_mysql_num_rows;
        return true;
      }
      HASH_GUARD(0x1601C1826E90B330LL, strptime) {
        ci = &ci_strptime;
        return true;
      }
      break;
    case 817:
      HASH_GUARD(0x00DAFE46631AE331LL, stream_set_timeout) {
        ci = &ci_stream_set_timeout;
        return true;
      }
      break;
    case 818:
      HASH_GUARD(0x037055C215998332LL, bcsub) {
        ci = &ci_bcsub;
        return true;
      }
      break;
    case 824:
      HASH_GUARD(0x549D51040C250338LL, cleardrawingwand) {
        ci = &ci_cleardrawingwand;
        return true;
      }
      break;
    case 825:
      HASH_GUARD(0x48D57F17C5132339LL, drawgetclippath) {
        ci = &ci_drawgetclippath;
        return true;
      }
      break;
    case 826:
      HASH_GUARD(0x34DDF0DFC546033ALL, xbox_task_start) {
        ci = &ci_xbox_task_start;
        return true;
      }
      break;
    case 829:
      HASH_GUARD(0x4E166ECE0EC6A33DLL, openssl_pkey_get_public) {
        ci = &ci_openssl_pkey_get_public;
        return true;
      }
      break;
    case 830:
      HASH_GUARD(0x758EA7E9AA45C33ELL, xmlwriter_end_document) {
        ci = &ci_xmlwriter_end_document;
        return true;
      }
      break;
    case 835:
      HASH_GUARD(0x6794CFB89DEEF343LL, curl_exec) {
        ci = &ci_curl_exec;
        return true;
      }
      break;
    case 836:
      HASH_GUARD(0x1A9DC76AB74F6344LL, openssl_verify) {
        ci = &ci_openssl_verify;
        return true;
      }
      break;
    case 837:
      HASH_GUARD(0x45FAE3D08E96B345LL, curl_errno) {
        ci = &ci_curl_errno;
        return true;
      }
      break;
    case 838:
      HASH_GUARD(0x4B30FBA18042E346LL, session_cache_expire) {
        ci = &ci_session_cache_expire;
        return true;
      }
      break;
    case 842:
      HASH_GUARD(0x208BB4C3C0BA534ALL, xmlwriter_write_dtd_element) {
        ci = &ci_xmlwriter_write_dtd_element;
        return true;
      }
      break;
    case 843:
      HASH_GUARD(0x3880550F6AD8034BLL, session_destroy) {
        ci = &ci_session_destroy;
        return true;
      }
      HASH_GUARD(0x57A9E8878872D34BLL, parse_ini_file) {
        ci = &ci_parse_ini_file;
        return true;
      }
      break;
    case 844:
      HASH_GUARD(0x0644E5FB91C8134CLL, array_udiff) {
        ci = &ci_array_udiff;
        return true;
      }
      break;
    case 845:
      HASH_GUARD(0x5998E61D600D634DLL, drawaffine) {
        ci = &ci_drawaffine;
        return true;
      }
      break;
    case 847:
      HASH_GUARD(0x4F2D0EFF0D4B534FLL, fb_get_taint) {
        ci = &ci_fb_get_taint;
        return true;
      }
      HASH_GUARD(0x5C8B3B9FA833934FLL, ldap_first_attribute) {
        ci = &ci_ldap_first_attribute;
        return true;
      }
      break;
    case 849:
      HASH_GUARD(0x2B422699C3A57351LL, sha1) {
        ci = &ci_sha1;
        return true;
      }
      break;
    case 852:
      HASH_GUARD(0x501F4DF5C8997354LL, hphp_get_property) {
        ci = &ci_hphp_get_property;
        return true;
      }
      HASH_GUARD(0x77EB4D2F5BDDB354LL, magickgetimageresolution) {
        ci = &ci_magickgetimageresolution;
        return true;
      }
      break;
    case 858:
      HASH_GUARD(0x4BF5DEBDB76EC35ALL, mcrypt_enc_get_iv_size) {
        ci = &ci_mcrypt_enc_get_iv_size;
        return true;
      }
      HASH_GUARD(0x0E0C79E42812235ALL, imagepng) {
        ci = &ci_imagepng;
        return true;
      }
      break;
    case 859:
      HASH_GUARD(0x1AC48909BEEF935BLL, func_get_arg) {
        ci = &ci_func_get_arg;
        return true;
      }
      break;
    case 861:
      HASH_GUARD(0x54C3E9AB6FB8E35DLL, magickswirlimage) {
        ci = &ci_magickswirlimage;
        return true;
      }
      break;
    case 863:
      HASH_GUARD(0x280DE04F84FB235FLL, popdrawingwand) {
        ci = &ci_popdrawingwand;
        return true;
      }
      break;
    case 869:
      HASH_GUARD(0x68DBF8ABB26A8365LL, hphp_directoryiterator_rewind) {
        ci = &ci_hphp_directoryiterator_rewind;
        return true;
      }
      break;
    case 870:
      HASH_GUARD(0x4EF3469306E44366LL, floatval) {
        ci = &ci_floatval;
        return true;
      }
      break;
    case 871:
      HASH_GUARD(0x4810A9774785C367LL, posix_getpgrp) {
        ci = &ci_posix_getpgrp;
        return true;
      }
      break;
    case 872:
      HASH_GUARD(0x5D406167C673D368LL, magickcompareimages) {
        ci = &ci_magickcompareimages;
        return true;
      }
      break;
    case 873:
      HASH_GUARD(0x6C715D7DD63DA369LL, is_integer) {
        ci = &ci_is_integer;
        return true;
      }
      break;
    case 878:
      HASH_GUARD(0x7CE90898E882F36ELL, pixelsetyellow) {
        ci = &ci_pixelsetyellow;
        return true;
      }
      break;
    case 882:
      HASH_GUARD(0x7107AE03689F5372LL, hphp_invoke) {
        ci = &ci_hphp_invoke;
        return true;
      }
      break;
    case 888:
      HASH_GUARD(0x34BAEFD8AE59D378LL, hphp_set_error_page) {
        ci = &ci_hphp_set_error_page;
        return true;
      }
      break;
    case 889:
      HASH_GUARD(0x5ED8901DB5D14379LL, magickcharcoalimage) {
        ci = &ci_magickcharcoalimage;
        return true;
      }
      break;
    case 890:
      HASH_GUARD(0x69EA8DC005FEC37ALL, hphp_splfileobject_fwrite) {
        ci = &ci_hphp_splfileobject_fwrite;
        return true;
      }
      break;
    case 893:
      HASH_GUARD(0x7C40E2514FB5437DLL, dom_namednodemap_get_named_item_ns) {
        ci = &ci_dom_namednodemap_get_named_item_ns;
        return true;
      }
      break;
    case 900:
      HASH_GUARD(0x44C1BC500D175384LL, wandgetexception) {
        ci = &ci_wandgetexception;
        return true;
      }
      break;
    case 901:
      HASH_GUARD(0x7C5CA3E2E3C8F385LL, magickflipimage) {
        ci = &ci_magickflipimage;
        return true;
      }
      HASH_GUARD(0x57554E082E0ED385LL, pcntl_exec) {
        ci = &ci_pcntl_exec;
        return true;
      }
      HASH_GUARD(0x0B0B8765A4CDD385LL, hphp_splfileobject_fgets) {
        ci = &ci_hphp_splfileobject_fgets;
        return true;
      }
      break;
    case 902:
      HASH_GUARD(0x589E24C7664D5386LL, doubleval) {
        ci = &ci_doubleval;
        return true;
      }
      break;
    case 904:
      HASH_GUARD(0x791E946E04F50388LL, magicksetresourcelimit) {
        ci = &ci_magicksetresourcelimit;
        return true;
      }
      break;
    case 907:
      HASH_GUARD(0x32354CC291ECF38BLL, fb_intercept) {
        ci = &ci_fb_intercept;
        return true;
      }
      HASH_GUARD(0x73A3F87C0A56238BLL, stat) {
        ci = &ci_stat;
        return true;
      }
      break;
    case 908:
      HASH_GUARD(0x7F18BA1FBD95B38CLL, hphp_directoryiterator_next) {
        ci = &ci_hphp_directoryiterator_next;
        return true;
      }
      break;
    case 909:
      HASH_GUARD(0x4127DE142CD4A38DLL, xml_get_error_code) {
        ci = &ci_xml_get_error_code;
        return true;
      }
      break;
    case 913:
      HASH_GUARD(0x25FA64929C619391LL, asin) {
        ci = &ci_asin;
        return true;
      }
      break;
    case 914:
      HASH_GUARD(0x2052D8D4822EF392LL, is_subclass_of) {
        ci = &ci_is_subclass_of;
        return true;
      }
      HASH_GUARD(0x2395B0A85E292392LL, hphp_splfileobject_flock) {
        ci = &ci_hphp_splfileobject_flock;
        return true;
      }
      break;
    case 916:
      HASH_GUARD(0x269A220896FD2394LL, deg2rad) {
        ci = &ci_deg2rad;
        return true;
      }
      HASH_GUARD(0x36953788781F4394LL, mailparse_msg_extract_part) {
        ci = &ci_mailparse_msg_extract_part;
        return true;
      }
      break;
    case 917:
      HASH_GUARD(0x7B0552A224E27395LL, bcsqrt) {
        ci = &ci_bcsqrt;
        return true;
      }
      HASH_GUARD(0x422599B9E8AC0395LL, stream_bucket_make_writeable) {
        ci = &ci_stream_bucket_make_writeable;
        return true;
      }
      break;
    case 918:
      HASH_GUARD(0x15EC64198D93C396LL, openssl_pkcs12_read) {
        ci = &ci_openssl_pkcs12_read;
        return true;
      }
      break;
    case 919:
      HASH_GUARD(0x1D2C305EA5C82397LL, idn_to_utf8) {
        ci = &ci_idn_to_utf8;
        return true;
      }
      break;
    case 920:
      HASH_GUARD(0x215547858BA7E398LL, hphp_recursiveiteratoriterator___construct) {
        ci = &ci_hphp_recursiveiteratoriterator___construct;
        return true;
      }
      break;
    case 921:
      HASH_GUARD(0x66DA89629BA5D399LL, posix_getgrgid) {
        ci = &ci_posix_getgrgid;
        return true;
      }
      break;
    case 922:
      HASH_GUARD(0x0CC562CBD773639ALL, i18n_loc_get_default) {
        ci = &ci_i18n_loc_get_default;
        return true;
      }
      HASH_GUARD(0x4C24BC37D807D39ALL, collator_get_strength) {
        ci = &ci_collator_get_strength;
        return true;
      }
      break;
    case 923:
      HASH_GUARD(0x25DF28703309C39BLL, idate) {
        ci = &ci_idate;
        return true;
      }
      HASH_GUARD(0x5B33B55D4B7E339BLL, fpassthru) {
        ci = &ci_fpassthru;
        return true;
      }
      break;
    case 924:
      HASH_GUARD(0x0136F8F03932E39CLL, session_unset) {
        ci = &ci_session_unset;
        return true;
      }
      break;
    case 926:
      HASH_GUARD(0x27AD0D17AA7FB39ELL, ldap_set_rebind_proc) {
        ci = &ci_ldap_set_rebind_proc;
        return true;
      }
      break;
    case 927:
      HASH_GUARD(0x57E72C21F67D039FLL, user_error) {
        ci = &ci_user_error;
        return true;
      }
      HASH_GUARD(0x0368F1779E3AE39FLL, mysql_field_table) {
        ci = &ci_mysql_field_table;
        return true;
      }
      HASH_GUARD(0x4019A6916456339FLL, dom_node_remove_child) {
        ci = &ci_dom_node_remove_child;
        return true;
      }
      break;
    case 929:
      HASH_GUARD(0x5C29B6D7973903A1LL, proc_nice) {
        ci = &ci_proc_nice;
        return true;
      }
      break;
    case 930:
      HASH_GUARD(0x0207E332D629A3A2LL, mailparse_msg_get_structure) {
        ci = &ci_mailparse_msg_get_structure;
        return true;
      }
      HASH_GUARD(0x0A2A4AA078D433A2LL, hexdec) {
        ci = &ci_hexdec;
        return true;
      }
      break;
    case 932:
      HASH_GUARD(0x1676FB393F8493A4LL, constant) {
        ci = &ci_constant;
        return true;
      }
      break;
    case 934:
      HASH_GUARD(0x40E0D496EE29B3A6LL, call_user_func_array) {
        ci = &ci_call_user_func_array;
        return true;
      }
      break;
    case 936:
      HASH_GUARD(0x0121CD6CDCE1C3A8LL, mysql_pconnect_with_db) {
        ci = &ci_mysql_pconnect_with_db;
        return true;
      }
      HASH_GUARD(0x4120B8157ED413A8LL, i18n_loc_set_strength) {
        ci = &ci_i18n_loc_set_strength;
        return true;
      }
      break;
    case 937:
      HASH_GUARD(0x7F9E810BC93023A9LL, memcache_close) {
        ci = &ci_memcache_close;
        return true;
      }
      break;
    case 938:
      HASH_GUARD(0x3238A5BD362443AALL, escapeshellcmd) {
        ci = &ci_escapeshellcmd;
        return true;
      }
      break;
    case 946:
      HASH_GUARD(0x3DB7EBC0B670C3B2LL, magicksetimageredprimary) {
        ci = &ci_magicksetimageredprimary;
        return true;
      }
      break;
    case 947:
      HASH_GUARD(0x61720D771D1A23B3LL, posix_getpwnam) {
        ci = &ci_posix_getpwnam;
        return true;
      }
      HASH_GUARD(0x6077CFE09EE4D3B3LL, session_save_path) {
        ci = &ci_session_save_path;
        return true;
      }
      break;
    case 950:
      HASH_GUARD(0x6E6C0E9A715073B6LL, dom_xpath_register_php_functions) {
        ci = &ci_dom_xpath_register_php_functions;
        return true;
      }
      HASH_GUARD(0x6C07640F7C5BD3B6LL, imagettfbbox) {
        ci = &ci_imagettfbbox;
        return true;
      }
      break;
    case 955:
      HASH_GUARD(0x5A3F5AAD1B13A3BBLL, is_executable) {
        ci = &ci_is_executable;
        return true;
      }
      break;
    case 956:
      HASH_GUARD(0x0629158C42C893BCLL, compact) {
        ci = &ci_compact;
        return true;
      }
      break;
    case 957:
      HASH_GUARD(0x60294C2616F6A3BDLL, mcrypt_enc_get_supported_key_sizes) {
        ci = &ci_mcrypt_enc_get_supported_key_sizes;
        return true;
      }
      break;
    case 958:
      HASH_GUARD(0x49A34964289453BELL, eregi) {
        ci = &ci_eregi;
        return true;
      }
      break;
    case 959:
      HASH_GUARD(0x0E38CDC93E5893BFLL, magicksetimagemattecolor) {
        ci = &ci_magicksetimagemattecolor;
        return true;
      }
      break;
    case 968:
      HASH_GUARD(0x4D100C70E86593C8LL, stream_set_write_buffer) {
        ci = &ci_stream_set_write_buffer;
        return true;
      }
      HASH_GUARD(0x3101CE70BA49A3C8LL, error_reporting) {
        ci = &ci_error_reporting;
        return true;
      }
      break;
    case 971:
      HASH_GUARD(0x0173CC6FACAB93CBLL, quotemeta) {
        ci = &ci_quotemeta;
        return true;
      }
      HASH_GUARD(0x4C3B6BE9112E63CBLL, str_split) {
        ci = &ci_str_split;
        return true;
      }
      break;
    case 972:
      HASH_GUARD(0x50C88817090C63CCLL, pcntl_wait) {
        ci = &ci_pcntl_wait;
        return true;
      }
      break;
    case 974:
      HASH_GUARD(0x4F9F68F60FD7A3CELL, drawgetfillrule) {
        ci = &ci_drawgetfillrule;
        return true;
      }
      HASH_GUARD(0x02BEFBEE8287D3CELL, get_magic_quotes_runtime) {
        ci = &ci_get_magic_quotes_runtime;
        return true;
      }
      break;
    case 978:
      HASH_GUARD(0x67C155632E5373D2LL, mailparse_msg_create) {
        ci = &ci_mailparse_msg_create;
        return true;
      }
      break;
    case 979:
      HASH_GUARD(0x734FD402E190E3D3LL, evhttp_async_get) {
        ci = &ci_evhttp_async_get;
        return true;
      }
      HASH_GUARD(0x0A8D4FAF266973D3LL, bcpow) {
        ci = &ci_bcpow;
        return true;
      }
      break;
    case 980:
      HASH_GUARD(0x0FF21F9BE4CCC3D4LL, call_user_func_rpc) {
        ci = &ci_call_user_func_rpc;
        return true;
      }
      break;
    case 983:
      HASH_GUARD(0x382B5B1EF00153D7LL, imagecreatefrompng) {
        ci = &ci_imagecreatefrompng;
        return true;
      }
      break;
    case 996:
      HASH_GUARD(0x7E7718CC939D63E4LL, setrawcookie) {
        ci = &ci_setrawcookie;
        return true;
      }
      break;
    case 1000:
      HASH_GUARD(0x6BB9D669DDB703E8LL, xml_get_current_byte_index) {
        ci = &ci_xml_get_current_byte_index;
        return true;
      }
      HASH_GUARD(0x4A3127C309B0C3E8LL, drawsetstrokelinecap) {
        ci = &ci_drawsetstrokelinecap;
        return true;
      }
      break;
    case 1002:
      HASH_GUARD(0x0D3C8F00B0C633EALL, inet_pton) {
        ci = &ci_inet_pton;
        return true;
      }
      HASH_GUARD(0x6DA49696220FE3EALL, mailparse_rfc822_parse_addresses) {
        ci = &ci_mailparse_rfc822_parse_addresses;
        return true;
      }
      break;
    case 1003:
      HASH_GUARD(0x1DAE0831CECB63EBLL, ob_get_clean) {
        ci = &ci_ob_get_clean;
        return true;
      }
      break;
    case 1006:
      HASH_GUARD(0x598472448937E3EELL, magickqueryfontmetrics) {
        ci = &ci_magickqueryfontmetrics;
        return true;
      }
      break;
    case 1009:
      HASH_GUARD(0x5EFE291585A713F1LL, method_exists) {
        ci = &ci_method_exists;
        return true;
      }
      break;
    case 1010:
      HASH_GUARD(0x0FE12E46BC9853F2LL, stream_filter_append) {
        ci = &ci_stream_filter_append;
        return true;
      }
      HASH_GUARD(0x41A19AE18BC8B3F2LL, curl_error) {
        ci = &ci_curl_error;
        return true;
      }
      HASH_GUARD(0x696241660648B3F2LL, magickwhitethresholdimage) {
        ci = &ci_magickwhitethresholdimage;
        return true;
      }
      break;
    case 1012:
      HASH_GUARD(0x1938C8715806E3F4LL, spl_classes) {
        ci = &ci_spl_classes;
        return true;
      }
      HASH_GUARD(0x26D53A77483EF3F4LL, drawbezier) {
        ci = &ci_drawbezier;
        return true;
      }
      break;
    case 1015:
      HASH_GUARD(0x43F22CB4E3E8F3F7LL, apache_note) {
        ci = &ci_apache_note;
        return true;
      }
      break;
    case 1016:
      HASH_GUARD(0x4C024573FCD5B3F8LL, var_dump) {
        ci = &ci_var_dump;
        return true;
      }
      HASH_GUARD(0x514EA9C8FF5B33F8LL, posix_getrlimit) {
        ci = &ci_posix_getrlimit;
        return true;
      }
      break;
    case 1018:
      HASH_GUARD(0x1B217E78CBC713FALL, zend_thread_id) {
        ci = &ci_zend_thread_id;
        return true;
      }
      break;
    case 1025:
      HASH_GUARD(0x36B9C440B1881401LL, fmod) {
        ci = &ci_fmod;
        return true;
      }
      HASH_GUARD(0x3DCB1C92B5864401LL, gzrewind) {
        ci = &ci_gzrewind;
        return true;
      }
      break;
    case 1028:
      HASH_GUARD(0x2B12B0E9109D0404LL, iptcembed) {
        ci = &ci_iptcembed;
        return true;
      }
      break;
    case 1033:
      HASH_GUARD(0x2E57E06900594409LL, xbox_send_message) {
        ci = &ci_xbox_send_message;
        return true;
      }
      break;
    case 1034:
      HASH_GUARD(0x6DC61C51FA1D340ALL, show_source) {
        ci = &ci_show_source;
        return true;
      }
      break;
    case 1035:
      HASH_GUARD(0x6C2CE092B900D40BLL, hphp_splfileinfo___construct) {
        ci = &ci_hphp_splfileinfo___construct;
        return true;
      }
      break;
    case 1037:
      HASH_GUARD(0x2939C5BAE0C4A40DLL, nl2br) {
        ci = &ci_nl2br;
        return true;
      }
      HASH_GUARD(0x267529454569840DLL, ob_flush) {
        ci = &ci_ob_flush;
        return true;
      }
      HASH_GUARD(0x152C7161567F940DLL, func_num_args) {
        ci = &ci_func_num_args;
        return true;
      }
      HASH_GUARD(0x002CCCD877D9640DLL, drawpathclose) {
        ci = &ci_drawpathclose;
        return true;
      }
      break;
    case 1043:
      HASH_GUARD(0x56EC1A6732D07413LL, drawgetfontsize) {
        ci = &ci_drawgetfontsize;
        return true;
      }
      HASH_GUARD(0x20C24D873DC65413LL, openssl_csr_get_subject) {
        ci = &ci_openssl_csr_get_subject;
        return true;
      }
      break;
    case 1051:
      HASH_GUARD(0x47279C717370B41BLL, acos) {
        ci = &ci_acos;
        return true;
      }
      break;
    case 1054:
      HASH_GUARD(0x3E4E7C561D3A541ELL, fgetss) {
        ci = &ci_fgetss;
        return true;
      }
      break;
    case 1055:
      HASH_GUARD(0x301963016A91741FLL, hphp_stats) {
        ci = &ci_hphp_stats;
        return true;
      }
      break;
    case 1059:
      HASH_GUARD(0x4C9108B5A5807423LL, drawsetfillcolor) {
        ci = &ci_drawsetfillcolor;
        return true;
      }
      break;
    case 1062:
      HASH_GUARD(0x21EFB0B9D1514426LL, magicksetpassphrase) {
        ci = &ci_magicksetpassphrase;
        return true;
      }
      HASH_GUARD(0x161D8EA3339AB426LL, apc_cas) {
        ci = &ci_apc_cas;
        return true;
      }
      break;
    case 1068:
      HASH_GUARD(0x12D324CC744BF42CLL, pixelgetcolorasstring) {
        ci = &ci_pixelgetcolorasstring;
        return true;
      }
      break;
    case 1069:
      HASH_GUARD(0x333D1E2E28B0942DLL, imagejpeg) {
        ci = &ci_imagejpeg;
        return true;
      }
      HASH_GUARD(0x2A5A519E4BFE442DLL, mb_eregi) {
        ci = &ci_mb_eregi;
        return true;
      }
      break;
    case 1071:
      HASH_GUARD(0x316F2725AC15042FLL, stream_resolve_include_path) {
        ci = &ci_stream_resolve_include_path;
        return true;
      }
      break;
    case 1072:
      HASH_GUARD(0x6349C9658B2A2430LL, memcache_pconnect) {
        ci = &ci_memcache_pconnect;
        return true;
      }
      break;
    case 1074:
      HASH_GUARD(0x71C6E38BC56CE432LL, stream_wrapper_register) {
        ci = &ci_stream_wrapper_register;
        return true;
      }
      break;
    case 1075:
      HASH_GUARD(0x6829094421CDB433LL, touch) {
        ci = &ci_touch;
        return true;
      }
      break;
    case 1077:
      HASH_GUARD(0x75DAFEF5BFEF1435LL, imagesetstyle) {
        ci = &ci_imagesetstyle;
        return true;
      }
      HASH_GUARD(0x044386A0E8B25435LL, drawgetclipunits) {
        ci = &ci_drawgetclipunits;
        return true;
      }
      break;
    case 1079:
      HASH_GUARD(0x1AAF02CF6DEBB437LL, magickdeconstructimages) {
        ci = &ci_magickdeconstructimages;
        return true;
      }
      break;
    case 1081:
      HASH_GUARD(0x34C52EF423EFD439LL, proc_open) {
        ci = &ci_proc_open;
        return true;
      }
      break;
    case 1082:
      HASH_GUARD(0x5019A1FBF377C43ALL, imagepsbbox) {
        ci = &ci_imagepsbbox;
        return true;
      }
      break;
    case 1084:
      HASH_GUARD(0x59ECE01C7629643CLL, mysql_drop_db) {
        ci = &ci_mysql_drop_db;
        return true;
      }
      break;
    case 1088:
      HASH_GUARD(0x5247425ED698B440LL, hphp_thread_is_warmup_enabled) {
        ci = &ci_hphp_thread_is_warmup_enabled;
        return true;
      }
      break;
    case 1089:
      HASH_GUARD(0x158E2271E381C441LL, hash_file) {
        ci = &ci_hash_file;
        return true;
      }
      HASH_GUARD(0x05892E3C5B9EB441LL, closedir) {
        ci = &ci_closedir;
        return true;
      }
      break;
    case 1090:
      HASH_GUARD(0x3F869126D0336442LL, trigger_error) {
        ci = &ci_trigger_error;
        return true;
      }
      break;
    case 1105:
      HASH_GUARD(0x7539134E1CC61451LL, xmlwriter_start_cdata) {
        ci = &ci_xmlwriter_start_cdata;
        return true;
      }
      break;
    case 1106:
      HASH_GUARD(0x1056EF1C14D2A452LL, socket_connect) {
        ci = &ci_socket_connect;
        return true;
      }
      break;
    case 1116:
      HASH_GUARD(0x436AB52B2099145CLL, ldap_close) {
        ci = &ci_ldap_close;
        return true;
      }
      break;
    case 1117:
      HASH_GUARD(0x0246AF48CD31245DLL, count_chars) {
        ci = &ci_count_chars;
        return true;
      }
      break;
    case 1118:
      HASH_GUARD(0x0ED191E71A60545ELL, magicksetfirstiterator) {
        ci = &ci_magicksetfirstiterator;
        return true;
      }
      break;
    case 1125:
      HASH_GUARD(0x05D72365192CE465LL, fwrite) {
        ci = &ci_fwrite;
        return true;
      }
      HASH_GUARD(0x406A1404F48E4465LL, posix_getuid) {
        ci = &ci_posix_getuid;
        return true;
      }
      break;
    case 1130:
      HASH_GUARD(0x32643AE461D3F46ALL, mailparse_stream_encode) {
        ci = &ci_mailparse_stream_encode;
        return true;
      }
      break;
    case 1132:
      HASH_GUARD(0x07D959A8C0CF546CLL, stream_wrapper_unregister) {
        ci = &ci_stream_wrapper_unregister;
        return true;
      }
      HASH_GUARD(0x4F39BD300305746CLL, hphp_splfileobject_key) {
        ci = &ci_hphp_splfileobject_key;
        return true;
      }
      break;
    case 1133:
      HASH_GUARD(0x738D381800CE946DLL, ldap_parse_result) {
        ci = &ci_ldap_parse_result;
        return true;
      }
      HASH_GUARD(0x5229C0069FD7D46DLL, vfprintf) {
        ci = &ci_vfprintf;
        return true;
      }
      break;
    case 1136:
      HASH_GUARD(0x0C626F268F120470LL, __halt_compiler) {
        ci = &ci___halt_compiler;
        return true;
      }
      break;
    case 1139:
      HASH_GUARD(0x0F8F276A48900473LL, drawgetstrokelinecap) {
        ci = &ci_drawgetstrokelinecap;
        return true;
      }
      break;
    case 1141:
      HASH_GUARD(0x268706C46202C475LL, sem_acquire) {
        ci = &ci_sem_acquire;
        return true;
      }
      break;
    case 1143:
      HASH_GUARD(0x18666906A8001477LL, array_diff_assoc) {
        ci = &ci_array_diff_assoc;
        return true;
      }
      break;
    case 1144:
      HASH_GUARD(0x080594ABE715B478LL, hphp_splfileobject_current) {
        ci = &ci_hphp_splfileobject_current;
        return true;
      }
      HASH_GUARD(0x6497CC8295DDB478LL, fb_thrift_unserialize) {
        ci = &ci_fb_thrift_unserialize;
        return true;
      }
      break;
    case 1145:
      HASH_GUARD(0x4859AF715D5A3479LL, magickmagnifyimage) {
        ci = &ci_magickmagnifyimage;
        return true;
      }
      break;
    case 1148:
      HASH_GUARD(0x1A08C578AD3BC47CLL, apache_response_headers) {
        ci = &ci_apache_response_headers;
        return true;
      }
      HASH_GUARD(0x2FA7269AB0E1147CLL, mysql_field_seek) {
        ci = &ci_mysql_field_seek;
        return true;
      }
      break;
    case 1150:
      HASH_GUARD(0x1D583AA4F7F6547ELL, drawpathlinetorelative) {
        ci = &ci_drawpathlinetorelative;
        return true;
      }
      HASH_GUARD(0x0AC36D9F961B247ELL, newpixeliterator) {
        ci = &ci_newpixeliterator;
        return true;
      }
      break;
    case 1151:
      HASH_GUARD(0x68AE04B02253B47FLL, mb_parse_str) {
        ci = &ci_mb_parse_str;
        return true;
      }
      break;
    case 1154:
      HASH_GUARD(0x4590C853C2027482LL, magickembossimage) {
        ci = &ci_magickembossimage;
        return true;
      }
      break;
    case 1157:
      HASH_GUARD(0x250DD3D58EA37485LL, gmstrftime) {
        ci = &ci_gmstrftime;
        return true;
      }
      HASH_GUARD(0x61499C92F4FBA485LL, hphp_splfileobject_fgetc) {
        ci = &ci_hphp_splfileobject_fgetc;
        return true;
      }
      break;
    case 1161:
      HASH_GUARD(0x4F7EAF5B37663489LL, magickgetimageredprimary) {
        ci = &ci_magickgetimageredprimary;
        return true;
      }
      HASH_GUARD(0x7505924F05854489LL, dom_element_set_attribute_ns) {
        ci = &ci_dom_element_set_attribute_ns;
        return true;
      }
      break;
    case 1162:
      HASH_GUARD(0x7E88764A1DE8548ALL, drawgetstrokewidth) {
        ci = &ci_drawgetstrokewidth;
        return true;
      }
      break;
    case 1163:
      HASH_GUARD(0x5860ACF621DD948BLL, is_file) {
        ci = &ci_is_file;
        return true;
      }
      break;
    case 1165:
      HASH_GUARD(0x23511F83C2BC548DLL, header) {
        ci = &ci_header;
        return true;
      }
      HASH_GUARD(0x275D127C87EF048DLL, mysql_db_query) {
        ci = &ci_mysql_db_query;
        return true;
      }
      break;
    case 1167:
      HASH_GUARD(0x43672229728A648FLL, drawpushpattern) {
        ci = &ci_drawpushpattern;
        return true;
      }
      break;
    case 1171:
      HASH_GUARD(0x56377FCC2447D493LL, magicksetimagepixels) {
        ci = &ci_magicksetimagepixels;
        return true;
      }
      break;
    case 1175:
      HASH_GUARD(0x353E2A635A47F497LL, evhttp_get) {
        ci = &ci_evhttp_get;
        return true;
      }
      HASH_GUARD(0x5388045C2D13D497LL, mysql_num_fields) {
        ci = &ci_mysql_num_fields;
        return true;
      }
      break;
    case 1181:
      HASH_GUARD(0x7A59813AC331449DLL, mb_ereg_search_regs) {
        ci = &ci_mb_ereg_search_regs;
        return true;
      }
      break;
    case 1183:
      HASH_GUARD(0x7FF66005524E649FLL, drawgettextdecoration) {
        ci = &ci_drawgettextdecoration;
        return true;
      }
      break;
    case 1188:
      HASH_GUARD(0x6EC476E42A53A4A4LL, ldap_err2str) {
        ci = &ci_ldap_err2str;
        return true;
      }
      break;
    case 1189:
      HASH_GUARD(0x18BE9B1C2DE6D4A5LL, imagexbm) {
        ci = &ci_imagexbm;
        return true;
      }
      break;
    case 1192:
      HASH_GUARD(0x6F4497457F1584A8LL, dom_element_set_id_attribute_node) {
        ci = &ci_dom_element_set_id_attribute_node;
        return true;
      }
      break;
    case 1193:
      HASH_GUARD(0x386378F2BA3234A9LL, magickevaluateimage) {
        ci = &ci_magickevaluateimage;
        return true;
      }
      break;
    case 1196:
      HASH_GUARD(0x245AA2790C87C4ACLL, image_type_to_mime_type) {
        ci = &ci_image_type_to_mime_type;
        return true;
      }
      HASH_GUARD(0x6E8FFA56842304ACLL, drawgetfont) {
        ci = &ci_drawgetfont;
        return true;
      }
      break;
    case 1197:
      HASH_GUARD(0x3D98ACFCEBB764ADLL, hphp_set_property) {
        ci = &ci_hphp_set_property;
        return true;
      }
      break;
    case 1199:
      HASH_GUARD(0x42463E7E5C3434AFLL, mb_strrichr) {
        ci = &ci_mb_strrichr;
        return true;
      }
      HASH_GUARD(0x6AC751181531F4AFLL, simplexml_load_string) {
        ci = &ci_simplexml_load_string;
        return true;
      }
      break;
    case 1200:
      HASH_GUARD(0x0E11D317044974B0LL, magickgetnumberimages) {
        ci = &ci_magickgetnumberimages;
        return true;
      }
      HASH_GUARD(0x3AF65A9F3653E4B0LL, addslashes) {
        ci = &ci_addslashes;
        return true;
      }
      break;
    case 1201:
      HASH_GUARD(0x060619D7A1B5F4B1LL, checkdate) {
        ci = &ci_checkdate;
        return true;
      }
      break;
    case 1203:
      HASH_GUARD(0x57034CAD772AF4B3LL, magickgetimagechannelmean) {
        ci = &ci_magickgetimagechannelmean;
        return true;
      }
      break;
    case 1204:
      HASH_GUARD(0x00621C58E54D44B4LL, hphp_recursiveiteratoriterator_key) {
        ci = &ci_hphp_recursiveiteratoriterator_key;
        return true;
      }
      break;
    case 1206:
      HASH_GUARD(0x3DE291DCBA5134B6LL, dom_document_create_element) {
        ci = &ci_dom_document_create_element;
        return true;
      }
      HASH_GUARD(0x12A9166E68DCF4B6LL, pixelgetgreen) {
        ci = &ci_pixelgetgreen;
        return true;
      }
      break;
    case 1207:
      HASH_GUARD(0x7EEBC81AF9BC54B7LL, xml_parser_free) {
        ci = &ci_xml_parser_free;
        return true;
      }
      break;
    case 1209:
      HASH_GUARD(0x5351290CD139A4B9LL, mb_strrpos) {
        ci = &ci_mb_strrpos;
        return true;
      }
      break;
    case 1210:
      HASH_GUARD(0x6B49D11E633274BALL, fopen) {
        ci = &ci_fopen;
        return true;
      }
      break;
    case 1213:
      HASH_GUARD(0x35BE8F6E7726C4BDLL, dechex) {
        ci = &ci_dechex;
        return true;
      }
      HASH_GUARD(0x5BA371A93F60F4BDLL, use_soap_error_handler) {
        ci = &ci_use_soap_error_handler;
        return true;
      }
      break;
    case 1214:
      HASH_GUARD(0x57278846B8B0E4BELL, ldap_count_entries) {
        ci = &ci_ldap_count_entries;
        return true;
      }
      break;
    case 1215:
      HASH_GUARD(0x01681C307C5AE4BFLL, strtoupper) {
        ci = &ci_strtoupper;
        return true;
      }
      break;
    case 1219:
      HASH_GUARD(0x7AAC29849263C4C3LL, getprotobyname) {
        ci = &ci_getprotobyname;
        return true;
      }
      break;
    case 1220:
      HASH_GUARD(0x67EADCF4E81084C4LL, mb_ereg) {
        ci = &ci_mb_ereg;
        return true;
      }
      HASH_GUARD(0x4A24DB9D6B0334C4LL, hphp_recursivedirectoryiterator_next) {
        ci = &ci_hphp_recursivedirectoryiterator_next;
        return true;
      }
      break;
    case 1221:
      HASH_GUARD(0x34A38DDF2CD914C5LL, long2ip) {
        ci = &ci_long2ip;
        return true;
      }
      break;
    case 1222:
      HASH_GUARD(0x651F7FBBA90604C6LL, magickgetimageindex) {
        ci = &ci_magickgetimageindex;
        return true;
      }
      HASH_GUARD(0x4F7AA8120E33E4C6LL, collator_get_attribute) {
        ci = &ci_collator_get_attribute;
        return true;
      }
      break;
    case 1224:
      HASH_GUARD(0x1B8BBFC882FDB4C8LL, magicktintimage) {
        ci = &ci_magicktintimage;
        return true;
      }
      break;
    case 1230:
      HASH_GUARD(0x60783C20BF7724CELL, mailparse_msg_free) {
        ci = &ci_mailparse_msg_free;
        return true;
      }
      break;
    case 1231:
      HASH_GUARD(0x72DECE786967A4CFLL, magickpreviousimage) {
        ci = &ci_magickpreviousimage;
        return true;
      }
      break;
    case 1233:
      HASH_GUARD(0x29EE24C41FD3D4D1LL, mysql_field_name) {
        ci = &ci_mysql_field_name;
        return true;
      }
      break;
    case 1238:
      HASH_GUARD(0x19ECDD5A937DD4D6LL, mailparse_msg_get_part_data) {
        ci = &ci_mailparse_msg_get_part_data;
        return true;
      }
      break;
    case 1239:
      HASH_GUARD(0x215403F1E335C4D7LL, magicksolarizeimage) {
        ci = &ci_magicksolarizeimage;
        return true;
      }
      break;
    case 1240:
      HASH_GUARD(0x2532EB687D51E4D8LL, unregister_tick_function) {
        ci = &ci_unregister_tick_function;
        return true;
      }
      HASH_GUARD(0x14BF763DDDC014D8LL, imagepsencodefont) {
        ci = &ci_imagepsencodefont;
        return true;
      }
      HASH_GUARD(0x56B908FC91C834D8LL, magickflopimage) {
        ci = &ci_magickflopimage;
        return true;
      }
      HASH_GUARD(0x1301F911ED6D54D8LL, is_nan) {
        ci = &ci_is_nan;
        return true;
      }
      HASH_GUARD(0x575C5AE3D2A694D8LL, ob_end_clean) {
        ci = &ci_ob_end_clean;
        return true;
      }
      break;
    case 1247:
      HASH_GUARD(0x747A7F585CD694DFLL, zend_version) {
        ci = &ci_zend_version;
        return true;
      }
      HASH_GUARD(0x2E5E5A0FC3B5C4DFLL, xml_set_character_data_handler) {
        ci = &ci_xml_set_character_data_handler;
        return true;
      }
      break;
    case 1248:
      HASH_GUARD(0x340A51AE22A924E0LL, reset) {
        ci = &ci_reset;
        return true;
      }
      break;
    case 1251:
      HASH_GUARD(0x7D57A0D72D6254E3LL, ob_implicit_flush) {
        ci = &ci_ob_implicit_flush;
        return true;
      }
      break;
    case 1262:
      HASH_GUARD(0x5895ADDD91F354EELL, hphp_thread_set_warmup_enabled) {
        ci = &ci_hphp_thread_set_warmup_enabled;
        return true;
      }
      break;
    case 1265:
      HASH_GUARD(0x65BD541EAB38E4F1LL, mysql_close) {
        ci = &ci_mysql_close;
        return true;
      }
      break;
    case 1266:
      HASH_GUARD(0x41276F8DE35354F2LL, dom_document_get_elements_by_tag_name) {
        ci = &ci_dom_document_get_elements_by_tag_name;
        return true;
      }
      break;
    case 1268:
      HASH_GUARD(0x436B36C5EB8DB4F4LL, mcrypt_generic) {
        ci = &ci_mcrypt_generic;
        return true;
      }
      break;
    case 1269:
      HASH_GUARD(0x528AC8D252D224F5LL, log10) {
        ci = &ci_log10;
        return true;
      }
      HASH_GUARD(0x112A0ACDD8B9D4F5LL, mb_list_mime_names) {
        ci = &ci_mb_list_mime_names;
        return true;
      }
      break;
    case 1271:
      HASH_GUARD(0x0BD9C5D811CB04F7LL, dom_element_set_id_attribute_ns) {
        ci = &ci_dom_element_set_id_attribute_ns;
        return true;
      }
      break;
    case 1272:
      HASH_GUARD(0x011006D90D79E4F8LL, mysql_errno) {
        ci = &ci_mysql_errno;
        return true;
      }
      break;
    case 1277:
      HASH_GUARD(0x002387F1D23B44FDLL, mcrypt_list_modes) {
        ci = &ci_mcrypt_list_modes;
        return true;
      }
      HASH_GUARD(0x2CEAE845E4F404FDLL, dom_document_save) {
        ci = &ci_dom_document_save;
        return true;
      }
      break;
    case 1287:
      HASH_GUARD(0x4FC9FE38A748B507LL, intl_get_error_message) {
        ci = &ci_intl_get_error_message;
        return true;
      }
      HASH_GUARD(0x197A5D237BD4C507LL, mb_ereg_search_getpos) {
        ci = &ci_mb_ereg_search_getpos;
        return true;
      }
      break;
    case 1288:
      HASH_GUARD(0x63A08D6AD1209508LL, magickgetexception) {
        ci = &ci_magickgetexception;
        return true;
      }
      break;
    case 1291:
      HASH_GUARD(0x71DCF11E3640C50BLL, hphp_directoryiterator_valid) {
        ci = &ci_hphp_directoryiterator_valid;
        return true;
      }
      break;
    case 1295:
      HASH_GUARD(0x5A66CCB3D924450FLL, xml_parser_create) {
        ci = &ci_xml_parser_create;
        return true;
      }
      break;
    case 1297:
      HASH_GUARD(0x09D5355CA8198511LL, mb_internal_encoding) {
        ci = &ci_mb_internal_encoding;
        return true;
      }
      HASH_GUARD(0x3C0304A55503D511LL, magickgetimageiterations) {
        ci = &ci_magickgetimageiterations;
        return true;
      }
      break;
    case 1299:
      HASH_GUARD(0x772E8BF114FEF513LL, eregi_replace) {
        ci = &ci_eregi_replace;
        return true;
      }
      break;
    case 1300:
      HASH_GUARD(0x100385A0988FD514LL, magickgetfilename) {
        ci = &ci_magickgetfilename;
        return true;
      }
      break;
    case 1305:
      HASH_GUARD(0x54EDBB6BAF318519LL, memcache_add) {
        ci = &ci_memcache_add;
        return true;
      }
      break;
    case 1314:
      HASH_GUARD(0x7DA98E0379D33522LL, chdir) {
        ci = &ci_chdir;
        return true;
      }
      break;
    case 1316:
      HASH_GUARD(0x28E724EDE0BB6524LL, mb_strcut) {
        ci = &ci_mb_strcut;
        return true;
      }
      break;
    case 1317:
      HASH_GUARD(0x230FE1D6EC599525LL, link) {
        ci = &ci_link;
        return true;
      }
      break;
    case 1318:
      HASH_GUARD(0x57DDA4C3F7FF8526LL, fputcsv) {
        ci = &ci_fputcsv;
        return true;
      }
      break;
    case 1319:
      HASH_GUARD(0x6B2B942CAF1A2527LL, array_shift) {
        ci = &ci_array_shift;
        return true;
      }
      break;
    case 1324:
      HASH_GUARD(0x1AB55BBA0967952CLL, mb_convert_variables) {
        ci = &ci_mb_convert_variables;
        return true;
      }
      break;
    case 1327:
      HASH_GUARD(0x6770E2559C9A152FLL, openssl_private_decrypt) {
        ci = &ci_openssl_private_decrypt;
        return true;
      }
      break;
    case 1329:
      HASH_GUARD(0x6776C27C6123D531LL, dl) {
        ci = &ci_dl;
        return true;
      }
      break;
    case 1330:
      HASH_GUARD(0x6193A26936F4D532LL, disk_total_space) {
        ci = &ci_disk_total_space;
        return true;
      }
      break;
    case 1331:
      HASH_GUARD(0x313D2A505076A533LL, dir) {
        ci = &ci_dir;
        return true;
      }
      break;
    case 1333:
      HASH_GUARD(0x6C87406DDC0AB535LL, mcrypt_ecb) {
        ci = &ci_mcrypt_ecb;
        return true;
      }
      break;
    case 1334:
      HASH_GUARD(0x0E80D04691227536LL, eval) {
        ci = &ci_eval;
        return true;
      }
      HASH_GUARD(0x746DC7AD953EA536LL, memcache_set_compress_threshold) {
        ci = &ci_memcache_set_compress_threshold;
        return true;
      }
      break;
    case 1335:
      HASH_GUARD(0x0830FF7C379D7537LL, dom_text_split_text) {
        ci = &ci_dom_text_split_text;
        return true;
      }
      HASH_GUARD(0x557C72DE98679537LL, hash_update_stream) {
        ci = &ci_hash_update_stream;
        return true;
      }
      HASH_GUARD(0x175B86BCB3124537LL, magickgetexceptionstring) {
        ci = &ci_magickgetexceptionstring;
        return true;
      }
      break;
    case 1337:
      HASH_GUARD(0x3C88F0FAC3EDD539LL, phpversion) {
        ci = &ci_phpversion;
        return true;
      }
      break;
    case 1340:
      HASH_GUARD(0x5CA55E62F2A5953CLL, drawgetstrokeopacity) {
        ci = &ci_drawgetstrokeopacity;
        return true;
      }
      break;
    case 1341:
      HASH_GUARD(0x0F32841DBF7A053DLL, fb_crossall_query) {
        ci = &ci_fb_crossall_query;
        return true;
      }
      break;
    case 1342:
      HASH_GUARD(0x36A80B48E08B753ELL, implode) {
        ci = &ci_implode;
        return true;
      }
      break;
    case 1346:
      HASH_GUARD(0x59A44591E67D4542LL, drawrender) {
        ci = &ci_drawrender;
        return true;
      }
      break;
    case 1347:
      HASH_GUARD(0x20E2B1D920122543LL, die) {
        ci = &ci_die;
        return true;
      }
      HASH_GUARD(0x0962EACAE0F0B543LL, hphp_splfileinfo_getlinktarget) {
        ci = &ci_hphp_splfileinfo_getlinktarget;
        return true;
      }
      break;
    case 1348:
      HASH_GUARD(0x4D397FE5D0C0B544LL, magickmedianfilterimage) {
        ci = &ci_magickmedianfilterimage;
        return true;
      }
      break;
    case 1350:
      HASH_GUARD(0x12A739BE0ED32546LL, ignore_user_abort) {
        ci = &ci_ignore_user_abort;
        return true;
      }
      HASH_GUARD(0x081F76AC889BC546LL, getrusage) {
        ci = &ci_getrusage;
        return true;
      }
      break;
    case 1352:
      HASH_GUARD(0x0AD3BFAB5F780548LL, magickcoalesceimages) {
        ci = &ci_magickcoalesceimages;
        return true;
      }
      break;
    case 1355:
      HASH_GUARD(0x40CE61115E11154BLL, msg_stat_queue) {
        ci = &ci_msg_stat_queue;
        return true;
      }
      break;
    case 1356:
      HASH_GUARD(0x1D011CB0E810D54CLL, pdo_drivers) {
        ci = &ci_pdo_drivers;
        return true;
      }
      break;
    case 1357:
      HASH_GUARD(0x0F0702D91EAFB54DLL, drawgettextantialias) {
        ci = &ci_drawgettextantialias;
        return true;
      }
      HASH_GUARD(0x1B9E769FFEC3C54DLL, pcntl_wtermsig) {
        ci = &ci_pcntl_wtermsig;
        return true;
      }
      break;
    case 1359:
      HASH_GUARD(0x30DE78E7131B954FLL, furchash_hphp_ext_supported) {
        ci = &ci_furchash_hphp_ext_supported;
        return true;
      }
      HASH_GUARD(0x063200B5AAFEC54FLL, mysql_thread_id) {
        ci = &ci_mysql_thread_id;
        return true;
      }
      break;
    case 1370:
      HASH_GUARD(0x268EE73DB2EA555ALL, get_object_vars) {
        ci = &ci_get_object_vars;
        return true;
      }
      break;
    case 1372:
      HASH_GUARD(0x5749AD20CAFCD55CLL, pixelgetbluequantum) {
        ci = &ci_pixelgetbluequantum;
        return true;
      }
      break;
    case 1379:
      HASH_GUARD(0x1B1B2D70792D9563LL, mysql_get_client_info) {
        ci = &ci_mysql_get_client_info;
        return true;
      }
      break;
    case 1382:
      HASH_GUARD(0x6E2FDBD28F895566LL, timezone_abbreviations_list) {
        ci = &ci_timezone_abbreviations_list;
        return true;
      }
      HASH_GUARD(0x3DA2058E5C540566LL, spliti) {
        ci = &ci_spliti;
        return true;
      }
      break;
    case 1386:
      HASH_GUARD(0x74599147803DC56ALL, magickgetstringwidth) {
        ci = &ci_magickgetstringwidth;
        return true;
      }
      break;
    case 1387:
      HASH_GUARD(0x0DE86977367F656BLL, register_shutdown_function) {
        ci = &ci_register_shutdown_function;
        return true;
      }
      break;
    case 1390:
      HASH_GUARD(0x2A1F1B52160DE56ELL, zend_logo_guid) {
        ci = &ci_zend_logo_guid;
        return true;
      }
      break;
    case 1391:
      HASH_GUARD(0x016722439BBA756FLL, filetype) {
        ci = &ci_filetype;
        return true;
      }
      break;
    case 1392:
      HASH_GUARD(0x13D0427F3BB3E570LL, get_declared_interfaces) {
        ci = &ci_get_declared_interfaces;
        return true;
      }
      HASH_GUARD(0x21B3935EB3140570LL, mysql_fetch_object) {
        ci = &ci_mysql_fetch_object;
        return true;
      }
      break;
    case 1393:
      HASH_GUARD(0x2AD3361DE8B1D571LL, pcntl_signal_dispatch) {
        ci = &ci_pcntl_signal_dispatch;
        return true;
      }
      break;
    case 1396:
      HASH_GUARD(0x636C871213F37574LL, mcrypt_encrypt) {
        ci = &ci_mcrypt_encrypt;
        return true;
      }
      break;
    case 1399:
      HASH_GUARD(0x412521E7ADB21577LL, iconv_mime_decode_headers) {
        ci = &ci_iconv_mime_decode_headers;
        return true;
      }
      HASH_GUARD(0x1E154D823451B577LL, magicksetresolution) {
        ci = &ci_magicksetresolution;
        return true;
      }
      break;
    case 1401:
      HASH_GUARD(0x1DC8A386E219C579LL, ldap_add) {
        ci = &ci_ldap_add;
        return true;
      }
      break;
    case 1405:
      HASH_GUARD(0x78EDB608B02A857DLL, join) {
        ci = &ci_join;
        return true;
      }
      HASH_GUARD(0x22E08DEDF360057DLL, pixelsetmagenta) {
        ci = &ci_pixelsetmagenta;
        return true;
      }
      break;
    case 1406:
      HASH_GUARD(0x31529E9BCA1E157ELL, shm_remove) {
        ci = &ci_shm_remove;
        return true;
      }
      HASH_GUARD(0x132776D93181E57ELL, ldap_set_option) {
        ci = &ci_ldap_set_option;
        return true;
      }
      break;
    case 1410:
      HASH_GUARD(0x02688986D5D76582LL, magickspreadimage) {
        ci = &ci_magickspreadimage;
        return true;
      }
      HASH_GUARD(0x0B1F0EB755BDB582LL, ispixeliterator) {
        ci = &ci_ispixeliterator;
        return true;
      }
      break;
    case 1411:
      HASH_GUARD(0x3B2CD86F5DB72583LL, magickblackthresholdimage) {
        ci = &ci_magickblackthresholdimage;
        return true;
      }
      break;
    case 1419:
      HASH_GUARD(0x1EF2C1426AB0A58BLL, dom_node_replace_child) {
        ci = &ci_dom_node_replace_child;
        return true;
      }
      HASH_GUARD(0x3A34B44E4C51C58BLL, xml_set_element_handler) {
        ci = &ci_xml_set_element_handler;
        return true;
      }
      break;
    case 1420:
      HASH_GUARD(0x560C2F71978CE58CLL, shm_put_var) {
        ci = &ci_shm_put_var;
        return true;
      }
      break;
    case 1426:
      HASH_GUARD(0x3E9519FE856C4592LL, curl_multi_init) {
        ci = &ci_curl_multi_init;
        return true;
      }
      HASH_GUARD(0x5464E148E8A0C592LL, get_extension_funcs) {
        ci = &ci_get_extension_funcs;
        return true;
      }
      HASH_GUARD(0x7F65501600346592LL, mcrypt_get_block_size) {
        ci = &ci_mcrypt_get_block_size;
        return true;
      }
      break;
    case 1427:
      HASH_GUARD(0x0F5984B8A7FD8593LL, hphp_splfileinfo_getperms) {
        ci = &ci_hphp_splfileinfo_getperms;
        return true;
      }
      break;
    case 1431:
      HASH_GUARD(0x513787A813DB0597LL, date_date_set) {
        ci = &ci_date_date_set;
        return true;
      }
      break;
    case 1433:
      HASH_GUARD(0x12F502A88E0AA599LL, magickcompositeimage) {
        ci = &ci_magickcompositeimage;
        return true;
      }
      break;
    case 1434:
      HASH_GUARD(0x77F1EDE7D5EF759ALL, apc_cache_info) {
        ci = &ci_apc_cache_info;
        return true;
      }
      break;
    case 1435:
      HASH_GUARD(0x37D003B09D0C759BLL, stream_get_contents) {
        ci = &ci_stream_get_contents;
        return true;
      }
      break;
    case 1440:
      HASH_GUARD(0x20502FCACBB9F5A0LL, convert_uuencode) {
        ci = &ci_convert_uuencode;
        return true;
      }
      break;
    case 1441:
      HASH_GUARD(0x297690F3A63335A1LL, magickrotateimage) {
        ci = &ci_magickrotateimage;
        return true;
      }
      break;
    case 1444:
      HASH_GUARD(0x3C014439AE5D75A4LL, magickgetcharheight) {
        ci = &ci_magickgetcharheight;
        return true;
      }
      break;
    case 1448:
      HASH_GUARD(0x4FBB1F662399A5A8LL, is_soap_fault) {
        ci = &ci_is_soap_fault;
        return true;
      }
      break;
    case 1452:
      HASH_GUARD(0x763BA2B1C60A55ACLL, pixelgetalphaquantum) {
        ci = &ci_pixelgetalphaquantum;
        return true;
      }
      break;
    case 1453:
      HASH_GUARD(0x4110AF96B98B25ADLL, gzeof) {
        ci = &ci_gzeof;
        return true;
      }
      break;
    case 1455:
      HASH_GUARD(0x1636FBA5043CF5AFLL, ldap_error) {
        ci = &ci_ldap_error;
        return true;
      }
      break;
    case 1459:
      HASH_GUARD(0x001DBE44BC0B55B3LL, magicksetimagecolormapcolor) {
        ci = &ci_magicksetimagecolormapcolor;
        return true;
      }
      HASH_GUARD(0x7AFA32F70E8195B3LL, xbox_set_thread_timeout) {
        ci = &ci_xbox_set_thread_timeout;
        return true;
      }
      break;
    case 1461:
      HASH_GUARD(0x3F9C5B4708FC55B5LL, timezone_name_get) {
        ci = &ci_timezone_name_get;
        return true;
      }
      HASH_GUARD(0x5EFE573046B565B5LL, mcrypt_module_close) {
        ci = &ci_mcrypt_module_close;
        return true;
      }
      break;
    case 1462:
      HASH_GUARD(0x1A05907F563235B6LL, collator_set_attribute) {
        ci = &ci_collator_set_attribute;
        return true;
      }
      break;
    case 1466:
      HASH_GUARD(0x05B8EB2C515885BALL, vprintf) {
        ci = &ci_vprintf;
        return true;
      }
      break;
    case 1472:
      HASH_GUARD(0x61465CD8C67905C0LL, openssl_pkey_free) {
        ci = &ci_openssl_pkey_free;
        return true;
      }
      break;
    case 1473:
      HASH_GUARD(0x7731B90FB7C975C1LL, magickremoveimageprofile) {
        ci = &ci_magickremoveimageprofile;
        return true;
      }
      break;
    case 1478:
      HASH_GUARD(0x3B3D5CE69B1565C6LL, mcrypt_module_is_block_mode) {
        ci = &ci_mcrypt_module_is_block_mode;
        return true;
      }
      break;
    case 1480:
      HASH_GUARD(0x1CE8175A87C785C8LL, dom_document_validate) {
        ci = &ci_dom_document_validate;
        return true;
      }
      break;
    case 1481:
      HASH_GUARD(0x75B299F5E35A95C9LL, mb_strwidth) {
        ci = &ci_mb_strwidth;
        return true;
      }
      HASH_GUARD(0x60F8818C0F38D5C9LL, hphp_directoryiterator___tostring) {
        ci = &ci_hphp_directoryiterator___tostring;
        return true;
      }
      break;
    case 1483:
      HASH_GUARD(0x6751946191FBE5CBLL, override_function) {
        ci = &ci_override_function;
        return true;
      }
      break;
    case 1484:
      HASH_GUARD(0x2A6F86821A39C5CCLL, expm1) {
        ci = &ci_expm1;
        return true;
      }
      break;
    case 1486:
      HASH_GUARD(0x406AC1DDB92925CELL, parse_hdf_file) {
        ci = &ci_parse_hdf_file;
        return true;
      }
      break;
    case 1487:
      HASH_GUARD(0x5D9818B3E1C385CFLL, openssl_pkey_export_to_file) {
        ci = &ci_openssl_pkey_export_to_file;
        return true;
      }
      break;
    case 1489:
      HASH_GUARD(0x054503DBBF5CA5D1LL, imagecopy) {
        ci = &ci_imagecopy;
        return true;
      }
      break;
    case 1492:
      HASH_GUARD(0x2FE56B4C457AB5D4LL, ctype_graph) {
        ci = &ci_ctype_graph;
        return true;
      }
      break;
    case 1493:
      HASH_GUARD(0x43901543EA8625D5LL, curl_multi_select) {
        ci = &ci_curl_multi_select;
        return true;
      }
      break;
    case 1494:
      HASH_GUARD(0x6D265875A19685D6LL, is_float) {
        ci = &ci_is_float;
        return true;
      }
      break;
    case 1495:
      HASH_GUARD(0x617AD1AD708785D7LL, magickmodulateimage) {
        ci = &ci_magickmodulateimage;
        return true;
      }
      break;
    case 1508:
      HASH_GUARD(0x3A9643992AC805E4LL, magickdrawimage) {
        ci = &ci_magickdrawimage;
        return true;
      }
      break;
    case 1509:
      HASH_GUARD(0x470F990B218315E5LL, fb_unset_taint) {
        ci = &ci_fb_unset_taint;
        return true;
      }
      break;
    case 1510:
      HASH_GUARD(0x6FE2E44FBC44E5E6LL, magickaddnoiseimage) {
        ci = &ci_magickaddnoiseimage;
        return true;
      }
      HASH_GUARD(0x08069ECE0EA3C5E6LL, imagecopymergegray) {
        ci = &ci_imagecopymergegray;
        return true;
      }
      break;
    case 1514:
      HASH_GUARD(0x0B7ACBAB402015EALL, mb_send_mail) {
        ci = &ci_mb_send_mail;
        return true;
      }
      break;
    case 1518:
      HASH_GUARD(0x3076D369F63E65EELL, pixelgetalpha) {
        ci = &ci_pixelgetalpha;
        return true;
      }
      break;
    case 1524:
      HASH_GUARD(0x1E89F15B7F2805F4LL, openssl_pkcs7_encrypt) {
        ci = &ci_openssl_pkcs7_encrypt;
        return true;
      }
      HASH_GUARD(0x459330C31956A5F4LL, vsprintf) {
        ci = &ci_vsprintf;
        return true;
      }
      break;
    case 1525:
      HASH_GUARD(0x0D1BD0E5AF4175F5LL, drawsetfont) {
        ci = &ci_drawsetfont;
        return true;
      }
      HASH_GUARD(0x73A1F34DF95B35F5LL, get_defined_constants) {
        ci = &ci_get_defined_constants;
        return true;
      }
      break;
    case 1527:
      HASH_GUARD(0x18E4CC945005E5F7LL, drawpushclippath) {
        ci = &ci_drawpushclippath;
        return true;
      }
      break;
    case 1528:
      HASH_GUARD(0x7C48F6EA39B7B5F8LL, magickadaptivethresholdimage) {
        ci = &ci_magickadaptivethresholdimage;
        return true;
      }
      break;
    case 1531:
      HASH_GUARD(0x3535B6615F2B05FBLL, session_cache_limiter) {
        ci = &ci_session_cache_limiter;
        return true;
      }
      HASH_GUARD(0x0FEC4ED541B7F5FBLL, magickgetimagevirtualpixelmethod) {
        ci = &ci_magickgetimagevirtualpixelmethod;
        return true;
      }
      break;
    case 1532:
      HASH_GUARD(0x39156C7CCE2D75FCLL, hash_update) {
        ci = &ci_hash_update;
        return true;
      }
      break;
    case 1533:
      HASH_GUARD(0x0C1CB24A3FC065FDLL, bcmul) {
        ci = &ci_bcmul;
        return true;
      }
      HASH_GUARD(0x46832743CAF5C5FDLL, dom_element_set_attribute_node) {
        ci = &ci_dom_element_set_attribute_node;
        return true;
      }
      break;
    case 1534:
      HASH_GUARD(0x397D3C6576ED75FELL, set_include_path) {
        ci = &ci_set_include_path;
        return true;
      }
      break;
    case 1535:
      HASH_GUARD(0x40A557CBB9FC35FFLL, mysql_tablename) {
        ci = &ci_mysql_tablename;
        return true;
      }
      break;
    case 1536:
      HASH_GUARD(0x552D7CAD93755600LL, dom_document_create_comment) {
        ci = &ci_dom_document_create_comment;
        return true;
      }
      break;
    case 1537:
      HASH_GUARD(0x0F3403D8676C2601LL, mysql_query) {
        ci = &ci_mysql_query;
        return true;
      }
      break;
    case 1545:
      HASH_GUARD(0x52D5698F31D12609LL, pcntl_setpriority) {
        ci = &ci_pcntl_setpriority;
        return true;
      }
      break;
    case 1555:
      HASH_GUARD(0x36783304F63C4613LL, sscanf) {
        ci = &ci_sscanf;
        return true;
      }
      HASH_GUARD(0x4AC405EA2B8C4613LL, magickresetiterator) {
        ci = &ci_magickresetiterator;
        return true;
      }
      break;
    case 1557:
      HASH_GUARD(0x6AD774816F8F7615LL, mb_strrchr) {
        ci = &ci_mb_strrchr;
        return true;
      }
      break;
    case 1558:
      HASH_GUARD(0x66C7616225F1C616LL, pixelsetgreen) {
        ci = &ci_pixelsetgreen;
        return true;
      }
      HASH_GUARD(0x7FA6D13B0D38E616LL, imagegif) {
        ci = &ci_imagegif;
        return true;
      }
      break;
    case 1561:
      HASH_GUARD(0x6DD51BF03F003619LL, mailparse_uudecode_all) {
        ci = &ci_mailparse_uudecode_all;
        return true;
      }
      HASH_GUARD(0x2F29627AF1A97619LL, shm_attach) {
        ci = &ci_shm_attach;
        return true;
      }
      break;
    case 1563:
      HASH_GUARD(0x40DDE277D934061BLL, gzputs) {
        ci = &ci_gzputs;
        return true;
      }
      break;
    case 1564:
      HASH_GUARD(0x70725954DC99F61CLL, mcrypt_create_iv) {
        ci = &ci_mcrypt_create_iv;
        return true;
      }
      break;
    case 1565:
      HASH_GUARD(0x69E1368FD737F61DLL, dom_namednodemap_get_named_item) {
        ci = &ci_dom_namednodemap_get_named_item;
        return true;
      }
      HASH_GUARD(0x7E98B97C1B5D861DLL, magickqueryconfigureoptions) {
        ci = &ci_magickqueryconfigureoptions;
        return true;
      }
      break;
    case 1569:
      HASH_GUARD(0x0F71DDE51AA55621LL, hphp_output_global_state) {
        ci = &ci_hphp_output_global_state;
        return true;
      }
      break;
    case 1570:
      HASH_GUARD(0x134550B9EB596622LL, drawgetfontstyle) {
        ci = &ci_drawgetfontstyle;
        return true;
      }
      break;
    case 1576:
      HASH_GUARD(0x1E77B3BCF062D628LL, magickreadimage) {
        ci = &ci_magickreadimage;
        return true;
      }
      break;
    case 1577:
      HASH_GUARD(0x679B81CE06EE0629LL, bcdiv) {
        ci = &ci_bcdiv;
        return true;
      }
      break;
    case 1578:
      HASH_GUARD(0x608EA42B08A7462ALL, linkinfo) {
        ci = &ci_linkinfo;
        return true;
      }
      break;
    case 1580:
      HASH_GUARD(0x5CEA60D9C54A162CLL, pcntl_wifstopped) {
        ci = &ci_pcntl_wifstopped;
        return true;
      }
      break;
    case 1583:
      HASH_GUARD(0x652C331CE138362FLL, is_string) {
        ci = &ci_is_string;
        return true;
      }
      break;
    case 1585:
      HASH_GUARD(0x5AD6595ACA656631LL, pixelresetiterator) {
        ci = &ci_pixelresetiterator;
        return true;
      }
      break;
    case 1591:
      HASH_GUARD(0x60276BC7990F9637LL, mysql_list_dbs) {
        ci = &ci_mysql_list_dbs;
        return true;
      }
      HASH_GUARD(0x75AFA49220C9B637LL, collator_sort) {
        ci = &ci_collator_sort;
        return true;
      }
      break;
    case 1595:
      HASH_GUARD(0x391C68F2BE85E63BLL, pixelgetiteratorexceptionstring) {
        ci = &ci_pixelgetiteratorexceptionstring;
        return true;
      }
      break;
    case 1596:
      HASH_GUARD(0x62DE03461EF4663CLL, symlink) {
        ci = &ci_symlink;
        return true;
      }
      break;
    case 1598:
      HASH_GUARD(0x60302D15A677963ELL, ldap_free_result) {
        ci = &ci_ldap_free_result;
        return true;
      }
      break;
    case 1599:
      HASH_GUARD(0x17242BC6C9C9563FLL, crypt) {
        ci = &ci_crypt;
        return true;
      }
      break;
    case 1606:
      HASH_GUARD(0x4901517CB796F646LL, msg_set_queue) {
        ci = &ci_msg_set_queue;
        return true;
      }
      HASH_GUARD(0x234F6A0A486E8646LL, natcasesort) {
        ci = &ci_natcasesort;
        return true;
      }
      break;
    case 1614:
      HASH_GUARD(0x7E978C38D741664ELL, fgetcsv) {
        ci = &ci_fgetcsv;
        return true;
      }
      HASH_GUARD(0x769E5C6A5369F64ELL, ob_list_handlers) {
        ci = &ci_ob_list_handlers;
        return true;
      }
      break;
    case 1618:
      HASH_GUARD(0x03066277F647E652LL, hphp_splfileobject_ftell) {
        ci = &ci_hphp_splfileobject_ftell;
        return true;
      }
      break;
    case 1621:
      HASH_GUARD(0x629EDDC1E74ED655LL, array_uintersect_assoc) {
        ci = &ci_array_uintersect_assoc;
        return true;
      }
      break;
    case 1625:
      HASH_GUARD(0x7A4B37C23D674659LL, collator_get_error_message) {
        ci = &ci_collator_get_error_message;
        return true;
      }
      break;
    case 1628:
      HASH_GUARD(0x381BBFEABFEC865CLL, libxml_get_last_error) {
        ci = &ci_libxml_get_last_error;
        return true;
      }
      break;
    case 1630:
      HASH_GUARD(0x1491ED033E39465ELL, dom_document_schema_validate_xml) {
        ci = &ci_dom_document_schema_validate_xml;
        return true;
      }
      HASH_GUARD(0x205BB9CFF397B65ELL, ldap_mod_replace) {
        ci = &ci_ldap_mod_replace;
        return true;
      }
      break;
    case 1631:
      HASH_GUARD(0x1355AFB40AB1165FLL, drawsetfontstyle) {
        ci = &ci_drawsetfontstyle;
        return true;
      }
      break;
    case 1634:
      HASH_GUARD(0x5629E14D6B9FF662LL, dom_document_get_element_by_id) {
        ci = &ci_dom_document_get_element_by_id;
        return true;
      }
      break;
    case 1636:
      HASH_GUARD(0x5B0759F776EC2664LL, newdrawingwand) {
        ci = &ci_newdrawingwand;
        return true;
      }
      break;
    case 1637:
      HASH_GUARD(0x08A6AD20C2C5A665LL, hphp_set_static_property) {
        ci = &ci_hphp_set_static_property;
        return true;
      }
      break;
    case 1639:
      HASH_GUARD(0x557A08AC57724667LL, hphp_splfileinfo_getpathinfo) {
        ci = &ci_hphp_splfileinfo_getpathinfo;
        return true;
      }
      break;
    case 1647:
      HASH_GUARD(0x7D68CADB8069466FLL, magickaverageimages) {
        ci = &ci_magickaverageimages;
        return true;
      }
      break;
    case 1651:
      HASH_GUARD(0x126FC82D358E9673LL, magicksetimagevirtualpixelmethod) {
        ci = &ci_magicksetimagevirtualpixelmethod;
        return true;
      }
      break;
    case 1655:
      HASH_GUARD(0x001F23CAC36E3677LL, magickgetimagescene) {
        ci = &ci_magickgetimagescene;
        return true;
      }
      break;
    case 1658:
      HASH_GUARD(0x583AA7498A40E67ALL, drawgetcliprule) {
        ci = &ci_drawgetcliprule;
        return true;
      }
      break;
    case 1659:
      HASH_GUARD(0x5BCED33A57D9B67BLL, intval) {
        ci = &ci_intval;
        return true;
      }
      break;
    case 1660:
      HASH_GUARD(0x43B1BAFFB27F367CLL, session_is_registered) {
        ci = &ci_session_is_registered;
        return true;
      }
      break;
    case 1661:
      HASH_GUARD(0x69616E2817E1967DLL, fileinode) {
        ci = &ci_fileinode;
        return true;
      }
      HASH_GUARD(0x111DACCF8628267DLL, array_replace_recursive) {
        ci = &ci_array_replace_recursive;
        return true;
      }
      break;
    case 1666:
      HASH_GUARD(0x665D2615E377A682LL, pagelet_server_task_start) {
        ci = &ci_pagelet_server_task_start;
        return true;
      }
      HASH_GUARD(0x5F6750E1C7E5D682LL, imageinterlace) {
        ci = &ci_imageinterlace;
        return true;
      }
      break;
    case 1677:
      HASH_GUARD(0x07A946E3DD8E968DLL, ldap_connect) {
        ci = &ci_ldap_connect;
        return true;
      }
      break;
    case 1679:
      HASH_GUARD(0x2EFF4F69EB1DF68FLL, apache_get_config) {
        ci = &ci_apache_get_config;
        return true;
      }
      break;
    case 1680:
      HASH_GUARD(0x166D5E2336878690LL, imagepolygon) {
        ci = &ci_imagepolygon;
        return true;
      }
      break;
    case 1681:
      HASH_GUARD(0x57BA0BC1A4870691LL, magickgetquantumdepth) {
        ci = &ci_magickgetquantumdepth;
        return true;
      }
      break;
    case 1682:
      HASH_GUARD(0x16BE0DBA42800692LL, magickgetimagesize) {
        ci = &ci_magickgetimagesize;
        return true;
      }
      break;
    case 1684:
      HASH_GUARD(0x2673FAB2B4DE4694LL, destroypixelwands) {
        ci = &ci_destroypixelwands;
        return true;
      }
      break;
    case 1685:
      HASH_GUARD(0x7186EF5EF0581695LL, exp) {
        ci = &ci_exp;
        return true;
      }
      break;
    case 1686:
      HASH_GUARD(0x0DD7A2DB53093696LL, utf8_decode) {
        ci = &ci_utf8_decode;
        return true;
      }
      break;
    case 1690:
      HASH_GUARD(0x5CC40F6A365FE69ALL, session_register) {
        ci = &ci_session_register;
        return true;
      }
      break;
    case 1691:
      HASH_GUARD(0x24D34E49C21DE69BLL, mb_stristr) {
        ci = &ci_mb_stristr;
        return true;
      }
      break;
    case 1694:
      HASH_GUARD(0x5E9821F06711669ELL, gethostbynamel) {
        ci = &ci_gethostbynamel;
        return true;
      }
      break;
    case 1702:
      HASH_GUARD(0x0D841874977646A6LL, krsort) {
        ci = &ci_krsort;
        return true;
      }
      break;
    case 1703:
      HASH_GUARD(0x38BBEE42F136D6A7LL, magickgetimageblueprimary) {
        ci = &ci_magickgetimageblueprimary;
        return true;
      }
      break;
    case 1704:
      HASH_GUARD(0x45AB8F419BA666A8LL, drawpathlinetohorizontalabsolute) {
        ci = &ci_drawpathlinetohorizontalabsolute;
        return true;
      }
      break;
    case 1706:
      HASH_GUARD(0x6E9D4D3A119D76AALL, wandgetexceptiontype) {
        ci = &ci_wandgetexceptiontype;
        return true;
      }
      HASH_GUARD(0x48C4DB333172F6AALL, parse_url) {
        ci = &ci_parse_url;
        return true;
      }
      HASH_GUARD(0x541926FB6D6FC6AALL, magickgetimagecolors) {
        ci = &ci_magickgetimagecolors;
        return true;
      }
      break;
    case 1707:
      HASH_GUARD(0x72B3F8E02D8B16ABLL, array_unshift) {
        ci = &ci_array_unshift;
        return true;
      }
      break;
    case 1711:
      HASH_GUARD(0x65497D63C0D716AFLL, getdate) {
        ci = &ci_getdate;
        return true;
      }
      break;
    case 1712:
      HASH_GUARD(0x23AAF570C78AC6B0LL, ip2long) {
        ci = &ci_ip2long;
        return true;
      }
      break;
    case 1714:
      HASH_GUARD(0x0D669C546C0EC6B2LL, proc_terminate) {
        ci = &ci_proc_terminate;
        return true;
      }
      break;
    case 1717:
      HASH_GUARD(0x798B4197212456B5LL, bcpowmod) {
        ci = &ci_bcpowmod;
        return true;
      }
      HASH_GUARD(0x623CE67C41A9E6B5LL, ldap_next_attribute) {
        ci = &ci_ldap_next_attribute;
        return true;
      }
      HASH_GUARD(0x7E773A36449576B5LL, imagecharup) {
        ci = &ci_imagecharup;
        return true;
      }
      break;
    case 1719:
      HASH_GUARD(0x0C44E5EEB9C646B7LL, memcache_connect) {
        ci = &ci_memcache_connect;
        return true;
      }
      break;
    case 1721:
      HASH_GUARD(0x316F054CB76446B9LL, openssl_sign) {
        ci = &ci_openssl_sign;
        return true;
      }
      break;
    case 1722:
      HASH_GUARD(0x4605D48C234606BALL, dom_document_import_node) {
        ci = &ci_dom_document_import_node;
        return true;
      }
      HASH_GUARD(0x72B901C3605CB6BALL, pixelsetopacity) {
        ci = &ci_pixelsetopacity;
        return true;
      }
      break;
    case 1726:
      HASH_GUARD(0x081D5EA9920076BELL, drawgetfillalpha) {
        ci = &ci_drawgetfillalpha;
        return true;
      }
      break;
    case 1732:
      HASH_GUARD(0x4842AF70A71BE6C4LL, uksort) {
        ci = &ci_uksort;
        return true;
      }
      HASH_GUARD(0x34184B42D6AA86C4LL, mb_ereg_search_pos) {
        ci = &ci_mb_ereg_search_pos;
        return true;
      }
      HASH_GUARD(0x3C042C09F662C6C4LL, drawsetstrokepatternurl) {
        ci = &ci_drawsetstrokepatternurl;
        return true;
      }
      break;
    case 1733:
      HASH_GUARD(0x28526EF49FF516C5LL, pixelsetgreenquantum) {
        ci = &ci_pixelsetgreenquantum;
        return true;
      }
      break;
    case 1736:
      HASH_GUARD(0x29DD2C9F889246C8LL, passthru) {
        ci = &ci_passthru;
        return true;
      }
      break;
    case 1737:
      HASH_GUARD(0x2D8DF100C30D06C9LL, xmlwriter_set_indent_string) {
        ci = &ci_xmlwriter_set_indent_string;
        return true;
      }
      break;
    case 1738:
      HASH_GUARD(0x41BCD0A72B1396CALL, xmlwriter_start_dtd_attlist) {
        ci = &ci_xmlwriter_start_dtd_attlist;
        return true;
      }
      break;
    case 1745:
      HASH_GUARD(0x2B3D5B9AF915D6D1LL, imagecopymerge) {
        ci = &ci_imagecopymerge;
        return true;
      }
      break;
    case 1746:
      HASH_GUARD(0x1FDF80EA9B8A96D2LL, collator_set_strength) {
        ci = &ci_collator_set_strength;
        return true;
      }
      break;
    case 1748:
      HASH_GUARD(0x04A0E6E8337E56D4LL, drawcolor) {
        ci = &ci_drawcolor;
        return true;
      }
      break;
    case 1749:
      HASH_GUARD(0x317FFA522A7D96D5LL, imagefilledpolygon) {
        ci = &ci_imagefilledpolygon;
        return true;
      }
      break;
    case 1750:
      HASH_GUARD(0x158348EB08F406D6LL, strtr) {
        ci = &ci_strtr;
        return true;
      }
      break;
    case 1761:
      HASH_GUARD(0x11DA0A0EB8E0D6E1LL, clock_getres) {
        ci = &ci_clock_getres;
        return true;
      }
      break;
    case 1764:
      HASH_GUARD(0x40D0E3AF799226E4LL, bin2hex) {
        ci = &ci_bin2hex;
        return true;
      }
      HASH_GUARD(0x1CF3544CB5C9D6E4LL, xml_set_processing_instruction_handler) {
        ci = &ci_xml_set_processing_instruction_handler;
        return true;
      }
      HASH_GUARD(0x31FFFC333AA6D6E4LL, drawsetfillrule) {
        ci = &ci_drawsetfillrule;
        return true;
      }
      break;
    case 1767:
      HASH_GUARD(0x44201A16F3D876E7LL, trim) {
        ci = &ci_trim;
        return true;
      }
      break;
    case 1772:
      HASH_GUARD(0x0A5EFECAE87EA6ECLL, hphp_splfileobject_eof) {
        ci = &ci_hphp_splfileobject_eof;
        return true;
      }
      break;
    case 1773:
      HASH_GUARD(0x04BD4B43921956EDLL, ldap_search) {
        ci = &ci_ldap_search;
        return true;
      }
      HASH_GUARD(0x2B661CD43C6006EDLL, hphpd_break) {
        ci = &ci_hphpd_break;
        return true;
      }
      break;
    case 1774:
      HASH_GUARD(0x76382756EA00B6EELL, is_object) {
        ci = &ci_is_object;
        return true;
      }
      break;
    case 1775:
      HASH_GUARD(0x0FA74D85885F86EFLL, output_add_rewrite_var) {
        ci = &ci_output_add_rewrite_var;
        return true;
      }
      break;
    case 1776:
      HASH_GUARD(0x014BD9A6823256F0LL, extract) {
        ci = &ci_extract;
        return true;
      }
      break;
    case 1777:
      HASH_GUARD(0x6B7347DF1AA7E6F1LL, drawpopdefs) {
        ci = &ci_drawpopdefs;
        return true;
      }
      break;
    case 1778:
      HASH_GUARD(0x314DA880FE2CE6F2LL, session_start) {
        ci = &ci_session_start;
        return true;
      }
      break;
    case 1779:
      HASH_GUARD(0x6F1968BE449FB6F3LL, stream_socket_pair) {
        ci = &ci_stream_socket_pair;
        return true;
      }
      HASH_GUARD(0x5768A80BB0B926F3LL, apd_set_session_trace_socket) {
        ci = &ci_apd_set_session_trace_socket;
        return true;
      }
      break;
    case 1782:
      HASH_GUARD(0x534C1A5E626C26F6LL, collator_get_error_code) {
        ci = &ci_collator_get_error_code;
        return true;
      }
      break;
    case 1785:
      HASH_GUARD(0x20740D956F0236F9LL, image2wbmp) {
        ci = &ci_image2wbmp;
        return true;
      }
      break;
    case 1791:
      HASH_GUARD(0x623C20A027A606FFLL, array_uintersect_uassoc) {
        ci = &ci_array_uintersect_uassoc;
        return true;
      }
      break;
    case 1793:
      HASH_GUARD(0x1A80392751AA7701LL, magickgetformat) {
        ci = &ci_magickgetformat;
        return true;
      }
      break;
    case 1796:
      HASH_GUARD(0x5EFE15CE970A5704LL, drawpolyline) {
        ci = &ci_drawpolyline;
        return true;
      }
      break;
    case 1801:
      HASH_GUARD(0x7681C631B34CC709LL, hphp_splfileobject_fflush) {
        ci = &ci_hphp_splfileobject_fflush;
        return true;
      }
      HASH_GUARD(0x21972B2BC7A14709LL, imageistruecolor) {
        ci = &ci_imageistruecolor;
        return true;
      }
      break;
    case 1803:
      HASH_GUARD(0x27AF8F6A5DF0B70BLL, dom_document_xinclude) {
        ci = &ci_dom_document_xinclude;
        return true;
      }
      HASH_GUARD(0x5F7873F2DF5BE70BLL, ctype_cntrl) {
        ci = &ci_ctype_cntrl;
        return true;
      }
      break;
    case 1805:
      HASH_GUARD(0x7CE752299E80B70DLL, unserialize) {
        ci = &ci_unserialize;
        return true;
      }
      HASH_GUARD(0x4F3C0DB2F6C8F70DLL, unlink) {
        ci = &ci_unlink;
        return true;
      }
      break;
    case 1807:
      HASH_GUARD(0x2FB2FA1DD832C70FLL, xmlwriter_write_attribute_ns) {
        ci = &ci_xmlwriter_write_attribute_ns;
        return true;
      }
      break;
    case 1812:
      HASH_GUARD(0x1778ED2AF035F714LL, rsort) {
        ci = &ci_rsort;
        return true;
      }
      break;
    case 1813:
      HASH_GUARD(0x25D578B4772C1715LL, define) {
        ci = &ci_define;
        return true;
      }
      break;
    case 1816:
      HASH_GUARD(0x7971A5647C957718LL, date_time_set) {
        ci = &ci_date_time_set;
        return true;
      }
      break;
    case 1819:
      HASH_GUARD(0x3C16230CBC6D471BLL, imagecreatetruecolor) {
        ci = &ci_imagecreatetruecolor;
        return true;
      }
      break;
    case 1820:
      HASH_GUARD(0x50AC61A28C5AC71CLL, imagecolorclosestalpha) {
        ci = &ci_imagecolorclosestalpha;
        return true;
      }
      break;
    case 1824:
      HASH_GUARD(0x2D213FD80048F720LL, usleep) {
        ci = &ci_usleep;
        return true;
      }
      break;
    case 1827:
      HASH_GUARD(0x78420E0B5D110723LL, imagetruecolortopalette) {
        ci = &ci_imagetruecolortopalette;
        return true;
      }
      break;
    case 1828:
      HASH_GUARD(0x4DAA3FBC2BD3A724LL, magickequalizeimage) {
        ci = &ci_magickequalizeimage;
        return true;
      }
      break;
    case 1829:
      HASH_GUARD(0x31EAD049860CE725LL, posix_kill) {
        ci = &ci_posix_kill;
        return true;
      }
      break;
    case 1830:
      HASH_GUARD(0x523AB2EA95DAD726LL, get_included_files) {
        ci = &ci_get_included_files;
        return true;
      }
      break;
    case 1831:
      HASH_GUARD(0x11641BE0F11CD727LL, magickgammaimage) {
        ci = &ci_magickgammaimage;
        return true;
      }
      break;
    case 1833:
      HASH_GUARD(0x1D30F1E638D71729LL, readgzfile) {
        ci = &ci_readgzfile;
        return true;
      }
      break;
    case 1834:
      HASH_GUARD(0x17C0D9B1C10B872ALL, openssl_x509_export) {
        ci = &ci_openssl_x509_export;
        return true;
      }
      HASH_GUARD(0x1F98B41362CDA72ALL, magickgetimagegreenprimary) {
        ci = &ci_magickgetimagegreenprimary;
        return true;
      }
      break;
    case 1837:
      HASH_GUARD(0x14563723F798172DLL, magickpaintopaqueimage) {
        ci = &ci_magickpaintopaqueimage;
        return true;
      }
      break;
    case 1840:
      HASH_GUARD(0x0D558F552A784730LL, ob_get_contents) {
        ci = &ci_ob_get_contents;
        return true;
      }
      break;
    case 1842:
      HASH_GUARD(0x2B1C192C419B8732LL, drawgetexception) {
        ci = &ci_drawgetexception;
        return true;
      }
      break;
    case 1850:
      HASH_GUARD(0x404236CC5ABD973ALL, xhprof_run_trace) {
        ci = &ci_xhprof_run_trace;
        return true;
      }
      break;
    case 1855:
      HASH_GUARD(0x650E641CC0E3873FLL, connection_aborted) {
        ci = &ci_connection_aborted;
        return true;
      }
      break;
    case 1857:
      HASH_GUARD(0x5062777D2B947741LL, wordwrap) {
        ci = &ci_wordwrap;
        return true;
      }
      break;
    case 1863:
      HASH_GUARD(0x3CD58419E181A747LL, magickstereoimage) {
        ci = &ci_magickstereoimage;
        return true;
      }
      HASH_GUARD(0x13BB9EC5A2D2E747LL, hphp_splfileinfo_isdir) {
        ci = &ci_hphp_splfileinfo_isdir;
        return true;
      }
      break;
    case 1864:
      HASH_GUARD(0x0D7BBA9608A36748LL, magickcombineimages) {
        ci = &ci_magickcombineimages;
        return true;
      }
      break;
    case 1865:
      HASH_GUARD(0x73E4417BA7B49749LL, curl_multi_info_read) {
        ci = &ci_curl_multi_info_read;
        return true;
      }
      break;
    case 1866:
      HASH_GUARD(0x1FF03B7DE19DD74ALL, drawpathmovetorelative) {
        ci = &ci_drawpathmovetorelative;
        return true;
      }
      break;
    case 1867:
      HASH_GUARD(0x7DA9307A6149B74BLL, get_meta_tags) {
        ci = &ci_get_meta_tags;
        return true;
      }
      break;
    case 1873:
      HASH_GUARD(0x017FF216C00D9751LL, property_exists) {
        ci = &ci_property_exists;
        return true;
      }
      break;
    case 1875:
      HASH_GUARD(0x42795829DF700753LL, mysql_get_host_info) {
        ci = &ci_mysql_get_host_info;
        return true;
      }
      break;
    case 1876:
      HASH_GUARD(0x53AEFD595C044754LL, max) {
        ci = &ci_max;
        return true;
      }
      break;
    case 1879:
      HASH_GUARD(0x7554E3E8674F2757LL, mb_list_encodings) {
        ci = &ci_mb_list_encodings;
        return true;
      }
      break;
    case 1883:
      HASH_GUARD(0x05D293F45C15F75BLL, ldap_mod_del) {
        ci = &ci_ldap_mod_del;
        return true;
      }
      break;
    case 1884:
      HASH_GUARD(0x6D5B592E524AF75CLL, hphp_splfileinfo_getbasename) {
        ci = &ci_hphp_splfileinfo_getbasename;
        return true;
      }
      break;
    case 1887:
      HASH_GUARD(0x3EDB48C5DDD9675FLL, socket_select) {
        ci = &ci_socket_select;
        return true;
      }
      break;
    case 1888:
      HASH_GUARD(0x1BD984C11BB16760LL, array_merge) {
        ci = &ci_array_merge;
        return true;
      }
      HASH_GUARD(0x7AB5E6EA37196760LL, date_timezone_set) {
        ci = &ci_date_timezone_set;
        return true;
      }
      break;
    case 1889:
      HASH_GUARD(0x6AF50085AC2AC761LL, xmlwriter_write_element) {
        ci = &ci_xmlwriter_write_element;
        return true;
      }
      break;
    case 1891:
      HASH_GUARD(0x7FCE6DD53FED6763LL, intl_is_failure) {
        ci = &ci_intl_is_failure;
        return true;
      }
      break;
    case 1893:
      HASH_GUARD(0x1D803CE961921765LL, md5) {
        ci = &ci_md5;
        return true;
      }
      HASH_GUARD(0x45631C592AD6D765LL, str_ireplace) {
        ci = &ci_str_ireplace;
        return true;
      }
      break;
    case 1894:
      HASH_GUARD(0x1F4505BE6460D766LL, scandir) {
        ci = &ci_scandir;
        return true;
      }
      break;
    case 1895:
      HASH_GUARD(0x2FC27987B3F88767LL, dom_node_clone_node) {
        ci = &ci_dom_node_clone_node;
        return true;
      }
      HASH_GUARD(0x6C280D5855D20767LL, drawsetfillalpha) {
        ci = &ci_drawsetfillalpha;
        return true;
      }
      break;
    case 1896:
      HASH_GUARD(0x179A72074C778768LL, openssl_x509_export_to_file) {
        ci = &ci_openssl_x509_export_to_file;
        return true;
      }
      break;
    case 1901:
      HASH_GUARD(0x3304663FBC6C976DLL, get_html_translation_table) {
        ci = &ci_get_html_translation_table;
        return true;
      }
      HASH_GUARD(0x553ADA5A41AE976DLL, mb_ereg_replace) {
        ci = &ci_mb_ereg_replace;
        return true;
      }
      break;
    case 1902:
      HASH_GUARD(0x6DB71D850799D76ELL, hphp_splfileobject_fscanf) {
        ci = &ci_hphp_splfileobject_fscanf;
        return true;
      }
      break;
    case 1904:
      HASH_GUARD(0x6F6C5B9E3DC64770LL, drawgetstrokemiterlimit) {
        ci = &ci_drawgetstrokemiterlimit;
        return true;
      }
      break;
    case 1909:
      HASH_GUARD(0x04D9076808F79775LL, getenv) {
        ci = &ci_getenv;
        return true;
      }
      break;
    case 1910:
      HASH_GUARD(0x616DDB67073A0776LL, ord) {
        ci = &ci_ord;
        return true;
      }
      HASH_GUARD(0x4102C410C5031776LL, magickcolorizeimage) {
        ci = &ci_magickcolorizeimage;
        return true;
      }
      break;
    case 1914:
      HASH_GUARD(0x1FBF36B5D65E677ALL, fb_call_user_func_safe_return) {
        ci = &ci_fb_call_user_func_safe_return;
        return true;
      }
      HASH_GUARD(0x4330CE9C9002477ALL, array_udiff_uassoc) {
        ci = &ci_array_udiff_uassoc;
        return true;
      }
      break;
    case 1915:
      HASH_GUARD(0x129E39AC523A977BLL, magickgethomeurl) {
        ci = &ci_magickgethomeurl;
        return true;
      }
      break;
    case 1920:
      HASH_GUARD(0x29824AAA934CE780LL, array_filter) {
        ci = &ci_array_filter;
        return true;
      }
      break;
    case 1923:
      HASH_GUARD(0x53B4DBE58B356783LL, imagesetthickness) {
        ci = &ci_imagesetthickness;
        return true;
      }
      HASH_GUARD(0x38704D99FEA9B783LL, mysql_fetch_array) {
        ci = &ci_mysql_fetch_array;
        return true;
      }
      break;
    case 1924:
      HASH_GUARD(0x784FD2E7191A3784LL, drawpathellipticarcrelative) {
        ci = &ci_drawpathellipticarcrelative;
        return true;
      }
      break;
    case 1925:
      HASH_GUARD(0x5BFC6198960A5785LL, in_array) {
        ci = &ci_in_array;
        return true;
      }
      break;
    case 1927:
      HASH_GUARD(0x4991643BD854D787LL, drawgetexceptionstring) {
        ci = &ci_drawgetexceptionstring;
        return true;
      }
      break;
    case 1928:
      HASH_GUARD(0x32D8CE5D0FA6D788LL, ldap_rename) {
        ci = &ci_ldap_rename;
        return true;
      }
      break;
    case 1930:
      HASH_GUARD(0x70A1EC006032E78ALL, pixelgetquantumcolor) {
        ci = &ci_pixelgetquantumcolor;
        return true;
      }
      break;
    case 1935:
      HASH_GUARD(0x7B4E25772D0AC78FLL, simplexml_load_file) {
        ci = &ci_simplexml_load_file;
        return true;
      }
      break;
    case 1938:
      HASH_GUARD(0x0D4891A5E1A20792LL, get_defined_functions) {
        ci = &ci_get_defined_functions;
        return true;
      }
      break;
    case 1941:
      HASH_GUARD(0x34BA3AAA6711C795LL, dom_document_create_entity_reference) {
        ci = &ci_dom_document_create_entity_reference;
        return true;
      }
      break;
    case 1942:
      HASH_GUARD(0x5B42B2AB1B57D796LL, array_replace) {
        ci = &ci_array_replace;
        return true;
      }
      break;
    case 1945:
      HASH_GUARD(0x26D226FD28566799LL, date_isodate_set) {
        ci = &ci_date_isodate_set;
        return true;
      }
      break;
    case 1947:
      HASH_GUARD(0x1196D899ACCD379BLL, evhttp_recv) {
        ci = &ci_evhttp_recv;
        return true;
      }
      break;
    case 1949:
      HASH_GUARD(0x02ECD8C169DF579DLL, feof) {
        ci = &ci_feof;
        return true;
      }
      break;
    case 1951:
      HASH_GUARD(0x4B092931EFB7979FLL, mysql_create_db) {
        ci = &ci_mysql_create_db;
        return true;
      }
      break;
    case 1959:
      HASH_GUARD(0x1F76E954F9A147A7LL, magickcontrastimage) {
        ci = &ci_magickcontrastimage;
        return true;
      }
      break;
    case 1961:
      HASH_GUARD(0x7C251B7DE8DB87A9LL, mcrypt_list_algorithms) {
        ci = &ci_mcrypt_list_algorithms;
        return true;
      }
      HASH_GUARD(0x7707A7FEA07FB7A9LL, hphp_recursivedirectoryiterator___construct) {
        ci = &ci_hphp_recursivedirectoryiterator___construct;
        return true;
      }
      break;
    case 1962:
      HASH_GUARD(0x45A53A884414A7AALL, pack) {
        ci = &ci_pack;
        return true;
      }
      HASH_GUARD(0x58D6464A3A9127AALL, apc_bin_loadfile) {
        ci = &ci_apc_bin_loadfile;
        return true;
      }
      break;
    case 1965:
      HASH_GUARD(0x7DA08D9D148837ADLL, posix_mkfifo) {
        ci = &ci_posix_mkfifo;
        return true;
      }
      break;
    case 1966:
      HASH_GUARD(0x00141B0E3E6F77AELL, xml_set_unparsed_entity_decl_handler) {
        ci = &ci_xml_set_unparsed_entity_decl_handler;
        return true;
      }
      break;
    case 1967:
      HASH_GUARD(0x16CB9891EF26D7AFLL, drawgetstrokedashoffset) {
        ci = &ci_drawgetstrokedashoffset;
        return true;
      }
      break;
    case 1977:
      HASH_GUARD(0x1FC9406FD7FCD7B9LL, strrpos) {
        ci = &ci_strrpos;
        return true;
      }
      HASH_GUARD(0x1B6467AD87E167B9LL, log1p) {
        ci = &ci_log1p;
        return true;
      }
      break;
    case 1983:
      HASH_GUARD(0x3F46374E6E1B07BFLL, posix_getpwuid) {
        ci = &ci_posix_getpwuid;
        return true;
      }
      break;
    case 1984:
      HASH_GUARD(0x152D1AB941A647C0LL, hphp_get_extension_info) {
        ci = &ci_hphp_get_extension_info;
        return true;
      }
      HASH_GUARD(0x52FDAC1D298D67C0LL, mcrypt_enc_get_algorithms_name) {
        ci = &ci_mcrypt_enc_get_algorithms_name;
        return true;
      }
      break;
    case 1985:
      HASH_GUARD(0x4E172EA6743697C1LL, ldap_first_entry) {
        ci = &ci_ldap_first_entry;
        return true;
      }
      break;
    case 1988:
      HASH_GUARD(0x3C696836396BE7C4LL, mb_language) {
        ci = &ci_mb_language;
        return true;
      }
      break;
    case 1990:
      HASH_GUARD(0x0C8A7BE6ABC957C6LL, clearpixeliterator) {
        ci = &ci_clearpixeliterator;
        return true;
      }
      HASH_GUARD(0x3D6D684AF537A7C6LL, ldap_explode_dn) {
        ci = &ci_ldap_explode_dn;
        return true;
      }
      break;
    case 1991:
      HASH_GUARD(0x686C5142FD0337C7LL, lcg_value) {
        ci = &ci_lcg_value;
        return true;
      }
      break;
    case 1993:
      HASH_GUARD(0x6BF7D7B5FBFF77C9LL, hphp_get_thread_id) {
        ci = &ci_hphp_get_thread_id;
        return true;
      }
      break;
    case 1994:
      HASH_GUARD(0x3C781898488687CALL, xml_parse) {
        ci = &ci_xml_parse;
        return true;
      }
      HASH_GUARD(0x55B68546CFAC87CALL, magicksetimageresolution) {
        ci = &ci_magicksetimageresolution;
        return true;
      }
      break;
    case 1998:
      HASH_GUARD(0x3AE33FEA6830C7CELL, magickshearimage) {
        ci = &ci_magickshearimage;
        return true;
      }
      break;
    case 1999:
      HASH_GUARD(0x2FAB1F75659707CFLL, is_scalar) {
        ci = &ci_is_scalar;
        return true;
      }
      break;
    case 2001:
      HASH_GUARD(0x35B661C87484D7D1LL, openssl_csr_sign) {
        ci = &ci_openssl_csr_sign;
        return true;
      }
      break;
    case 2009:
      HASH_GUARD(0x2ED6760DAA3A67D9LL, strcasecmp) {
        ci = &ci_strcasecmp;
        return true;
      }
      break;
    case 2012:
      HASH_GUARD(0x1FE65AFCC92967DCLL, rmdir) {
        ci = &ci_rmdir;
        return true;
      }
      break;
    case 2013:
      HASH_GUARD(0x2B5AEDF1A5FC47DDLL, strripos) {
        ci = &ci_strripos;
        return true;
      }
      break;
    case 2017:
      HASH_GUARD(0x7AA1691D3D94A7E1LL, dom_xpath_evaluate) {
        ci = &ci_dom_xpath_evaluate;
        return true;
      }
      break;
    case 2018:
      HASH_GUARD(0x0888289CBD2887E2LL, iconv_substr) {
        ci = &ci_iconv_substr;
        return true;
      }
      break;
    case 2020:
      HASH_GUARD(0x2621680306BC97E4LL, magicksetimagescene) {
        ci = &ci_magicksetimagescene;
        return true;
      }
      break;
    case 2023:
      HASH_GUARD(0x4215DDB57604F7E7LL, xmlwriter_start_pi) {
        ci = &ci_xmlwriter_start_pi;
        return true;
      }
      break;
    case 2024:
      HASH_GUARD(0x53B7BF8991FA67E8LL, i18n_loc_get_error_code) {
        ci = &ci_i18n_loc_get_error_code;
        return true;
      }
      break;
    case 2025:
      HASH_GUARD(0x6BB8AC68771287E9LL, strcmp) {
        ci = &ci_strcmp;
        return true;
      }
      break;
    case 2027:
      HASH_GUARD(0x54AE7140B95027EBLL, pixelgetgreenquantum) {
        ci = &ci_pixelgetgreenquantum;
        return true;
      }
      HASH_GUARD(0x1A397501431EC7EBLL, is_numeric) {
        ci = &ci_is_numeric;
        return true;
      }
      break;
    case 2029:
      HASH_GUARD(0x0DC2C2D372EC97EDLL, hphp_crash_log) {
        ci = &ci_hphp_crash_log;
        return true;
      }
      break;
    case 2031:
      HASH_GUARD(0x5367B0F3A4D2D7EFLL, ldap_list) {
        ci = &ci_ldap_list;
        return true;
      }
      break;
    case 2032:
      HASH_GUARD(0x14F700DD189DB7F0LL, drawsetclipunits) {
        ci = &ci_drawsetclipunits;
        return true;
      }
      break;
    case 2035:
      HASH_GUARD(0x73877357478137F3LL, posix_ctermid) {
        ci = &ci_posix_ctermid;
        return true;
      }
      HASH_GUARD(0x4B57E07A323FE7F3LL, drawpathlinetoverticalabsolute) {
        ci = &ci_drawpathlinetoverticalabsolute;
        return true;
      }
      HASH_GUARD(0x7F436B50B7BBD7F3LL, getcwd) {
        ci = &ci_getcwd;
        return true;
      }
      break;
    case 2041:
      HASH_GUARD(0x376FB2649384A7F9LL, str_pad) {
        ci = &ci_str_pad;
        return true;
      }
      break;
    case 2042:
      HASH_GUARD(0x0FD7C3144B4007FALL, libxml_set_streams_context) {
        ci = &ci_libxml_set_streams_context;
        return true;
      }
      break;
    case 2045:
      HASH_GUARD(0x238E501F2536E7FDLL, drawsetclippath) {
        ci = &ci_drawsetclippath;
        return true;
      }
      break;
    case 2048:
      HASH_GUARD(0x0E66983DD04B0800LL, get_current_user) {
        ci = &ci_get_current_user;
        return true;
      }
      break;
    case 2049:
      HASH_GUARD(0x290E54137CF06801LL, dom_nodelist_item) {
        ci = &ci_dom_nodelist_item;
        return true;
      }
      break;
    case 2051:
      HASH_GUARD(0x10F7244AA9CB5803LL, imagepstext) {
        ci = &ci_imagepstext;
        return true;
      }
      break;
    case 2052:
      HASH_GUARD(0x349A0DF6723B6804LL, pixelsetcolorcount) {
        ci = &ci_pixelsetcolorcount;
        return true;
      }
      break;
    case 2054:
      HASH_GUARD(0x4D832DD6A72AB806LL, dom_document_create_attribute) {
        ci = &ci_dom_document_create_attribute;
        return true;
      }
      break;
    case 2056:
      HASH_GUARD(0x19279D6DB4F70808LL, hash_hmac) {
        ci = &ci_hash_hmac;
        return true;
      }
      HASH_GUARD(0x083B8F01AE15B808LL, assert) {
        ci = &ci_assert;
        return true;
      }
      break;
    case 2057:
      HASH_GUARD(0x52DCFB6F41D41809LL, dom_characterdata_append_data) {
        ci = &ci_dom_characterdata_append_data;
        return true;
      }
      HASH_GUARD(0x221F5A9D5E021809LL, magickwriteimages) {
        ci = &ci_magickwriteimages;
        return true;
      }
      break;
    case 2058:
      HASH_GUARD(0x5A0D1AE1D4C6F80ALL, array_slice) {
        ci = &ci_array_slice;
        return true;
      }
      break;
    case 2060:
      HASH_GUARD(0x3FF63423EC4B280CLL, posix_getegid) {
        ci = &ci_posix_getegid;
        return true;
      }
      break;
    case 2061:
      HASH_GUARD(0x11EC19E702F2C80DLL, getmyinode) {
        ci = &ci_getmyinode;
        return true;
      }
      HASH_GUARD(0x727F5A6D8E26B80DLL, extension_loaded) {
        ci = &ci_extension_loaded;
        return true;
      }
      break;
    case 2064:
      HASH_GUARD(0x4297B1072CE76810LL, fb_call_user_func_array_safe) {
        ci = &ci_fb_call_user_func_array_safe;
        return true;
      }
      break;
    case 2067:
      HASH_GUARD(0x1A6B577442218813LL, pixelsetmagentaquantum) {
        ci = &ci_pixelsetmagentaquantum;
        return true;
      }
      HASH_GUARD(0x5F7940A713863813LL, floor) {
        ci = &ci_floor;
        return true;
      }
      break;
    case 2068:
      HASH_GUARD(0x3C0DFA15D3447814LL, rawurldecode) {
        ci = &ci_rawurldecode;
        return true;
      }
      break;
    case 2071:
      HASH_GUARD(0x0D8B1D0A8C381817LL, stream_bucket_new) {
        ci = &ci_stream_bucket_new;
        return true;
      }
      break;
    case 2072:
      HASH_GUARD(0x0FBDB0B22A59B818LL, mailparse_msg_parse) {
        ci = &ci_mailparse_msg_parse;
        return true;
      }
      break;
    case 2077:
      HASH_GUARD(0x4D624A655A9B581DLL, drawpoint) {
        ci = &ci_drawpoint;
        return true;
      }
      break;
    case 2081:
      HASH_GUARD(0x2D52FB9B52EC2821LL, xml_set_notation_decl_handler) {
        ci = &ci_xml_set_notation_decl_handler;
        return true;
      }
      HASH_GUARD(0x107DBCA79C15B821LL, addcslashes) {
        ci = &ci_addcslashes;
        return true;
      }
      break;
    case 2082:
      HASH_GUARD(0x13C241C02DE72822LL, dom_document_relaxng_validate_xml) {
        ci = &ci_dom_document_relaxng_validate_xml;
        return true;
      }
      break;
    case 2084:
      HASH_GUARD(0x2B78E204F615A824LL, openssl_pkcs12_export_to_file) {
        ci = &ci_openssl_pkcs12_export_to_file;
        return true;
      }
      break;
    case 2087:
      HASH_GUARD(0x33EC567341B9C827LL, magickgetmaxtextadvance) {
        ci = &ci_magickgetmaxtextadvance;
        return true;
      }
      break;
    case 2089:
      HASH_GUARD(0x39EE4CCCA716E829LL, stream_context_get_options) {
        ci = &ci_stream_context_get_options;
        return true;
      }
      HASH_GUARD(0x57FFCEB7FA2D9829LL, usort) {
        ci = &ci_usort;
        return true;
      }
      break;
    case 2092:
      HASH_GUARD(0x34F0E032AB05C82CLL, pixelsetblue) {
        ci = &ci_pixelsetblue;
        return true;
      }
      break;
    case 2093:
      HASH_GUARD(0x1C4AE57BF4E4A82DLL, apc_dec) {
        ci = &ci_apc_dec;
        return true;
      }
      break;
    case 2094:
      HASH_GUARD(0x3402C1E7544C382ELL, lstat) {
        ci = &ci_lstat;
        return true;
      }
      break;
    case 2095:
      HASH_GUARD(0x79A05154A7F5482FLL, magickgetimagedelay) {
        ci = &ci_magickgetimagedelay;
        return true;
      }
      break;
    case 2096:
      HASH_GUARD(0x5BBFA7EAEBD25830LL, pixelgetcyanquantum) {
        ci = &ci_pixelgetcyanquantum;
        return true;
      }
      break;
    case 2100:
      HASH_GUARD(0x605132E71CE7D834LL, array_push) {
        ci = &ci_array_push;
        return true;
      }
      break;
    case 2101:
      HASH_GUARD(0x1C4A162E6635B835LL, imageftbbox) {
        ci = &ci_imageftbbox;
        return true;
      }
      HASH_GUARD(0x43A96BA7F58EB835LL, hphp_splfileobject_valid) {
        ci = &ci_hphp_splfileobject_valid;
        return true;
      }
      break;
    case 2104:
      HASH_GUARD(0x63E554E0F11CE838LL, mysql_unbuffered_query) {
        ci = &ci_mysql_unbuffered_query;
        return true;
      }
      HASH_GUARD(0x03098F16B0AD5838LL, mcrypt_module_get_supported_key_sizes) {
        ci = &ci_mcrypt_module_get_supported_key_sizes;
        return true;
      }
      HASH_GUARD(0x0890F9052322E838LL, fstat) {
        ci = &ci_fstat;
        return true;
      }
      break;
    case 2107:
      HASH_GUARD(0x63E2EA180786B83BLL, pixelsetblack) {
        ci = &ci_pixelsetblack;
        return true;
      }
      break;
    case 2108:
      HASH_GUARD(0x7C8969C75CA1783CLL, get_declared_classes) {
        ci = &ci_get_declared_classes;
        return true;
      }
      HASH_GUARD(0x034EDEBD109FD83CLL, filesize) {
        ci = &ci_filesize;
        return true;
      }
      break;
    case 2115:
      HASH_GUARD(0x567A7139AD476843LL, socket_listen) {
        ci = &ci_socket_listen;
        return true;
      }
      break;
    case 2118:
      HASH_GUARD(0x50088ED5D482C846LL, ldap_mod_add) {
        ci = &ci_ldap_mod_add;
        return true;
      }
      break;
    case 2119:
      HASH_GUARD(0x4E69A952E3EA4847LL, magicksetfilename) {
        ci = &ci_magicksetfilename;
        return true;
      }
      break;
    case 2122:
      HASH_GUARD(0x7D3F626E636C084ALL, ldap_delete) {
        ci = &ci_ldap_delete;
        return true;
      }
      break;
    case 2123:
      HASH_GUARD(0x68B7597C22FA484BLL, openssl_public_encrypt) {
        ci = &ci_openssl_public_encrypt;
        return true;
      }
      break;
    case 2124:
      HASH_GUARD(0x26A2BBC465A2B84CLL, strcoll) {
        ci = &ci_strcoll;
        return true;
      }
      break;
    case 2126:
      HASH_GUARD(0x488C2F267BF2884ELL, array_intersect) {
        ci = &ci_array_intersect;
        return true;
      }
      break;
    case 2127:
      HASH_GUARD(0x632D491E42E7E84FLL, session_get_cookie_params) {
        ci = &ci_session_get_cookie_params;
        return true;
      }
      break;
    case 2128:
      HASH_GUARD(0x4DDB82A3632FA850LL, atan) {
        ci = &ci_atan;
        return true;
      }
      break;
    case 2129:
      HASH_GUARD(0x488BFCC942C73851LL, gzopen) {
        ci = &ci_gzopen;
        return true;
      }
      break;
    case 2134:
      HASH_GUARD(0x51FD8C9B5109F856LL, dom_characterdata_replace_data) {
        ci = &ci_dom_characterdata_replace_data;
        return true;
      }
      break;
    case 2140:
      HASH_GUARD(0x5A017A4C6A41E85CLL, curl_multi_add_handle) {
        ci = &ci_curl_multi_add_handle;
        return true;
      }
      break;
    case 2142:
      HASH_GUARD(0x3D8327794429585ELL, hphpd_install_user_command) {
        ci = &ci_hphpd_install_user_command;
        return true;
      }
      HASH_GUARD(0x6B4DE6865142285ELL, destroypixeliterator) {
        ci = &ci_destroypixeliterator;
        return true;
      }
      break;
    case 2145:
      HASH_GUARD(0x2AD6B0E3B9F3B861LL, array_search) {
        ci = &ci_array_search;
        return true;
      }
      break;
    case 2147:
      HASH_GUARD(0x21B30164F5D49863LL, is_resource) {
        ci = &ci_is_resource;
        return true;
      }
      break;
    case 2148:
      HASH_GUARD(0x168EDA8238EEE864LL, mb_detect_order) {
        ci = &ci_mb_detect_order;
        return true;
      }
      break;
    case 2151:
      HASH_GUARD(0x65A68A31B96E7867LL, hash) {
        ci = &ci_hash;
        return true;
      }
      break;
    case 2152:
      HASH_GUARD(0x785C812E6292E868LL, i18n_loc_set_default) {
        ci = &ci_i18n_loc_set_default;
        return true;
      }
      break;
    case 2153:
      HASH_GUARD(0x246EC2B1844DB869LL, pixelgetexception) {
        ci = &ci_pixelgetexception;
        return true;
      }
      break;
    case 2155:
      HASH_GUARD(0x0C1BBEDECEF1C86BLL, newmagickwand) {
        ci = &ci_newmagickwand;
        return true;
      }
      break;
    case 2156:
      HASH_GUARD(0x6414504A6658286CLL, stripos) {
        ci = &ci_stripos;
        return true;
      }
      break;
    case 2159:
      HASH_GUARD(0x1476A177CC50686FLL, mb_strstr) {
        ci = &ci_mb_strstr;
        return true;
      }
      break;
    case 2160:
      HASH_GUARD(0x34F50577C14C6870LL, array_diff_uassoc) {
        ci = &ci_array_diff_uassoc;
        return true;
      }
      break;
    case 2162:
      HASH_GUARD(0x3C7B86F57AFA0872LL, hebrev) {
        ci = &ci_hebrev;
        return true;
      }
      HASH_GUARD(0x558D62FBEB210872LL, str_rot13) {
        ci = &ci_str_rot13;
        return true;
      }
      break;
    case 2163:
      HASH_GUARD(0x4C06B4AFC1C08873LL, str_shuffle) {
        ci = &ci_str_shuffle;
        return true;
      }
      break;
    case 2167:
      HASH_GUARD(0x6AA3788C9B737877LL, magickdespeckleimage) {
        ci = &ci_magickdespeckleimage;
        return true;
      }
      break;
    case 2168:
      HASH_GUARD(0x00F8C6758B50B878LL, drawpathcurvetoquadraticbezierabsolute) {
        ci = &ci_drawpathcurvetoquadraticbezierabsolute;
        return true;
      }
      break;
    case 2172:
      HASH_GUARD(0x11DFC3C9D916387CLL, hphp_splfileobject_ftruncate) {
        ci = &ci_hphp_splfileobject_ftruncate;
        return true;
      }
      HASH_GUARD(0x6451BCB825D1787CLL, chroot) {
        ci = &ci_chroot;
        return true;
      }
      break;
    case 2173:
      HASH_GUARD(0x54F84DC9A334287DLL, gzencode) {
        ci = &ci_gzencode;
        return true;
      }
      HASH_GUARD(0x2B36081E0828487DLL, debug_print_backtrace) {
        ci = &ci_debug_print_backtrace;
        return true;
      }
      break;
    case 2176:
      HASH_GUARD(0x7549612A72BA5880LL, hphp_splfileinfo_getrealpath) {
        ci = &ci_hphp_splfileinfo_getrealpath;
        return true;
      }
      break;
    case 2179:
      HASH_GUARD(0x3EBD8F559B4EA883LL, hphp_splfileobject_getflags) {
        ci = &ci_hphp_splfileobject_getflags;
        return true;
      }
      break;
    case 2180:
      HASH_GUARD(0x766CD15A7F2A0884LL, array_uintersect) {
        ci = &ci_array_uintersect;
        return true;
      }
      break;
    case 2184:
      HASH_GUARD(0x1062CF2DA5443888LL, imagedashedline) {
        ci = &ci_imagedashedline;
        return true;
      }
      break;
    case 2191:
      HASH_GUARD(0x5DDC2A079AB7988FLL, dom_document_schema_validate_file) {
        ci = &ci_dom_document_schema_validate_file;
        return true;
      }
      HASH_GUARD(0x539868C56806688FLL, imagecopyresampled) {
        ci = &ci_imagecopyresampled;
        return true;
      }
      break;
    case 2200:
      HASH_GUARD(0x4AC522FF7BB60898LL, xmlwriter_write_dtd_entity) {
        ci = &ci_xmlwriter_write_dtd_entity;
        return true;
      }
      break;
    case 2205:
      HASH_GUARD(0x1FC855F0E4F1189DLL, magickminifyimage) {
        ci = &ci_magickminifyimage;
        return true;
      }
      break;
    case 2208:
      HASH_GUARD(0x6B1A3BCE67BAC8A0LL, openssl_csr_new) {
        ci = &ci_openssl_csr_new;
        return true;
      }
      break;
    case 2209:
      HASH_GUARD(0x1756D4437A4098A1LL, date_modify) {
        ci = &ci_date_modify;
        return true;
      }
      break;
    case 2215:
      HASH_GUARD(0x57105D4E43B078A7LL, magicksetformat) {
        ci = &ci_magicksetformat;
        return true;
      }
      HASH_GUARD(0x6C6B4B739AE1B8A7LL, curl_close) {
        ci = &ci_curl_close;
        return true;
      }
      break;
    case 2217:
      HASH_GUARD(0x346B2DB3BA2378A9LL, imagecolormatch) {
        ci = &ci_imagecolormatch;
        return true;
      }
      break;
    case 2218:
      HASH_GUARD(0x44BC069A75EE98AALL, xhprof_disable) {
        ci = &ci_xhprof_disable;
        return true;
      }
      break;
    case 2219:
      HASH_GUARD(0x39F11BA6A4D778ABLL, strnatcmp) {
        ci = &ci_strnatcmp;
        return true;
      }
      break;
    case 2220:
      HASH_GUARD(0x5B1F4C6424DDD8ACLL, openlog) {
        ci = &ci_openlog;
        return true;
      }
      break;
    case 2224:
      HASH_GUARD(0x2CEF8DDC092698B0LL, drawgetvectorgraphics) {
        ci = &ci_drawgetvectorgraphics;
        return true;
      }
      break;
    case 2226:
      HASH_GUARD(0x31830AA5032428B2LL, is_double) {
        ci = &ci_is_double;
        return true;
      }
      break;
    case 2230:
      HASH_GUARD(0x5866C5DF3A1AD8B6LL, dom_element_get_attribute_node) {
        ci = &ci_dom_element_get_attribute_node;
        return true;
      }
      break;
    case 2236:
      HASH_GUARD(0x7AE3AE9B634988BCLL, stream_context_create) {
        ci = &ci_stream_context_create;
        return true;
      }
      break;
    case 2244:
      HASH_GUARD(0x5C28BE7FFE6A68C4LL, xml_set_start_namespace_decl_handler) {
        ci = &ci_xml_set_start_namespace_decl_handler;
        return true;
      }
      break;
    case 2245:
      HASH_GUARD(0x146A1A7658CCA8C5LL, asinh) {
        ci = &ci_asinh;
        return true;
      }
      break;
    case 2247:
      HASH_GUARD(0x4623383F8534E8C7LL, array_multisort) {
        ci = &ci_array_multisort;
        return true;
      }
      HASH_GUARD(0x6D9B9BE3CED388C7LL, apc_load_constants) {
        ci = &ci_apc_load_constants;
        return true;
      }
      break;
    case 2254:
      HASH_GUARD(0x3FFAA982E4B1E8CELL, date_offset_get) {
        ci = &ci_date_offset_get;
        return true;
      }
      break;
    case 2257:
      HASH_GUARD(0x1015EB3F52B098D1LL, print) {
        ci = &ci_print;
        return true;
      }
      break;
    case 2258:
      HASH_GUARD(0x74EB6C564ABC68D2LL, dom_document_create_text_node) {
        ci = &ci_dom_document_create_text_node;
        return true;
      }
      break;
    case 2260:
      HASH_GUARD(0x6DB4EE8696C7E8D4LL, magicksetimageiterations) {
        ci = &ci_magicksetimageiterations;
        return true;
      }
      break;
    case 2262:
      HASH_GUARD(0x2F585B36DDDB68D6LL, mb_convert_case) {
        ci = &ci_mb_convert_case;
        return true;
      }
      HASH_GUARD(0x26DC8AB4A9CBE8D6LL, iconv) {
        ci = &ci_iconv;
        return true;
      }
      break;
    case 2264:
      HASH_GUARD(0x3A65182A3E8908D8LL, openssl_open) {
        ci = &ci_openssl_open;
        return true;
      }
      break;
    case 2265:
      HASH_GUARD(0x18B64D6BFE4208D9LL, stream_get_transports) {
        ci = &ci_stream_get_transports;
        return true;
      }
      break;
    case 2267:
      HASH_GUARD(0x4052842EC87038DBLL, magickcropimage) {
        ci = &ci_magickcropimage;
        return true;
      }
      break;
    case 2268:
      HASH_GUARD(0x31F50FDA18B888DCLL, magickgetimagetype) {
        ci = &ci_magickgetimagetype;
        return true;
      }
      break;
    case 2276:
      HASH_GUARD(0x16A18007E10F48E4LL, socket_getsockname) {
        ci = &ci_socket_getsockname;
        return true;
      }
      break;
    case 2278:
      HASH_GUARD(0x69887F054A1E28E6LL, strtok) {
        ci = &ci_strtok;
        return true;
      }
      break;
    case 2279:
      HASH_GUARD(0x608729F27FA428E7LL, error_get_last) {
        ci = &ci_error_get_last;
        return true;
      }
      break;
    case 2280:
      HASH_GUARD(0x4F7ED8C3156AD8E8LL, magicksetimagedispose) {
        ci = &ci_magicksetimagedispose;
        return true;
      }
      break;
    case 2293:
      HASH_GUARD(0x45DA105C5B48F8F5LL, apd_set_pprof_trace) {
        ci = &ci_apd_set_pprof_trace;
        return true;
      }
      break;
    case 2295:
      HASH_GUARD(0x17582BEA497D48F7LL, ctype_alpha) {
        ci = &ci_ctype_alpha;
        return true;
      }
      break;
    case 2298:
      HASH_GUARD(0x6F0F82818B68A8FALL, array_values) {
        ci = &ci_array_values;
        return true;
      }
      break;
    case 2299:
      HASH_GUARD(0x214532C4A2BC28FBLL, ldap_next_entry) {
        ci = &ci_ldap_next_entry;
        return true;
      }
      break;
    case 2300:
      HASH_GUARD(0x4C2AFB2EFDB1B8FCLL, stripslashes) {
        ci = &ci_stripslashes;
        return true;
      }
      break;
    case 2302:
      HASH_GUARD(0x047BF4D3D0ED08FELL, strchr) {
        ci = &ci_strchr;
        return true;
      }
      break;
    case 2315:
      HASH_GUARD(0x67B879A1120C190BLL, headers_sent) {
        ci = &ci_headers_sent;
        return true;
      }
      HASH_GUARD(0x2987B15E11FE890BLL, clock_settime) {
        ci = &ci_clock_settime;
        return true;
      }
      break;
    case 2321:
      HASH_GUARD(0x04F822B7817E5911LL, bindec) {
        ci = &ci_bindec;
        return true;
      }
      HASH_GUARD(0x0AFD4F231D6CB911LL, magickaddimage) {
        ci = &ci_magickaddimage;
        return true;
      }
      HASH_GUARD(0x5B9B2C3B32906911LL, drawsetfillpatternurl) {
        ci = &ci_drawsetfillpatternurl;
        return true;
      }
      break;
    case 2323:
      HASH_GUARD(0x55757E1242390913LL, cos) {
        ci = &ci_cos;
        return true;
      }
      break;
    case 2324:
      HASH_GUARD(0x6E22C6D840B44914LL, mcrypt_generic_init) {
        ci = &ci_mcrypt_generic_init;
        return true;
      }
      break;
    case 2329:
      HASH_GUARD(0x022B16C0D64D7919LL, file_put_contents) {
        ci = &ci_file_put_contents;
        return true;
      }
      break;
    case 2331:
      HASH_GUARD(0x37A3DF6E0795091BLL, memcache_increment) {
        ci = &ci_memcache_increment;
        return true;
      }
      break;
    case 2333:
      HASH_GUARD(0x069C028EFEF8C91DLL, date) {
        ci = &ci_date;
        return true;
      }
      break;
    case 2335:
      HASH_GUARD(0x277D7E2D1F5C191FLL, drawpathcurvetoquadraticbezierrelative) {
        ci = &ci_drawpathcurvetoquadraticbezierrelative;
        return true;
      }
      HASH_GUARD(0x4E2C55C92D71F91FLL, magickcolorfloodfillimage) {
        ci = &ci_magickcolorfloodfillimage;
        return true;
      }
      break;
    case 2337:
      HASH_GUARD(0x0F5917FFCDD6C921LL, mb_substr) {
        ci = &ci_mb_substr;
        return true;
      }
      break;
    case 2339:
      HASH_GUARD(0x044B276686B77923LL, fscanf) {
        ci = &ci_fscanf;
        return true;
      }
      break;
    case 2346:
      HASH_GUARD(0x174C510386E6492ALL, hphp_directoryiterator_key) {
        ci = &ci_hphp_directoryiterator_key;
        return true;
      }
      break;
    case 2349:
      HASH_GUARD(0x27363CE6CBFC392DLL, pcntl_wexitstatus) {
        ci = &ci_pcntl_wexitstatus;
        return true;
      }
      HASH_GUARD(0x2337F8C3EE17192DLL, sprintf) {
        ci = &ci_sprintf;
        return true;
      }
      break;
    case 2350:
      HASH_GUARD(0x26E8B741BDDDC92ELL, xmlwriter_start_element) {
        ci = &ci_xmlwriter_start_element;
        return true;
      }
      break;
    case 2352:
      HASH_GUARD(0x507CE1912FD74930LL, mail) {
        ci = &ci_mail;
        return true;
      }
      HASH_GUARD(0x30972530BD557930LL, shell_exec) {
        ci = &ci_shell_exec;
        return true;
      }
      break;
    case 2354:
      HASH_GUARD(0x72C01E1D90BE5932LL, mcrypt_enc_get_block_size) {
        ci = &ci_mcrypt_enc_get_block_size;
        return true;
      }
      break;
    case 2356:
      HASH_GUARD(0x4FB95164A5F84934LL, mcrypt_generic_end) {
        ci = &ci_mcrypt_generic_end;
        return true;
      }
      break;
    case 2357:
      HASH_GUARD(0x46BD9A56BDE40935LL, mysql_escape_string) {
        ci = &ci_mysql_escape_string;
        return true;
      }
      HASH_GUARD(0x06486B6912479935LL, zlib_get_coding_type) {
        ci = &ci_zlib_get_coding_type;
        return true;
      }
      HASH_GUARD(0x48D3CA6CA0B29935LL, mb_regex_set_options) {
        ci = &ci_mb_regex_set_options;
        return true;
      }
      break;
    case 2361:
      HASH_GUARD(0x5B60C8396C624939LL, mb_substitute_character) {
        ci = &ci_mb_substitute_character;
        return true;
      }
      break;
    case 2366:
      HASH_GUARD(0x3946D67A0D16D93ELL, hphp_splfileinfo_isreadable) {
        ci = &ci_hphp_splfileinfo_isreadable;
        return true;
      }
      HASH_GUARD(0x0CADFE289C92893ELL, socket_getpeername) {
        ci = &ci_socket_getpeername;
        return true;
      }
      break;
    case 2371:
      HASH_GUARD(0x7C565AD57BC84943LL, pixelsetindex) {
        ci = &ci_pixelsetindex;
        return true;
      }
      break;
    case 2373:
      HASH_GUARD(0x7CB0596B6CCFA945LL, split) {
        ci = &ci_split;
        return true;
      }
      break;
    case 2375:
      HASH_GUARD(0x630288865DE68947LL, php_strip_whitespace) {
        ci = &ci_php_strip_whitespace;
        return true;
      }
      break;
    case 2376:
      HASH_GUARD(0x6A3412DE82715948LL, openssl_x509_checkpurpose) {
        ci = &ci_openssl_x509_checkpurpose;
        return true;
      }
      break;
    case 2377:
      HASH_GUARD(0x243BB8B284895949LL, apache_get_rewrite_rules) {
        ci = &ci_apache_get_rewrite_rules;
        return true;
      }
      break;
    case 2379:
      HASH_GUARD(0x37F356F578FA394BLL, substr) {
        ci = &ci_substr;
        return true;
      }
      break;
    case 2381:
      HASH_GUARD(0x3D3AD12E52FF294DLL, imagecreatefromwbmp) {
        ci = &ci_imagecreatefromwbmp;
        return true;
      }
      break;
    case 2387:
      HASH_GUARD(0x068438AFD33A9953LL, imagecolorclosesthwb) {
        ci = &ci_imagecolorclosesthwb;
        return true;
      }
      break;
    case 2391:
      HASH_GUARD(0x253AC5D4E450A957LL, magickgetreleasedate) {
        ci = &ci_magickgetreleasedate;
        return true;
      }
      break;
    case 2394:
      HASH_GUARD(0x103C12985527295ALL, hphp_splfileobject_setcsvcontrol) {
        ci = &ci_hphp_splfileobject_setcsvcontrol;
        return true;
      }
      HASH_GUARD(0x7056E766A274895ALL, virtual) {
        ci = &ci_virtual;
        return true;
      }
      break;
    case 2397:
      HASH_GUARD(0x21DBCE74EB1FC95DLL, xmlwriter_text) {
        ci = &ci_xmlwriter_text;
        return true;
      }
      break;
    case 2401:
      HASH_GUARD(0x5EA7052A00E88961LL, magickgetcopyright) {
        ci = &ci_magickgetcopyright;
        return true;
      }
      break;
    case 2407:
      HASH_GUARD(0x1419B3BF428B2967LL, evhttp_async_post) {
        ci = &ci_evhttp_async_post;
        return true;
      }
      break;
    case 2415:
      HASH_GUARD(0x134EF88685C0396FLL, magickgetexceptiontype) {
        ci = &ci_magickgetexceptiontype;
        return true;
      }
      break;
    case 2417:
      HASH_GUARD(0x442A28FB6F6C3971LL, xmlwriter_start_attribute) {
        ci = &ci_xmlwriter_start_attribute;
        return true;
      }
      HASH_GUARD(0x72C73F5DA7D6F971LL, magickgetimagecolormapcolor) {
        ci = &ci_magickgetimagecolormapcolor;
        return true;
      }
      break;
    case 2418:
      HASH_GUARD(0x758263CEBF2E8972LL, assert_options) {
        ci = &ci_assert_options;
        return true;
      }
      break;
    case 2421:
      HASH_GUARD(0x7E26D48503362975LL, drawpathcurvetoabsolute) {
        ci = &ci_drawpathcurvetoabsolute;
        return true;
      }
      HASH_GUARD(0x488141281A75E975LL, imagecreatefromgif) {
        ci = &ci_imagecreatefromgif;
        return true;
      }
      break;
    case 2423:
      HASH_GUARD(0x0C16C797916C2977LL, posix_setegid) {
        ci = &ci_posix_setegid;
        return true;
      }
      break;
    case 2430:
      HASH_GUARD(0x5067A65AD1D0297ELL, pixelgetiteratorexception) {
        ci = &ci_pixelgetiteratorexception;
        return true;
      }
      break;
    case 2432:
      HASH_GUARD(0x3D3445105C335980LL, filectime) {
        ci = &ci_filectime;
        return true;
      }
      break;
    case 2434:
      HASH_GUARD(0x214EA70BDD8FB982LL, magickmorphimages) {
        ci = &ci_magickmorphimages;
        return true;
      }
      break;
    case 2435:
      HASH_GUARD(0x3DA64BF893DBF983LL, strncmp) {
        ci = &ci_strncmp;
        return true;
      }
      break;
    case 2438:
      HASH_GUARD(0x6ECE4BDB8842E986LL, posix_strerror) {
        ci = &ci_posix_strerror;
        return true;
      }
      break;
    case 2439:
      HASH_GUARD(0x22B3CF8DD3D1A987LL, pixelsynciterator) {
        ci = &ci_pixelsynciterator;
        return true;
      }
      break;
    case 2440:
      HASH_GUARD(0x489355BDBE396988LL, drawsettextencoding) {
        ci = &ci_drawsettextencoding;
        return true;
      }
      HASH_GUARD(0x55BE7AE8DEF3F988LL, magickgetstringheight) {
        ci = &ci_magickgetstringheight;
        return true;
      }
      break;
    case 2443:
      HASH_GUARD(0x0E863EF8C11A598BLL, is_writable) {
        ci = &ci_is_writable;
        return true;
      }
      break;
    case 2445:
      HASH_GUARD(0x69003892F71C798DLL, apache_get_scoreboard) {
        ci = &ci_apache_get_scoreboard;
        return true;
      }
      HASH_GUARD(0x651A8CBB8D2A398DLL, mysql_stat) {
        ci = &ci_mysql_stat;
        return true;
      }
      break;
    case 2446:
      HASH_GUARD(0x45CFDEE19995398ELL, hphp_recursiveiteratoriterator_next) {
        ci = &ci_hphp_recursiveiteratoriterator_next;
        return true;
      }
      HASH_GUARD(0x333D4DFD4927898ELL, magickgetimagewhitepoint) {
        ci = &ci_magickgetimagewhitepoint;
        return true;
      }
      break;
    case 2448:
      HASH_GUARD(0x342D957A86A03990LL, hphp_splfileobject_seek) {
        ci = &ci_hphp_splfileobject_seek;
        return true;
      }
      break;
    case 2456:
      HASH_GUARD(0x501AAD31C8086998LL, posix_getcwd) {
        ci = &ci_posix_getcwd;
        return true;
      }
      break;
    case 2459:
      HASH_GUARD(0x564D8D3DA1E8E99BLL, xml_get_current_line_number) {
        ci = &ci_xml_get_current_line_number;
        return true;
      }
      break;
    case 2462:
      HASH_GUARD(0x59D2DFF08F4DB99ELL, imagecreate) {
        ci = &ci_imagecreate;
        return true;
      }
      break;
    case 2464:
      HASH_GUARD(0x047EF9173590C9A0LL, session_decode) {
        ci = &ci_session_decode;
        return true;
      }
      break;
    case 2466:
      HASH_GUARD(0x01D2367A02F0A9A2LL, magicksetsize) {
        ci = &ci_magicksetsize;
        return true;
      }
      break;
    case 2467:
      HASH_GUARD(0x43D1339C52E309A3LL, hphp_service_thread_started) {
        ci = &ci_hphp_service_thread_started;
        return true;
      }
      HASH_GUARD(0x78261FA60B8D89A3LL, imagepsloadfont) {
        ci = &ci_imagepsloadfont;
        return true;
      }
      break;
    case 2468:
      HASH_GUARD(0x6F8676B049C919A4LL, array_intersect_uassoc) {
        ci = &ci_array_intersect_uassoc;
        return true;
      }
      break;
    case 2469:
      HASH_GUARD(0x76988956F35329A5LL, xmlwriter_end_cdata) {
        ci = &ci_xmlwriter_end_cdata;
        return true;
      }
      break;
    case 2473:
      HASH_GUARD(0x6F9CF95104CAE9A9LL, pixelgetyellowquantum) {
        ci = &ci_pixelgetyellowquantum;
        return true;
      }
      break;
    case 2476:
      HASH_GUARD(0x522256BAA78159ACLL, popen) {
        ci = &ci_popen;
        return true;
      }
      break;
    case 2477:
      HASH_GUARD(0x05C5AD90751159ADLL, drawpathcurvetoquadraticbeziersmoothabsolute) {
        ci = &ci_drawpathcurvetoquadraticbeziersmoothabsolute;
        return true;
      }
      break;
    case 2479:
      HASH_GUARD(0x25268012A48A99AFLL, magickclipimage) {
        ci = &ci_magickclipimage;
        return true;
      }
      break;
    case 2481:
      HASH_GUARD(0x7C1CE38F14E529B1LL, date_default_timezone_set) {
        ci = &ci_date_default_timezone_set;
        return true;
      }
      break;
    case 2482:
      HASH_GUARD(0x65D7CBE8681CE9B2LL, gzgetss) {
        ci = &ci_gzgetss;
        return true;
      }
      break;
    case 2486:
      HASH_GUARD(0x5FC1B94446EA59B6LL, magickremoveimageprofiles) {
        ci = &ci_magickremoveimageprofiles;
        return true;
      }
      break;
    case 2487:
      HASH_GUARD(0x18F2C246FACAD9B7LL, each) {
        ci = &ci_each;
        return true;
      }
      break;
    case 2488:
      HASH_GUARD(0x3741447B159359B8LL, mcrypt_get_cipher_name) {
        ci = &ci_mcrypt_get_cipher_name;
        return true;
      }
      HASH_GUARD(0x4EFD7A9C90E559B8LL, posix_ttyname) {
        ci = &ci_posix_ttyname;
        return true;
      }
      break;
    case 2489:
      HASH_GUARD(0x145702974C97F9B9LL, ltrim) {
        ci = &ci_ltrim;
        return true;
      }
      break;
    case 2490:
      HASH_GUARD(0x13B3172E092D99BALL, is_dir) {
        ci = &ci_is_dir;
        return true;
      }
      break;
    case 2492:
      HASH_GUARD(0x7E7BF1BDA6DB49BCLL, hphp_splfileinfo_getgroup) {
        ci = &ci_hphp_splfileinfo_getgroup;
        return true;
      }
      break;
    case 2494:
      HASH_GUARD(0x458B5ABEDAC1C9BELL, disk_free_space) {
        ci = &ci_disk_free_space;
        return true;
      }
      break;
    case 2498:
      HASH_GUARD(0x6A7BDB900E7429C2LL, magickconstituteimage) {
        ci = &ci_magickconstituteimage;
        return true;
      }
      break;
    case 2500:
      HASH_GUARD(0x47B7D3745D80B9C4LL, socket_get_option) {
        ci = &ci_socket_get_option;
        return true;
      }
      break;
    case 2502:
      HASH_GUARD(0x080F661DB8BFC9C6LL, hphp_splfileinfo_getmtime) {
        ci = &ci_hphp_splfileinfo_getmtime;
        return true;
      }
      break;
    case 2503:
      HASH_GUARD(0x6ECDF24B29D789C7LL, strtolower) {
        ci = &ci_strtolower;
        return true;
      }
      break;
    case 2506:
      HASH_GUARD(0x5C5B0CC85133B9CALL, mkdir) {
        ci = &ci_mkdir;
        return true;
      }
      break;
    case 2507:
      HASH_GUARD(0x032DFAC5B24679CBLL, header_remove) {
        ci = &ci_header_remove;
        return true;
      }
      break;
    case 2509:
      HASH_GUARD(0x4E61FE901C1C29CDLL, array_intersect_key) {
        ci = &ci_array_intersect_key;
        return true;
      }
      break;
    case 2510:
      HASH_GUARD(0x7A9FB932873D09CELL, gmmktime) {
        ci = &ci_gmmktime;
        return true;
      }
      break;
    case 2511:
      HASH_GUARD(0x415B91CAEE0689CFLL, magickgetimageinterlacescheme) {
        ci = &ci_magickgetimageinterlacescheme;
        return true;
      }
      break;
    case 2514:
      HASH_GUARD(0x3DCCD1FEAD8759D2LL, array_sum) {
        ci = &ci_array_sum;
        return true;
      }
      break;
    case 2515:
      HASH_GUARD(0x1C31A9E1207209D3LL, mb_split) {
        ci = &ci_mb_split;
        return true;
      }
      HASH_GUARD(0x10C82F357BB7E9D3LL, curl_version) {
        ci = &ci_curl_version;
        return true;
      }
      HASH_GUARD(0x25CA0299103F49D3LL, magickgetsize) {
        ci = &ci_magickgetsize;
        return true;
      }
      break;
    case 2517:
      HASH_GUARD(0x245860A2FE4CB9D5LL, socket_set_blocking) {
        ci = &ci_socket_set_blocking;
        return true;
      }
      break;
    case 2519:
      HASH_GUARD(0x7628053EFCC0C9D7LL, hphp_clear_unflushed) {
        ci = &ci_hphp_clear_unflushed;
        return true;
      }
      break;
    case 2523:
      HASH_GUARD(0x48B2E069B89489DBLL, magickappendimages) {
        ci = &ci_magickappendimages;
        return true;
      }
      break;
    case 2526:
      HASH_GUARD(0x5C039967E60089DELL, array_intersect_ukey) {
        ci = &ci_array_intersect_ukey;
        return true;
      }
      break;
    case 2527:
      HASH_GUARD(0x349E2E0F2CD7B9DFLL, magickgetversion) {
        ci = &ci_magickgetversion;
        return true;
      }
      break;
    case 2534:
      HASH_GUARD(0x1B44CF284E9B09E6LL, interface_exists) {
        ci = &ci_interface_exists;
        return true;
      }
      break;
    case 2537:
      HASH_GUARD(0x4ADFA265F07AB9E9LL, drawgettextalignment) {
        ci = &ci_drawgettextalignment;
        return true;
      }
      HASH_GUARD(0x6A45EB471332A9E9LL, imagecolorexactalpha) {
        ci = &ci_imagecolorexactalpha;
        return true;
      }
      HASH_GUARD(0x330EE2729DB7C9E9LL, drawgetfontstretch) {
        ci = &ci_drawgetfontstretch;
        return true;
      }
      break;
    case 2538:
      HASH_GUARD(0x25DDD924EFE979EALL, hash_update_file) {
        ci = &ci_hash_update_file;
        return true;
      }
      break;
    case 2539:
      HASH_GUARD(0x71B0FF80B88459EBLL, diskfreespace) {
        ci = &ci_diskfreespace;
        return true;
      }
      break;
    case 2543:
      HASH_GUARD(0x7EA6200B688459EFLL, ldap_modify) {
        ci = &ci_ldap_modify;
        return true;
      }
      break;
    case 2544:
      HASH_GUARD(0x1FC307200E8959F0LL, stream_bucket_append) {
        ci = &ci_stream_bucket_append;
        return true;
      }
      break;
    case 2547:
      HASH_GUARD(0x6535B60A4BC449F3LL, dns_get_record) {
        ci = &ci_dns_get_record;
        return true;
      }
      break;
    case 2548:
      HASH_GUARD(0x51201EE65BC729F4LL, localtime) {
        ci = &ci_localtime;
        return true;
      }
      break;
    case 2549:
      HASH_GUARD(0x2BC61637253BE9F5LL, drawgetfontweight) {
        ci = &ci_drawgetfontweight;
        return true;
      }
      HASH_GUARD(0x35BABFBC091759F5LL, socket_server) {
        ci = &ci_socket_server;
        return true;
      }
      break;
    case 2557:
      HASH_GUARD(0x2394D4E030AB69FDLL, getmypid) {
        ci = &ci_getmypid;
        return true;
      }
      break;
    case 2564:
      HASH_GUARD(0x0B88D3F582D16A04LL, memcache_get_extended_stats) {
        ci = &ci_memcache_get_extended_stats;
        return true;
      }
      HASH_GUARD(0x17B83C425BD09A04LL, atanh) {
        ci = &ci_atanh;
        return true;
      }
      break;
    case 2567:
      HASH_GUARD(0x391E0A4CF1EC9A07LL, stream_socket_recvfrom) {
        ci = &ci_stream_socket_recvfrom;
        return true;
      }
      break;
    case 2568:
      HASH_GUARD(0x0436CA4DFB315A08LL, soundex) {
        ci = &ci_soundex;
        return true;
      }
      break;
    case 2571:
      HASH_GUARD(0x70075DC878825A0BLL, ctype_lower) {
        ci = &ci_ctype_lower;
        return true;
      }
      break;
    case 2573:
      HASH_GUARD(0x736C133EFF8E5A0DLL, mysql_list_fields) {
        ci = &ci_mysql_list_fields;
        return true;
      }
      HASH_GUARD(0x50A7146A79877A0DLL, pcntl_alarm) {
        ci = &ci_pcntl_alarm;
        return true;
      }
      break;
    case 2577:
      HASH_GUARD(0x472CA39715598A11LL, mb_eregi_replace) {
        ci = &ci_mb_eregi_replace;
        return true;
      }
      break;
    case 2584:
      HASH_GUARD(0x66A378C6BBC26A18LL, dom_document_create_cdatasection) {
        ci = &ci_dom_document_create_cdatasection;
        return true;
      }
      break;
    case 2588:
      HASH_GUARD(0x12D49AD562F38A1CLL, date_timezone_get) {
        ci = &ci_date_timezone_get;
        return true;
      }
      break;
    case 2591:
      HASH_GUARD(0x35C8BD7DFDADEA1FLL, hphp_directoryiterator_current) {
        ci = &ci_hphp_directoryiterator_current;
        return true;
      }
      break;
    case 2592:
      HASH_GUARD(0x2A420675E6AF0A20LL, basename) {
        ci = &ci_basename;
        return true;
      }
      break;
    case 2593:
      HASH_GUARD(0x14279BB1A6872A21LL, atan2) {
        ci = &ci_atan2;
        return true;
      }
      break;
    case 2594:
      HASH_GUARD(0x3FC127C442BAEA22LL, session_id) {
        ci = &ci_session_id;
        return true;
      }
      break;
    case 2597:
      HASH_GUARD(0x5EC0A3DD935EEA25LL, magickresampleimage) {
        ci = &ci_magickresampleimage;
        return true;
      }
      HASH_GUARD(0x1DB9A1FB97A3AA25LL, magicksetimageoption) {
        ci = &ci_magicksetimageoption;
        return true;
      }
      break;
    case 2601:
      HASH_GUARD(0x618D2A98986B1A29LL, ldap_unbind) {
        ci = &ci_ldap_unbind;
        return true;
      }
      break;
    case 2602:
      HASH_GUARD(0x3CAEA6B8D1C92A2ALL, stream_bucket_prepend) {
        ci = &ci_stream_bucket_prepend;
        return true;
      }
      break;
    case 2604:
      HASH_GUARD(0x073ACDF9B3F06A2CLL, memcache_setoptimeout) {
        ci = &ci_memcache_setoptimeout;
        return true;
      }
      break;
    case 2609:
      HASH_GUARD(0x1F3E32847C1CCA31LL, mb_ereg_match) {
        ci = &ci_mb_ereg_match;
        return true;
      }
      break;
    case 2612:
      HASH_GUARD(0x2D948E4099975A34LL, restore_include_path) {
        ci = &ci_restore_include_path;
        return true;
      }
      HASH_GUARD(0x5AB266C6E7075A34LL, mysql_error) {
        ci = &ci_mysql_error;
        return true;
      }
      break;
    case 2616:
      HASH_GUARD(0x3E65EF9761BE5A38LL, pixelgetiteratorexceptiontype) {
        ci = &ci_pixelgetiteratorexceptiontype;
        return true;
      }
      break;
    case 2619:
      HASH_GUARD(0x545A7BE199EC4A3BLL, pcntl_getpriority) {
        ci = &ci_pcntl_getpriority;
        return true;
      }
      HASH_GUARD(0x785ECCF53D98BA3BLL, curl_multi_exec) {
        ci = &ci_curl_multi_exec;
        return true;
      }
      break;
    case 2620:
      HASH_GUARD(0x21DF7BAEEFABCA3CLL, umask) {
        ci = &ci_umask;
        return true;
      }
      break;
    case 2622:
      HASH_GUARD(0x31C3A072D092FA3ELL, socket_create_listen) {
        ci = &ci_socket_create_listen;
        return true;
      }
      break;
    case 2623:
      HASH_GUARD(0x4C0E2C6882051A3FLL, magickgetresourcelimit) {
        ci = &ci_magickgetresourcelimit;
        return true;
      }
      break;
    case 2624:
      HASH_GUARD(0x4926EE59103B2A40LL, destroydrawingwand) {
        ci = &ci_destroydrawingwand;
        return true;
      }
      HASH_GUARD(0x682C14726D484A40LL, fileatime) {
        ci = &ci_fileatime;
        return true;
      }
      break;
    case 2626:
      HASH_GUARD(0x128914E131AFFA42LL, microtime) {
        ci = &ci_microtime;
        return true;
      }
      HASH_GUARD(0x5FF7C3A6BDDCFA42LL, mb_convert_kana) {
        ci = &ci_mb_convert_kana;
        return true;
      }
      break;
    case 2628:
      HASH_GUARD(0x7F6A6306BBE8AA44LL, imagelayereffect) {
        ci = &ci_imagelayereffect;
        return true;
      }
      break;
    case 2629:
      HASH_GUARD(0x7CDF1FB642529A45LL, dom_characterdata_insert_data) {
        ci = &ci_dom_characterdata_insert_data;
        return true;
      }
      break;
    case 2631:
      HASH_GUARD(0x1B45CFF586F85A47LL, utf8_encode) {
        ci = &ci_utf8_encode;
        return true;
      }
      break;
    case 2636:
      HASH_GUARD(0x4894583F517C6A4CLL, intl_get_error_code) {
        ci = &ci_intl_get_error_code;
        return true;
      }
      HASH_GUARD(0x7039B1C3356B8A4CLL, hphp_splfileobject_rewind) {
        ci = &ci_hphp_splfileobject_rewind;
        return true;
      }
      break;
    case 2638:
      HASH_GUARD(0x1635DCC4882CBA4ELL, dom_node_has_attributes) {
        ci = &ci_dom_node_has_attributes;
        return true;
      }
      break;
    case 2640:
      HASH_GUARD(0x506BBFC1B32AEA50LL, memcache_replace) {
        ci = &ci_memcache_replace;
        return true;
      }
      break;
    case 2647:
      HASH_GUARD(0x5088945958DD4A57LL, mktime) {
        ci = &ci_mktime;
        return true;
      }
      HASH_GUARD(0x7E929ED7D9BE6A57LL, ini_get) {
        ci = &ci_ini_get;
        return true;
      }
      break;
    case 2648:
      HASH_GUARD(0x6E823A722DE1EA58LL, stream_socket_client) {
        ci = &ci_stream_socket_client;
        return true;
      }
      break;
    case 2651:
      HASH_GUARD(0x2B18DFF183C0BA5BLL, mb_get_info) {
        ci = &ci_mb_get_info;
        return true;
      }
      break;
    case 2653:
      HASH_GUARD(0x7E1E9C4C3D4E8A5DLL, stream_select) {
        ci = &ci_stream_select;
        return true;
      }
      break;
    case 2654:
      HASH_GUARD(0x2C6826999658AA5ELL, getopt) {
        ci = &ci_getopt;
        return true;
      }
      break;
    case 2655:
      HASH_GUARD(0x7CAE3FE798EC0A5FLL, php_logo_guid) {
        ci = &ci_php_logo_guid;
        return true;
      }
      break;
    case 2661:
      HASH_GUARD(0x469199B8FD886A65LL, putenv) {
        ci = &ci_putenv;
        return true;
      }
      HASH_GUARD(0x3590F3AAC94E0A65LL, array_change_key_case) {
        ci = &ci_array_change_key_case;
        return true;
      }
      break;
    case 2662:
      HASH_GUARD(0x60C4B9EEDBD5FA66LL, pos) {
        ci = &ci_pos;
        return true;
      }
      break;
    case 2664:
      HASH_GUARD(0x01DD2057FD9B1A68LL, xmlwriter_write_cdata) {
        ci = &ci_xmlwriter_write_cdata;
        return true;
      }
      HASH_GUARD(0x32AD0455A7689A68LL, magickoilpaintimage) {
        ci = &ci_magickoilpaintimage;
        return true;
      }
      break;
    case 2665:
      HASH_GUARD(0x1DD37E722E11AA69LL, session_regenerate_id) {
        ci = &ci_session_regenerate_id;
        return true;
      }
      HASH_GUARD(0x10CDCF2BB4057A69LL, debug_zval_dump) {
        ci = &ci_debug_zval_dump;
        return true;
      }
      break;
    case 2667:
      HASH_GUARD(0x0912965F4440FA6BLL, str_repeat) {
        ci = &ci_str_repeat;
        return true;
      }
      break;
    case 2673:
      HASH_GUARD(0x5B5DA6AD0AD63A71LL, drawannotation) {
        ci = &ci_drawannotation;
        return true;
      }
      break;
    case 2674:
      HASH_GUARD(0x71AFF1D58D103A72LL, imagefontheight) {
        ci = &ci_imagefontheight;
        return true;
      }
      break;
    case 2677:
      HASH_GUARD(0x7A957BEC6CA57A75LL, preg_replace_callback) {
        ci = &ci_preg_replace_callback;
        return true;
      }
      break;
    case 2681:
      HASH_GUARD(0x28AC28C54C4E6A79LL, openssl_error_string) {
        ci = &ci_openssl_error_string;
        return true;
      }
      break;
    case 2685:
      HASH_GUARD(0x414C2E31304E9A7DLL, stream_get_filters) {
        ci = &ci_stream_get_filters;
        return true;
      }
      break;
    case 2689:
      HASH_GUARD(0x09367774F803EA81LL, hphp_recursiveiteratoriterator_valid) {
        ci = &ci_hphp_recursiveiteratoriterator_valid;
        return true;
      }
      break;
    case 2690:
      HASH_GUARD(0x258205B54DC06A82LL, newpixelwands) {
        ci = &ci_newpixelwands;
        return true;
      }
      HASH_GUARD(0x79786FABC5551A82LL, jpeg2wbmp) {
        ci = &ci_jpeg2wbmp;
        return true;
      }
      break;
    case 2691:
      HASH_GUARD(0x11149278DB0A9A83LL, levenshtein) {
        ci = &ci_levenshtein;
        return true;
      }
      break;
    case 2692:
      HASH_GUARD(0x08C1A5A05B6A0A84LL, ob_get_length) {
        ci = &ci_ob_get_length;
        return true;
      }
      break;
    case 2693:
      HASH_GUARD(0x755DEFDEDF35DA85LL, ctype_print) {
        ci = &ci_ctype_print;
        return true;
      }
      HASH_GUARD(0x2180916F8D4F6A85LL, drawcomment) {
        ci = &ci_drawcomment;
        return true;
      }
      break;
    case 2695:
      HASH_GUARD(0x7C5A22328CAB4A87LL, ereg_replace) {
        ci = &ci_ereg_replace;
        return true;
      }
      break;
    case 2696:
      HASH_GUARD(0x1818A3CFBA357A88LL, magicksetwandsize) {
        ci = &ci_magicksetwandsize;
        return true;
      }
      break;
    case 2699:
      HASH_GUARD(0x7588BD0546C8BA8BLL, hphp_recursivedirectoryiterator_valid) {
        ci = &ci_hphp_recursivedirectoryiterator_valid;
        return true;
      }
      HASH_GUARD(0x7ACBCD9CF335AA8BLL, xmlwriter_start_document) {
        ci = &ci_xmlwriter_start_document;
        return true;
      }
      break;
    case 2700:
      HASH_GUARD(0x6A2EEE463F969A8CLL, getservbyname) {
        ci = &ci_getservbyname;
        return true;
      }
      break;
    case 2706:
      HASH_GUARD(0x1257DB9F159E9A92LL, magickmontageimage) {
        ci = &ci_magickmontageimage;
        return true;
      }
      break;
    case 2707:
      HASH_GUARD(0x4A32653C8E719A93LL, pixelgetcyan) {
        ci = &ci_pixelgetcyan;
        return true;
      }
      break;
    case 2708:
      HASH_GUARD(0x465E6C67F885AA94LL, drawgetstrokelinejoin) {
        ci = &ci_drawgetstrokelinejoin;
        return true;
      }
      HASH_GUARD(0x7761D019E0B5EA94LL, magickstripimage) {
        ci = &ci_magickstripimage;
        return true;
      }
      HASH_GUARD(0x4B1501C4C22FFA94LL, quoted_printable_encode) {
        ci = &ci_quoted_printable_encode;
        return true;
      }
      HASH_GUARD(0x0AC7CBCE30442A94LL, imagepalettecopy) {
        ci = &ci_imagepalettecopy;
        return true;
      }
      break;
    case 2709:
      HASH_GUARD(0x34B8A4E5AE0EFA95LL, pixelgetopacity) {
        ci = &ci_pixelgetopacity;
        return true;
      }
      break;
    case 2711:
      HASH_GUARD(0x0089115038C03A97LL, array_diff_ukey) {
        ci = &ci_array_diff_ukey;
        return true;
      }
      break;
    case 2714:
      HASH_GUARD(0x19AFF8596E19DA9ALL, xhprof_enable) {
        ci = &ci_xhprof_enable;
        return true;
      }
      break;
    case 2717:
      HASH_GUARD(0x1234AB687C515A9DLL, mb_encode_numericentity) {
        ci = &ci_mb_encode_numericentity;
        return true;
      }
      break;
    case 2719:
      HASH_GUARD(0x2E5E23ECA0525A9FLL, bcadd) {
        ci = &ci_bcadd;
        return true;
      }
      break;
    case 2720:
      HASH_GUARD(0x55FAF12AF1920AA0LL, sha1_file) {
        ci = &ci_sha1_file;
        return true;
      }
      break;
    case 2723:
      HASH_GUARD(0x2B75B48A53AACAA3LL, imagestring) {
        ci = &ci_imagestring;
        return true;
      }
      break;
    case 2725:
      HASH_GUARD(0x2418528164415AA5LL, magickscaleimage) {
        ci = &ci_magickscaleimage;
        return true;
      }
      break;
    case 2726:
      HASH_GUARD(0x4BBA1E164DF9CAA6LL, localeconv) {
        ci = &ci_localeconv;
        return true;
      }
      break;
    case 2727:
      HASH_GUARD(0x797CEC173CBB7AA7LL, ob_get_flush) {
        ci = &ci_ob_get_flush;
        return true;
      }
      break;
    case 2729:
      HASH_GUARD(0x2238FC7870E9CAA9LL, strspn) {
        ci = &ci_strspn;
        return true;
      }
      break;
    case 2731:
      HASH_GUARD(0x1331979EF8EF0AABLL, mb_ereg_search) {
        ci = &ci_mb_ereg_search;
        return true;
      }
      break;
    case 2732:
      HASH_GUARD(0x18CF3E4A60E4AAACLL, pi) {
        ci = &ci_pi;
        return true;
      }
      break;
    case 2735:
      HASH_GUARD(0x3ED47399FE1D6AAFLL, dom_document_create_attribute_ns) {
        ci = &ci_dom_document_create_attribute_ns;
        return true;
      }
      break;
    case 2738:
      HASH_GUARD(0x569EED88F20BAAB2LL, drawgettextundercolor) {
        ci = &ci_drawgettextundercolor;
        return true;
      }
      HASH_GUARD(0x62519270CC9F1AB2LL, stream_get_meta_data) {
        ci = &ci_stream_get_meta_data;
        return true;
      }
      break;
    case 2740:
      HASH_GUARD(0x1BAFB965204D0AB4LL, openssl_x509_check_private_key) {
        ci = &ci_openssl_x509_check_private_key;
        return true;
      }
      break;
    case 2751:
      HASH_GUARD(0x030DFC3D3C88BABFLL, filegroup) {
        ci = &ci_filegroup;
        return true;
      }
      break;
    case 2757:
      HASH_GUARD(0x3754E97715176AC5LL, hphp_get_stats) {
        ci = &ci_hphp_get_stats;
        return true;
      }
      break;
    case 2759:
      HASH_GUARD(0x5D2F899A270D9AC7LL, xmlwriter_end_dtd_element) {
        ci = &ci_xmlwriter_end_dtd_element;
        return true;
      }
      HASH_GUARD(0x79215854355CBAC7LL, proc_get_status) {
        ci = &ci_proc_get_status;
        return true;
      }
      HASH_GUARD(0x3886D2664F874AC7LL, openssl_pkcs7_verify) {
        ci = &ci_openssl_pkcs7_verify;
        return true;
      }
      break;
    case 2761:
      HASH_GUARD(0x5CA9671385EF0AC9LL, sem_release) {
        ci = &ci_sem_release;
        return true;
      }
      break;
    case 2762:
      HASH_GUARD(0x45B30CD663284ACALL, is_int) {
        ci = &ci_is_int;
        return true;
      }
      break;
    case 2763:
      HASH_GUARD(0x348888DDF223AACBLL, mt_getrandmax) {
        ci = &ci_mt_getrandmax;
        return true;
      }
      break;
    case 2764:
      HASH_GUARD(0x750D0396676E6ACCLL, imagecolorexact) {
        ci = &ci_imagecolorexact;
        return true;
      }
      HASH_GUARD(0x2BD6476D2C467ACCLL, pagelet_server_task_status) {
        ci = &ci_pagelet_server_task_status;
        return true;
      }
      break;
    case 2765:
      HASH_GUARD(0x173EDC165B673ACDLL, magicktransformimage) {
        ci = &ci_magicktransformimage;
        return true;
      }
      break;
    case 2769:
      HASH_GUARD(0x47E2B4F7B8DE5AD1LL, xmlwriter_write_dtd_attlist) {
        ci = &ci_xmlwriter_write_dtd_attlist;
        return true;
      }
      HASH_GUARD(0x314317450857FAD1LL, ctype_punct) {
        ci = &ci_ctype_punct;
        return true;
      }
      break;
    case 2773:
      HASH_GUARD(0x0D5DAF8034B41AD5LL, get_include_path) {
        ci = &ci_get_include_path;
        return true;
      }
      HASH_GUARD(0x5338F971C6DCEAD5LL, hphp_splfileinfo_islink) {
        ci = &ci_hphp_splfileinfo_islink;
        return true;
      }
      break;
    case 2774:
      HASH_GUARD(0x231BCE6071220AD6LL, drawcircle) {
        ci = &ci_drawcircle;
        return true;
      }
      break;
    case 2776:
      HASH_GUARD(0x52401023E146AAD8LL, xmlwriter_end_dtd) {
        ci = &ci_xmlwriter_end_dtd;
        return true;
      }
      break;
    case 2779:
      HASH_GUARD(0x24771ED112008ADBLL, echo) {
        ci = &ci_echo;
        return true;
      }
      HASH_GUARD(0x56E867A1F7507ADBLL, dom_document_create_processing_instruction) {
        ci = &ci_dom_document_create_processing_instruction;
        return true;
      }
      break;
    case 2780:
      HASH_GUARD(0x547E7EE64761AADCLL, imagecreatefromxbm) {
        ci = &ci_imagecreatefromxbm;
        return true;
      }
      break;
    case 2781:
      HASH_GUARD(0x3E319E451A32FADDLL, magicksharpenimage) {
        ci = &ci_magicksharpenimage;
        return true;
      }
      break;
    case 2782:
      HASH_GUARD(0x31D1C58F7BD89ADELL, hphp_directoryiterator_seek) {
        ci = &ci_hphp_directoryiterator_seek;
        return true;
      }
      break;
    case 2788:
      HASH_GUARD(0x47B15A7136E94AE4LL, strnatcasecmp) {
        ci = &ci_strnatcasecmp;
        return true;
      }
      HASH_GUARD(0x1827F1C22F1CCAE4LL, hebrevc) {
        ci = &ci_hebrevc;
        return true;
      }
      break;
    case 2790:
      HASH_GUARD(0x0E09D0FEA30B6AE6LL, hphp_get_function_info) {
        ci = &ci_hphp_get_function_info;
        return true;
      }
      break;
    case 2795:
      HASH_GUARD(0x225F05071947BAEBLL, drawpathlinetoabsolute) {
        ci = &ci_drawpathlinetoabsolute;
        return true;
      }
      break;
    case 2797:
      HASH_GUARD(0x46C33B4739C2FAEDLL, shm_remove_var) {
        ci = &ci_shm_remove_var;
        return true;
      }
      break;
    case 2798:
      HASH_GUARD(0x160A82E3E2CBBAEELL, is_finite) {
        ci = &ci_is_finite;
        return true;
      }
      break;
    case 2800:
      HASH_GUARD(0x6B259D5D9D681AF0LL, register_postsend_function) {
        ci = &ci_register_postsend_function;
        return true;
      }
      break;
    case 2804:
      HASH_GUARD(0x2EC0ABF9A979FAF4LL, ob_get_level) {
        ci = &ci_ob_get_level;
        return true;
      }
      break;
    case 2806:
      HASH_GUARD(0x2C7C9772AE983AF6LL, drawsetgravity) {
        ci = &ci_drawsetgravity;
        return true;
      }
      break;
    case 2808:
      HASH_GUARD(0x12859AD75BAF3AF8LL, magickreadimageblob) {
        ci = &ci_magickreadimageblob;
        return true;
      }
      HASH_GUARD(0x757229A894864AF8LL, session_set_cookie_params) {
        ci = &ci_session_set_cookie_params;
        return true;
      }
      break;
    case 2813:
      HASH_GUARD(0x16BA422EB6C51AFDLL, gzwrite) {
        ci = &ci_gzwrite;
        return true;
      }
      break;
    case 2814:
      HASH_GUARD(0x04E86BA79B6CBAFELL, stream_socket_shutdown) {
        ci = &ci_stream_socket_shutdown;
        return true;
      }
      break;
    case 2815:
      HASH_GUARD(0x7833F4C337542AFFLL, openssl_pkey_export) {
        ci = &ci_openssl_pkey_export;
        return true;
      }
      break;
    case 2817:
      HASH_GUARD(0x6F3503C7FB12DB01LL, lchgrp) {
        ci = &ci_lchgrp;
        return true;
      }
      break;
    case 2819:
      HASH_GUARD(0x673A96C50F00FB03LL, str_word_count) {
        ci = &ci_str_word_count;
        return true;
      }
      HASH_GUARD(0x32458C11C6E74B03LL, pixelsetblackquantum) {
        ci = &ci_pixelsetblackquantum;
        return true;
      }
      break;
    case 2826:
      HASH_GUARD(0x14B366EF64A66B0ALL, get_loaded_extensions) {
        ci = &ci_get_loaded_extensions;
        return true;
      }
      HASH_GUARD(0x14AF32A23B507B0ALL, metaphone) {
        ci = &ci_metaphone;
        return true;
      }
      break;
    case 2829:
      HASH_GUARD(0x368DBC0699272B0DLL, magicknegateimage) {
        ci = &ci_magicknegateimage;
        return true;
      }
      break;
    case 2836:
      HASH_GUARD(0x76675F14C1138B14LL, gzuncompress) {
        ci = &ci_gzuncompress;
        return true;
      }
      break;
    case 2837:
      HASH_GUARD(0x24D0895FBB7BCB15LL, is_callable) {
        ci = &ci_is_callable;
        return true;
      }
      HASH_GUARD(0x773E3809C4954B15LL, hphp_recursivedirectoryiterator_current) {
        ci = &ci_hphp_recursivedirectoryiterator_current;
        return true;
      }
      break;
    case 2839:
      HASH_GUARD(0x66F9A476DAB47B17LL, pixelsetcolor) {
        ci = &ci_pixelsetcolor;
        return true;
      }
      break;
    case 2840:
      HASH_GUARD(0x70448A629A74FB18LL, ksort) {
        ci = &ci_ksort;
        return true;
      }
      break;
    case 2841:
      HASH_GUARD(0x0551EACBE8278B19LL, decoct) {
        ci = &ci_decoct;
        return true;
      }
      break;
    case 2842:
      HASH_GUARD(0x399522EE0CF3EB1ALL, drawsetstrokewidth) {
        ci = &ci_drawsetstrokewidth;
        return true;
      }
      break;
    case 2843:
      HASH_GUARD(0x1B7CE8114AEACB1BLL, magickannotateimage) {
        ci = &ci_magickannotateimage;
        return true;
      }
      break;
    case 2844:
      HASH_GUARD(0x249399CEC35B7B1CLL, png2wbmp) {
        ci = &ci_png2wbmp;
        return true;
      }
      break;
    case 2846:
      HASH_GUARD(0x7160AA24D4251B1ELL, mb_strripos) {
        ci = &ci_mb_strripos;
        return true;
      }
      break;
    case 2848:
      HASH_GUARD(0x1112712715D75B20LL, pixelgetblackquantum) {
        ci = &ci_pixelgetblackquantum;
        return true;
      }
      break;
    case 2853:
      HASH_GUARD(0x798F2776FECAEB25LL, get_required_files) {
        ci = &ci_get_required_files;
        return true;
      }
      break;
    case 2854:
      HASH_GUARD(0x24CE95457EACBB26LL, get_parent_class) {
        ci = &ci_get_parent_class;
        return true;
      }
      break;
    case 2857:
      HASH_GUARD(0x17C38BE3A6EE8B29LL, mysql_field_flags) {
        ci = &ci_mysql_field_flags;
        return true;
      }
      break;
    case 2858:
      HASH_GUARD(0x1F4984938E1DBB2ALL, sort) {
        ci = &ci_sort;
        return true;
      }
      break;
    case 2860:
      HASH_GUARD(0x70742211FA3EFB2CLL, imagettftext) {
        ci = &ci_imagettftext;
        return true;
      }
      break;
    case 2865:
      HASH_GUARD(0x442B1E05FC146B31LL, stream_context_set_param) {
        ci = &ci_stream_context_set_param;
        return true;
      }
      break;
    case 2867:
      HASH_GUARD(0x00DCD60DD8752B33LL, set_exception_handler) {
        ci = &ci_set_exception_handler;
        return true;
      }
      HASH_GUARD(0x4D5D45D1F1EB3B33LL, posix_access) {
        ci = &ci_posix_access;
        return true;
      }
      break;
    case 2868:
      HASH_GUARD(0x0B7D52E2540ABB34LL, tan) {
        ci = &ci_tan;
        return true;
      }
      break;
    case 2869:
      HASH_GUARD(0x78842C1950B38B35LL, drawpathfinish) {
        ci = &ci_drawpathfinish;
        return true;
      }
      break;
    case 2871:
      HASH_GUARD(0x053B14F52350FB37LL, socket_shutdown) {
        ci = &ci_socket_shutdown;
        return true;
      }
      break;
    case 2872:
      HASH_GUARD(0x68C09D6CB8E79B38LL, class_exists) {
        ci = &ci_class_exists;
        return true;
      }
      break;
    case 2873:
      HASH_GUARD(0x02A2C373E54FFB39LL, hash_init) {
        ci = &ci_hash_init;
        return true;
      }
      break;
    case 2874:
      HASH_GUARD(0x49A45F75B2B25B3ALL, apd_breakpoint) {
        ci = &ci_apd_breakpoint;
        return true;
      }
      break;
    case 2876:
      HASH_GUARD(0x35F4A0789F367B3CLL, drawpathlinetohorizontalrelative) {
        ci = &ci_drawpathlinetohorizontalrelative;
        return true;
      }
      break;
    case 2878:
      HASH_GUARD(0x5E2AF775FEB04B3ELL, posix_getppid) {
        ci = &ci_posix_getppid;
        return true;
      }
      break;
    case 2879:
      HASH_GUARD(0x0B07AD87DF1B5B3FLL, urldecode) {
        ci = &ci_urldecode;
        return true;
      }
      break;
    case 2880:
      HASH_GUARD(0x24CBCBA5C4407B40LL, evhttp_set_cache) {
        ci = &ci_evhttp_set_cache;
        return true;
      }
      break;
    case 2884:
      HASH_GUARD(0x4E4449EBAADD7B44LL, magickpingimage) {
        ci = &ci_magickpingimage;
        return true;
      }
      break;
    case 2885:
      HASH_GUARD(0x684881C79ED1AB45LL, func_get_args) {
        ci = &ci_func_get_args;
        return true;
      }
      HASH_GUARD(0x72E3AE55A0B33B45LL, ispixelwand) {
        ci = &ci_ispixelwand;
        return true;
      }
      break;
    case 2886:
      HASH_GUARD(0x00D8FE7A00252B46LL, escapeshellarg) {
        ci = &ci_escapeshellarg;
        return true;
      }
      break;
    case 2893:
      HASH_GUARD(0x37DF53E4D9348B4DLL, xbox_post_message) {
        ci = &ci_xbox_post_message;
        return true;
      }
      break;
    case 2896:
      HASH_GUARD(0x6237393C71E56B50LL, array_fill_keys) {
        ci = &ci_array_fill_keys;
        return true;
      }
      break;
    case 2899:
      HASH_GUARD(0x40F0B69D55F7EB53LL, drawsetstrokealpha) {
        ci = &ci_drawsetstrokealpha;
        return true;
      }
      break;
    case 2901:
      HASH_GUARD(0x333FB673518A1B55LL, ldap_get_entries) {
        ci = &ci_ldap_get_entries;
        return true;
      }
      break;
    case 2904:
      HASH_GUARD(0x6158E2E0A5ACCB58LL, idn_to_ascii) {
        ci = &ci_idn_to_ascii;
        return true;
      }
      break;
    case 2907:
      HASH_GUARD(0x29203294F6214B5BLL, memcache_debug) {
        ci = &ci_memcache_debug;
        return true;
      }
      HASH_GUARD(0x23FD09A13E0D8B5BLL, xmlwriter_open_memory) {
        ci = &ci_xmlwriter_open_memory;
        return true;
      }
      break;
    case 2909:
      HASH_GUARD(0x4888951358F53B5DLL, dom_document_get_elements_by_tag_name_ns) {
        ci = &ci_dom_document_get_elements_by_tag_name_ns;
        return true;
      }
      break;
    case 2913:
      HASH_GUARD(0x7636825871399B61LL, highlight_file) {
        ci = &ci_highlight_file;
        return true;
      }
      break;
    case 2920:
      HASH_GUARD(0x674F1DA24EDE7B68LL, xmlwriter_end_attribute) {
        ci = &ci_xmlwriter_end_attribute;
        return true;
      }
      break;
    case 2922:
      HASH_GUARD(0x4BD4E9D9D4A56B6ALL, exif_tagname) {
        ci = &ci_exif_tagname;
        return true;
      }
      break;
    case 2923:
      HASH_GUARD(0x5543A0CACD153B6BLL, substr_replace) {
        ci = &ci_substr_replace;
        return true;
      }
      HASH_GUARD(0x1D4136B4CEAE4B6BLL, stripcslashes) {
        ci = &ci_stripcslashes;
        return true;
      }
      break;
    case 2927:
      HASH_GUARD(0x2D8D57FC1DC6CB6FLL, import_request_variables) {
        ci = &ci_import_request_variables;
        return true;
      }
      break;
    case 2928:
      HASH_GUARD(0x1A73FD4416FECB70LL, magickwriteimagefile) {
        ci = &ci_magickwriteimagefile;
        return true;
      }
      break;
    case 2929:
      HASH_GUARD(0x5E5C875DB04CFB71LL, drawrectangle) {
        ci = &ci_drawrectangle;
        return true;
      }
      break;
    case 2933:
      HASH_GUARD(0x42F0AED7599C1B75LL, magickechoimageblob) {
        ci = &ci_magickechoimageblob;
        return true;
      }
      break;
    case 2934:
      HASH_GUARD(0x2A63A0BF9B7E3B76LL, ini_alter) {
        ci = &ci_ini_alter;
        return true;
      }
      break;
    case 2935:
      HASH_GUARD(0x7F5F29D8E63ABB77LL, mcrypt_module_self_test) {
        ci = &ci_mcrypt_module_self_test;
        return true;
      }
      HASH_GUARD(0x5025B43B46679B77LL, openssl_x509_free) {
        ci = &ci_openssl_x509_free;
        return true;
      }
      break;
    case 2937:
      HASH_GUARD(0x31242F51AA828B79LL, drawpoppattern) {
        ci = &ci_drawpoppattern;
        return true;
      }
      break;
    case 2940:
      HASH_GUARD(0x3A096F905FBF7B7CLL, magickcommentimage) {
        ci = &ci_magickcommentimage;
        return true;
      }
      break;
    case 2941:
      HASH_GUARD(0x28DE19828167FB7DLL, magickmapimage) {
        ci = &ci_magickmapimage;
        return true;
      }
      break;
    case 2943:
      HASH_GUARD(0x308C90AD9478CB7FLL, substr_compare) {
        ci = &ci_substr_compare;
        return true;
      }
      break;
    case 2946:
      HASH_GUARD(0x5BDE96FD5015AB82LL, base_convert) {
        ci = &ci_base_convert;
        return true;
      }
      break;
    case 2949:
      HASH_GUARD(0x41F8FDD700C0CB85LL, socket_last_error) {
        ci = &ci_socket_last_error;
        return true;
      }
      break;
    case 2955:
      HASH_GUARD(0x3B72159A4B04FB8BLL, set_time_limit) {
        ci = &ci_set_time_limit;
        return true;
      }
      break;
    case 2957:
      HASH_GUARD(0x3B831DB1A615FB8DLL, xhprof_sample_enable) {
        ci = &ci_xhprof_sample_enable;
        return true;
      }
      break;
    case 2958:
      HASH_GUARD(0x62A4D7A03F7C3B8ELL, ceil) {
        ci = &ci_ceil;
        return true;
      }
      break;
    case 2967:
      HASH_GUARD(0x09837A82A928AB97LL, is_null) {
        ci = &ci_is_null;
        return true;
      }
      break;
    case 2969:
      HASH_GUARD(0x076E66D4089A3B99LL, mb_stripos) {
        ci = &ci_mb_stripos;
        return true;
      }
      break;
    case 2970:
      HASH_GUARD(0x023133732CB51B9ALL, exif_thumbnail) {
        ci = &ci_exif_thumbnail;
        return true;
      }
      break;
    case 2975:
      HASH_GUARD(0x390A267EC6B51B9FLL, socket_sendto) {
        ci = &ci_socket_sendto;
        return true;
      }
      break;
    case 2978:
      HASH_GUARD(0x4870ADD98EE02BA2LL, pcntl_wifsignaled) {
        ci = &ci_pcntl_wifsignaled;
        return true;
      }
      break;
    case 2979:
      HASH_GUARD(0x444A3375EFBC2BA3LL, openssl_public_decrypt) {
        ci = &ci_openssl_public_decrypt;
        return true;
      }
      break;
    case 2980:
      HASH_GUARD(0x0D95DD13A2D3BBA4LL, drawtranslate) {
        ci = &ci_drawtranslate;
        return true;
      }
      break;
    case 2986:
      HASH_GUARD(0x7C833A303C7CFBAALL, getrandmax) {
        ci = &ci_getrandmax;
        return true;
      }
      break;
    case 2987:
      HASH_GUARD(0x006481EAF2A70BABLL, ldap_errno) {
        ci = &ci_ldap_errno;
        return true;
      }
      break;
    case 2991:
      HASH_GUARD(0x6A2236CDDFF12BAFLL, magickhaspreviousimage) {
        ci = &ci_magickhaspreviousimage;
        return true;
      }
      break;
    case 2992:
      HASH_GUARD(0x1F3E4C6660247BB0LL, imagecolorresolve) {
        ci = &ci_imagecolorresolve;
        return true;
      }
      HASH_GUARD(0x7D9BF61D6CDE3BB0LL, fb_parallel_query) {
        ci = &ci_fb_parallel_query;
        return true;
      }
      break;
    case 2993:
      HASH_GUARD(0x04A24B397CF46BB1LL, strrchr) {
        ci = &ci_strrchr;
        return true;
      }
      break;
    case 2997:
      HASH_GUARD(0x3F7DCC3A00800BB5LL, imagecolorallocate) {
        ci = &ci_imagecolorallocate;
        return true;
      }
      break;
    case 3004:
      HASH_GUARD(0x43B74276235F4BBCLL, is_bool) {
        ci = &ci_is_bool;
        return true;
      }
      break;
    case 3006:
      HASH_GUARD(0x79617ED8EFD1ABBELL, get_class_vars) {
        ci = &ci_get_class_vars;
        return true;
      }
      HASH_GUARD(0x3F56AF1511AEDBBELL, magicklabelimage) {
        ci = &ci_magicklabelimage;
        return true;
      }
      HASH_GUARD(0x5ECB0B145B88EBBELL, imagefilledarc) {
        ci = &ci_imagefilledarc;
        return true;
      }
      HASH_GUARD(0x42684202E2E62BBELL, mcrypt_get_iv_size) {
        ci = &ci_mcrypt_get_iv_size;
        return true;
      }
      break;
    case 3015:
      HASH_GUARD(0x10C5CF7B55173BC7LL, settype) {
        ci = &ci_settype;
        return true;
      }
      break;
    case 3017:
      HASH_GUARD(0x0B4E7B9180C4ABC9LL, xml_set_end_namespace_decl_handler) {
        ci = &ci_xml_set_end_namespace_decl_handler;
        return true;
      }
      HASH_GUARD(0x22BA0903D344CBC9LL, array_rand) {
        ci = &ci_array_rand;
        return true;
      }
      break;
    case 3018:
      HASH_GUARD(0x0D375A94E75ACBCALL, hphp_throw_fatal_error) {
        ci = &ci_hphp_throw_fatal_error;
        return true;
      }
      HASH_GUARD(0x4122DFAC25BDFBCALL, hphp_splfileinfo_getowner) {
        ci = &ci_hphp_splfileinfo_getowner;
        return true;
      }
      break;
    case 3021:
      HASH_GUARD(0x22251ECF8CD58BCDLL, array_product) {
        ci = &ci_array_product;
        return true;
      }
      HASH_GUARD(0x53A88C8F973CFBCDLL, apc_clear_cache) {
        ci = &ci_apc_clear_cache;
        return true;
      }
      break;
    case 3022:
      HASH_GUARD(0x45D6BA980AFFDBCELL, msg_get_queue) {
        ci = &ci_msg_get_queue;
        return true;
      }
      HASH_GUARD(0x600AFF0A6378ABCELL, is_writeable) {
        ci = &ci_is_writeable;
        return true;
      }
      break;
    case 3024:
      HASH_GUARD(0x7046755D8374EBD0LL, ctype_digit) {
        ci = &ci_ctype_digit;
        return true;
      }
      HASH_GUARD(0x6846CA07A5E21BD0LL, hphp_directoryiterator___construct) {
        ci = &ci_hphp_directoryiterator___construct;
        return true;
      }
      break;
    case 3026:
      HASH_GUARD(0x6FE3C5FF5E883BD2LL, round) {
        ci = &ci_round;
        return true;
      }
      break;
    case 3028:
      HASH_GUARD(0x5B2F2A23D8368BD4LL, magickraiseimage) {
        ci = &ci_magickraiseimage;
        return true;
      }
      HASH_GUARD(0x4E4EB301A994DBD4LL, drawpolygon) {
        ci = &ci_drawpolygon;
        return true;
      }
      break;
    case 3032:
      HASH_GUARD(0x21E44C7C7A911BD8LL, phpinfo) {
        ci = &ci_phpinfo;
        return true;
      }
      HASH_GUARD(0x06D5979AB150EBD8LL, dom_node_lookup_namespace_uri) {
        ci = &ci_dom_node_lookup_namespace_uri;
        return true;
      }
      break;
    case 3038:
      HASH_GUARD(0x58D0D9B66F045BDELL, strpos) {
        ci = &ci_strpos;
        return true;
      }
      break;
    case 3040:
      HASH_GUARD(0x2E10B74DC6067BE0LL, strip_tags) {
        ci = &ci_strip_tags;
        return true;
      }
      break;
    case 3041:
      HASH_GUARD(0x25FBB61480091BE1LL, mysql_client_encoding) {
        ci = &ci_mysql_client_encoding;
        return true;
      }
      break;
    case 3047:
      HASH_GUARD(0x1BB5D99C1D29CBE7LL, strstr) {
        ci = &ci_strstr;
        return true;
      }
      break;
    case 3048:
      HASH_GUARD(0x4E903B706977ABE8LL, imagepsslantfont) {
        ci = &ci_imagepsslantfont;
        return true;
      }
      break;
    case 3051:
      HASH_GUARD(0x505B44DDF2383BEBLL, drawgetfillcolor) {
        ci = &ci_drawgetfillcolor;
        return true;
      }
      HASH_GUARD(0x0C1904372E8EDBEBLL, stream_copy_to_stream) {
        ci = &ci_stream_copy_to_stream;
        return true;
      }
      break;
    case 3052:
      HASH_GUARD(0x44279BB3E2191BECLL, socket_accept) {
        ci = &ci_socket_accept;
        return true;
      }
      HASH_GUARD(0x5A22BA9B012A9BECLL, dom_document_save_html) {
        ci = &ci_dom_document_save_html;
        return true;
      }
      break;
    case 3054:
      HASH_GUARD(0x03F50E435DE20BEELL, magickclippathimage) {
        ci = &ci_magickclippathimage;
        return true;
      }
      HASH_GUARD(0x790B7C44A3442BEELL, asort) {
        ci = &ci_asort;
        return true;
      }
      break;
    case 3056:
      HASH_GUARD(0x187C049E785A1BF0LL, iconv_get_encoding) {
        ci = &ci_iconv_get_encoding;
        return true;
      }
      HASH_GUARD(0x04C0582DB1AD7BF0LL, mt_srand) {
        ci = &ci_mt_srand;
        return true;
      }
      break;
    case 3057:
      HASH_GUARD(0x0CA96856E5BEFBF1LL, iptcparse) {
        ci = &ci_iptcparse;
        return true;
      }
      break;
    case 3060:
      HASH_GUARD(0x1444DB037B4D5BF4LL, imagegammacorrect) {
        ci = &ci_imagegammacorrect;
        return true;
      }
      break;
    case 3062:
      HASH_GUARD(0x08B4BEBAB3312BF6LL, image_type_to_extension) {
        ci = &ci_image_type_to_extension;
        return true;
      }
      break;
    case 3063:
      HASH_GUARD(0x74ABB4A1E10BBBF7LL, time) {
        ci = &ci_time;
        return true;
      }
      break;
    case 3065:
      HASH_GUARD(0x5B7F6E0A642BBBF9LL, sleep) {
        ci = &ci_sleep;
        return true;
      }
      break;
    case 3068:
      HASH_GUARD(0x64F52E1DB5E95BFCLL, curl_multi_remove_handle) {
        ci = &ci_curl_multi_remove_handle;
        return true;
      }
      break;
    case 3074:
      HASH_GUARD(0x249340DF734D9C02LL, magickgetimageheight) {
        ci = &ci_magickgetimageheight;
        return true;
      }
      break;
    case 3077:
      HASH_GUARD(0x2EC378A759F9EC05LL, xbox_task_status) {
        ci = &ci_xbox_task_status;
        return true;
      }
      break;
    case 3080:
      HASH_GUARD(0x48E1616EE837FC08LL, is_uploaded_file) {
        ci = &ci_is_uploaded_file;
        return true;
      }
      break;
    case 3082:
      HASH_GUARD(0x1E47C281193ABC0ALL, collator_compare) {
        ci = &ci_collator_compare;
        return true;
      }
      break;
    case 3083:
      HASH_GUARD(0x0EEE484739520C0BLL, magickthresholdimage) {
        ci = &ci_magickthresholdimage;
        return true;
      }
      HASH_GUARD(0x0833BCE91C40CC0BLL, magickqueryconfigureoption) {
        ci = &ci_magickqueryconfigureoption;
        return true;
      }
      break;
    case 3090:
      HASH_GUARD(0x062C0FFA8E29DC12LL, intl_error_name) {
        ci = &ci_intl_error_name;
        return true;
      }
      HASH_GUARD(0x510B683F2E764C12LL, fb_load_local_databases) {
        ci = &ci_fb_load_local_databases;
        return true;
      }
      break;
    case 3095:
      HASH_GUARD(0x3A702EF906B37C17LL, collator_get_locale) {
        ci = &ci_collator_get_locale;
        return true;
      }
      break;
    case 3099:
      HASH_GUARD(0x67742A0F218F6C1BLL, posix_initgroups) {
        ci = &ci_posix_initgroups;
        return true;
      }
      HASH_GUARD(0x7D615C7E3ADB2C1BLL, xmlwriter_write_comment) {
        ci = &ci_xmlwriter_write_comment;
        return true;
      }
      break;
    case 3100:
      HASH_GUARD(0x758A62BD65E6FC1CLL, imagegd2) {
        ci = &ci_imagegd2;
        return true;
      }
      break;
    case 3102:
      HASH_GUARD(0x7039C5EBB1D6BC1ELL, array_walk) {
        ci = &ci_array_walk;
        return true;
      }
      break;
    case 3103:
      HASH_GUARD(0x3A5D921797669C1FLL, hphp_log) {
        ci = &ci_hphp_log;
        return true;
      }
      break;
    case 3104:
      HASH_GUARD(0x7BD43EB167198C20LL, xmlwriter_write_pi) {
        ci = &ci_xmlwriter_write_pi;
        return true;
      }
      break;
    case 3105:
      HASH_GUARD(0x0179CBA2C5F4DC21LL, magickgetimageformat) {
        ci = &ci_magickgetimageformat;
        return true;
      }
      break;
    case 3111:
      HASH_GUARD(0x5A02EE8ED39F0C27LL, posix_getgrnam) {
        ci = &ci_posix_getgrnam;
        return true;
      }
      break;
    case 3112:
      HASH_GUARD(0x79A4E240F18BAC28LL, rand) {
        ci = &ci_rand;
        return true;
      }
      break;
    case 3115:
      HASH_GUARD(0x09A98E99D51E8C2BLL, hphp_recursivedirectoryiterator_seek) {
        ci = &ci_hphp_recursivedirectoryiterator_seek;
        return true;
      }
      break;
    case 3116:
      HASH_GUARD(0x116C3EC924B9AC2CLL, imagegd) {
        ci = &ci_imagegd;
        return true;
      }
      break;
    case 3122:
      HASH_GUARD(0x0B9B362534621C32LL, isdrawingwand) {
        ci = &ci_isdrawingwand;
        return true;
      }
      break;
    case 3123:
      HASH_GUARD(0x49965C44E9EE3C33LL, set_file_buffer) {
        ci = &ci_set_file_buffer;
        return true;
      }
      break;
    case 3125:
      HASH_GUARD(0x2B9A380A29D0EC35LL, session_write_close) {
        ci = &ci_session_write_close;
        return true;
      }
      break;
    case 3128:
      HASH_GUARD(0x21564F9315F3FC38LL, drawsettextdecoration) {
        ci = &ci_drawsettextdecoration;
        return true;
      }
      break;
    case 3132:
      HASH_GUARD(0x69488CC69B897C3CLL, hphp_recursiveiteratoriterator_getinneriterator) {
        ci = &ci_hphp_recursiveiteratoriterator_getinneriterator;
        return true;
      }
      break;
    case 3134:
      HASH_GUARD(0x15EC581662651C3ELL, date_parse) {
        ci = &ci_date_parse;
        return true;
      }
      break;
    case 3141:
      HASH_GUARD(0x6EF89BCAD607CC45LL, strncasecmp) {
        ci = &ci_strncasecmp;
        return true;
      }
      break;
    case 3142:
      HASH_GUARD(0x7D992445F5E37C46LL, magicktextureimage) {
        ci = &ci_magicktextureimage;
        return true;
      }
      break;
    case 3143:
      HASH_GUARD(0x44055093E56E4C47LL, mcrypt_enc_get_key_size) {
        ci = &ci_mcrypt_enc_get_key_size;
        return true;
      }
      break;
    case 3145:
      HASH_GUARD(0x2D3F0F8DB0C20C49LL, dom_node_insert_before) {
        ci = &ci_dom_node_insert_before;
        return true;
      }
      HASH_GUARD(0x357F73CEBD6E2C49LL, write_hdf_string) {
        ci = &ci_write_hdf_string;
        return true;
      }
      break;
    case 3146:
      HASH_GUARD(0x3C23768CFB492C4ALL, gzinflate) {
        ci = &ci_gzinflate;
        return true;
      }
      break;
    case 3147:
      HASH_GUARD(0x120E7B01366DFC4BLL, call_user_func_serialized) {
        ci = &ci_call_user_func_serialized;
        return true;
      }
      break;
    case 3150:
      HASH_GUARD(0x5DAC1C64D8F08C4ELL, openssl_pkey_get_private) {
        ci = &ci_openssl_pkey_get_private;
        return true;
      }
      break;
    case 3152:
      HASH_GUARD(0x04534F26B8D05C50LL, drawgetstrokecolor) {
        ci = &ci_drawgetstrokecolor;
        return true;
      }
      break;
    case 3153:
      HASH_GUARD(0x56EDB60C824E8C51LL, key) {
        ci = &ci_key;
        return true;
      }
      break;
    case 3154:
      HASH_GUARD(0x1FC294B806F76C52LL, php_sapi_name) {
        ci = &ci_php_sapi_name;
        return true;
      }
      break;
    case 3159:
      HASH_GUARD(0x793259E03C37CC57LL, memcache_decrement) {
        ci = &ci_memcache_decrement;
        return true;
      }
      HASH_GUARD(0x313E8EB28A111C57LL, hphp_splfileinfo_setinfoclass) {
        ci = &ci_hphp_splfileinfo_setinfoclass;
        return true;
      }
      break;
    case 3160:
      HASH_GUARD(0x1B8C3DA27170DC58LL, dirname) {
        ci = &ci_dirname;
        return true;
      }
      break;
    case 3161:
      HASH_GUARD(0x57633BDF8DB3FC59LL, i18n_loc_set_attribute) {
        ci = &ci_i18n_loc_set_attribute;
        return true;
      }
      break;
    case 3166:
      HASH_GUARD(0x47B38F1E4FA29C5ELL, fb_get_code_coverage) {
        ci = &ci_fb_get_code_coverage;
        return true;
      }
      break;
    case 3169:
      HASH_GUARD(0x6E54EEDA1D887C61LL, magicksetimageinterlacescheme) {
        ci = &ci_magicksetimageinterlacescheme;
        return true;
      }
      HASH_GUARD(0x5176725DA884DC61LL, curl_setopt) {
        ci = &ci_curl_setopt;
        return true;
      }
      break;
    case 3171:
      HASH_GUARD(0x43C0E9827D502C63LL, array_intersect_assoc) {
        ci = &ci_array_intersect_assoc;
        return true;
      }
      break;
    case 3172:
      HASH_GUARD(0x3409D717D9246C64LL, libxml_use_internal_errors) {
        ci = &ci_libxml_use_internal_errors;
        return true;
      }
      break;
    case 3175:
      HASH_GUARD(0x07DC355325165C67LL, magickwriteimage) {
        ci = &ci_magickwriteimage;
        return true;
      }
      break;
    case 3176:
      HASH_GUARD(0x10D6AE9D688D1C68LL, copy) {
        ci = &ci_copy;
        return true;
      }
      break;
    case 3178:
      HASH_GUARD(0x41BD9EA0BC5E4C6ALL, move_uploaded_file) {
        ci = &ci_move_uploaded_file;
        return true;
      }
      break;
    case 3179:
      HASH_GUARD(0x7C6B37BF6300AC6BLL, iconv_mime_encode) {
        ci = &ci_iconv_mime_encode;
        return true;
      }
      break;
    case 3185:
      HASH_GUARD(0x1E074215FE5FCC71LL, set_error_handler) {
        ci = &ci_set_error_handler;
        return true;
      }
      HASH_GUARD(0x18D9ED67E8E0FC71LL, dom_attr_is_id) {
        ci = &ci_dom_attr_is_id;
        return true;
      }
      break;
    case 3188:
      HASH_GUARD(0x20F0AAA486F39C74LL, dom_element_get_elements_by_tag_name_ns) {
        ci = &ci_dom_element_get_elements_by_tag_name_ns;
        return true;
      }
      break;
    case 3189:
      HASH_GUARD(0x528366F3195ACC75LL, xbox_task_result) {
        ci = &ci_xbox_task_result;
        return true;
      }
      break;
    case 3190:
      HASH_GUARD(0x1C35934C6BC52C76LL, libxml_clear_errors) {
        ci = &ci_libxml_clear_errors;
        return true;
      }
      break;
    case 3192:
      HASH_GUARD(0x665F08996BD4AC78LL, magicksetimagegreenprimary) {
        ci = &ci_magicksetimagegreenprimary;
        return true;
      }
      break;
    case 3194:
      HASH_GUARD(0x05D7B804ECDE8C7ALL, checkdnsrr) {
        ci = &ci_checkdnsrr;
        return true;
      }
      HASH_GUARD(0x05F3BC04D61CAC7ALL, get_defined_vars) {
        ci = &ci_get_defined_vars;
        return true;
      }
      break;
    case 3195:
      HASH_GUARD(0x749E45FBD48BEC7BLL, hphp_recursivedirectoryiterator___tostring) {
        ci = &ci_hphp_recursivedirectoryiterator___tostring;
        return true;
      }
      HASH_GUARD(0x71B25229CD080C7BLL, dom_element_set_attribute_node_ns) {
        ci = &ci_dom_element_set_attribute_node_ns;
        return true;
      }
      break;
    case 3198:
      HASH_GUARD(0x5F41821072A06C7ELL, hphp_splfileinfo_getctime) {
        ci = &ci_hphp_splfileinfo_getctime;
        return true;
      }
      break;
    case 3201:
      HASH_GUARD(0x767806D6F1053C81LL, sin) {
        ci = &ci_sin;
        return true;
      }
      break;
    case 3204:
      HASH_GUARD(0x5D49AF7004696C84LL, shm_detach) {
        ci = &ci_shm_detach;
        return true;
      }
      break;
    case 3205:
      HASH_GUARD(0x56DA17241B793C85LL, mysql_set_timeout) {
        ci = &ci_mysql_set_timeout;
        return true;
      }
      break;
    case 3209:
      HASH_GUARD(0x0F9C0C82F40F2C89LL, pixelsetcyanquantum) {
        ci = &ci_pixelsetcyanquantum;
        return true;
      }
      break;
    case 3214:
      HASH_GUARD(0x467470230015AC8ELL, mcrypt_module_is_block_algorithm_mode) {
        ci = &ci_mcrypt_module_is_block_algorithm_mode;
        return true;
      }
      break;
    case 3215:
      HASH_GUARD(0x4173EFD9A8EECC8FLL, magicknewimage) {
        ci = &ci_magicknewimage;
        return true;
      }
      break;
    case 3216:
      HASH_GUARD(0x05556EDFC1BB0C90LL, mysql_info) {
        ci = &ci_mysql_info;
        return true;
      }
      HASH_GUARD(0x3F0C947E68D02C90LL, ini_get_all) {
        ci = &ci_ini_get_all;
        return true;
      }
      break;
    case 3217:
      HASH_GUARD(0x4E04B71729485C91LL, clonedrawingwand) {
        ci = &ci_clonedrawingwand;
        return true;
      }
      break;
    case 3219:
      HASH_GUARD(0x0F8242C6327B5C93LL, dns_check_record) {
        ci = &ci_dns_check_record;
        return true;
      }
      break;
    case 3222:
      HASH_GUARD(0x47C5BC101A512C96LL, magickquantizeimage) {
        ci = &ci_magickquantizeimage;
        return true;
      }
      break;
    case 3225:
      HASH_GUARD(0x2EA6E1D600786C99LL, mb_strtoupper) {
        ci = &ci_mb_strtoupper;
        return true;
      }
      break;
    case 3226:
      HASH_GUARD(0x374F20BDAF709C9ALL, mb_preferred_mime_name) {
        ci = &ci_mb_preferred_mime_name;
        return true;
      }
      break;
    case 3227:
      HASH_GUARD(0x36F7F9FD7766DC9BLL, xmlwriter_end_comment) {
        ci = &ci_xmlwriter_end_comment;
        return true;
      }
      break;
    case 3230:
      HASH_GUARD(0x50296037C7968C9ELL, preg_split) {
        ci = &ci_preg_split;
        return true;
      }
      break;
    case 3233:
      HASH_GUARD(0x4590B5971EC9ACA1LL, getmygid) {
        ci = &ci_getmygid;
        return true;
      }
      break;
    case 3235:
      HASH_GUARD(0x737253E9FC112CA3LL, socket_close) {
        ci = &ci_socket_close;
        return true;
      }
      break;
    case 3245:
      HASH_GUARD(0x1C1216F2B7C16CADLL, ftell) {
        ci = &ci_ftell;
        return true;
      }
      break;
    case 3246:
      HASH_GUARD(0x12580A083B0D7CAELL, iterator_apply) {
        ci = &ci_iterator_apply;
        return true;
      }
      HASH_GUARD(0x3ACD2F1EA5282CAELL, magickmattefloodfillimage) {
        ci = &ci_magickmattefloodfillimage;
        return true;
      }
      break;
    case 3248:
      HASH_GUARD(0x373B3FADEACB7CB0LL, openssl_private_encrypt) {
        ci = &ci_openssl_private_encrypt;
        return true;
      }
      break;
    case 3249:
      HASH_GUARD(0x40D8DC24FA917CB1LL, hphp_splfileobject_fgetss) {
        ci = &ci_hphp_splfileobject_fgetss;
        return true;
      }
      HASH_GUARD(0x735555B148E58CB1LL, ldap_read) {
        ci = &ci_ldap_read;
        return true;
      }
      break;
    case 3250:
      HASH_GUARD(0x56023CC5ECC9ECB2LL, dns_get_mx) {
        ci = &ci_dns_get_mx;
        return true;
      }
      break;
    case 3252:
      HASH_GUARD(0x41FBEF9F7A024CB4LL, xmlwriter_end_element) {
        ci = &ci_xmlwriter_end_element;
        return true;
      }
      HASH_GUARD(0x742AD1AA5A80ECB4LL, output_reset_rewrite_vars) {
        ci = &ci_output_reset_rewrite_vars;
        return true;
      }
      break;
    case 3254:
      HASH_GUARD(0x560637BE51C36CB6LL, ezmlm_hash) {
        ci = &ci_ezmlm_hash;
        return true;
      }
      break;
    case 3255:
      HASH_GUARD(0x3DFD5CA79919DCB7LL, imageantialias) {
        ci = &ci_imageantialias;
        return true;
      }
      HASH_GUARD(0x39E03AAC188D3CB7LL, magickgetimagecompressionquality) {
        ci = &ci_magickgetimagecompressionquality;
        return true;
      }
      break;
    case 3259:
      HASH_GUARD(0x41D3B07854936CBBLL, token_get_all) {
        ci = &ci_token_get_all;
        return true;
      }
      HASH_GUARD(0x15ACD9F32D214CBBLL, mysql_fetch_lengths) {
        ci = &ci_mysql_fetch_lengths;
        return true;
      }
      break;
    case 3260:
      HASH_GUARD(0x19C1872E55A7ECBCLL, is_long) {
        ci = &ci_is_long;
        return true;
      }
      HASH_GUARD(0x3978BE548631ECBCLL, hash_final) {
        ci = &ci_hash_final;
        return true;
      }
      HASH_GUARD(0x733137183026ACBCLL, hphp_splfileobject_next) {
        ci = &ci_hphp_splfileobject_next;
        return true;
      }
      break;
    case 3264:
      HASH_GUARD(0x3033FE14E114FCC0LL, magicksetimageblueprimary) {
        ci = &ci_magicksetimageblueprimary;
        return true;
      }
      break;
    case 3266:
      HASH_GUARD(0x42BCEFCF899D0CC2LL, magickgetimagecolorspace) {
        ci = &ci_magickgetimagecolorspace;
        return true;
      }
      HASH_GUARD(0x34B6388D7730BCC2LL, drawline) {
        ci = &ci_drawline;
        return true;
      }
      break;
    case 3267:
      HASH_GUARD(0x7A147B8B98C76CC3LL, key_exists) {
        ci = &ci_key_exists;
        return true;
      }
      break;
    case 3278:
      HASH_GUARD(0x0183A548B759BCCELL, posix_getpgid) {
        ci = &ci_posix_getpgid;
        return true;
      }
      HASH_GUARD(0x66273C5932B1FCCELL, clock_gettime) {
        ci = &ci_clock_gettime;
        return true;
      }
      break;
    case 3279:
      HASH_GUARD(0x407B1F3AFEC43CCFLL, pixelgetblue) {
        ci = &ci_pixelgetblue;
        return true;
      }
      break;
    case 3281:
      HASH_GUARD(0x576C5DC462663CD1LL, explode) {
        ci = &ci_explode;
        return true;
      }
      break;
    case 3282:
      HASH_GUARD(0x1FD3FB2AB0F48CD2LL, magickgetimagesignature) {
        ci = &ci_magickgetimagesignature;
        return true;
      }
      break;
    case 3283:
      HASH_GUARD(0x544302E2FAD3FCD3LL, magicknextimage) {
        ci = &ci_magicknextimage;
        return true;
      }
      HASH_GUARD(0x6406BC03A5D84CD3LL, dom_element_remove_attribute) {
        ci = &ci_dom_element_remove_attribute;
        return true;
      }
      break;
    case 3284:
      HASH_GUARD(0x323FE1D92C9B3CD4LL, gzdecode) {
        ci = &ci_gzdecode;
        return true;
      }
      break;
    case 3285:
      HASH_GUARD(0x757BC444FDF79CD5LL, posix_get_last_error) {
        ci = &ci_posix_get_last_error;
        return true;
      }
      break;
    case 3286:
      HASH_GUARD(0x11166D3106DB6CD6LL, wandhasexception) {
        ci = &ci_wandhasexception;
        return true;
      }
      break;
    case 3289:
      HASH_GUARD(0x27BFAF1293A60CD9LL, ldap_get_dn) {
        ci = &ci_ldap_get_dn;
        return true;
      }
      break;
    case 3290:
      HASH_GUARD(0x674AA2DBDA5E4CDALL, imageloadfont) {
        ci = &ci_imageloadfont;
        return true;
      }
      HASH_GUARD(0x09C6455B4BC6FCDALL, drawsetviewbox) {
        ci = &ci_drawsetviewbox;
        return true;
      }
      break;
    case 3298:
      HASH_GUARD(0x6B92530A9ABA0CE2LL, session_commit) {
        ci = &ci_session_commit;
        return true;
      }
      break;
    case 3300:
      HASH_GUARD(0x7CDDF96AFEA2DCE4LL, chunk_split) {
        ci = &ci_chunk_split;
        return true;
      }
      break;
    case 3306:
      HASH_GUARD(0x5A8AF4F880DA4CEALL, mailparse_msg_extract_whole_part_file) {
        ci = &ci_mailparse_msg_extract_whole_part_file;
        return true;
      }
      HASH_GUARD(0x7821BD05E5228CEALL, imagewbmp) {
        ci = &ci_imagewbmp;
        return true;
      }
      break;
    case 3310:
      HASH_GUARD(0x78FFA0E69D6AACEELL, mcrypt_cfb) {
        ci = &ci_mcrypt_cfb;
        return true;
      }
      break;
    case 3311:
      HASH_GUARD(0x6AA89C314C647CEFLL, magickgetimagehistogram) {
        ci = &ci_magickgetimagehistogram;
        return true;
      }
      break;
    case 3313:
      HASH_GUARD(0x21C8FC9A94404CF1LL, php_ini_scanned_files) {
        ci = &ci_php_ini_scanned_files;
        return true;
      }
      break;
    case 3314:
      HASH_GUARD(0x26C49BBC67475CF2LL, magicksetimagewhitepoint) {
        ci = &ci_magicksetimagewhitepoint;
        return true;
      }
      break;
    case 3315:
      HASH_GUARD(0x5C1F75D51C077CF3LL, pixelgetindex) {
        ci = &ci_pixelgetindex;
        return true;
      }
      break;
    case 3317:
      HASH_GUARD(0x26729ECB00B8ECF5LL, end_user_func_async) {
        ci = &ci_end_user_func_async;
        return true;
      }
      break;
    case 3319:
      HASH_GUARD(0x1C30C8470100ECF7LL, mcrypt_enc_is_block_mode) {
        ci = &ci_mcrypt_enc_is_block_mode;
        return true;
      }
      break;
    case 3321:
      HASH_GUARD(0x537CF5DE8C43CCF9LL, curl_getinfo) {
        ci = &ci_curl_getinfo;
        return true;
      }
      break;
    case 3323:
      HASH_GUARD(0x09B4EE276DCCFCFBLL, mysql_fetch_row) {
        ci = &ci_mysql_fetch_row;
        return true;
      }
      break;
    case 3326:
      HASH_GUARD(0x768F3E6D1CBA5CFELL, socket_recv) {
        ci = &ci_socket_recv;
        return true;
      }
      break;
    case 3327:
      HASH_GUARD(0x748D3DFF0EB57CFFLL, uniqid) {
        ci = &ci_uniqid;
        return true;
      }
      HASH_GUARD(0x48A2F2A7A4620CFFLL, pixelsetyellowquantum) {
        ci = &ci_pixelsetyellowquantum;
        return true;
      }
      break;
    case 3330:
      HASH_GUARD(0x018F22AEA371ED02LL, filemtime) {
        ci = &ci_filemtime;
        return true;
      }
      HASH_GUARD(0x7EB48D1BB5B7AD02LL, dom_element_set_attribute) {
        ci = &ci_dom_element_set_attribute;
        return true;
      }
      break;
    case 3332:
      HASH_GUARD(0x1248250E701DAD04LL, magickgaussianblurimage) {
        ci = &ci_magickgaussianblurimage;
        return true;
      }
      break;
    case 3334:
      HASH_GUARD(0x2BA9FB0F8B76DD06LL, number_format) {
        ci = &ci_number_format;
        return true;
      }
      break;
    case 3335:
      HASH_GUARD(0x19B643D858DC6D07LL, magickgetimagerenderingintent) {
        ci = &ci_magickgetimagerenderingintent;
        return true;
      }
      break;
    case 3337:
      HASH_GUARD(0x153F7DBFC9047D09LL, pixelsetred) {
        ci = &ci_pixelsetred;
        return true;
      }
      break;
    case 3338:
      HASH_GUARD(0x6E8996DD071CED0ALL, dom_element_remove_attribute_node) {
        ci = &ci_dom_element_remove_attribute_node;
        return true;
      }
      break;
    case 3340:
      HASH_GUARD(0x30A8326034801D0CLL, mysql_pconnect) {
        ci = &ci_mysql_pconnect;
        return true;
      }
      break;
    case 3341:
      HASH_GUARD(0x3ACE8A8BC9ACDD0DLL, iconv_mime_decode) {
        ci = &ci_iconv_mime_decode;
        return true;
      }
      break;
    case 3344:
      HASH_GUARD(0x42BEEC88EE81FD10LL, imagechar) {
        ci = &ci_imagechar;
        return true;
      }
      HASH_GUARD(0x08F41A00D5D57D10LL, mb_decode_mimeheader) {
        ci = &ci_mb_decode_mimeheader;
        return true;
      }
      HASH_GUARD(0x5CEFA5A265104D10LL, count) {
        ci = &ci_count;
        return true;
      }
      break;
    case 3345:
      HASH_GUARD(0x2D484921B5400D11LL, magickradialblurimage) {
        ci = &ci_magickradialblurimage;
        return true;
      }
      break;
    case 3346:
      HASH_GUARD(0x5F165B40AEEE5D12LL, hphp_splfileinfo_getfilename) {
        ci = &ci_hphp_splfileinfo_getfilename;
        return true;
      }
      break;
    case 3348:
      HASH_GUARD(0x63837ECAF6235D14LL, preg_replace) {
        ci = &ci_preg_replace;
        return true;
      }
      break;
    case 3351:
      HASH_GUARD(0x12BB5E00E714ED17LL, magickgetimagecompose) {
        ci = &ci_magickgetimagecompose;
        return true;
      }
      break;
    case 3354:
      HASH_GUARD(0x75DB75CA9DE56D1ALL, xml_parser_get_option) {
        ci = &ci_xml_parser_get_option;
        return true;
      }
      HASH_GUARD(0x39994614C6315D1ALL, hphp_recursivedirectoryiterator_key) {
        ci = &ci_hphp_recursivedirectoryiterator_key;
        return true;
      }
      break;
    case 3355:
      HASH_GUARD(0x70C22A7EEF54CD1BLL, ldap_compare) {
        ci = &ci_ldap_compare;
        return true;
      }
      break;
    case 3358:
      HASH_GUARD(0x25DADFF238A15D1ELL, collator_create) {
        ci = &ci_collator_create;
        return true;
      }
      break;
    case 3359:
      HASH_GUARD(0x566465036CCBCD1FLL, min) {
        ci = &ci_min;
        return true;
      }
      break;
    case 3365:
      HASH_GUARD(0x71DF0C17F47EDD25LL, getprotobynumber) {
        ci = &ci_getprotobynumber;
        return true;
      }
      break;
    case 3366:
      HASH_GUARD(0x429D088E9779CD26LL, dom_document_normalize_document) {
        ci = &ci_dom_document_normalize_document;
        return true;
      }
      break;
    case 3368:
      HASH_GUARD(0x7C12261259F87D28LL, mcrypt_enc_is_block_algorithm_mode) {
        ci = &ci_mcrypt_enc_is_block_algorithm_mode;
        return true;
      }
      break;
    case 3369:
      HASH_GUARD(0x632D50B69429ED29LL, socket_set_block) {
        ci = &ci_socket_set_block;
        return true;
      }
      break;
    case 3370:
      HASH_GUARD(0x7A9C06B9CF853D2ALL, substr_count) {
        ci = &ci_substr_count;
        return true;
      }
      break;
    case 3378:
      HASH_GUARD(0x4DAC43060BA57D32LL, stream_wrapper_restore) {
        ci = &ci_stream_wrapper_restore;
        return true;
      }
      break;
    case 3382:
      HASH_GUARD(0x515841235FADCD36LL, class_implements) {
        ci = &ci_class_implements;
        return true;
      }
      break;
    case 3383:
      HASH_GUARD(0x3ACF745D381E9D37LL, rtrim) {
        ci = &ci_rtrim;
        return true;
      }
      break;
    case 3384:
      HASH_GUARD(0x0BA3AD85EB597D38LL, pagelet_server_task_result) {
        ci = &ci_pagelet_server_task_result;
        return true;
      }
      break;
    case 3387:
      HASH_GUARD(0x0784B2B034560D3BLL, destroypixelwand) {
        ci = &ci_destroypixelwand;
        return true;
      }
      HASH_GUARD(0x6C9AE626DAD02D3BLL, mailparse_msg_extract_part_file) {
        ci = &ci_mailparse_msg_extract_part_file;
        return true;
      }
      break;
    case 3392:
      HASH_GUARD(0x198627C81DABAD40LL, register_cleanup_function) {
        ci = &ci_register_cleanup_function;
        return true;
      }
      break;
    case 3393:
      HASH_GUARD(0x6B6DA1EE18673D41LL, xmlwriter_end_dtd_entity) {
        ci = &ci_xmlwriter_end_dtd_entity;
        return true;
      }
      break;
    case 3394:
      HASH_GUARD(0x40497FCA4EC4DD42LL, posix_seteuid) {
        ci = &ci_posix_seteuid;
        return true;
      }
      HASH_GUARD(0x298BA735FA3ABD42LL, nl_langinfo) {
        ci = &ci_nl_langinfo;
        return true;
      }
      break;
    case 3397:
      HASH_GUARD(0x400A44045A999D45LL, rawurlencode) {
        ci = &ci_rawurlencode;
        return true;
      }
      break;
    case 3398:
      HASH_GUARD(0x502CF4EB0A747D46LL, magicksetimagebias) {
        ci = &ci_magicksetimagebias;
        return true;
      }
      HASH_GUARD(0x455DB7F86BCEDD46LL, pixelsetopacityquantum) {
        ci = &ci_pixelsetopacityquantum;
        return true;
      }
      HASH_GUARD(0x59AD2C922FF75D46LL, mdecrypt_generic) {
        ci = &ci_mdecrypt_generic;
        return true;
      }
      break;
    case 3401:
      HASH_GUARD(0x113ED435AEFDDD49LL, imagecolorallocatealpha) {
        ci = &ci_imagecolorallocatealpha;
        return true;
      }
      HASH_GUARD(0x41785512C45FCD49LL, mysql_ping) {
        ci = &ci_mysql_ping;
        return true;
      }
      break;
    case 3407:
      HASH_GUARD(0x0FBCF35ADD209D4FLL, drawarc) {
        ci = &ci_drawarc;
        return true;
      }
      break;
    case 3408:
      HASH_GUARD(0x39B11A2A25E40D50LL, mysql_get_server_info) {
        ci = &ci_mysql_get_server_info;
        return true;
      }
      HASH_GUARD(0x337D2252CDA22D50LL, is_real) {
        ci = &ci_is_real;
        return true;
      }
      break;
    case 3413:
      HASH_GUARD(0x36D672EF4FBEFD55LL, json_encode) {
        ci = &ci_json_encode;
        return true;
      }
      break;
    case 3416:
      HASH_GUARD(0x146109BDD2F97D58LL, hphp_splfileobject_setmaxlinelen) {
        ci = &ci_hphp_splfileobject_setmaxlinelen;
        return true;
      }
      break;
    case 3418:
      HASH_GUARD(0x4ACCF26A7AE80D5ALL, imagefilltoborder) {
        ci = &ci_imagefilltoborder;
        return true;
      }
      break;
    case 3419:
      HASH_GUARD(0x41B5E3D2AADE2D5BLL, drawroundrectangle) {
        ci = &ci_drawroundrectangle;
        return true;
      }
      break;
    case 3420:
      HASH_GUARD(0x1371413B4F6F8D5CLL, pixelgetred) {
        ci = &ci_pixelgetred;
        return true;
      }
      break;
    case 3424:
      HASH_GUARD(0x6FACBD7F02B6FD60LL, uasort) {
        ci = &ci_uasort;
        return true;
      }
      HASH_GUARD(0x567276D68FE12D60LL, preg_quote) {
        ci = &ci_preg_quote;
        return true;
      }
      break;
    case 3425:
      HASH_GUARD(0x34F150F3D94E6D61LL, gzpassthru) {
        ci = &ci_gzpassthru;
        return true;
      }
      HASH_GUARD(0x357BAB6E700EBD61LL, destroypixelwandarray) {
        ci = &ci_destroypixelwandarray;
        return true;
      }
      break;
    case 3430:
      HASH_GUARD(0x0C393EE8F6540D66LL, bccomp) {
        ci = &ci_bccomp;
        return true;
      }
      break;
    case 3437:
      HASH_GUARD(0x21D924BA98BFCD6DLL, file_get_contents) {
        ci = &ci_file_get_contents;
        return true;
      }
      HASH_GUARD(0x7D9E024FD8696D6DLL, get_class) {
        ci = &ci_get_class;
        return true;
      }
      HASH_GUARD(0x4351AFD0FD818D6DLL, magickmotionblurimage) {
        ci = &ci_magickmotionblurimage;
        return true;
      }
      break;
    case 3438:
      HASH_GUARD(0x0B1348D1540E7D6ELL, magicksetimageformat) {
        ci = &ci_magicksetimageformat;
        return true;
      }
      break;
    case 3441:
      HASH_GUARD(0x74FDC4596C654D71LL, dom_node_is_default_namespace) {
        ci = &ci_dom_node_is_default_namespace;
        return true;
      }
      break;
    case 3443:
      HASH_GUARD(0x7D8DCC72522CBD73LL, mb_detect_encoding) {
        ci = &ci_mb_detect_encoding;
        return true;
      }
      break;
    case 3446:
      HASH_GUARD(0x7467E8107EF08D76LL, unpack) {
        ci = &ci_unpack;
        return true;
      }
      break;
    case 3447:
      HASH_GUARD(0x3ED49C2BBDDFAD77LL, ldap_next_reference) {
        ci = &ci_ldap_next_reference;
        return true;
      }
      HASH_GUARD(0x7FCAAAB932C57D77LL, iterator_count) {
        ci = &ci_iterator_count;
        return true;
      }
      break;
    case 3448:
      HASH_GUARD(0x6352349F97557D78LL, stream_socket_get_name) {
        ci = &ci_stream_socket_get_name;
        return true;
      }
      break;
    case 3451:
      HASH_GUARD(0x680A7EB3DA1F5D7BLL, prev) {
        ci = &ci_prev;
        return true;
      }
      break;
    case 3454:
      HASH_GUARD(0x384E8BC9B5FE2D7ELL, magickfximage) {
        ci = &ci_magickfximage;
        return true;
      }
      break;
    case 3455:
      HASH_GUARD(0x4E19AFB75A62AD7FLL, imagerotate) {
        ci = &ci_imagerotate;
        return true;
      }
      break;
    case 3457:
      HASH_GUARD(0x25EA810DAEA74D81LL, ob_clean) {
        ci = &ci_ob_clean;
        return true;
      }
      break;
    case 3458:
      HASH_GUARD(0x2D15262403ADDD82LL, drawcomposite) {
        ci = &ci_drawcomposite;
        return true;
      }
      break;
    case 3459:
      HASH_GUARD(0x1B0FF5C02F571D83LL, fb_rename_function) {
        ci = &ci_fb_rename_function;
        return true;
      }
      break;
    case 3463:
      HASH_GUARD(0x344091B785FE8D87LL, socket_set_timeout) {
        ci = &ci_socket_set_timeout;
        return true;
      }
      break;
    case 3464:
      HASH_GUARD(0x2AFF8525E93D6D88LL, drawsetfillopacity) {
        ci = &ci_drawsetfillopacity;
        return true;
      }
      HASH_GUARD(0x1F22C82816F9AD88LL, hphp_splfileinfo_getpath) {
        ci = &ci_hphp_splfileinfo_getpath;
        return true;
      }
      break;
    case 3465:
      HASH_GUARD(0x230E7AD147721D89LL, end) {
        ci = &ci_end;
        return true;
      }
      break;
    case 3470:
      HASH_GUARD(0x6A351AEDFC4D0D8ELL, magickgetimagemimetype) {
        ci = &ci_magickgetimagemimetype;
        return true;
      }
      break;
    case 3471:
      HASH_GUARD(0x1806DC9468882D8FLL, gzfile) {
        ci = &ci_gzfile;
        return true;
      }
      break;
    case 3472:
      HASH_GUARD(0x5E4360FC28D0AD90LL, magicksetinterlacescheme) {
        ci = &ci_magicksetinterlacescheme;
        return true;
      }
      break;
    case 3473:
      HASH_GUARD(0x5695393CF6428D91LL, dom_element_set_id_attribute) {
        ci = &ci_dom_element_set_id_attribute;
        return true;
      }
      HASH_GUARD(0x48444F8F18E60D91LL, strftime) {
        ci = &ci_strftime;
        return true;
      }
      HASH_GUARD(0x7C2B3FE61FBDFD91LL, openssl_pkey_get_details) {
        ci = &ci_openssl_pkey_get_details;
        return true;
      }
      break;
    case 3480:
      HASH_GUARD(0x06A796D329C21D98LL, call_user_func) {
        ci = &ci_call_user_func;
        return true;
      }
      break;
    case 3485:
      HASH_GUARD(0x74BE8836F3B13D9DLL, session_name) {
        ci = &ci_session_name;
        return true;
      }
      break;
    case 3486:
      HASH_GUARD(0x30C1AE2B06990D9ELL, gzseek) {
        ci = &ci_gzseek;
        return true;
      }
      break;
    case 3488:
      HASH_GUARD(0x73B43ABDD5C61DA0LL, shuffle) {
        ci = &ci_shuffle;
        return true;
      }
      HASH_GUARD(0x5E8606470A09BDA0LL, magickposterizeimage) {
        ci = &ci_magickposterizeimage;
        return true;
      }
      HASH_GUARD(0x7084C6294240CDA0LL, octdec) {
        ci = &ci_octdec;
        return true;
      }
      HASH_GUARD(0x167A11C41EB71DA0LL, pixelgetexceptiontype) {
        ci = &ci_pixelgetexceptiontype;
        return true;
      }
      break;
    case 3490:
      HASH_GUARD(0x71583A8FEF5C7DA2LL, sys_get_temp_dir) {
        ci = &ci_sys_get_temp_dir;
        return true;
      }
      break;
    case 3493:
      HASH_GUARD(0x46B2F287D2FC7DA5LL, memcache_get) {
        ci = &ci_memcache_get;
        return true;
      }
      break;
    case 3494:
      HASH_GUARD(0x28DC1AD6DA9E7DA6LL, gethostbyname) {
        ci = &ci_gethostbyname;
        return true;
      }
      break;
    case 3496:
      HASH_GUARD(0x18FEAF2459E5ADA8LL, dom_element_has_attribute) {
        ci = &ci_dom_element_has_attribute;
        return true;
      }
      HASH_GUARD(0x572AE270D9E4FDA8LL, socket_set_option) {
        ci = &ci_socket_set_option;
        return true;
      }
      HASH_GUARD(0x474A096265502DA8LL, glob) {
        ci = &ci_glob;
        return true;
      }
      break;
    case 3498:
      HASH_GUARD(0x6326C14D0FFA7DAALL, fb_thrift_serialize) {
        ci = &ci_fb_thrift_serialize;
        return true;
      }
      break;
    case 3499:
      HASH_GUARD(0x188720048AB37DABLL, magickquantizeimages) {
        ci = &ci_magickquantizeimages;
        return true;
      }
      HASH_GUARD(0x66764CAABFF4CDABLL, array_keys) {
        ci = &ci_array_keys;
        return true;
      }
      break;
    case 3505:
      HASH_GUARD(0x67EAC6D7332F3DB1LL, hphp_splfileobject_fgetcsv) {
        ci = &ci_hphp_splfileobject_fgetcsv;
        return true;
      }
      break;
    case 3506:
      HASH_GUARD(0x257371BC40186DB2LL, magickblurimage) {
        ci = &ci_magickblurimage;
        return true;
      }
      break;
    case 3507:
      HASH_GUARD(0x628069E483F35DB3LL, hphp_splfileobject_fstat) {
        ci = &ci_hphp_splfileobject_fstat;
        return true;
      }
      HASH_GUARD(0x53F2C6F5AE244DB3LL, drawpushdefs) {
        ci = &ci_drawpushdefs;
        return true;
      }
      break;
    case 3512:
      HASH_GUARD(0x2B1D442AEA06ADB8LL, strpbrk) {
        ci = &ci_strpbrk;
        return true;
      }
      break;
    case 3514:
      HASH_GUARD(0x5E0C6E797607DDBALL, mysql_result) {
        ci = &ci_mysql_result;
        return true;
      }
      HASH_GUARD(0x7964DE73DCA17DBALL, magickhasnextimage) {
        ci = &ci_magickhasnextimage;
        return true;
      }
      break;
    case 3516:
      HASH_GUARD(0x770DEDCB168B0DBCLL, mb_ereg_search_setpos) {
        ci = &ci_mb_ereg_search_setpos;
        return true;
      }
      break;
    case 3517:
      HASH_GUARD(0x48AA091B1E493DBDLL, setlocale) {
        ci = &ci_setlocale;
        return true;
      }
      HASH_GUARD(0x01E6FF7D9746CDBDLL, stream_socket_accept) {
        ci = &ci_stream_socket_accept;
        return true;
      }
      break;
    case 3521:
      HASH_GUARD(0x683E88F441F9BDC1LL, chgrp) {
        ci = &ci_chgrp;
        return true;
      }
      break;
    case 3523:
      HASH_GUARD(0x069EE6F604BA2DC3LL, array_reverse) {
        ci = &ci_array_reverse;
        return true;
      }
      HASH_GUARD(0x0433140BB339DDC3LL, log) {
        ci = &ci_log;
        return true;
      }
      break;
    case 3524:
      HASH_GUARD(0x2A38BA8B4A0F9DC4LL, apc_fetch) {
        ci = &ci_apc_fetch;
        return true;
      }
      break;
    case 3526:
      HASH_GUARD(0x73210FEAA2EACDC6LL, imagecolorsforindex) {
        ci = &ci_imagecolorsforindex;
        return true;
      }
      break;
    case 3528:
      HASH_GUARD(0x66C3E73210067DC8LL, magickgetimageunits) {
        ci = &ci_magickgetimageunits;
        return true;
      }
      break;
    case 3530:
      HASH_GUARD(0x3BB701F2BDD0ADCALL, magickgetimageprofile) {
        ci = &ci_magickgetimageprofile;
        return true;
      }
      break;
    case 3534:
      HASH_GUARD(0x3E5C990C32470DCELL, array_combine) {
        ci = &ci_array_combine;
        return true;
      }
      HASH_GUARD(0x4AD5B65BCE665DCELL, array_key_exists) {
        ci = &ci_array_key_exists;
        return true;
      }
      HASH_GUARD(0x40C3C7DE46D62DCELL, ob_start) {
        ci = &ci_ob_start;
        return true;
      }
      break;
    case 3536:
      HASH_GUARD(0x0E1C354339208DD0LL, imagetypes) {
        ci = &ci_imagetypes;
        return true;
      }
      break;
    case 3541:
      HASH_GUARD(0x7E1801C8E70D1DD5LL, imagefontwidth) {
        ci = &ci_imagefontwidth;
        return true;
      }
      break;
    case 3543:
      HASH_GUARD(0x638690DF6D06FDD7LL, imageconvolution) {
        ci = &ci_imageconvolution;
        return true;
      }
      HASH_GUARD(0x1AE08377A1630DD7LL, mysql_insert_id) {
        ci = &ci_mysql_insert_id;
        return true;
      }
      break;
    case 3548:
      HASH_GUARD(0x5EBE067E3FAECDDCLL, ob_gzhandler) {
        ci = &ci_ob_gzhandler;
        return true;
      }
      HASH_GUARD(0x2497295AC9F72DDCLL, stream_set_blocking) {
        ci = &ci_stream_set_blocking;
        return true;
      }
      break;
    case 3549:
      HASH_GUARD(0x3B00B916C3682DDDLL, ctype_upper) {
        ci = &ci_ctype_upper;
        return true;
      }
      break;
    case 3560:
      HASH_GUARD(0x47A4BA8616D02DE8LL, restore_exception_handler) {
        ci = &ci_restore_exception_handler;
        return true;
      }
      break;
    case 3564:
      HASH_GUARD(0x5B51DD18C3E13DECLL, openssl_x509_parse) {
        ci = &ci_openssl_x509_parse;
        return true;
      }
      HASH_GUARD(0x5ABB7486CE861DECLL, array_merge_recursive) {
        ci = &ci_array_merge_recursive;
        return true;
      }
      break;
    case 3567:
      HASH_GUARD(0x0BB22147ADADDDEFLL, pfsockopen) {
        ci = &ci_pfsockopen;
        return true;
      }
      HASH_GUARD(0x72293DCE8CC4BDEFLL, htmlspecialchars) {
        ci = &ci_htmlspecialchars;
        return true;
      }
      break;
    case 3571:
      HASH_GUARD(0x7AE1BE187F18FDF3LL, fgets) {
        ci = &ci_fgets;
        return true;
      }
      break;
    case 3572:
      HASH_GUARD(0x73B30E65808A6DF4LL, ctype_xdigit) {
        ci = &ci_ctype_xdigit;
        return true;
      }
      HASH_GUARD(0x5046A0D9DFDB5DF4LL, strcspn) {
        ci = &ci_strcspn;
        return true;
      }
      break;
    case 3575:
      HASH_GUARD(0x23E563F1EC919DF7LL, hphp_splfileinfo_getpathname) {
        ci = &ci_hphp_splfileinfo_getpathname;
        return true;
      }
      break;
    case 3576:
      HASH_GUARD(0x5E43280BC8DD1DF8LL, magicktrimimage) {
        ci = &ci_magicktrimimage;
        return true;
      }
      break;
    case 3579:
      HASH_GUARD(0x47C62D58B0B65DFBLL, thrift_protocol_write_binary) {
        ci = &ci_thrift_protocol_write_binary;
        return true;
      }
      break;
    case 3582:
      HASH_GUARD(0x21F24104004CFDFELL, evhttp_post) {
        ci = &ci_evhttp_post;
        return true;
      }
      HASH_GUARD(0x072690BF719D7DFELL, hphp_recursivedirectoryiterator_rewind) {
        ci = &ci_hphp_recursivedirectoryiterator_rewind;
        return true;
      }
      break;
    case 3586:
      HASH_GUARD(0x7829D2171DFBFE02LL, magickgetimagegamma) {
        ci = &ci_magickgetimagegamma;
        return true;
      }
      break;
    case 3596:
      HASH_GUARD(0x3AD6E084483B2E0CLL, array_udiff_assoc) {
        ci = &ci_array_udiff_assoc;
        return true;
      }
      break;
    case 3597:
      HASH_GUARD(0x5EB0A2F93E650E0DLL, array_diff_key) {
        ci = &ci_array_diff_key;
        return true;
      }
      HASH_GUARD(0x756B92411E7FBE0DLL, stream_get_wrappers) {
        ci = &ci_stream_get_wrappers;
        return true;
      }
      break;
    case 3598:
      HASH_GUARD(0x5230E4C9D8D64E0ELL, highlight_string) {
        ci = &ci_highlight_string;
        return true;
      }
      break;
    case 3602:
      HASH_GUARD(0x05FAA2085D94FE12LL, urlencode) {
        ci = &ci_urlencode;
        return true;
      }
      HASH_GUARD(0x76636D0F0C090E12LL, curl_copy_handle) {
        ci = &ci_curl_copy_handle;
        return true;
      }
      break;
    case 3604:
      HASH_GUARD(0x41E394B12170BE14LL, socket_send) {
        ci = &ci_socket_send;
        return true;
      }
      HASH_GUARD(0x3192209D50C1FE14LL, pixelsetalpha) {
        ci = &ci_pixelsetalpha;
        return true;
      }
      break;
    case 3605:
      HASH_GUARD(0x525F197D74423E15LL, get_resource_type) {
        ci = &ci_get_resource_type;
        return true;
      }
      break;
    case 3607:
      HASH_GUARD(0x0F5759A501FAFE17LL, imagecreatefromgd2part) {
        ci = &ci_imagecreatefromgd2part;
        return true;
      }
      HASH_GUARD(0x3D13FD5FE3AF6E17LL, imagestringup) {
        ci = &ci_imagestringup;
        return true;
      }
      break;
    case 3609:
      HASH_GUARD(0x4A694B42B21A9E19LL, destroymagickwand) {
        ci = &ci_destroymagickwand;
        return true;
      }
      break;
    case 3611:
      HASH_GUARD(0x7FA0B63054221E1BLL, magickrollimage) {
        ci = &ci_magickrollimage;
        return true;
      }
      break;
    case 3616:
      HASH_GUARD(0x7BDA47B5C47EAE20LL, fread) {
        ci = &ci_fread;
        return true;
      }
      break;
    case 3617:
      HASH_GUARD(0x5B7F218FA08D8E21LL, imagefilledellipse) {
        ci = &ci_imagefilledellipse;
        return true;
      }
      break;
    case 3621:
      HASH_GUARD(0x1C6246FA51EBDE25LL, hphp_get_static_property) {
        ci = &ci_hphp_get_static_property;
        return true;
      }
      break;
    case 3624:
      HASH_GUARD(0x3456885FF0679E28LL, lchown) {
        ci = &ci_lchown;
        return true;
      }
      break;
    case 3625:
      HASH_GUARD(0x73FE5C79E14A0E29LL, pixelsetbluequantum) {
        ci = &ci_pixelsetbluequantum;
        return true;
      }
      break;
    case 3629:
      HASH_GUARD(0x7817FA38BAAEFE2DLL, fsockopen) {
        ci = &ci_fsockopen;
        return true;
      }
      break;
    case 3630:
      HASH_GUARD(0x3E62C1A48E9EEE2ELL, hphp_splfileinfo_getsize) {
        ci = &ci_hphp_splfileinfo_getsize;
        return true;
      }
      break;
    case 3634:
      HASH_GUARD(0x000AAF93F814AE32LL, drawsetvectorgraphics) {
        ci = &ci_drawsetvectorgraphics;
        return true;
      }
      break;
    case 3635:
      HASH_GUARD(0x38433635F28B4E33LL, is_readable) {
        ci = &ci_is_readable;
        return true;
      }
      break;
    case 3638:
      HASH_GUARD(0x2E42ED1E15CCFE36LL, mysql_affected_rows) {
        ci = &ci_mysql_affected_rows;
        return true;
      }
      break;
    case 3642:
      HASH_GUARD(0x6E2CF6ECA0987E3ALL, get_headers) {
        ci = &ci_get_headers;
        return true;
      }
      HASH_GUARD(0x13048F0A79F7CE3ALL, magicksetsamplingfactors) {
        ci = &ci_magicksetsamplingfactors;
        return true;
      }
      break;
    case 3648:
      HASH_GUARD(0x11681FDE841D0E40LL, drawskewy) {
        ci = &ci_drawskewy;
        return true;
      }
      break;
    case 3650:
      HASH_GUARD(0x160B01F095B20E42LL, mb_output_handler) {
        ci = &ci_mb_output_handler;
        return true;
      }
      break;
    case 3652:
      HASH_GUARD(0x71B7756BD1B43E44LL, dom_document_savexml) {
        ci = &ci_dom_document_savexml;
        return true;
      }
      break;
    case 3654:
      HASH_GUARD(0x7F4C1DF551150E46LL, pixelgetnextiteratorrow) {
        ci = &ci_pixelgetnextiteratorrow;
        return true;
      }
      break;
    case 3660:
      HASH_GUARD(0x1EEBDFD62B6BEE4CLL, mcrypt_module_get_algo_block_size) {
        ci = &ci_mcrypt_module_get_algo_block_size;
        return true;
      }
      break;
    case 3663:
      HASH_GUARD(0x62C934CD93938E4FLL, magickimplodeimage) {
        ci = &ci_magickimplodeimage;
        return true;
      }
      break;
    case 3664:
      HASH_GUARD(0x4022005DE7E24E50LL, openssl_pkcs7_sign) {
        ci = &ci_openssl_pkcs7_sign;
        return true;
      }
      break;
    case 3668:
      HASH_GUARD(0x6BF155774D546E54LL, define_syslog_variables) {
        ci = &ci_define_syslog_variables;
        return true;
      }
      HASH_GUARD(0x7B6BF544EB420E54LL, hphp_recursivedirectoryiterator_haschildren) {
        ci = &ci_hphp_recursivedirectoryiterator_haschildren;
        return true;
      }
      break;
    case 3671:
      HASH_GUARD(0x21B07F1F212BDE57LL, hphp_get_original_class_name) {
        ci = &ci_hphp_get_original_class_name;
        return true;
      }
      HASH_GUARD(0x2DEF52641933CE57LL, magickgetimagemattecolor) {
        ci = &ci_magickgetimagemattecolor;
        return true;
      }
      break;
    case 3675:
      HASH_GUARD(0x299F1A5895461E5BLL, curl_multi_close) {
        ci = &ci_curl_multi_close;
        return true;
      }
      break;
    case 3676:
      HASH_GUARD(0x532D0D905CE60E5CLL, posix_times) {
        ci = &ci_posix_times;
        return true;
      }
      break;
    case 3677:
      HASH_GUARD(0x38373F6643B14E5DLL, ldap_parse_reference) {
        ci = &ci_ldap_parse_reference;
        return true;
      }
      break;
    case 3681:
      HASH_GUARD(0x593EA675D239CE61LL, ldap_first_reference) {
        ci = &ci_ldap_first_reference;
        return true;
      }
      break;
    case 3682:
      HASH_GUARD(0x7639C74DBC4F4E62LL, array_splice) {
        ci = &ci_array_splice;
        return true;
      }
      break;
    case 3683:
      HASH_GUARD(0x4B6FE37D66784E63LL, imagesy) {
        ci = &ci_imagesy;
        return true;
      }
      HASH_GUARD(0x5697E5F6AAF47E63LL, mb_http_input) {
        ci = &ci_mb_http_input;
        return true;
      }
      break;
    case 3684:
      HASH_GUARD(0x4F0DF8BBC4340E64LL, stream_socket_server) {
        ci = &ci_stream_socket_server;
        return true;
      }
      break;
    case 3685:
      HASH_GUARD(0x21D5A3208639EE65LL, dom_element_get_attribute_node_ns) {
        ci = &ci_dom_element_get_attribute_node_ns;
        return true;
      }
      break;
    case 3686:
      HASH_GUARD(0x6CB3DEB458A2DE66LL, apc_bin_load) {
        ci = &ci_apc_bin_load;
        return true;
      }
      break;
    case 3688:
      HASH_GUARD(0x5B1DFB89BFC1CE68LL, realpath) {
        ci = &ci_realpath;
        return true;
      }
      break;
    case 3689:
      HASH_GUARD(0x24B836D2C79D0E69LL, magickgetimagepixels) {
        ci = &ci_magickgetimagepixels;
        return true;
      }
      break;
    case 3690:
      HASH_GUARD(0x2F9816D9A2B2CE6ALL, mysql_set_charset) {
        ci = &ci_mysql_set_charset;
        return true;
      }
      HASH_GUARD(0x25C0C5E961AFDE6ALL, xmlwriter_full_end_element) {
        ci = &ci_xmlwriter_full_end_element;
        return true;
      }
      break;
    case 3693:
      HASH_GUARD(0x714001ABB0D76E6DLL, magickgetinterlacescheme) {
        ci = &ci_magickgetinterlacescheme;
        return true;
      }
      break;
    case 3695:
      HASH_GUARD(0x7E6223D0CF184E6FLL, magickqueryformats) {
        ci = &ci_magickqueryformats;
        return true;
      }
      break;
    case 3697:
      HASH_GUARD(0x6AC126DCE941FE71LL, memory_get_peak_usage) {
        ci = &ci_memory_get_peak_usage;
        return true;
      }
      break;
    case 3699:
      HASH_GUARD(0x3B28CA1BE1D0DE73LL, xbox_get_thread_timeout) {
        ci = &ci_xbox_get_thread_timeout;
        return true;
      }
      break;
    case 3700:
      HASH_GUARD(0x47D0510206B89E74LL, ini_restore) {
        ci = &ci_ini_restore;
        return true;
      }
      break;
    case 3701:
      HASH_GUARD(0x4EC7C66593DDEE75LL, sql_regcase) {
        ci = &ci_sql_regcase;
        return true;
      }
      break;
    case 3702:
      HASH_GUARD(0x36E9EC047FC73E76LL, mb_convert_encoding) {
        ci = &ci_mb_convert_encoding;
        return true;
      }
      break;
    case 3703:
      HASH_GUARD(0x12B7B2D835B80E77LL, chmod) {
        ci = &ci_chmod;
        return true;
      }
      break;
    case 3706:
      HASH_GUARD(0x6A3D9F8EDB005E7ALL, flush) {
        ci = &ci_flush;
        return true;
      }
      break;
    case 3708:
      HASH_GUARD(0x4D9C5B9A944CCE7CLL, convert_uudecode) {
        ci = &ci_convert_uudecode;
        return true;
      }
      break;
    case 3710:
      HASH_GUARD(0x51060D186C703E7ELL, headers_list) {
        ci = &ci_headers_list;
        return true;
      }
      break;
    case 3713:
      HASH_GUARD(0x0ECFC3676B4FDE81LL, chr) {
        ci = &ci_chr;
        return true;
      }
      HASH_GUARD(0x3B426B13FA584E81LL, fb_unserialize) {
        ci = &ci_fb_unserialize;
        return true;
      }
      break;
    case 3714:
      HASH_GUARD(0x379F7BF525FF1E82LL, magicksetimagecolorspace) {
        ci = &ci_magicksetimagecolorspace;
        return true;
      }
      break;
    case 3715:
      HASH_GUARD(0x724011CF7C31AE83LL, sqrt) {
        ci = &ci_sqrt;
        return true;
      }
      break;
    case 3716:
      HASH_GUARD(0x1765A63835CC4E84LL, drawgetfontfamily) {
        ci = &ci_drawgetfontfamily;
        return true;
      }
      break;
    case 3717:
      HASH_GUARD(0x4710320ED6638E85LL, rename_function) {
        ci = &ci_rename_function;
        return true;
      }
      break;
    case 3720:
      HASH_GUARD(0x1569DCC552EE8E88LL, cosh) {
        ci = &ci_cosh;
        return true;
      }
      break;
    case 3722:
      HASH_GUARD(0x15C9E5C16374EE8ALL, gzclose) {
        ci = &ci_gzclose;
        return true;
      }
      break;
    case 3726:
      HASH_GUARD(0x29A2FBD427647E8ELL, mysql_connect) {
        ci = &ci_mysql_connect;
        return true;
      }
      break;
    case 3728:
      HASH_GUARD(0x33D6CC3959D3CE90LL, clearmagickwand) {
        ci = &ci_clearmagickwand;
        return true;
      }
      break;
    case 3731:
      HASH_GUARD(0x5E968924197F5E93LL, mcrypt_ofb) {
        ci = &ci_mcrypt_ofb;
        return true;
      }
      HASH_GUARD(0x37A9E8F91C33EE93LL, magickborderimage) {
        ci = &ci_magickborderimage;
        return true;
      }
      break;
    case 3735:
      HASH_GUARD(0x6254E9BDC11F3E97LL, imagecreatefromgd2) {
        ci = &ci_imagecreatefromgd2;
        return true;
      }
      break;
    case 3739:
      HASH_GUARD(0x2A019CAA1188BE9BLL, preg_grep) {
        ci = &ci_preg_grep;
        return true;
      }
      break;
    case 3742:
      HASH_GUARD(0x76EBE919625D8E9ELL, openssl_pkcs12_export) {
        ci = &ci_openssl_pkcs12_export;
        return true;
      }
      break;
    case 3743:
      HASH_GUARD(0x224004A728974E9FLL, spl_object_hash) {
        ci = &ci_spl_object_hash;
        return true;
      }
      HASH_GUARD(0x7CFF820207DC6E9FLL, debug_backtrace) {
        ci = &ci_debug_backtrace;
        return true;
      }
      break;
    case 3744:
      HASH_GUARD(0x37C5AF6E7E8B5EA0LL, fputs) {
        ci = &ci_fputs;
        return true;
      }
      break;
    case 3747:
      HASH_GUARD(0x6467FFB910B8BEA3LL, magickspliceimage) {
        ci = &ci_magickspliceimage;
        return true;
      }
      break;
    case 3750:
      HASH_GUARD(0x1D7B8E395613AEA6LL, dom_element_remove_attribute_ns) {
        ci = &ci_dom_element_remove_attribute_ns;
        return true;
      }
      break;
    case 3753:
      HASH_GUARD(0x308D76DB12424EA9LL, magicksetimageindex) {
        ci = &ci_magicksetimageindex;
        return true;
      }
      break;
    case 3755:
      HASH_GUARD(0x632D4FC346797EABLL, pixelgetexceptionstring) {
        ci = &ci_pixelgetexceptionstring;
        return true;
      }
      break;
    case 3758:
      HASH_GUARD(0x5772A0B8C16DAEAELL, posix_setuid) {
        ci = &ci_posix_setuid;
        return true;
      }
      break;
    case 3759:
      HASH_GUARD(0x12D83A92EFB0EEAFLL, xmlwriter_open_uri) {
        ci = &ci_xmlwriter_open_uri;
        return true;
      }
      break;
    case 3761:
      HASH_GUARD(0x33FE101882726EB1LL, proc_close) {
        ci = &ci_proc_close;
        return true;
      }
      break;
    case 3763:
      HASH_GUARD(0x7DB9D839ACE0DEB3LL, natsort) {
        ci = &ci_natsort;
        return true;
      }
      HASH_GUARD(0x7379B5B97EC2EEB3LL, hypot) {
        ci = &ci_hypot;
        return true;
      }
      break;
    case 3764:
      HASH_GUARD(0x1F936B3C5406DEB4LL, fb_set_taint) {
        ci = &ci_fb_set_taint;
        return true;
      }
      break;
    case 3767:
      HASH_GUARD(0x58B9EFA0FB35FEB7LL, stream_filter_prepend) {
        ci = &ci_stream_filter_prepend;
        return true;
      }
      break;
    case 3769:
      HASH_GUARD(0x2A483AD7A3D07EB9LL, magickgetwandsize) {
        ci = &ci_magickgetwandsize;
        return true;
      }
      break;
    case 3770:
      HASH_GUARD(0x1F5B2728DE875EBALL, magicksetimage) {
        ci = &ci_magicksetimage;
        return true;
      }
      break;
    case 3773:
      HASH_GUARD(0x31A30B274AD2DEBDLL, call_user_func_array_rpc) {
        ci = &ci_call_user_func_array_rpc;
        return true;
      }
      break;
    case 3776:
      HASH_GUARD(0x2475D7045D9DEEC0LL, magicksetimagecompression) {
        ci = &ci_magicksetimagecompression;
        return true;
      }
      HASH_GUARD(0x495316E596537EC0LL, imagefttext) {
        ci = &ci_imagefttext;
        return true;
      }
      break;
    case 3778:
      HASH_GUARD(0x4CDD0B7BF826FEC2LL, rewinddir) {
        ci = &ci_rewinddir;
        return true;
      }
      break;
    case 3780:
      HASH_GUARD(0x7052903F1B17AEC4LL, parse_str) {
        ci = &ci_parse_str;
        return true;
      }
      break;
    case 3781:
      HASH_GUARD(0x7D69B3537C353EC5LL, hphp_splfileinfo_isfile) {
        ci = &ci_hphp_splfileinfo_isfile;
        return true;
      }
      break;
    case 3783:
      HASH_GUARD(0x4FC99DC20A955EC7LL, session_module_name) {
        ci = &ci_session_module_name;
        return true;
      }
      break;
    case 3785:
      HASH_GUARD(0x58C8DCAAE5B7CEC9LL, get_cfg_var) {
        ci = &ci_get_cfg_var;
        return true;
      }
      break;
    case 3786:
      HASH_GUARD(0x08E6C1CD3AC64ECALL, hphp_splfileinfo_gettype) {
        ci = &ci_hphp_splfileinfo_gettype;
        return true;
      }
      HASH_GUARD(0x1AA83A1057BE6ECALL, mysql_field_len) {
        ci = &ci_mysql_field_len;
        return true;
      }
      break;
    case 3794:
      HASH_GUARD(0x3CCD09EC3511CED2LL, apd_stop_trace) {
        ci = &ci_apd_stop_trace;
        return true;
      }
      break;
    case 3798:
      HASH_GUARD(0x134B37520683DED6LL, imagesetbrush) {
        ci = &ci_imagesetbrush;
        return true;
      }
      break;
    case 3800:
      HASH_GUARD(0x338D9D95095D1ED8LL, magicksetimagedelay) {
        ci = &ci_magicksetimagedelay;
        return true;
      }
      break;
    case 3801:
      HASH_GUARD(0x7F802A06996BBED9LL, apd_set_browser_trace) {
        ci = &ci_apd_set_browser_trace;
        return true;
      }
      break;
    case 3802:
      HASH_GUARD(0x29E2771785CCBEDALL, magickgettextdescent) {
        ci = &ci_magickgettextdescent;
        return true;
      }
      break;
    case 3803:
      HASH_GUARD(0x16331E18B5CD8EDBLL, timezone_open) {
        ci = &ci_timezone_open;
        return true;
      }
      HASH_GUARD(0x1340509769275EDBLL, magickgetimagecompression) {
        ci = &ci_magickgetimagecompression;
        return true;
      }
      break;
    case 3808:
      HASH_GUARD(0x7A1C6E429399CEE0LL, iconv_set_encoding) {
        ci = &ci_iconv_set_encoding;
        return true;
      }
      break;
    case 3809:
      HASH_GUARD(0x528BA9796BD0FEE1LL, fb_rpc_intercept_handler) {
        ci = &ci_fb_rpc_intercept_handler;
        return true;
      }
      break;
    case 3811:
      HASH_GUARD(0x1F4AACF075E9CEE3LL, memcache_get_server_status) {
        ci = &ci_memcache_get_server_status;
        return true;
      }
      HASH_GUARD(0x28A98134BD97BEE3LL, mb_regex_encoding) {
        ci = &ci_mb_regex_encoding;
        return true;
      }
      HASH_GUARD(0x0E1368A3BDFE6EE3LL, hphp_recursiveiteratoriterator_rewind) {
        ci = &ci_hphp_recursiveiteratoriterator_rewind;
        return true;
      }
      break;
    case 3812:
      HASH_GUARD(0x5B6FF42ACB2FBEE4LL, getmyuid) {
        ci = &ci_getmyuid;
        return true;
      }
      break;
    case 3813:
      HASH_GUARD(0x367CFD20B4446EE5LL, is_array) {
        ci = &ci_is_array;
        return true;
      }
      break;
    case 3816:
      HASH_GUARD(0x6CB6650E66CE4EE8LL, magicksetimagebordercolor) {
        ci = &ci_magicksetimagebordercolor;
        return true;
      }
      HASH_GUARD(0x32B3951DFD2B9EE8LL, hphp_directoryiterator_isdot) {
        ci = &ci_hphp_directoryiterator_isdot;
        return true;
      }
      break;
    case 3819:
      HASH_GUARD(0x72882DBF2D49CEEBLL, set_magic_quotes_runtime) {
        ci = &ci_set_magic_quotes_runtime;
        return true;
      }
      break;
    case 3824:
      HASH_GUARD(0x7DFF9707F1CD9EF0LL, dangling_server_proxy_old_request) {
        ci = &ci_dangling_server_proxy_old_request;
        return true;
      }
      break;
    case 3832:
      HASH_GUARD(0x33FD10AC81146EF8LL, thrift_protocol_read_binary) {
        ci = &ci_thrift_protocol_read_binary;
        return true;
      }
      break;
    case 3833:
      HASH_GUARD(0x200FC256EB093EF9LL, gettimeofday) {
        ci = &ci_gettimeofday;
        return true;
      }
      break;
    case 3835:
      HASH_GUARD(0x6D450F078F02BEFBLL, apd_continue) {
        ci = &ci_apd_continue;
        return true;
      }
      break;
    case 3837:
      HASH_GUARD(0x0CF27A6BC84CEEFDLL, openssl_get_publickey) {
        ci = &ci_openssl_get_publickey;
        return true;
      }
      HASH_GUARD(0x283E167EB3F04EFDLL, posix_getgid) {
        ci = &ci_posix_getgid;
        return true;
      }
      break;
    case 3840:
      HASH_GUARD(0x09637D7CA2E33F00LL, fgetc) {
        ci = &ci_fgetc;
        return true;
      }
      break;
    case 3841:
      HASH_GUARD(0x66137942508EBF01LL, date_create) {
        ci = &ci_date_create;
        return true;
      }
      HASH_GUARD(0x7B6A0D7510184F01LL, mysql_fetch_assoc) {
        ci = &ci_mysql_fetch_assoc;
        return true;
      }
      break;
    case 3842:
      HASH_GUARD(0x78A02A603FA6FF02LL, magickreducenoiseimage) {
        ci = &ci_magickreducenoiseimage;
        return true;
      }
      break;
    case 3845:
      HASH_GUARD(0x6842585E79988F05LL, magickmosaicimages) {
        ci = &ci_magickmosaicimages;
        return true;
      }
      break;
    case 3846:
      HASH_GUARD(0x1D3B08AA0AF50F06LL, gettype) {
        ci = &ci_gettype;
        return true;
      }
      HASH_GUARD(0x6692475BA65A2F06LL, imagearc) {
        ci = &ci_imagearc;
        return true;
      }
      break;
    case 3851:
      HASH_GUARD(0x7756593AAC1F6F0BLL, imagecreatefromstring) {
        ci = &ci_imagecreatefromstring;
        return true;
      }
      break;
    case 3855:
      HASH_GUARD(0x61E7A36CA7FF5F0FLL, drawsetcliprule) {
        ci = &ci_drawsetcliprule;
        return true;
      }
      HASH_GUARD(0x4BD54A631F665F0FLL, drawpathcurvetosmoothabsolute) {
        ci = &ci_drawpathcurvetosmoothabsolute;
        return true;
      }
      break;
    case 3856:
      HASH_GUARD(0x700A75BF904DAF10LL, magickgetcharwidth) {
        ci = &ci_magickgetcharwidth;
        return true;
      }
      break;
    case 3858:
      HASH_GUARD(0x042492DDA48C4F12LL, gzdeflate) {
        ci = &ci_gzdeflate;
        return true;
      }
      break;
    case 3859:
      HASH_GUARD(0x3B197C0731233F13LL, dom_characterdata_substring_data) {
        ci = &ci_dom_characterdata_substring_data;
        return true;
      }
      break;
    case 3860:
      HASH_GUARD(0x04525BA2AE51EF14LL, date_sun_info) {
        ci = &ci_date_sun_info;
        return true;
      }
      break;
    case 3861:
      HASH_GUARD(0x12F09EAED9078F15LL, mysql_fetch_field) {
        ci = &ci_mysql_fetch_field;
        return true;
      }
      break;
    case 3862:
      HASH_GUARD(0x23B7D9E4EC992F16LL, stream_get_line) {
        ci = &ci_stream_get_line;
        return true;
      }
      HASH_GUARD(0x38664EFE3E0A0F16LL, json_decode) {
        ci = &ci_json_decode;
        return true;
      }
      HASH_GUARD(0x0287B907DDA3EF16LL, hphpd_get_user_commands) {
        ci = &ci_hphpd_get_user_commands;
        return true;
      }
      break;
    case 3867:
      HASH_GUARD(0x27A4633381195F1BLL, chown) {
        ci = &ci_chown;
        return true;
      }
      break;
    case 3871:
      HASH_GUARD(0x7C0C145EFE0EBF1FLL, defined) {
        ci = &ci_defined;
        return true;
      }
      break;
    case 3872:
      HASH_GUARD(0x2C4206A0BD904F20LL, hphp_splfileobject_fseek) {
        ci = &ci_hphp_splfileobject_fseek;
        return true;
      }
      break;
    case 3873:
      HASH_GUARD(0x4282496A4BF42F21LL, php_uname) {
        ci = &ci_php_uname;
        return true;
      }
      HASH_GUARD(0x77EC28645855AF21LL, magicksetcompressionquality) {
        ci = &ci_magicksetcompressionquality;
        return true;
      }
      HASH_GUARD(0x1FF5B9A4FC78BF21LL, drawsettextantialias) {
        ci = &ci_drawsettextantialias;
        return true;
      }
      break;
    case 3876:
      HASH_GUARD(0x05BD68F1D09CEF24LL, array_count_values) {
        ci = &ci_array_count_values;
        return true;
      }
      HASH_GUARD(0x5FA07E8B63BEAF24LL, mcrypt_enc_get_modes_name) {
        ci = &ci_mcrypt_enc_get_modes_name;
        return true;
      }
      break;
    case 3879:
      HASH_GUARD(0x4BAA5B688E6F6F27LL, gd_info) {
        ci = &ci_gd_info;
        return true;
      }
      break;
    case 3884:
      HASH_GUARD(0x035EFF9E1757DF2CLL, http_build_query) {
        ci = &ci_http_build_query;
        return true;
      }
      break;
    case 3890:
      HASH_GUARD(0x78257F34467BDF32LL, drawsetstrokedasharray) {
        ci = &ci_drawsetstrokedasharray;
        return true;
      }
      HASH_GUARD(0x2B66EACB77AE9F32LL, print_r) {
        ci = &ci_print_r;
        return true;
      }
      break;
    case 3897:
      HASH_GUARD(0x0D4446B2DBC8EF39LL, hphp_splfileinfo_getinode) {
        ci = &ci_hphp_splfileinfo_getinode;
        return true;
      }
      HASH_GUARD(0x3E9146C06AAEFF39LL, magicksetimagecompressionquality) {
        ci = &ci_magicksetimagecompressionquality;
        return true;
      }
      HASH_GUARD(0x496CF4113CEA8F39LL, magicksetimagefilename) {
        ci = &ci_magicksetimagefilename;
        return true;
      }
      break;
    case 3899:
      HASH_GUARD(0x7EE74F798791CF3BLL, magickedgeimage) {
        ci = &ci_magickedgeimage;
        return true;
      }
      break;
    case 3900:
      HASH_GUARD(0x41136A5F28E84F3CLL, forward_static_call_array) {
        ci = &ci_forward_static_call_array;
        return true;
      }
      break;
    case 3903:
      HASH_GUARD(0x1A9EFDD653DB8F3FLL, pcntl_wstopsig) {
        ci = &ci_pcntl_wstopsig;
        return true;
      }
      break;
    case 3906:
      HASH_GUARD(0x3B46305DA1154F42LL, drawpopclippath) {
        ci = &ci_drawpopclippath;
        return true;
      }
      break;
    case 3909:
      HASH_GUARD(0x4E36A077234B8F45LL, pixelgetblack) {
        ci = &ci_pixelgetblack;
        return true;
      }
      HASH_GUARD(0x79265AADD9A8AF45LL, mcrypt_cbc) {
        ci = &ci_mcrypt_cbc;
        return true;
      }
      HASH_GUARD(0x5D3A31AB0E326F45LL, crc32) {
        ci = &ci_crc32;
        return true;
      }
      break;
    case 3910:
      HASH_GUARD(0x079EA27F72594F46LL, gzgets) {
        ci = &ci_gzgets;
        return true;
      }
      break;
    case 3920:
      HASH_GUARD(0x7978A278AEAFAF50LL, pixelgetmagenta) {
        ci = &ci_pixelgetmagenta;
        return true;
      }
      break;
    case 3925:
      HASH_GUARD(0x49D986274B1C5F55LL, collator_asort) {
        ci = &ci_collator_asort;
        return true;
      }
      break;
    case 3926:
      HASH_GUARD(0x621590803EC88F56LL, imageline) {
        ci = &ci_imageline;
        return true;
      }
      break;
    case 3928:
      HASH_GUARD(0x0551AAE8F1A6FF58LL, magicklevelimage) {
        ci = &ci_magicklevelimage;
        return true;
      }
      break;
    case 3929:
      HASH_GUARD(0x38246B6BDE246F59LL, magickgetimagedispose) {
        ci = &ci_magickgetimagedispose;
        return true;
      }
      break;
    case 3931:
      HASH_GUARD(0x24F698A8A4B5AF5BLL, imagecolordeallocate) {
        ci = &ci_imagecolordeallocate;
        return true;
      }
      HASH_GUARD(0x76418F884500DF5BLL, stream_socket_enable_crypto) {
        ci = &ci_stream_socket_enable_crypto;
        return true;
      }
      break;
    case 3933:
      HASH_GUARD(0x07FF92CF46DDFF5DLL, imagepsfreefont) {
        ci = &ci_imagepsfreefont;
        return true;
      }
      break;
    case 3935:
      HASH_GUARD(0x703D339DD44E8F5FLL, dom_element_get_elements_by_tag_name) {
        ci = &ci_dom_element_get_elements_by_tag_name;
        return true;
      }
      break;
    case 3936:
      HASH_GUARD(0x4F1D2858AD31AF60LL, imagecreatefromgd) {
        ci = &ci_imagecreatefromgd;
        return true;
      }
      break;
    case 3939:
      HASH_GUARD(0x1FFD204252F60F63LL, magicksetimageprofile) {
        ci = &ci_magicksetimageprofile;
        return true;
      }
      break;
    case 3940:
      HASH_GUARD(0x41EF51E62AD3DF64LL, pagelet_server_is_enabled) {
        ci = &ci_pagelet_server_is_enabled;
        return true;
      }
      HASH_GUARD(0x280051555A21DF64LL, rename) {
        ci = &ci_rename;
        return true;
      }
      break;
    case 3942:
      HASH_GUARD(0x6FFF1304EA444F66LL, drawsetstrokemiterlimit) {
        ci = &ci_drawsetstrokemiterlimit;
        return true;
      }
      break;
    case 3943:
      HASH_GUARD(0x319407AC92912F67LL, ereg) {
        ci = &ci_ereg;
        return true;
      }
      break;
    case 3946:
      HASH_GUARD(0x1670096FDE27AF6ALL, rewind) {
        ci = &ci_rewind;
        return true;
      }
      break;
    case 3947:
      HASH_GUARD(0x56EF59D6CB0A5F6BLL, dom_document_save_html_file) {
        ci = &ci_dom_document_save_html_file;
        return true;
      }
      break;
    case 3948:
      HASH_GUARD(0x23D5E9E53D11BF6CLL, gmdate) {
        ci = &ci_gmdate;
        return true;
      }
      break;
    case 3950:
      HASH_GUARD(0x3A56371CDDEA0F6ELL, gzgetc) {
        ci = &ci_gzgetc;
        return true;
      }
      break;
    case 3951:
      HASH_GUARD(0x42C4EC9D9F782F6FLL, htmlentities) {
        ci = &ci_htmlentities;
        return true;
      }
      break;
    case 3952:
      HASH_GUARD(0x68C257B62A36EF70LL, magicksetimagebackgroundcolor) {
        ci = &ci_magicksetimagebackgroundcolor;
        return true;
      }
      HASH_GUARD(0x71557D108E5C0F70LL, xml_set_object) {
        ci = &ci_xml_set_object;
        return true;
      }
      break;
    case 3954:
      HASH_GUARD(0x4B22EF06BAA83F72LL, version_compare) {
        ci = &ci_version_compare;
        return true;
      }
      break;
    case 3956:
      HASH_GUARD(0x18BC9BF6D1E3CF74LL, magickpreviewimages) {
        ci = &ci_magickpreviewimages;
        return true;
      }
      break;
    case 3961:
      HASH_GUARD(0x4BE9D91DD8624F79LL, money_format) {
        ci = &ci_money_format;
        return true;
      }
      break;
    case 3962:
      HASH_GUARD(0x7B0E6DB649084F7ALL, clearstatcache) {
        ci = &ci_clearstatcache;
        return true;
      }
      break;
    case 3966:
      HASH_GUARD(0x7064BEBF508F3F7ELL, socket_read) {
        ci = &ci_socket_read;
        return true;
      }
      break;
    case 3968:
      HASH_GUARD(0x63F18DE0DB807F80LL, magickqueryfonts) {
        ci = &ci_magickqueryfonts;
        return true;
      }
      break;
    case 3972:
      HASH_GUARD(0x14402B01D00E9F84LL, magicksteganoimage) {
        ci = &ci_magicksteganoimage;
        return true;
      }
      break;
    case 3973:
      HASH_GUARD(0x7EF68B9A55222F85LL, wandgetexceptionstring) {
        ci = &ci_wandgetexceptionstring;
        return true;
      }
      break;
    case 3974:
      HASH_GUARD(0x44CE4DB1CE7E9F86LL, flock) {
        ci = &ci_flock;
        return true;
      }
      break;
    case 3977:
      HASH_GUARD(0x13F52A829BAC0F89LL, timezone_identifiers_list) {
        ci = &ci_timezone_identifiers_list;
        return true;
      }
      break;
    case 3979:
      HASH_GUARD(0x2755DD4112AA5F8BLL, magicksampleimage) {
        ci = &ci_magicksampleimage;
        return true;
      }
      HASH_GUARD(0x3703D22147C24F8BLL, pixelsetcyan) {
        ci = &ci_pixelsetcyan;
        return true;
      }
      break;
    case 3982:
      HASH_GUARD(0x7A8F1104B0CCDF8ELL, phpcredits) {
        ci = &ci_phpcredits;
        return true;
      }
      break;
    case 3983:
      HASH_GUARD(0x4A6C46DC7FE29F8FLL, hphp_recursivedirectoryiterator_getchildren) {
        ci = &ci_hphp_recursivedirectoryiterator_getchildren;
        return true;
      }
      break;
    case 3985:
      HASH_GUARD(0x78463112BE739F91LL, connection_timeout) {
        ci = &ci_connection_timeout;
        return true;
      }
      break;
    case 3986:
      HASH_GUARD(0x288D61E7DE28AF92LL, ucwords) {
        ci = &ci_ucwords;
        return true;
      }
      break;
    case 3988:
      HASH_GUARD(0x76B9D87BC7F02F94LL, preg_match) {
        ci = &ci_preg_match;
        return true;
      }
      break;
    case 3989:
      HASH_GUARD(0x40D620CBA0D41F95LL, opendir) {
        ci = &ci_opendir;
        return true;
      }
      break;
    case 3991:
      HASH_GUARD(0x35117886C885DF97LL, hphp_recursivedirectoryiterator_getsubpathname) {
        ci = &ci_hphp_recursivedirectoryiterator_getsubpathname;
        return true;
      }
      HASH_GUARD(0x6F9651265C096F97LL, magickreadimages) {
        ci = &ci_magickreadimages;
        return true;
      }
      break;
    case 3992:
      HASH_GUARD(0x0293F60B46511F98LL, drawsetfontstretch) {
        ci = &ci_drawsetfontstretch;
        return true;
      }
      HASH_GUARD(0x66F1F0DB16C82F98LL, imagesavealpha) {
        ci = &ci_imagesavealpha;
        return true;
      }
      break;
    case 3994:
      HASH_GUARD(0x2B7CAC006AF27F9ALL, fflush) {
        ci = &ci_fflush;
        return true;
      }
      break;
    case 3995:
      HASH_GUARD(0x44244ECFB9F76F9BLL, dom_document_create_element_ns) {
        ci = &ci_dom_document_create_element_ns;
        return true;
      }
      break;
    case 3997:
      HASH_GUARD(0x0AD6DE8829773F9DLL, apc_compile_file) {
        ci = &ci_apc_compile_file;
        return true;
      }
      break;
    case 4004:
      HASH_GUARD(0x0E7E9AA21AE99FA4LL, hphp_recursiveiteratoriterator_current) {
        ci = &ci_hphp_recursiveiteratoriterator_current;
        return true;
      }
      break;
    case 4006:
      HASH_GUARD(0x0DEEA8C3E3A47FA6LL, read_exif_data) {
        ci = &ci_read_exif_data;
        return true;
      }
      break;
    case 4014:
      HASH_GUARD(0x64D269A505D51FAELL, array_map) {
        ci = &ci_array_map;
        return true;
      }
      break;
    case 4015:
      HASH_GUARD(0x03979AACDBB24FAFLL, mailparse_msg_get_part) {
        ci = &ci_mailparse_msg_get_part;
        return true;
      }
      break;
    case 4016:
      HASH_GUARD(0x4A0B5F4676578FB0LL, imagecolorresolvealpha) {
        ci = &ci_imagecolorresolvealpha;
        return true;
      }
      break;
    case 4017:
      HASH_GUARD(0x0F78ECF42C30DFB1LL, array_chunk) {
        ci = &ci_array_chunk;
        return true;
      }
      break;
    case 4020:
      HASH_GUARD(0x3900FDF1C97BEFB4LL, drawrotate) {
        ci = &ci_drawrotate;
        return true;
      }
      break;
    case 4022:
      HASH_GUARD(0x56C0CCB57BB6EFB6LL, magicksetimageunits) {
        ci = &ci_magicksetimageunits;
        return true;
      }
      HASH_GUARD(0x2B451EF5D52C4FB6LL, array_diff) {
        ci = &ci_array_diff;
        return true;
      }
      break;
    case 4023:
      HASH_GUARD(0x6465CD999F4C5FB7LL, hphp_invoke_method) {
        ci = &ci_hphp_invoke_method;
        return true;
      }
      break;
    case 4024:
      HASH_GUARD(0x6DB2DB341ECF3FB8LL, file_exists) {
        ci = &ci_file_exists;
        return true;
      }
      break;
    case 4026:
      HASH_GUARD(0x0664323CB1CC2FBALL, imagecolorset) {
        ci = &ci_imagecolorset;
        return true;
      }
      break;
    case 4031:
      HASH_GUARD(0x70B38AB9EAE16FBFLL, ini_set) {
        ci = &ci_ini_set;
        return true;
      }
      break;
    case 4033:
      HASH_GUARD(0x3FF9AAFF85DDDFC1LL, class_parents) {
        ci = &ci_class_parents;
        return true;
      }
      break;
    case 4034:
      HASH_GUARD(0x6CA22E62D4762FC2LL, magickpainttransparentimage) {
        ci = &ci_magickpainttransparentimage;
        return true;
      }
      HASH_GUARD(0x460470C490FAFFC2LL, dom_node_normalize) {
        ci = &ci_dom_node_normalize;
        return true;
      }
      break;
    case 4037:
      HASH_GUARD(0x38498DD4C28D0FC5LL, hphp_splfileinfo_getatime) {
        ci = &ci_hphp_splfileinfo_getatime;
        return true;
      }
      break;
    case 4043:
      HASH_GUARD(0x38237A4515F42FCBLL, array_pad) {
        ci = &ci_array_pad;
        return true;
      }
      break;
    case 4045:
      HASH_GUARD(0x474566F3A2BE0FCDLL, mcrypt_enc_is_block_algorithm) {
        ci = &ci_mcrypt_enc_is_block_algorithm;
        return true;
      }
      break;
    case 4046:
      HASH_GUARD(0x042193C97C65FFCELL, magickwaveimage) {
        ci = &ci_magickwaveimage;
        return true;
      }
      break;
    case 4047:
      HASH_GUARD(0x3A3CFC1F001A6FCFLL, magickreadimagefile) {
        ci = &ci_magickreadimagefile;
        return true;
      }
      break;
    case 4048:
      HASH_GUARD(0x21104CCA2942AFD0LL, fb_const_fetch) {
        ci = &ci_fb_const_fetch;
        return true;
      }
      HASH_GUARD(0x2EAA47FA6C3FEFD0LL, drawgetstrokealpha) {
        ci = &ci_drawgetstrokealpha;
        return true;
      }
      HASH_GUARD(0x53DB5D0490C51FD0LL, xhprof_sample_disable) {
        ci = &ci_xhprof_sample_disable;
        return true;
      }
      break;
    case 4052:
      HASH_GUARD(0x4970B72A182E4FD4LL, readdir) {
        ci = &ci_readdir;
        return true;
      }
      break;
    case 4053:
      HASH_GUARD(0x751283FE764CAFD5LL, mysql_select_db) {
        ci = &ci_mysql_select_db;
        return true;
      }
      break;
    case 4054:
      HASH_GUARD(0x7FC00035D14B9FD6LL, apc_delete_file) {
        ci = &ci_apc_delete_file;
        return true;
      }
      break;
    case 4056:
      HASH_GUARD(0x4234F2B59531FFD8LL, posix_getlogin) {
        ci = &ci_posix_getlogin;
        return true;
      }
      break;
    case 4061:
      HASH_GUARD(0x4EDEDA4278CD3FDDLL, magickchopimage) {
        ci = &ci_magickchopimage;
        return true;
      }
      break;
    case 4062:
      HASH_GUARD(0x7F5FC3CAF8CE9FDELL, gzcompress) {
        ci = &ci_gzcompress;
        return true;
      }
      HASH_GUARD(0x72925D2DF7E61FDELL, drawpathcurvetoquadraticbeziersmoothrelative) {
        ci = &ci_drawpathcurvetoquadraticbeziersmoothrelative;
        return true;
      }
      break;
    case 4071:
      HASH_GUARD(0x217067889854CFE7LL, xmlwriter_start_dtd) {
        ci = &ci_xmlwriter_start_dtd;
        return true;
      }
      break;
    case 4072:
      HASH_GUARD(0x4D7AEC41CFD73FE8LL, hphp_recursivedirectoryiterator_getsubpath) {
        ci = &ci_hphp_recursivedirectoryiterator_getsubpath;
        return true;
      }
      break;
    case 4075:
      HASH_GUARD(0x67D1EE05DFE71FEBLL, hphp_splfileobject_getcvscontrol) {
        ci = &ci_hphp_splfileobject_getcvscontrol;
        return true;
      }
      break;
    case 4079:
      HASH_GUARD(0x00EEEE9C6CEA5FEFLL, xmlwriter_write_element_ns) {
        ci = &ci_xmlwriter_write_element_ns;
        return true;
      }
      break;
    case 4080:
      HASH_GUARD(0x1189B7C4F4874FF0LL, php_check_syntax) {
        ci = &ci_php_check_syntax;
        return true;
      }
      break;
    case 4085:
      HASH_GUARD(0x191ECE88E06E6FF5LL, dom_node_is_supported) {
        ci = &ci_dom_node_is_supported;
        return true;
      }
      break;
    case 4086:
      HASH_GUARD(0x25FCE64E12505FF6LL, magicksetimagerenderingintent) {
        ci = &ci_magicksetimagerenderingintent;
        return true;
      }
      break;
    case 4087:
      HASH_GUARD(0x7883232CD1A7CFF7LL, dom_node_is_same_node) {
        ci = &ci_dom_node_is_same_node;
        return true;
      }
      break;
    case 4090:
      HASH_GUARD(0x13EE24AF67113FFALL, ob_end_flush) {
        ci = &ci_ob_end_flush;
        return true;
      }
      break;
    case 4091:
      HASH_GUARD(0x63BE4CEF1FC47FFBLL, imagefill) {
        ci = &ci_imagefill;
        return true;
      }
      break;
    case 4094:
      HASH_GUARD(0x32F8747E480CCFFELL, connection_status) {
        ci = &ci_connection_status;
        return true;
      }
      break;
    default:
      break;
  }
  return false;
}

///////////////////////////////////////////////////////////////////////////////
}
