// @generated by Thrift for thrift/compiler/test/fixtures/basic-annotations/src/module.thrift
// This file is probably not the place you want to edit!

//! Server definitions for `module`.

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, unused_imports, clippy::all)]

#[doc(inline)]
pub use :: as types;

pub mod errors {
    #[doc(inline)]
    pub use ::::services::my_service;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::my_service::*;

    #[doc(inline)]
    pub use ::::services::my_service_prio_parent;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::my_service_prio_parent::*;

    #[doc(inline)]
    pub use ::::services::my_service_prio_child;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::my_service_prio_child::*;

    #[doc(inline)]
    pub use ::::services::bad_service;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::bad_service::*;
    #[doc(inline)]
    pub use ::::services::bad_interaction;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::bad_interaction::*;

    #[doc(inline)]
    pub use ::::services::foo_bar_baz_service;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::foo_bar_baz_service::*;
}

pub(crate) use crate as server;
pub(crate) use ::::services;


#[::async_trait::async_trait]
pub trait MyService: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service::PingExn> {
        ::std::result::Result::Err(crate::services::my_service::PingExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyService",
                "ping",
            ),
        ))
    }
    async fn getRandomData(
        &self,
    ) -> ::std::result::Result<::std::string::String, crate::services::my_service::GetRandomDataExn> {
        ::std::result::Result::Err(crate::services::my_service::GetRandomDataExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyService",
                "getRandomData",
            ),
        ))
    }
    async fn hasDataById(
        &self,
        _id: ::std::primitive::i64,
    ) -> ::std::result::Result<::std::primitive::bool, crate::services::my_service::HasDataByIdExn> {
        ::std::result::Result::Err(crate::services::my_service::HasDataByIdExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyService",
                "hasDataById",
            ),
        ))
    }
    async fn getDataById(
        &self,
        _id: ::std::primitive::i64,
    ) -> ::std::result::Result<::std::string::String, crate::services::my_service::GetDataByIdExn> {
        ::std::result::Result::Err(crate::services::my_service::GetDataByIdExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyService",
                "getDataById",
            ),
        ))
    }
    async fn putDataById(
        &self,
        _id: ::std::primitive::i64,
        _data: ::std::string::String,
    ) -> ::std::result::Result<(), crate::services::my_service::PutDataByIdExn> {
        ::std::result::Result::Err(crate::services::my_service::PutDataByIdExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyService",
                "putDataById",
            ),
        ))
    }
    async fn lobDataById(
        &self,
        _id: ::std::primitive::i64,
        _data: ::std::string::String,
    ) -> ::std::result::Result<(), crate::services::my_service::LobDataByIdExn> {
        ::std::result::Result::Err(crate::services::my_service::LobDataByIdExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyService",
                "lobDataById",
            ),
        ))
    }
    async fn doNothing(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service::DoNothingExn> {
        ::std::result::Result::Err(crate::services::my_service::DoNothingExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyService",
                "doNothing",
            ),
        ))
    }
}

#[::async_trait::async_trait]
impl<T> MyService for ::std::boxed::Box<T>
where
    T: MyService + Send + Sync + ?Sized,
{
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service::PingExn> {
        (**self).ping(
        ).await
    }
    async fn getRandomData(
        &self,
    ) -> ::std::result::Result<::std::string::String, crate::services::my_service::GetRandomDataExn> {
        (**self).getRandomData(
        ).await
    }
    async fn hasDataById(
        &self,
        id: ::std::primitive::i64,
    ) -> ::std::result::Result<::std::primitive::bool, crate::services::my_service::HasDataByIdExn> {
        (**self).hasDataById(
            id,
        ).await
    }
    async fn getDataById(
        &self,
        id: ::std::primitive::i64,
    ) -> ::std::result::Result<::std::string::String, crate::services::my_service::GetDataByIdExn> {
        (**self).getDataById(
            id,
        ).await
    }
    async fn putDataById(
        &self,
        id: ::std::primitive::i64,
        data: ::std::string::String,
    ) -> ::std::result::Result<(), crate::services::my_service::PutDataByIdExn> {
        (**self).putDataById(
            id,
            data,
        ).await
    }
    async fn lobDataById(
        &self,
        id: ::std::primitive::i64,
        data: ::std::string::String,
    ) -> ::std::result::Result<(), crate::services::my_service::LobDataByIdExn> {
        (**self).lobDataById(
            id,
            data,
        ).await
    }
    async fn doNothing(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service::DoNothingExn> {
        (**self).doNothing(
        ).await
    }
}

#[::async_trait::async_trait]
impl<T> MyService for ::std::sync::Arc<T>
where
    T: MyService + Send + Sync + ?Sized,
{
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service::PingExn> {
        (**self).ping(
        ).await
    }
    async fn getRandomData(
        &self,
    ) -> ::std::result::Result<::std::string::String, crate::services::my_service::GetRandomDataExn> {
        (**self).getRandomData(
        ).await
    }
    async fn hasDataById(
        &self,
        id: ::std::primitive::i64,
    ) -> ::std::result::Result<::std::primitive::bool, crate::services::my_service::HasDataByIdExn> {
        (**self).hasDataById(
            id,
        ).await
    }
    async fn getDataById(
        &self,
        id: ::std::primitive::i64,
    ) -> ::std::result::Result<::std::string::String, crate::services::my_service::GetDataByIdExn> {
        (**self).getDataById(
            id,
        ).await
    }
    async fn putDataById(
        &self,
        id: ::std::primitive::i64,
        data: ::std::string::String,
    ) -> ::std::result::Result<(), crate::services::my_service::PutDataByIdExn> {
        (**self).putDataById(
            id,
            data,
        ).await
    }
    async fn lobDataById(
        &self,
        id: ::std::primitive::i64,
        data: ::std::string::String,
    ) -> ::std::result::Result<(), crate::services::my_service::LobDataByIdExn> {
        (**self).lobDataById(
            id,
            data,
        ).await
    }
    async fn doNothing(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service::DoNothingExn> {
        (**self).doNothing(
        ).await
    }
}


/// Processor for MyService's methods.
#[derive(Clone, Debug)]
pub struct MyServiceProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}

struct Args_MyService_ping {
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyService_ping {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyService.ping"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

struct Args_MyService_getRandomData {
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyService_getRandomData {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyService.getRandomData"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

struct Args_MyService_hasDataById {
    id: ::std::primitive::i64,
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyService_hasDataById {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyService.hasDataById"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 1),
        ];
        let mut field_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MyService.hasDataById", "id"))?,
        })
    }
}

struct Args_MyService_getDataById {
    id: ::std::primitive::i64,
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyService_getDataById {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyService.getDataById"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 1),
        ];
        let mut field_id = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MyService.getDataById", "id"))?,
        })
    }
}

struct Args_MyService_putDataById {
    id: ::std::primitive::i64,
    data: ::std::string::String,
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyService_putDataById {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyService.putDataById"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 1),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_data = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MyService.putDataById", "id"))?,
            data: field_data.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MyService.putDataById", "data"))?,
        })
    }
}

struct Args_MyService_lobDataById {
    id: ::std::primitive::i64,
    data: ::std::string::String,
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyService_lobDataById {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyService.lobDataById"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data", ::fbthrift::TType::String, 2),
            ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 1),
        ];
        let mut field_id = ::std::option::Option::None;
        let mut field_data = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I64, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 2) => field_data = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            id: field_id.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MyService.lobDataById", "id"))?,
            data: field_data.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MyService.lobDataById", "data"))?,
        })
    }
}

struct Args_MyService_doNothing {
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyService_doNothing {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyService.doNothing"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


impl<P, H, R, RS> MyServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: MyService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyService.ping"))]
    async fn handle_ping<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "MyService";
            METHOD_NAME = "ping";
            SERVICE_METHOD_NAME = "MyService.ping";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyService_ping = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.ping(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyService.ping", "success");
                crate::services::my_service::PingExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_service::PingExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "ping",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "MyService.ping", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.ping", exn);
                ::tracing::error!(method = "MyService.ping", panic = ?aexn);
                crate::services::my_service::PingExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "ping",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyService.getRandomData"))]
    async fn handle_getRandomData<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "MyService";
            METHOD_NAME = "getRandomData";
            SERVICE_METHOD_NAME = "MyService.getRandomData";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyService_getRandomData = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.getRandomData(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyService.getRandomData", "success");
                crate::services::my_service::GetRandomDataExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_service::GetRandomDataExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "getRandomData",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "MyService.getRandomData", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.getRandomData", exn);
                ::tracing::error!(method = "MyService.getRandomData", panic = ?aexn);
                crate::services::my_service::GetRandomDataExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "getRandomData",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyService.hasDataById"))]
    async fn handle_hasDataById<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "MyService";
            METHOD_NAME = "hasDataById";
            SERVICE_METHOD_NAME = "MyService.hasDataById";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyService_hasDataById = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.hasDataById(
                _args.id,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyService.hasDataById", "success");
                crate::services::my_service::HasDataByIdExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_service::HasDataByIdExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "hasDataById",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "MyService.hasDataById", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.hasDataById", exn);
                ::tracing::error!(method = "MyService.hasDataById", panic = ?aexn);
                crate::services::my_service::HasDataByIdExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "hasDataById",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyService.getDataById"))]
    async fn handle_getDataById<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "MyService";
            METHOD_NAME = "getDataById";
            SERVICE_METHOD_NAME = "MyService.getDataById";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyService_getDataById = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.getDataById(
                _args.id,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyService.getDataById", "success");
                crate::services::my_service::GetDataByIdExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_service::GetDataByIdExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "getDataById",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "MyService.getDataById", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.getDataById", exn);
                ::tracing::error!(method = "MyService.getDataById", panic = ?aexn);
                crate::services::my_service::GetDataByIdExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "getDataById",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyService.putDataById"))]
    async fn handle_putDataById<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "MyService";
            METHOD_NAME = "putDataById";
            SERVICE_METHOD_NAME = "MyService.putDataById";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyService_putDataById = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.putDataById(
                _args.id,
                _args.data,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyService.putDataById", "success");
                crate::services::my_service::PutDataByIdExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_service::PutDataByIdExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "putDataById",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "MyService.putDataById", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.putDataById", exn);
                ::tracing::error!(method = "MyService.putDataById", panic = ?aexn);
                crate::services::my_service::PutDataByIdExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "putDataById",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyService.lobDataById"))]
    async fn handle_lobDataById<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "MyService";
            METHOD_NAME = "lobDataById";
            SERVICE_METHOD_NAME = "MyService.lobDataById";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyService_lobDataById = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.lobDataById(
                _args.id,
                _args.data,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyService.lobDataById", "success");
                crate::services::my_service::LobDataByIdExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_service::LobDataByIdExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "lobDataById",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "MyService.lobDataById", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.lobDataById", exn);
                ::tracing::error!(method = "MyService.lobDataById", panic = ?aexn);
                crate::services::my_service::LobDataByIdExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "lobDataById",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyService.doNothing"))]
    async fn handle_doNothing<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "MyService";
            METHOD_NAME = "doNothing";
            SERVICE_METHOD_NAME = "MyService.doNothing";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyService_doNothing = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.doNothing(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyService.doNothing", "success");
                crate::services::my_service::DoNothingExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_service::DoNothingExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "doNothing",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "MyService.doNothing", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.doNothing", exn);
                ::tracing::error!(method = "MyService.doNothing", panic = ?aexn);
                crate::services::my_service::DoNothingExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "doNothing",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MyServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: MyService,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"ping" => ::std::result::Result::Ok(0usize),
            b"getRandomData" => ::std::result::Result::Ok(1usize),
            b"hasDataById" => ::std::result::Result::Ok(2usize),
            b"getDataById" => ::std::result::Result::Ok(3usize),
            b"putDataById" => ::std::result::Result::Ok(4usize),
            b"lobDataById" => ::std::result::Result::Ok(5usize),
            b"doNothing" => ::std::result::Result::Ok(6usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            0usize => {
                self.handle_ping(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            1usize => {
                self.handle_getRandomData(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            2usize => {
                self.handle_hasDataById(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            3usize => {
                self.handle_getDataById(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            4usize => {
                self.handle_putDataById(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            5usize => {
                self.handle_lobDataById(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            6usize => {
                self.handle_doNothing(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "MyServiceProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            bad => panic!(
                "{}: unexpected method idx {}",
                "MyServiceProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MyServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: MyService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "MyService"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        Ok(())
    }

    fn create_interaction(
        &self,
        name: &str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_names(&self) -> &'static [&'static str] {
        &[
                // from MyService
                "ping",
                "getRandomData",
                "hasDataById",
                "getDataById",
                "putDataById",
                "lobDataById",
                "doNothing",
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a MyService service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_MyService_server<F, H, R, RS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: MyService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(MyServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(MyServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
        }
        bad => {
            ::tracing::error!(method = "MyService.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}

#[::async_trait::async_trait]
pub trait MyServicePrioParent: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service_prio_parent::PingExn> {
        ::std::result::Result::Err(crate::services::my_service_prio_parent::PingExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyServicePrioParent",
                "ping",
            ),
        ))
    }
    async fn pong(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service_prio_parent::PongExn> {
        ::std::result::Result::Err(crate::services::my_service_prio_parent::PongExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyServicePrioParent",
                "pong",
            ),
        ))
    }
}

#[::async_trait::async_trait]
impl<T> MyServicePrioParent for ::std::boxed::Box<T>
where
    T: MyServicePrioParent + Send + Sync + ?Sized,
{
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service_prio_parent::PingExn> {
        (**self).ping(
        ).await
    }
    async fn pong(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service_prio_parent::PongExn> {
        (**self).pong(
        ).await
    }
}

#[::async_trait::async_trait]
impl<T> MyServicePrioParent for ::std::sync::Arc<T>
where
    T: MyServicePrioParent + Send + Sync + ?Sized,
{
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service_prio_parent::PingExn> {
        (**self).ping(
        ).await
    }
    async fn pong(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service_prio_parent::PongExn> {
        (**self).pong(
        ).await
    }
}


/// Processor for MyServicePrioParent's methods.
#[derive(Clone, Debug)]
pub struct MyServicePrioParentProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}

struct Args_MyServicePrioParent_ping {
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyServicePrioParent_ping {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyServicePrioParent.ping"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

struct Args_MyServicePrioParent_pong {
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyServicePrioParent_pong {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyServicePrioParent.pong"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


impl<P, H, R, RS> MyServicePrioParentProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: MyServicePrioParent,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyServicePrioParent.ping"))]
    async fn handle_ping<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "MyServicePrioParent";
            METHOD_NAME = "ping";
            SERVICE_METHOD_NAME = "MyServicePrioParent.ping";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyServicePrioParent_ping = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.ping(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyServicePrioParent.ping", "success");
                crate::services::my_service_prio_parent::PingExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_service_prio_parent::PingExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "ping",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "MyServicePrioParent.ping", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyServicePrioParent.ping", exn);
                ::tracing::error!(method = "MyServicePrioParent.ping", panic = ?aexn);
                crate::services::my_service_prio_parent::PingExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "ping",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyServicePrioParent.pong"))]
    async fn handle_pong<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "MyServicePrioParent";
            METHOD_NAME = "pong";
            SERVICE_METHOD_NAME = "MyServicePrioParent.pong";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyServicePrioParent_pong = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.pong(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyServicePrioParent.pong", "success");
                crate::services::my_service_prio_parent::PongExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_service_prio_parent::PongExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "pong",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "MyServicePrioParent.pong", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyServicePrioParent.pong", exn);
                ::tracing::error!(method = "MyServicePrioParent.pong", panic = ?aexn);
                crate::services::my_service_prio_parent::PongExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "pong",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MyServicePrioParentProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: MyServicePrioParent,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"ping" => ::std::result::Result::Ok(0usize),
            b"pong" => ::std::result::Result::Ok(1usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            0usize => {
                self.handle_ping(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            1usize => {
                self.handle_pong(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "MyServicePrioParentProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            bad => panic!(
                "{}: unexpected method idx {}",
                "MyServicePrioParentProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MyServicePrioParentProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: MyServicePrioParent,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "MyServicePrioParent"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        Ok(())
    }

    fn create_interaction(
        &self,
        name: &str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_names(&self) -> &'static [&'static str] {
        &[
                // from MyServicePrioParent
                "ping",
                "pong",
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a MyServicePrioParent service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_MyServicePrioParent_server<F, H, R, RS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: MyServicePrioParent,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(MyServicePrioParentProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(MyServicePrioParentProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
        }
        bad => {
            ::tracing::error!(method = "MyServicePrioParent.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}

#[::async_trait::async_trait]
pub trait MyServicePrioChild: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn pang(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service_prio_child::PangExn> {
        ::std::result::Result::Err(crate::services::my_service_prio_child::PangExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyServicePrioChild",
                "pang",
            ),
        ))
    }
}

#[::async_trait::async_trait]
impl<T> MyServicePrioChild for ::std::boxed::Box<T>
where
    T: MyServicePrioChild + Send + Sync + ?Sized,
{
    async fn pang(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service_prio_child::PangExn> {
        (**self).pang(
        ).await
    }
}

#[::async_trait::async_trait]
impl<T> MyServicePrioChild for ::std::sync::Arc<T>
where
    T: MyServicePrioChild + Send + Sync + ?Sized,
{
    async fn pang(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service_prio_child::PangExn> {
        (**self).pang(
        ).await
    }
}


/// Processor for MyServicePrioChild's methods.
#[derive(Clone, Debug)]
pub struct MyServicePrioChildProcessor<P, H, R, RS, SS> {
    service: H,
    supa: SS,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}

struct Args_MyServicePrioChild_pang {
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyServicePrioChild_pang {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyServicePrioChild.pang"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


impl<P, H, R, RS, SS> MyServicePrioChildProcessor<P, H, R, RS, SS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: MyServicePrioChild,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    SS: ::fbthrift::ThriftService<P::Frame>,
    SS::Handler: crate::MyServicePrioParent
{
    pub fn new(service: H, supa: SS) -> Self {
        Self {
            service,
            supa,
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyServicePrioChild.pang"))]
    async fn handle_pang<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "MyServicePrioChild";
            METHOD_NAME = "pang";
            SERVICE_METHOD_NAME = "MyServicePrioChild.pang";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyServicePrioChild_pang = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.pang(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyServicePrioChild.pang", "success");
                crate::services::my_service_prio_child::PangExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_service_prio_child::PangExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "pang",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "MyServicePrioChild.pang", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyServicePrioChild.pang", exn);
                ::tracing::error!(method = "MyServicePrioChild.pang", panic = ?aexn);
                crate::services::my_service_prio_child::PangExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "pang",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS, SS> ::fbthrift::ServiceProcessor<P> for MyServicePrioChildProcessor<P, H, R, RS, SS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: MyServicePrioChild,
    SS: ::fbthrift::ThriftService<P::Frame>,
    SS::Handler: crate::MyServicePrioParent,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"pang" => ::std::result::Result::Ok(0usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            0usize => {
                self.handle_pang(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "MyServicePrioChildProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            bad => panic!(
                "{}: unexpected method idx {}",
                "MyServicePrioChildProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS, SS> ::fbthrift::ThriftService<P::Frame> for MyServicePrioChildProcessor<P, H, R, RS, SS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: MyServicePrioChild,
    SS: ::fbthrift::ThriftService<P::Frame, RequestContext = R, ReplyState = RS>,
    SS::Handler: crate::MyServicePrioParent,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "MyServicePrioChild"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        Ok(())
    }

    fn create_interaction(
        &self,
        name: &str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_names(&self) -> &'static [&'static str] {
        &[
                // from MyServicePrioParent
                "ping",
                "pong",
                // from MyServicePrioChild
                "pang",
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a MyServicePrioChild service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_MyServicePrioChild_server<F, H, R, RS, SMAKE, SS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
    supa: SMAKE,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: MyServicePrioChild,
    SMAKE: ::std::ops::FnOnce(::fbthrift::ProtocolID) -> ::std::result::Result<SS, ::fbthrift::ApplicationException>,
    SS: ::fbthrift::ThriftService<F, RequestContext = R, ReplyState = RS>,
    SS::Handler: crate::MyServicePrioParent,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(MyServicePrioChildProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS, SS>::new(handler, supa(proto)?)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(MyServicePrioChildProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS, SS>::new(handler, supa(proto)?)))
        }
        bad => {
            ::tracing::error!(method = "MyServicePrioChild.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}

#[::async_trait::async_trait]
pub trait BadInteraction: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::bad_interaction::FooExn> {
        ::std::result::Result::Err(crate::services::bad_interaction::FooExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "BadInteraction",
                "foo",
            ),
        ))
    }
    async fn on_termination(&self) {}
}

#[::async_trait::async_trait]
impl<T> BadInteraction for ::std::boxed::Box<T>
where
    T: BadInteraction + Send + Sync + ?Sized,
{
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::bad_interaction::FooExn> {
        (**self).foo(
        ).await
    }
    async fn on_termination(&self) {
        (**self).on_termination().await;
    }
}

#[::async_trait::async_trait]
impl<T> BadInteraction for ::std::sync::Arc<T>
where
    T: BadInteraction + Send + Sync + ?Sized,
{
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::bad_interaction::FooExn> {
        (**self).foo(
        ).await
    }
    async fn on_termination(&self) {
        (**self).on_termination().await;
    }
}


/// Processor for BadInteraction's methods.
#[derive(Clone, Debug)]
pub struct BadInteractionProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}

struct Args_BadInteraction_foo {
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_BadInteraction_foo {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "BadInteraction.foo"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


impl<P, H, R, RS> BadInteractionProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: BadInteraction,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "BadInteraction.foo"))]
    async fn handle_foo<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "BadService";
            METHOD_NAME = "BadInteraction.foo";
            SERVICE_METHOD_NAME = "BadService.BadInteraction.foo";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_BadInteraction_foo = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.foo(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "BadInteraction.foo", "success");
                crate::services::bad_interaction::FooExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::bad_interaction::FooExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "foo",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "BadInteraction.foo", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("BadInteraction.foo", exn);
                ::tracing::error!(method = "BadInteraction.foo", panic = ?aexn);
                crate::services::bad_interaction::FooExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "foo",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for BadInteractionProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: BadInteraction,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"BadInteraction.foo" => ::std::result::Result::Ok(0usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            0usize => {
                self.handle_foo(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "BadInteractionProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            bad => panic!(
                "{}: unexpected method idx {}",
                "BadInteractionProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
        self.service.on_termination().await
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for BadInteractionProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: BadInteraction,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    // Interactions have () as their handler associated type
    // to make `create_interaction` have a common return type.
    type Handler = ();
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "BadInteraction"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        Ok(())
    }

    fn create_interaction(
        &self,
        name: &str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_names(&self) -> &'static [&'static str] {
        &[
                // interaction's method names are never queried directly.
                // they are always queried from the "main" processor.
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}


#[::async_trait::async_trait]
pub trait BadService: ::std::marker::Send + ::std::marker::Sync + 'static {
    fn createBadInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn BadInteraction>> {
        ::anyhow::bail!("BadService.createBadInteraction not implemented");
    }
    async fn bar(
        &self,
    ) -> ::std::result::Result<::std::primitive::i32, crate::services::bad_service::BarExn> {
        ::std::result::Result::Err(crate::services::bad_service::BarExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "BadService",
                "bar",
            ),
        ))
    }
}

#[::async_trait::async_trait]
impl<T> BadService for ::std::boxed::Box<T>
where
    T: BadService + Send + Sync + ?Sized,
{
    fn createBadInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn BadInteraction>> {
        (**self).createBadInteraction()
    }
    async fn bar(
        &self,
    ) -> ::std::result::Result<::std::primitive::i32, crate::services::bad_service::BarExn> {
        (**self).bar(
        ).await
    }
}

#[::async_trait::async_trait]
impl<T> BadService for ::std::sync::Arc<T>
where
    T: BadService + Send + Sync + ?Sized,
{
    fn createBadInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn BadInteraction>> {
        (**self).createBadInteraction()
    }
    async fn bar(
        &self,
    ) -> ::std::result::Result<::std::primitive::i32, crate::services::bad_service::BarExn> {
        (**self).bar(
        ).await
    }
}


/// Processor for BadService's methods.
#[derive(Clone, Debug)]
pub struct BadServiceProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}

struct Args_BadService_bar {
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_BadService_bar {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "BadService.bar"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


impl<P, H, R, RS> BadServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: BadService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    fn handle_createBadInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn BadInteraction>> {
        self.service.createBadInteraction()
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "BadService.bar"))]
    async fn handle_bar<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "BadService";
            METHOD_NAME = "bar";
            SERVICE_METHOD_NAME = "BadService.bar";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_BadService_bar = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.bar(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "BadService.bar", "success");
                crate::services::bad_service::BarExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::bad_service::BarExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "bar",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "BadService.bar", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("BadService.bar", exn);
                ::tracing::error!(method = "BadService.bar", panic = ?aexn);
                crate::services::bad_service::BarExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "bar",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for BadServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: BadService,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"bar" => ::std::result::Result::Ok(1usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            1usize => {
                self.handle_bar(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "BadServiceProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            "BadInteraction" => ::std::result::Result::Ok(0usize),
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            0usize => {
                let handler = self.handle_createBadInteraction()?;
                let server = ::std::sync::Arc::new(BadInteractionProcessor::<P, ::std::boxed::Box<dyn BadInteraction>, R, RS>::new(handler));
                Ok(server)
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "BadServiceProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for BadServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: BadService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "BadService"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        Ok(())
    }

    fn create_interaction(
        &self,
        name: &str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_names(&self) -> &'static [&'static str] {
        &[
                // from BadService
                "bar",
                "BadInteraction.foo",
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a BadService service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_BadService_server<F, H, R, RS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: BadService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(BadServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(BadServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
        }
        bad => {
            ::tracing::error!(method = "BadService.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}

#[::async_trait::async_trait]
pub trait FooBarBazService: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::foo_bar_baz_service::FooExn> {
        ::std::result::Result::Err(crate::services::foo_bar_baz_service::FooExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "FooBarBazService",
                "foo",
            ),
        ))
    }
    async fn bar(
        &self,
    ) -> ::std::result::Result<(), crate::services::foo_bar_baz_service::BarExn> {
        ::std::result::Result::Err(crate::services::foo_bar_baz_service::BarExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "FooBarBazService",
                "bar",
            ),
        ))
    }
    async fn baz(
        &self,
    ) -> ::std::result::Result<(), crate::services::foo_bar_baz_service::BazExn> {
        ::std::result::Result::Err(crate::services::foo_bar_baz_service::BazExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "FooBarBazService",
                "baz",
            ),
        ))
    }
}

#[::async_trait::async_trait]
impl<T> FooBarBazService for ::std::boxed::Box<T>
where
    T: FooBarBazService + Send + Sync + ?Sized,
{
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::foo_bar_baz_service::FooExn> {
        (**self).foo(
        ).await
    }
    async fn bar(
        &self,
    ) -> ::std::result::Result<(), crate::services::foo_bar_baz_service::BarExn> {
        (**self).bar(
        ).await
    }
    async fn baz(
        &self,
    ) -> ::std::result::Result<(), crate::services::foo_bar_baz_service::BazExn> {
        (**self).baz(
        ).await
    }
}

#[::async_trait::async_trait]
impl<T> FooBarBazService for ::std::sync::Arc<T>
where
    T: FooBarBazService + Send + Sync + ?Sized,
{
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::foo_bar_baz_service::FooExn> {
        (**self).foo(
        ).await
    }
    async fn bar(
        &self,
    ) -> ::std::result::Result<(), crate::services::foo_bar_baz_service::BarExn> {
        (**self).bar(
        ).await
    }
    async fn baz(
        &self,
    ) -> ::std::result::Result<(), crate::services::foo_bar_baz_service::BazExn> {
        (**self).baz(
        ).await
    }
}


/// Processor for FooBarBazService's methods.
#[derive(Clone, Debug)]
pub struct FooBarBazServiceProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}

struct Args_FooBarBazService_foo {
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_FooBarBazService_foo {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "FooBarBazService.foo"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

struct Args_FooBarBazService_bar {
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_FooBarBazService_bar {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "FooBarBazService.bar"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

struct Args_FooBarBazService_baz {
}
impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_FooBarBazService_baz {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "FooBarBazService.baz"))]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


impl<P, H, R, RS> FooBarBazServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: FooBarBazService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "FooBarBazService.foo"))]
    async fn handle_foo<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "FooBarBazService";
            METHOD_NAME = "foo";
            SERVICE_METHOD_NAME = "FooBarBazService.foo";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_FooBarBazService_foo = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.foo(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "FooBarBazService.foo", "success");
                crate::services::foo_bar_baz_service::FooExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::foo_bar_baz_service::FooExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "foo",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "FooBarBazService.foo", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("FooBarBazService.foo", exn);
                ::tracing::error!(method = "FooBarBazService.foo", panic = ?aexn);
                crate::services::foo_bar_baz_service::FooExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "foo",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "FooBarBazService.bar"))]
    async fn handle_bar<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "FooBarBazService";
            METHOD_NAME = "bar";
            SERVICE_METHOD_NAME = "FooBarBazService.bar";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_FooBarBazService_bar = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.bar(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "FooBarBazService.bar", "success");
                crate::services::foo_bar_baz_service::BarExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::foo_bar_baz_service::BarExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "bar",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "FooBarBazService.bar", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("FooBarBazService.bar", exn);
                ::tracing::error!(method = "FooBarBazService.bar", panic = ?aexn);
                crate::services::foo_bar_baz_service::BarExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "bar",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "FooBarBazService.baz"))]
    async fn handle_baz<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::const_cstr::const_cstr;
        use ::futures::FutureExt as _;

        const_cstr! {
            SERVICE_NAME = "FooBarBazService";
            METHOD_NAME = "baz";
            SERVICE_METHOD_NAME = "FooBarBazService.baz";
        }
        let mut ctx_stack = req_ctxt.get_context_stack(
            SERVICE_NAME.as_cstr(),
            SERVICE_METHOD_NAME.as_cstr(),
        )?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_FooBarBazService_baz = ::fbthrift::Deserialize::read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME.as_cstr(),
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.baz(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "FooBarBazService.baz", "success");
                crate::services::foo_bar_baz_service::BazExn::Success(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::foo_bar_baz_service::BazExn::Success(_))) => {
                panic!(
                    "{} attempted to return success via error",
                    "baz",
                )
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::info!(method = "FooBarBazService.baz", exception = ?exn);
                exn
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("FooBarBazService.baz", exn);
                ::tracing::error!(method = "FooBarBazService.baz", panic = ?aexn);
                crate::services::foo_bar_baz_service::BazExn::ApplicationException(aexn)
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, _>(
            "baz",
            METHOD_NAME.as_cstr(),
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res
        )?;
        reply_state.lock().unwrap().send_reply(env);
        Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for FooBarBazServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: FooBarBazService,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"foo" => ::std::result::Result::Ok(0usize),
            b"bar" => ::std::result::Result::Ok(1usize),
            b"baz" => ::std::result::Result::Ok(2usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            0usize => {
                self.handle_foo(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            1usize => {
                self.handle_bar(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            2usize => {
                self.handle_baz(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "FooBarBazServiceProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            bad => panic!(
                "{}: unexpected method idx {}",
                "FooBarBazServiceProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for FooBarBazServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: FooBarBazService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "FooBarBazService"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<::std::sync::Mutex<RS>>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        Ok(())
    }

    fn create_interaction(
        &self,
        name: &str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_names(&self) -> &'static [&'static str] {
        &[
                // from FooBarBazService
                "foo",
                "bar",
                "baz",
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a FooBarBazService service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_FooBarBazService_server<F, H, R, RS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: FooBarBazService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(FooBarBazServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(FooBarBazServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
        }
        bad => {
            ::tracing::error!(method = "FooBarBazService.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}
