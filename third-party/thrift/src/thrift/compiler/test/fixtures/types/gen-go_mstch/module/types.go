// @generated by Thrift for [[[ program path ]]]
// This file is probably not the place you want to edit!

package module // [[[ program thrift source path ]]]

import (
    "fmt"
    "strings"

    included "included"
    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

var _ = included.GoUnusedProtection__

// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = thrift.ZERO
var _ = strings.Split


type TBinary = []byte

func NewTBinary() TBinary {
    return []byte("")
}

func WriteTBinary(item TBinary, p thrift.Protocol) error {
    if err := p.WriteBinary(item); err != nil {
    return err
}
    return nil
}

func ReadTBinary(p thrift.Protocol) (TBinary, error) {
    var decodeResult TBinary
    decodeErr := func() error {
        result, err := p.ReadBinary()
if err != nil {
    return err
}
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type IntTypedef = int32

func NewIntTypedef() IntTypedef {
    return 0
}

func WriteIntTypedef(item IntTypedef, p thrift.Protocol) error {
    if err := p.WriteI32(item); err != nil {
    return err
}
    return nil
}

func ReadIntTypedef(p thrift.Protocol) (IntTypedef, error) {
    var decodeResult IntTypedef
    decodeErr := func() error {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type UintTypedef = IntTypedef

func NewUintTypedef() UintTypedef {
    return NewIntTypedef()
}

func WriteUintTypedef(item UintTypedef, p thrift.Protocol) error {
    err := WriteIntTypedef(item, p)
if err != nil {
    return err
}
    return nil
}

func ReadUintTypedef(p thrift.Protocol) (UintTypedef, error) {
    var decodeResult UintTypedef
    decodeErr := func() error {
        result, err := ReadIntTypedef(p)
if err != nil {
    return err
}
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type HasBitwiseOps int32

const (
    HasBitwiseOps_none HasBitwiseOps = 0
    HasBitwiseOps_zero HasBitwiseOps = 1
    HasBitwiseOps_one HasBitwiseOps = 2
    HasBitwiseOps_two HasBitwiseOps = 4
    HasBitwiseOps_three HasBitwiseOps = 8
)

// Enum value maps for HasBitwiseOps
var (
    HasBitwiseOpsToName = map[HasBitwiseOps]string {
        HasBitwiseOps_none: "none",
        HasBitwiseOps_zero: "zero",
        HasBitwiseOps_one: "one",
        HasBitwiseOps_two: "two",
        HasBitwiseOps_three: "three",
    }

    HasBitwiseOpsToValue = map[string]HasBitwiseOps {
        "none": HasBitwiseOps_none,
        "zero": HasBitwiseOps_zero,
        "one": HasBitwiseOps_one,
        "two": HasBitwiseOps_two,
        "three": HasBitwiseOps_three,
    }

    HasBitwiseOpsNames = []string{
        "none",
        "zero",
        "one",
        "two",
        "three",
    }

    HasBitwiseOpsValues = []HasBitwiseOps{
        HasBitwiseOps_none,
        HasBitwiseOps_zero,
        HasBitwiseOps_one,
        HasBitwiseOps_two,
        HasBitwiseOps_three,
    }
)

func (x HasBitwiseOps) String() string {
    if v, ok := HasBitwiseOpsToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x HasBitwiseOps) Ptr() *HasBitwiseOps {
    return &x
}

// Deprecated: Use HasBitwiseOpsToValue instead (e.g. `x, ok := HasBitwiseOpsToValue["name"]`).
func HasBitwiseOpsFromString(s string) (HasBitwiseOps, error) {
    if v, ok := HasBitwiseOpsToValue[s]; ok {
        return v, nil
    }
    return HasBitwiseOps(0), fmt.Errorf("not a valid HasBitwiseOps string")
}

// Deprecated: Use HasBitwiseOps.Ptr() instead.
func HasBitwiseOpsPtr(v HasBitwiseOps) *HasBitwiseOps {
    return &v
}


type IsUnscoped int32

const (
    IsUnscoped_hello IsUnscoped = 0
    IsUnscoped_world IsUnscoped = 1
)

// Enum value maps for IsUnscoped
var (
    IsUnscopedToName = map[IsUnscoped]string {
        IsUnscoped_hello: "hello",
        IsUnscoped_world: "world",
    }

    IsUnscopedToValue = map[string]IsUnscoped {
        "hello": IsUnscoped_hello,
        "world": IsUnscoped_world,
    }

    IsUnscopedNames = []string{
        "hello",
        "world",
    }

    IsUnscopedValues = []IsUnscoped{
        IsUnscoped_hello,
        IsUnscoped_world,
    }
)

func (x IsUnscoped) String() string {
    if v, ok := IsUnscopedToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x IsUnscoped) Ptr() *IsUnscoped {
    return &x
}

// Deprecated: Use IsUnscopedToValue instead (e.g. `x, ok := IsUnscopedToValue["name"]`).
func IsUnscopedFromString(s string) (IsUnscoped, error) {
    if v, ok := IsUnscopedToValue[s]; ok {
        return v, nil
    }
    return IsUnscoped(0), fmt.Errorf("not a valid IsUnscoped string")
}

// Deprecated: Use IsUnscoped.Ptr() instead.
func IsUnscopedPtr(v IsUnscoped) *IsUnscoped {
    return &v
}


type MyForwardRefEnum int32

const (
    MyForwardRefEnum_ZERO MyForwardRefEnum = 0
    MyForwardRefEnum_NONZERO MyForwardRefEnum = 12
)

// Enum value maps for MyForwardRefEnum
var (
    MyForwardRefEnumToName = map[MyForwardRefEnum]string {
        MyForwardRefEnum_ZERO: "ZERO",
        MyForwardRefEnum_NONZERO: "NONZERO",
    }

    MyForwardRefEnumToValue = map[string]MyForwardRefEnum {
        "ZERO": MyForwardRefEnum_ZERO,
        "NONZERO": MyForwardRefEnum_NONZERO,
    }

    MyForwardRefEnumNames = []string{
        "ZERO",
        "NONZERO",
    }

    MyForwardRefEnumValues = []MyForwardRefEnum{
        MyForwardRefEnum_ZERO,
        MyForwardRefEnum_NONZERO,
    }
)

func (x MyForwardRefEnum) String() string {
    if v, ok := MyForwardRefEnumToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x MyForwardRefEnum) Ptr() *MyForwardRefEnum {
    return &x
}

// Deprecated: Use MyForwardRefEnumToValue instead (e.g. `x, ok := MyForwardRefEnumToValue["name"]`).
func MyForwardRefEnumFromString(s string) (MyForwardRefEnum, error) {
    if v, ok := MyForwardRefEnumToValue[s]; ok {
        return v, nil
    }
    return MyForwardRefEnum(0), fmt.Errorf("not a valid MyForwardRefEnum string")
}

// Deprecated: Use MyForwardRefEnum.Ptr() instead.
func MyForwardRefEnumPtr(v MyForwardRefEnum) *MyForwardRefEnum {
    return &v
}


type EmptyStruct struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &EmptyStruct{}

func NewEmptyStruct() *EmptyStruct {
    return (&EmptyStruct{})
}


// Deprecated: Use EmptyStruct.Set* methods instead or set the fields directly.
type EmptyStructBuilder struct {
    obj *EmptyStruct
}

func NewEmptyStructBuilder() *EmptyStructBuilder {
    return &EmptyStructBuilder{
        obj: NewEmptyStruct(),
    }
}

func (x *EmptyStructBuilder) Emit() *EmptyStruct {
    var objCopy EmptyStruct = *x.obj
    return &objCopy
}

func (x *EmptyStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("empty_struct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *EmptyStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *EmptyStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("EmptyStruct({")
    sb.WriteString("})")

    return sb.String()
}

type DecoratedStruct struct {
    Field string `thrift:"field,1" json:"field" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &DecoratedStruct{}

func NewDecoratedStruct() *DecoratedStruct {
    return (&DecoratedStruct{}).
        SetFieldNonCompat("")
}

func (x *DecoratedStruct) GetFieldNonCompat() string {
    return x.Field
}

func (x *DecoratedStruct) GetField() string {
    return x.Field
}

func (x *DecoratedStruct) SetFieldNonCompat(value string) *DecoratedStruct {
    x.Field = value
    return x
}

func (x *DecoratedStruct) SetField(value string) *DecoratedStruct {
    x.Field = value
    return x
}

func (x *DecoratedStruct) writeField1(p thrift.Protocol) error {  // Field
    if err := p.WriteFieldBegin("field", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DecoratedStruct) readField1(p thrift.Protocol) error {  // Field
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetFieldNonCompat(result)
    return nil
}

func (x *DecoratedStruct) toString1() string {  // Field
    return fmt.Sprintf("%v", x.GetFieldNonCompat())
}


// Deprecated: Use DecoratedStruct.Set* methods instead or set the fields directly.
type DecoratedStructBuilder struct {
    obj *DecoratedStruct
}

func NewDecoratedStructBuilder() *DecoratedStructBuilder {
    return &DecoratedStructBuilder{
        obj: NewDecoratedStruct(),
    }
}

func (x *DecoratedStructBuilder) Field(value string) *DecoratedStructBuilder {
    x.obj.Field = value
    return x
}

func (x *DecoratedStructBuilder) Emit() *DecoratedStruct {
    var objCopy DecoratedStruct = *x.obj
    return &objCopy
}

func (x *DecoratedStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("decorated_struct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DecoratedStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *DecoratedStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("DecoratedStruct({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type ContainerStruct struct {
    FieldB []int32 `thrift:"fieldB,2" json:"fieldB" db:"fieldB"`
    FieldC []int32 `thrift:"fieldC,3" json:"fieldC" db:"fieldC"`
    FieldD []int32 `thrift:"fieldD,4" json:"fieldD" db:"fieldD"`
    FieldE []int32 `thrift:"fieldE,5" json:"fieldE" db:"fieldE"`
    FieldF []int32 `thrift:"fieldF,6" json:"fieldF" db:"fieldF"`
    FieldG map[int32]string `thrift:"fieldG,7" json:"fieldG" db:"fieldG"`
    FieldH included.SomeMap `thrift:"fieldH,8" json:"fieldH" db:"fieldH"`
    FieldA []int32 `thrift:"fieldA,12" json:"fieldA" db:"fieldA"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ContainerStruct{}

func NewContainerStruct() *ContainerStruct {
    return (&ContainerStruct{}).
        SetFieldBNonCompat(nil).
        SetFieldCNonCompat(nil).
        SetFieldDNonCompat(nil).
        SetFieldENonCompat(nil).
        SetFieldFNonCompat(nil).
        SetFieldGNonCompat(nil).
        SetFieldHNonCompat(included.NewSomeMap()).
        SetFieldANonCompat(nil)
}

func (x *ContainerStruct) GetFieldBNonCompat() []int32 {
    return x.FieldB
}

func (x *ContainerStruct) GetFieldB() []int32 {
    if !x.IsSetFieldB() {
        return nil
    }

    return x.FieldB
}

func (x *ContainerStruct) GetFieldCNonCompat() []int32 {
    return x.FieldC
}

func (x *ContainerStruct) GetFieldC() []int32 {
    if !x.IsSetFieldC() {
        return nil
    }

    return x.FieldC
}

func (x *ContainerStruct) GetFieldDNonCompat() []int32 {
    return x.FieldD
}

func (x *ContainerStruct) GetFieldD() []int32 {
    if !x.IsSetFieldD() {
        return nil
    }

    return x.FieldD
}

func (x *ContainerStruct) GetFieldENonCompat() []int32 {
    return x.FieldE
}

func (x *ContainerStruct) GetFieldE() []int32 {
    if !x.IsSetFieldE() {
        return nil
    }

    return x.FieldE
}

func (x *ContainerStruct) GetFieldFNonCompat() []int32 {
    return x.FieldF
}

func (x *ContainerStruct) GetFieldF() []int32 {
    if !x.IsSetFieldF() {
        return nil
    }

    return x.FieldF
}

func (x *ContainerStruct) GetFieldGNonCompat() map[int32]string {
    return x.FieldG
}

func (x *ContainerStruct) GetFieldG() map[int32]string {
    if !x.IsSetFieldG() {
        return nil
    }

    return x.FieldG
}

func (x *ContainerStruct) GetFieldHNonCompat() included.SomeMap {
    return x.FieldH
}

func (x *ContainerStruct) GetFieldH() included.SomeMap {
    if !x.IsSetFieldH() {
        return included.NewSomeMap()
    }

    return x.FieldH
}

func (x *ContainerStruct) GetFieldANonCompat() []int32 {
    return x.FieldA
}

func (x *ContainerStruct) GetFieldA() []int32 {
    if !x.IsSetFieldA() {
        return nil
    }

    return x.FieldA
}

func (x *ContainerStruct) SetFieldBNonCompat(value []int32) *ContainerStruct {
    x.FieldB = value
    return x
}

func (x *ContainerStruct) SetFieldB(value []int32) *ContainerStruct {
    x.FieldB = value
    return x
}

func (x *ContainerStruct) SetFieldCNonCompat(value []int32) *ContainerStruct {
    x.FieldC = value
    return x
}

func (x *ContainerStruct) SetFieldC(value []int32) *ContainerStruct {
    x.FieldC = value
    return x
}

func (x *ContainerStruct) SetFieldDNonCompat(value []int32) *ContainerStruct {
    x.FieldD = value
    return x
}

func (x *ContainerStruct) SetFieldD(value []int32) *ContainerStruct {
    x.FieldD = value
    return x
}

func (x *ContainerStruct) SetFieldENonCompat(value []int32) *ContainerStruct {
    x.FieldE = value
    return x
}

func (x *ContainerStruct) SetFieldE(value []int32) *ContainerStruct {
    x.FieldE = value
    return x
}

func (x *ContainerStruct) SetFieldFNonCompat(value []int32) *ContainerStruct {
    x.FieldF = value
    return x
}

func (x *ContainerStruct) SetFieldF(value []int32) *ContainerStruct {
    x.FieldF = value
    return x
}

func (x *ContainerStruct) SetFieldGNonCompat(value map[int32]string) *ContainerStruct {
    x.FieldG = value
    return x
}

func (x *ContainerStruct) SetFieldG(value map[int32]string) *ContainerStruct {
    x.FieldG = value
    return x
}

func (x *ContainerStruct) SetFieldHNonCompat(value included.SomeMap) *ContainerStruct {
    x.FieldH = value
    return x
}

func (x *ContainerStruct) SetFieldH(value included.SomeMap) *ContainerStruct {
    x.FieldH = value
    return x
}

func (x *ContainerStruct) SetFieldANonCompat(value []int32) *ContainerStruct {
    x.FieldA = value
    return x
}

func (x *ContainerStruct) SetFieldA(value []int32) *ContainerStruct {
    x.FieldA = value
    return x
}

func (x *ContainerStruct) IsSetFieldB() bool {
    return x != nil && x.FieldB != nil
}

func (x *ContainerStruct) IsSetFieldC() bool {
    return x != nil && x.FieldC != nil
}

func (x *ContainerStruct) IsSetFieldD() bool {
    return x != nil && x.FieldD != nil
}

func (x *ContainerStruct) IsSetFieldE() bool {
    return x != nil && x.FieldE != nil
}

func (x *ContainerStruct) IsSetFieldF() bool {
    return x != nil && x.FieldF != nil
}

func (x *ContainerStruct) IsSetFieldG() bool {
    return x != nil && x.FieldG != nil
}

func (x *ContainerStruct) IsSetFieldH() bool {
    return x != nil && x.FieldH != nil
}

func (x *ContainerStruct) IsSetFieldA() bool {
    return x != nil && x.FieldA != nil
}

func (x *ContainerStruct) writeField2(p thrift.Protocol) error {  // FieldB
    if !x.IsSetFieldB() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldB", thrift.LIST, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldBNonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField3(p thrift.Protocol) error {  // FieldC
    if !x.IsSetFieldC() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldC", thrift.LIST, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldCNonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField4(p thrift.Protocol) error {  // FieldD
    if !x.IsSetFieldD() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldD", thrift.LIST, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldDNonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField5(p thrift.Protocol) error {  // FieldE
    if !x.IsSetFieldE() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldE", thrift.LIST, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldENonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField6(p thrift.Protocol) error {  // FieldF
    if !x.IsSetFieldF() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldF", thrift.SET, 6); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldFNonCompat()
    if err := p.WriteSetBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteSetEnd(); err != nil {
    return thrift.PrependError("error writing set end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField7(p thrift.Protocol) error {  // FieldG
    if !x.IsSetFieldG() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldG", thrift.MAP, 7); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldGNonCompat()
    if err := p.WriteMapBegin(thrift.I32, thrift.STRING, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := p.WriteString(item); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField8(p thrift.Protocol) error {  // FieldH
    if !x.IsSetFieldH() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldH", thrift.MAP, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldHNonCompat()
    err := included.WriteSomeMap(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField12(p thrift.Protocol) error {  // FieldA
    if !x.IsSetFieldA() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldA", thrift.LIST, 12); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldANonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) readField2(p thrift.Protocol) error {  // FieldB
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldBNonCompat(result)
    return nil
}

func (x *ContainerStruct) readField3(p thrift.Protocol) error {  // FieldC
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldCNonCompat(result)
    return nil
}

func (x *ContainerStruct) readField4(p thrift.Protocol) error {  // FieldD
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldDNonCompat(result)
    return nil
}

func (x *ContainerStruct) readField5(p thrift.Protocol) error {  // FieldE
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldENonCompat(result)
    return nil
}

func (x *ContainerStruct) readField6(p thrift.Protocol) error {  // FieldF
    _ /* elemType */, size, err := p.ReadSetBegin()
if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
}

setResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    setResult = append(setResult, elem)
}

if err := p.ReadSetEnd(); err != nil {
    return thrift.PrependError("error reading set end: ", err)
}
result := setResult

    x.SetFieldFNonCompat(result)
    return nil
}

func (x *ContainerStruct) readField7(p thrift.Protocol) error {  // FieldG
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]string, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value string
    {
        result, err := p.ReadString()
if err != nil {
    return err
}
        value = result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.SetFieldGNonCompat(result)
    return nil
}

func (x *ContainerStruct) readField8(p thrift.Protocol) error {  // FieldH
    result, err := included.ReadSomeMap(p)
if err != nil {
    return err
}

    x.SetFieldHNonCompat(result)
    return nil
}

func (x *ContainerStruct) readField12(p thrift.Protocol) error {  // FieldA
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldANonCompat(result)
    return nil
}

func (x *ContainerStruct) toString2() string {  // FieldB
    return fmt.Sprintf("%v", x.GetFieldBNonCompat())
}

func (x *ContainerStruct) toString3() string {  // FieldC
    return fmt.Sprintf("%v", x.GetFieldCNonCompat())
}

func (x *ContainerStruct) toString4() string {  // FieldD
    return fmt.Sprintf("%v", x.GetFieldDNonCompat())
}

func (x *ContainerStruct) toString5() string {  // FieldE
    return fmt.Sprintf("%v", x.GetFieldENonCompat())
}

func (x *ContainerStruct) toString6() string {  // FieldF
    return fmt.Sprintf("%v", x.GetFieldFNonCompat())
}

func (x *ContainerStruct) toString7() string {  // FieldG
    return fmt.Sprintf("%v", x.GetFieldGNonCompat())
}

func (x *ContainerStruct) toString8() string {  // FieldH
    return fmt.Sprintf("%v", x.GetFieldHNonCompat())
}

func (x *ContainerStruct) toString12() string {  // FieldA
    return fmt.Sprintf("%v", x.GetFieldANonCompat())
}


// Deprecated: Use ContainerStruct.Set* methods instead or set the fields directly.
type ContainerStructBuilder struct {
    obj *ContainerStruct
}

func NewContainerStructBuilder() *ContainerStructBuilder {
    return &ContainerStructBuilder{
        obj: NewContainerStruct(),
    }
}

func (x *ContainerStructBuilder) FieldB(value []int32) *ContainerStructBuilder {
    x.obj.FieldB = value
    return x
}

func (x *ContainerStructBuilder) FieldC(value []int32) *ContainerStructBuilder {
    x.obj.FieldC = value
    return x
}

func (x *ContainerStructBuilder) FieldD(value []int32) *ContainerStructBuilder {
    x.obj.FieldD = value
    return x
}

func (x *ContainerStructBuilder) FieldE(value []int32) *ContainerStructBuilder {
    x.obj.FieldE = value
    return x
}

func (x *ContainerStructBuilder) FieldF(value []int32) *ContainerStructBuilder {
    x.obj.FieldF = value
    return x
}

func (x *ContainerStructBuilder) FieldG(value map[int32]string) *ContainerStructBuilder {
    x.obj.FieldG = value
    return x
}

func (x *ContainerStructBuilder) FieldH(value included.SomeMap) *ContainerStructBuilder {
    x.obj.FieldH = value
    return x
}

func (x *ContainerStructBuilder) FieldA(value []int32) *ContainerStructBuilder {
    x.obj.FieldA = value
    return x
}

func (x *ContainerStructBuilder) Emit() *ContainerStruct {
    var objCopy ContainerStruct = *x.obj
    return &objCopy
}

func (x *ContainerStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ContainerStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := x.writeField6(p); err != nil {
        return err
    }

    if err := x.writeField7(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := x.writeField12(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 2:  // fieldB
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 3:  // fieldC
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField3(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 4:  // fieldD
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField4(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 5:  // fieldE
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField5(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 6:  // fieldF
            expectedType := thrift.Type(thrift.SET)
            if wireType == expectedType {
                if err := x.readField6(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 7:  // fieldG
            expectedType := thrift.Type(thrift.MAP)
            if wireType == expectedType {
                if err := x.readField7(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 8:  // fieldH
            expectedType := thrift.Type(thrift.MAP)
            if wireType == expectedType {
                if err := x.readField8(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 12:  // fieldA
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField12(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ContainerStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ContainerStruct({")
    sb.WriteString(fmt.Sprintf("FieldB:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("FieldC:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("FieldD:%s ", x.toString4()))
    sb.WriteString(fmt.Sprintf("FieldE:%s ", x.toString5()))
    sb.WriteString(fmt.Sprintf("FieldF:%s ", x.toString6()))
    sb.WriteString(fmt.Sprintf("FieldG:%s ", x.toString7()))
    sb.WriteString(fmt.Sprintf("FieldH:%s ", x.toString8()))
    sb.WriteString(fmt.Sprintf("FieldA:%s", x.toString12()))
    sb.WriteString("})")

    return sb.String()
}

type CppTypeStruct struct {
    FieldA []int32 `thrift:"fieldA,1" json:"fieldA" db:"fieldA"`
}
// Compile time interface enforcer
var _ thrift.Struct = &CppTypeStruct{}

func NewCppTypeStruct() *CppTypeStruct {
    return (&CppTypeStruct{}).
        SetFieldANonCompat(nil)
}

func (x *CppTypeStruct) GetFieldANonCompat() []int32 {
    return x.FieldA
}

func (x *CppTypeStruct) GetFieldA() []int32 {
    if !x.IsSetFieldA() {
        return nil
    }

    return x.FieldA
}

func (x *CppTypeStruct) SetFieldANonCompat(value []int32) *CppTypeStruct {
    x.FieldA = value
    return x
}

func (x *CppTypeStruct) SetFieldA(value []int32) *CppTypeStruct {
    x.FieldA = value
    return x
}

func (x *CppTypeStruct) IsSetFieldA() bool {
    return x != nil && x.FieldA != nil
}

func (x *CppTypeStruct) writeField1(p thrift.Protocol) error {  // FieldA
    if !x.IsSetFieldA() {
        return nil
    }

    if err := p.WriteFieldBegin("fieldA", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldANonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *CppTypeStruct) readField1(p thrift.Protocol) error {  // FieldA
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldANonCompat(result)
    return nil
}

func (x *CppTypeStruct) toString1() string {  // FieldA
    return fmt.Sprintf("%v", x.GetFieldANonCompat())
}


// Deprecated: Use CppTypeStruct.Set* methods instead or set the fields directly.
type CppTypeStructBuilder struct {
    obj *CppTypeStruct
}

func NewCppTypeStructBuilder() *CppTypeStructBuilder {
    return &CppTypeStructBuilder{
        obj: NewCppTypeStruct(),
    }
}

func (x *CppTypeStructBuilder) FieldA(value []int32) *CppTypeStructBuilder {
    x.obj.FieldA = value
    return x
}

func (x *CppTypeStructBuilder) Emit() *CppTypeStruct {
    var objCopy CppTypeStruct = *x.obj
    return &objCopy
}

func (x *CppTypeStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("CppTypeStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CppTypeStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // fieldA
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *CppTypeStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("CppTypeStruct({")
    sb.WriteString(fmt.Sprintf("FieldA:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type VirtualStruct struct {
    MyIntField int64 `thrift:"MyIntField,1" json:"MyIntField" db:"MyIntField"`
}
// Compile time interface enforcer
var _ thrift.Struct = &VirtualStruct{}

func NewVirtualStruct() *VirtualStruct {
    return (&VirtualStruct{}).
        SetMyIntFieldNonCompat(0)
}

func (x *VirtualStruct) GetMyIntFieldNonCompat() int64 {
    return x.MyIntField
}

func (x *VirtualStruct) GetMyIntField() int64 {
    return x.MyIntField
}

func (x *VirtualStruct) SetMyIntFieldNonCompat(value int64) *VirtualStruct {
    x.MyIntField = value
    return x
}

func (x *VirtualStruct) SetMyIntField(value int64) *VirtualStruct {
    x.MyIntField = value
    return x
}

func (x *VirtualStruct) writeField1(p thrift.Protocol) error {  // MyIntField
    if err := p.WriteFieldBegin("MyIntField", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMyIntFieldNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *VirtualStruct) readField1(p thrift.Protocol) error {  // MyIntField
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetMyIntFieldNonCompat(result)
    return nil
}

func (x *VirtualStruct) toString1() string {  // MyIntField
    return fmt.Sprintf("%v", x.GetMyIntFieldNonCompat())
}


// Deprecated: Use VirtualStruct.Set* methods instead or set the fields directly.
type VirtualStructBuilder struct {
    obj *VirtualStruct
}

func NewVirtualStructBuilder() *VirtualStructBuilder {
    return &VirtualStructBuilder{
        obj: NewVirtualStruct(),
    }
}

func (x *VirtualStructBuilder) MyIntField(value int64) *VirtualStructBuilder {
    x.obj.MyIntField = value
    return x
}

func (x *VirtualStructBuilder) Emit() *VirtualStruct {
    var objCopy VirtualStruct = *x.obj
    return &objCopy
}

func (x *VirtualStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("VirtualStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *VirtualStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // MyIntField
            expectedType := thrift.Type(thrift.I64)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *VirtualStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("VirtualStruct({")
    sb.WriteString(fmt.Sprintf("MyIntField:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type MyStructWithForwardRefEnum struct {
    A MyForwardRefEnum `thrift:"a,1" json:"a" db:"a"`
    B MyForwardRefEnum `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = &MyStructWithForwardRefEnum{}

func NewMyStructWithForwardRefEnum() *MyStructWithForwardRefEnum {
    return (&MyStructWithForwardRefEnum{}).
        SetANonCompat(
              MyForwardRefEnum_NONZERO,
          ).
        SetBNonCompat(
              MyForwardRefEnum_NONZERO,
          )
}

func (x *MyStructWithForwardRefEnum) GetANonCompat() MyForwardRefEnum {
    return x.A
}

func (x *MyStructWithForwardRefEnum) GetA() MyForwardRefEnum {
    return x.A
}

func (x *MyStructWithForwardRefEnum) GetBNonCompat() MyForwardRefEnum {
    return x.B
}

func (x *MyStructWithForwardRefEnum) GetB() MyForwardRefEnum {
    return x.B
}

func (x *MyStructWithForwardRefEnum) SetANonCompat(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.A = value
    return x
}

func (x *MyStructWithForwardRefEnum) SetA(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.A = value
    return x
}

func (x *MyStructWithForwardRefEnum) SetBNonCompat(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.B = value
    return x
}

func (x *MyStructWithForwardRefEnum) SetB(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.B = value
    return x
}

func (x *MyStructWithForwardRefEnum) writeField1(p thrift.Protocol) error {  // A
    if err := p.WriteFieldBegin("a", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetANonCompat()
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) writeField2(p thrift.Protocol) error {  // B
    if err := p.WriteFieldBegin("b", thrift.I32, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBNonCompat()
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) readField1(p thrift.Protocol) error {  // A
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := MyForwardRefEnum(enumResult)

    x.SetANonCompat(result)
    return nil
}

func (x *MyStructWithForwardRefEnum) readField2(p thrift.Protocol) error {  // B
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := MyForwardRefEnum(enumResult)

    x.SetBNonCompat(result)
    return nil
}

func (x *MyStructWithForwardRefEnum) toString1() string {  // A
    return fmt.Sprintf("%v", x.GetANonCompat())
}

func (x *MyStructWithForwardRefEnum) toString2() string {  // B
    return fmt.Sprintf("%v", x.GetBNonCompat())
}


// Deprecated: Use MyStructWithForwardRefEnum.Set* methods instead or set the fields directly.
type MyStructWithForwardRefEnumBuilder struct {
    obj *MyStructWithForwardRefEnum
}

func NewMyStructWithForwardRefEnumBuilder() *MyStructWithForwardRefEnumBuilder {
    return &MyStructWithForwardRefEnumBuilder{
        obj: NewMyStructWithForwardRefEnum(),
    }
}

func (x *MyStructWithForwardRefEnumBuilder) A(value MyForwardRefEnum) *MyStructWithForwardRefEnumBuilder {
    x.obj.A = value
    return x
}

func (x *MyStructWithForwardRefEnumBuilder) B(value MyForwardRefEnum) *MyStructWithForwardRefEnumBuilder {
    x.obj.B = value
    return x
}

func (x *MyStructWithForwardRefEnumBuilder) Emit() *MyStructWithForwardRefEnum {
    var objCopy MyStructWithForwardRefEnum = *x.obj
    return &objCopy
}

func (x *MyStructWithForwardRefEnum) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MyStructWithForwardRefEnum"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // a
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // b
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MyStructWithForwardRefEnum) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MyStructWithForwardRefEnum({")
    sb.WriteString(fmt.Sprintf("A:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("B:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type TrivialNumeric struct {
    A int32 `thrift:"a,1" json:"a" db:"a"`
    B bool `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = &TrivialNumeric{}

func NewTrivialNumeric() *TrivialNumeric {
    return (&TrivialNumeric{}).
        SetANonCompat(0).
        SetBNonCompat(false)
}

func (x *TrivialNumeric) GetANonCompat() int32 {
    return x.A
}

func (x *TrivialNumeric) GetA() int32 {
    return x.A
}

func (x *TrivialNumeric) GetBNonCompat() bool {
    return x.B
}

func (x *TrivialNumeric) GetB() bool {
    return x.B
}

func (x *TrivialNumeric) SetANonCompat(value int32) *TrivialNumeric {
    x.A = value
    return x
}

func (x *TrivialNumeric) SetA(value int32) *TrivialNumeric {
    x.A = value
    return x
}

func (x *TrivialNumeric) SetBNonCompat(value bool) *TrivialNumeric {
    x.B = value
    return x
}

func (x *TrivialNumeric) SetB(value bool) *TrivialNumeric {
    x.B = value
    return x
}

func (x *TrivialNumeric) writeField1(p thrift.Protocol) error {  // A
    if err := p.WriteFieldBegin("a", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetANonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNumeric) writeField2(p thrift.Protocol) error {  // B
    if err := p.WriteFieldBegin("b", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNumeric) readField1(p thrift.Protocol) error {  // A
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetANonCompat(result)
    return nil
}

func (x *TrivialNumeric) readField2(p thrift.Protocol) error {  // B
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetBNonCompat(result)
    return nil
}

func (x *TrivialNumeric) toString1() string {  // A
    return fmt.Sprintf("%v", x.GetANonCompat())
}

func (x *TrivialNumeric) toString2() string {  // B
    return fmt.Sprintf("%v", x.GetBNonCompat())
}


// Deprecated: Use TrivialNumeric.Set* methods instead or set the fields directly.
type TrivialNumericBuilder struct {
    obj *TrivialNumeric
}

func NewTrivialNumericBuilder() *TrivialNumericBuilder {
    return &TrivialNumericBuilder{
        obj: NewTrivialNumeric(),
    }
}

func (x *TrivialNumericBuilder) A(value int32) *TrivialNumericBuilder {
    x.obj.A = value
    return x
}

func (x *TrivialNumericBuilder) B(value bool) *TrivialNumericBuilder {
    x.obj.B = value
    return x
}

func (x *TrivialNumericBuilder) Emit() *TrivialNumeric {
    var objCopy TrivialNumeric = *x.obj
    return &objCopy
}

func (x *TrivialNumeric) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("TrivialNumeric"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *TrivialNumeric) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // a
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // b
            expectedType := thrift.Type(thrift.BOOL)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *TrivialNumeric) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("TrivialNumeric({")
    sb.WriteString(fmt.Sprintf("A:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("B:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type TrivialNestedWithDefault struct {
    Z int32 `thrift:"z,1" json:"z" db:"z"`
    N *TrivialNumeric `thrift:"n,2" json:"n" db:"n"`
}
// Compile time interface enforcer
var _ thrift.Struct = &TrivialNestedWithDefault{}

func NewTrivialNestedWithDefault() *TrivialNestedWithDefault {
    return (&TrivialNestedWithDefault{}).
        SetZNonCompat(4).
        SetNNonCompat(
              *NewTrivialNumeric().
    SetANonCompat(3).
    SetBNonCompat(true),
          )
}

func (x *TrivialNestedWithDefault) GetZNonCompat() int32 {
    return x.Z
}

func (x *TrivialNestedWithDefault) GetZ() int32 {
    return x.Z
}

func (x *TrivialNestedWithDefault) GetNNonCompat() *TrivialNumeric {
    return x.N
}

func (x *TrivialNestedWithDefault) GetN() *TrivialNumeric {
    if !x.IsSetN() {
        return nil
    }

    return x.N
}

func (x *TrivialNestedWithDefault) SetZNonCompat(value int32) *TrivialNestedWithDefault {
    x.Z = value
    return x
}

func (x *TrivialNestedWithDefault) SetZ(value int32) *TrivialNestedWithDefault {
    x.Z = value
    return x
}

func (x *TrivialNestedWithDefault) SetNNonCompat(value TrivialNumeric) *TrivialNestedWithDefault {
    x.N = &value
    return x
}

func (x *TrivialNestedWithDefault) SetN(value *TrivialNumeric) *TrivialNestedWithDefault {
    x.N = value
    return x
}

func (x *TrivialNestedWithDefault) IsSetN() bool {
    return x != nil && x.N != nil
}

func (x *TrivialNestedWithDefault) writeField1(p thrift.Protocol) error {  // Z
    if err := p.WriteFieldBegin("z", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetZNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) writeField2(p thrift.Protocol) error {  // N
    if !x.IsSetN() {
        return nil
    }

    if err := p.WriteFieldBegin("n", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) readField1(p thrift.Protocol) error {  // Z
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetZNonCompat(result)
    return nil
}

func (x *TrivialNestedWithDefault) readField2(p thrift.Protocol) error {  // N
    result := *NewTrivialNumeric()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetNNonCompat(result)
    return nil
}

func (x *TrivialNestedWithDefault) toString1() string {  // Z
    return fmt.Sprintf("%v", x.GetZNonCompat())
}

func (x *TrivialNestedWithDefault) toString2() string {  // N
    return fmt.Sprintf("%v", x.GetNNonCompat())
}

// Deprecated: Use NewTrivialNestedWithDefault().GetN() instead.
var TrivialNestedWithDefault_N_DEFAULT = NewTrivialNestedWithDefault().GetN()

// Deprecated: Use NewTrivialNestedWithDefault().GetN() instead.
func (x *TrivialNestedWithDefault) DefaultGetN() *TrivialNumeric {
    if !x.IsSetN() {
        return NewTrivialNumeric()
    }
    return x.N
}


// Deprecated: Use TrivialNestedWithDefault.Set* methods instead or set the fields directly.
type TrivialNestedWithDefaultBuilder struct {
    obj *TrivialNestedWithDefault
}

func NewTrivialNestedWithDefaultBuilder() *TrivialNestedWithDefaultBuilder {
    return &TrivialNestedWithDefaultBuilder{
        obj: NewTrivialNestedWithDefault(),
    }
}

func (x *TrivialNestedWithDefaultBuilder) Z(value int32) *TrivialNestedWithDefaultBuilder {
    x.obj.Z = value
    return x
}

func (x *TrivialNestedWithDefaultBuilder) N(value *TrivialNumeric) *TrivialNestedWithDefaultBuilder {
    x.obj.N = value
    return x
}

func (x *TrivialNestedWithDefaultBuilder) Emit() *TrivialNestedWithDefault {
    var objCopy TrivialNestedWithDefault = *x.obj
    return &objCopy
}

func (x *TrivialNestedWithDefault) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("TrivialNestedWithDefault"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // z
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // n
            expectedType := thrift.Type(thrift.STRUCT)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *TrivialNestedWithDefault) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("TrivialNestedWithDefault({")
    sb.WriteString(fmt.Sprintf("Z:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("N:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type ComplexString struct {
    A string `thrift:"a,1" json:"a" db:"a"`
    B map[string]int32 `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ComplexString{}

func NewComplexString() *ComplexString {
    return (&ComplexString{}).
        SetANonCompat("").
        SetBNonCompat(nil)
}

func (x *ComplexString) GetANonCompat() string {
    return x.A
}

func (x *ComplexString) GetA() string {
    return x.A
}

func (x *ComplexString) GetBNonCompat() map[string]int32 {
    return x.B
}

func (x *ComplexString) GetB() map[string]int32 {
    if !x.IsSetB() {
        return nil
    }

    return x.B
}

func (x *ComplexString) SetANonCompat(value string) *ComplexString {
    x.A = value
    return x
}

func (x *ComplexString) SetA(value string) *ComplexString {
    x.A = value
    return x
}

func (x *ComplexString) SetBNonCompat(value map[string]int32) *ComplexString {
    x.B = value
    return x
}

func (x *ComplexString) SetB(value map[string]int32) *ComplexString {
    x.B = value
    return x
}

func (x *ComplexString) IsSetB() bool {
    return x != nil && x.B != nil
}

func (x *ComplexString) writeField1(p thrift.Protocol) error {  // A
    if err := p.WriteFieldBegin("a", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetANonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexString) writeField2(p thrift.Protocol) error {  // B
    if !x.IsSetB() {
        return nil
    }

    if err := p.WriteFieldBegin("b", thrift.MAP, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBNonCompat()
    if err := p.WriteMapBegin(thrift.STRING, thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteString(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexString) readField1(p thrift.Protocol) error {  // A
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetANonCompat(result)
    return nil
}

func (x *ComplexString) readField2(p thrift.Protocol) error {  // B
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[string]int32, size)
for i := 0; i < size; i++ {
    var key string
    {
        result, err := p.ReadString()
if err != nil {
    return err
}
        key = result
    }

    var value int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        value = result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.SetBNonCompat(result)
    return nil
}

func (x *ComplexString) toString1() string {  // A
    return fmt.Sprintf("%v", x.GetANonCompat())
}

func (x *ComplexString) toString2() string {  // B
    return fmt.Sprintf("%v", x.GetBNonCompat())
}


// Deprecated: Use ComplexString.Set* methods instead or set the fields directly.
type ComplexStringBuilder struct {
    obj *ComplexString
}

func NewComplexStringBuilder() *ComplexStringBuilder {
    return &ComplexStringBuilder{
        obj: NewComplexString(),
    }
}

func (x *ComplexStringBuilder) A(value string) *ComplexStringBuilder {
    x.obj.A = value
    return x
}

func (x *ComplexStringBuilder) B(value map[string]int32) *ComplexStringBuilder {
    x.obj.B = value
    return x
}

func (x *ComplexStringBuilder) Emit() *ComplexString {
    var objCopy ComplexString = *x.obj
    return &objCopy
}

func (x *ComplexString) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ComplexString"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ComplexString) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // a
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // b
            expectedType := thrift.Type(thrift.MAP)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ComplexString) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ComplexString({")
    sb.WriteString(fmt.Sprintf("A:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("B:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type ComplexNestedWithDefault struct {
    Z string `thrift:"z,1" json:"z" db:"z"`
    N *ComplexString `thrift:"n,2" json:"n" db:"n"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ComplexNestedWithDefault{}

func NewComplexNestedWithDefault() *ComplexNestedWithDefault {
    return (&ComplexNestedWithDefault{}).
        SetZNonCompat("4").
        SetNNonCompat(
              *NewComplexString().
    SetANonCompat("3").
    SetBNonCompat(
        map[string]int32{
    "a": 3,
},
    ),
          )
}

func (x *ComplexNestedWithDefault) GetZNonCompat() string {
    return x.Z
}

func (x *ComplexNestedWithDefault) GetZ() string {
    return x.Z
}

func (x *ComplexNestedWithDefault) GetNNonCompat() *ComplexString {
    return x.N
}

func (x *ComplexNestedWithDefault) GetN() *ComplexString {
    if !x.IsSetN() {
        return nil
    }

    return x.N
}

func (x *ComplexNestedWithDefault) SetZNonCompat(value string) *ComplexNestedWithDefault {
    x.Z = value
    return x
}

func (x *ComplexNestedWithDefault) SetZ(value string) *ComplexNestedWithDefault {
    x.Z = value
    return x
}

func (x *ComplexNestedWithDefault) SetNNonCompat(value ComplexString) *ComplexNestedWithDefault {
    x.N = &value
    return x
}

func (x *ComplexNestedWithDefault) SetN(value *ComplexString) *ComplexNestedWithDefault {
    x.N = value
    return x
}

func (x *ComplexNestedWithDefault) IsSetN() bool {
    return x != nil && x.N != nil
}

func (x *ComplexNestedWithDefault) writeField1(p thrift.Protocol) error {  // Z
    if err := p.WriteFieldBegin("z", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetZNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) writeField2(p thrift.Protocol) error {  // N
    if !x.IsSetN() {
        return nil
    }

    if err := p.WriteFieldBegin("n", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) readField1(p thrift.Protocol) error {  // Z
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetZNonCompat(result)
    return nil
}

func (x *ComplexNestedWithDefault) readField2(p thrift.Protocol) error {  // N
    result := *NewComplexString()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetNNonCompat(result)
    return nil
}

func (x *ComplexNestedWithDefault) toString1() string {  // Z
    return fmt.Sprintf("%v", x.GetZNonCompat())
}

func (x *ComplexNestedWithDefault) toString2() string {  // N
    return fmt.Sprintf("%v", x.GetNNonCompat())
}

// Deprecated: Use NewComplexNestedWithDefault().GetN() instead.
var ComplexNestedWithDefault_N_DEFAULT = NewComplexNestedWithDefault().GetN()

// Deprecated: Use NewComplexNestedWithDefault().GetN() instead.
func (x *ComplexNestedWithDefault) DefaultGetN() *ComplexString {
    if !x.IsSetN() {
        return NewComplexString()
    }
    return x.N
}


// Deprecated: Use ComplexNestedWithDefault.Set* methods instead or set the fields directly.
type ComplexNestedWithDefaultBuilder struct {
    obj *ComplexNestedWithDefault
}

func NewComplexNestedWithDefaultBuilder() *ComplexNestedWithDefaultBuilder {
    return &ComplexNestedWithDefaultBuilder{
        obj: NewComplexNestedWithDefault(),
    }
}

func (x *ComplexNestedWithDefaultBuilder) Z(value string) *ComplexNestedWithDefaultBuilder {
    x.obj.Z = value
    return x
}

func (x *ComplexNestedWithDefaultBuilder) N(value *ComplexString) *ComplexNestedWithDefaultBuilder {
    x.obj.N = value
    return x
}

func (x *ComplexNestedWithDefaultBuilder) Emit() *ComplexNestedWithDefault {
    var objCopy ComplexNestedWithDefault = *x.obj
    return &objCopy
}

func (x *ComplexNestedWithDefault) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ComplexNestedWithDefault"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // z
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // n
            expectedType := thrift.Type(thrift.STRUCT)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ComplexNestedWithDefault) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ComplexNestedWithDefault({")
    sb.WriteString(fmt.Sprintf("Z:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("N:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type MinPadding struct {
    Small int8 `thrift:"small,1,required" json:"small" db:"small"`
    Big int64 `thrift:"big,2,required" json:"big" db:"big"`
    Medium int16 `thrift:"medium,3,required" json:"medium" db:"medium"`
    Biggish int32 `thrift:"biggish,4,required" json:"biggish" db:"biggish"`
    Tiny int8 `thrift:"tiny,5,required" json:"tiny" db:"tiny"`
}
// Compile time interface enforcer
var _ thrift.Struct = &MinPadding{}

func NewMinPadding() *MinPadding {
    return (&MinPadding{}).
        SetSmallNonCompat(0).
        SetBigNonCompat(0).
        SetMediumNonCompat(0).
        SetBiggishNonCompat(0).
        SetTinyNonCompat(0)
}

func (x *MinPadding) GetSmallNonCompat() int8 {
    return x.Small
}

func (x *MinPadding) GetSmall() int8 {
    return x.Small
}

func (x *MinPadding) GetBigNonCompat() int64 {
    return x.Big
}

func (x *MinPadding) GetBig() int64 {
    return x.Big
}

func (x *MinPadding) GetMediumNonCompat() int16 {
    return x.Medium
}

func (x *MinPadding) GetMedium() int16 {
    return x.Medium
}

func (x *MinPadding) GetBiggishNonCompat() int32 {
    return x.Biggish
}

func (x *MinPadding) GetBiggish() int32 {
    return x.Biggish
}

func (x *MinPadding) GetTinyNonCompat() int8 {
    return x.Tiny
}

func (x *MinPadding) GetTiny() int8 {
    return x.Tiny
}

func (x *MinPadding) SetSmallNonCompat(value int8) *MinPadding {
    x.Small = value
    return x
}

func (x *MinPadding) SetSmall(value int8) *MinPadding {
    x.Small = value
    return x
}

func (x *MinPadding) SetBigNonCompat(value int64) *MinPadding {
    x.Big = value
    return x
}

func (x *MinPadding) SetBig(value int64) *MinPadding {
    x.Big = value
    return x
}

func (x *MinPadding) SetMediumNonCompat(value int16) *MinPadding {
    x.Medium = value
    return x
}

func (x *MinPadding) SetMedium(value int16) *MinPadding {
    x.Medium = value
    return x
}

func (x *MinPadding) SetBiggishNonCompat(value int32) *MinPadding {
    x.Biggish = value
    return x
}

func (x *MinPadding) SetBiggish(value int32) *MinPadding {
    x.Biggish = value
    return x
}

func (x *MinPadding) SetTinyNonCompat(value int8) *MinPadding {
    x.Tiny = value
    return x
}

func (x *MinPadding) SetTiny(value int8) *MinPadding {
    x.Tiny = value
    return x
}

func (x *MinPadding) writeField1(p thrift.Protocol) error {  // Small
    if err := p.WriteFieldBegin("small", thrift.BYTE, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetSmallNonCompat()
    if err := p.WriteByte(byte(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField2(p thrift.Protocol) error {  // Big
    if err := p.WriteFieldBegin("big", thrift.I64, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBigNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField3(p thrift.Protocol) error {  // Medium
    if err := p.WriteFieldBegin("medium", thrift.I16, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMediumNonCompat()
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField4(p thrift.Protocol) error {  // Biggish
    if err := p.WriteFieldBegin("biggish", thrift.I32, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBiggishNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField5(p thrift.Protocol) error {  // Tiny
    if err := p.WriteFieldBegin("tiny", thrift.BYTE, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetTinyNonCompat()
    if err := p.WriteByte(byte(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) readField1(p thrift.Protocol) error {  // Small
    resultByte, err := p.ReadByte()
result := int8(resultByte)
if err != nil {
    return err
}

    x.SetSmallNonCompat(result)
    return nil
}

func (x *MinPadding) readField2(p thrift.Protocol) error {  // Big
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetBigNonCompat(result)
    return nil
}

func (x *MinPadding) readField3(p thrift.Protocol) error {  // Medium
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.SetMediumNonCompat(result)
    return nil
}

func (x *MinPadding) readField4(p thrift.Protocol) error {  // Biggish
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetBiggishNonCompat(result)
    return nil
}

func (x *MinPadding) readField5(p thrift.Protocol) error {  // Tiny
    resultByte, err := p.ReadByte()
result := int8(resultByte)
if err != nil {
    return err
}

    x.SetTinyNonCompat(result)
    return nil
}

func (x *MinPadding) toString1() string {  // Small
    return fmt.Sprintf("%v", x.GetSmallNonCompat())
}

func (x *MinPadding) toString2() string {  // Big
    return fmt.Sprintf("%v", x.GetBigNonCompat())
}

func (x *MinPadding) toString3() string {  // Medium
    return fmt.Sprintf("%v", x.GetMediumNonCompat())
}

func (x *MinPadding) toString4() string {  // Biggish
    return fmt.Sprintf("%v", x.GetBiggishNonCompat())
}

func (x *MinPadding) toString5() string {  // Tiny
    return fmt.Sprintf("%v", x.GetTinyNonCompat())
}


// Deprecated: Use MinPadding.Set* methods instead or set the fields directly.
type MinPaddingBuilder struct {
    obj *MinPadding
}

func NewMinPaddingBuilder() *MinPaddingBuilder {
    return &MinPaddingBuilder{
        obj: NewMinPadding(),
    }
}

func (x *MinPaddingBuilder) Small(value int8) *MinPaddingBuilder {
    x.obj.Small = value
    return x
}

func (x *MinPaddingBuilder) Big(value int64) *MinPaddingBuilder {
    x.obj.Big = value
    return x
}

func (x *MinPaddingBuilder) Medium(value int16) *MinPaddingBuilder {
    x.obj.Medium = value
    return x
}

func (x *MinPaddingBuilder) Biggish(value int32) *MinPaddingBuilder {
    x.obj.Biggish = value
    return x
}

func (x *MinPaddingBuilder) Tiny(value int8) *MinPaddingBuilder {
    x.obj.Tiny = value
    return x
}

func (x *MinPaddingBuilder) Emit() *MinPadding {
    var objCopy MinPadding = *x.obj
    return &objCopy
}

func (x *MinPadding) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MinPadding"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // small
            expectedType := thrift.Type(thrift.BYTE)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // big
            expectedType := thrift.Type(thrift.I64)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 3:  // medium
            expectedType := thrift.Type(thrift.I16)
            if wireType == expectedType {
                if err := x.readField3(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 4:  // biggish
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField4(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 5:  // tiny
            expectedType := thrift.Type(thrift.BYTE)
            if wireType == expectedType {
                if err := x.readField5(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MinPadding) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MinPadding({")
    sb.WriteString(fmt.Sprintf("Small:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Big:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Medium:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("Biggish:%s ", x.toString4()))
    sb.WriteString(fmt.Sprintf("Tiny:%s", x.toString5()))
    sb.WriteString("})")

    return sb.String()
}

type MinPaddingWithCustomType struct {
    Small int8 `thrift:"small,1" json:"small" db:"small"`
    Big int64 `thrift:"big,2" json:"big" db:"big"`
    Medium int16 `thrift:"medium,3" json:"medium" db:"medium"`
    Biggish int32 `thrift:"biggish,4" json:"biggish" db:"biggish"`
    Tiny int8 `thrift:"tiny,5" json:"tiny" db:"tiny"`
}
// Compile time interface enforcer
var _ thrift.Struct = &MinPaddingWithCustomType{}

func NewMinPaddingWithCustomType() *MinPaddingWithCustomType {
    return (&MinPaddingWithCustomType{}).
        SetSmallNonCompat(0).
        SetBigNonCompat(0).
        SetMediumNonCompat(0).
        SetBiggishNonCompat(0).
        SetTinyNonCompat(0)
}

func (x *MinPaddingWithCustomType) GetSmallNonCompat() int8 {
    return x.Small
}

func (x *MinPaddingWithCustomType) GetSmall() int8 {
    return x.Small
}

func (x *MinPaddingWithCustomType) GetBigNonCompat() int64 {
    return x.Big
}

func (x *MinPaddingWithCustomType) GetBig() int64 {
    return x.Big
}

func (x *MinPaddingWithCustomType) GetMediumNonCompat() int16 {
    return x.Medium
}

func (x *MinPaddingWithCustomType) GetMedium() int16 {
    return x.Medium
}

func (x *MinPaddingWithCustomType) GetBiggishNonCompat() int32 {
    return x.Biggish
}

func (x *MinPaddingWithCustomType) GetBiggish() int32 {
    return x.Biggish
}

func (x *MinPaddingWithCustomType) GetTinyNonCompat() int8 {
    return x.Tiny
}

func (x *MinPaddingWithCustomType) GetTiny() int8 {
    return x.Tiny
}

func (x *MinPaddingWithCustomType) SetSmallNonCompat(value int8) *MinPaddingWithCustomType {
    x.Small = value
    return x
}

func (x *MinPaddingWithCustomType) SetSmall(value int8) *MinPaddingWithCustomType {
    x.Small = value
    return x
}

func (x *MinPaddingWithCustomType) SetBigNonCompat(value int64) *MinPaddingWithCustomType {
    x.Big = value
    return x
}

func (x *MinPaddingWithCustomType) SetBig(value int64) *MinPaddingWithCustomType {
    x.Big = value
    return x
}

func (x *MinPaddingWithCustomType) SetMediumNonCompat(value int16) *MinPaddingWithCustomType {
    x.Medium = value
    return x
}

func (x *MinPaddingWithCustomType) SetMedium(value int16) *MinPaddingWithCustomType {
    x.Medium = value
    return x
}

func (x *MinPaddingWithCustomType) SetBiggishNonCompat(value int32) *MinPaddingWithCustomType {
    x.Biggish = value
    return x
}

func (x *MinPaddingWithCustomType) SetBiggish(value int32) *MinPaddingWithCustomType {
    x.Biggish = value
    return x
}

func (x *MinPaddingWithCustomType) SetTinyNonCompat(value int8) *MinPaddingWithCustomType {
    x.Tiny = value
    return x
}

func (x *MinPaddingWithCustomType) SetTiny(value int8) *MinPaddingWithCustomType {
    x.Tiny = value
    return x
}

func (x *MinPaddingWithCustomType) writeField1(p thrift.Protocol) error {  // Small
    if err := p.WriteFieldBegin("small", thrift.BYTE, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetSmallNonCompat()
    if err := p.WriteByte(byte(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField2(p thrift.Protocol) error {  // Big
    if err := p.WriteFieldBegin("big", thrift.I64, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBigNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField3(p thrift.Protocol) error {  // Medium
    if err := p.WriteFieldBegin("medium", thrift.I16, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMediumNonCompat()
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField4(p thrift.Protocol) error {  // Biggish
    if err := p.WriteFieldBegin("biggish", thrift.I32, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBiggishNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField5(p thrift.Protocol) error {  // Tiny
    if err := p.WriteFieldBegin("tiny", thrift.BYTE, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetTinyNonCompat()
    if err := p.WriteByte(byte(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) readField1(p thrift.Protocol) error {  // Small
    resultByte, err := p.ReadByte()
result := int8(resultByte)
if err != nil {
    return err
}

    x.SetSmallNonCompat(result)
    return nil
}

func (x *MinPaddingWithCustomType) readField2(p thrift.Protocol) error {  // Big
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetBigNonCompat(result)
    return nil
}

func (x *MinPaddingWithCustomType) readField3(p thrift.Protocol) error {  // Medium
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.SetMediumNonCompat(result)
    return nil
}

func (x *MinPaddingWithCustomType) readField4(p thrift.Protocol) error {  // Biggish
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetBiggishNonCompat(result)
    return nil
}

func (x *MinPaddingWithCustomType) readField5(p thrift.Protocol) error {  // Tiny
    resultByte, err := p.ReadByte()
result := int8(resultByte)
if err != nil {
    return err
}

    x.SetTinyNonCompat(result)
    return nil
}

func (x *MinPaddingWithCustomType) toString1() string {  // Small
    return fmt.Sprintf("%v", x.GetSmallNonCompat())
}

func (x *MinPaddingWithCustomType) toString2() string {  // Big
    return fmt.Sprintf("%v", x.GetBigNonCompat())
}

func (x *MinPaddingWithCustomType) toString3() string {  // Medium
    return fmt.Sprintf("%v", x.GetMediumNonCompat())
}

func (x *MinPaddingWithCustomType) toString4() string {  // Biggish
    return fmt.Sprintf("%v", x.GetBiggishNonCompat())
}

func (x *MinPaddingWithCustomType) toString5() string {  // Tiny
    return fmt.Sprintf("%v", x.GetTinyNonCompat())
}


// Deprecated: Use MinPaddingWithCustomType.Set* methods instead or set the fields directly.
type MinPaddingWithCustomTypeBuilder struct {
    obj *MinPaddingWithCustomType
}

func NewMinPaddingWithCustomTypeBuilder() *MinPaddingWithCustomTypeBuilder {
    return &MinPaddingWithCustomTypeBuilder{
        obj: NewMinPaddingWithCustomType(),
    }
}

func (x *MinPaddingWithCustomTypeBuilder) Small(value int8) *MinPaddingWithCustomTypeBuilder {
    x.obj.Small = value
    return x
}

func (x *MinPaddingWithCustomTypeBuilder) Big(value int64) *MinPaddingWithCustomTypeBuilder {
    x.obj.Big = value
    return x
}

func (x *MinPaddingWithCustomTypeBuilder) Medium(value int16) *MinPaddingWithCustomTypeBuilder {
    x.obj.Medium = value
    return x
}

func (x *MinPaddingWithCustomTypeBuilder) Biggish(value int32) *MinPaddingWithCustomTypeBuilder {
    x.obj.Biggish = value
    return x
}

func (x *MinPaddingWithCustomTypeBuilder) Tiny(value int8) *MinPaddingWithCustomTypeBuilder {
    x.obj.Tiny = value
    return x
}

func (x *MinPaddingWithCustomTypeBuilder) Emit() *MinPaddingWithCustomType {
    var objCopy MinPaddingWithCustomType = *x.obj
    return &objCopy
}

func (x *MinPaddingWithCustomType) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MinPaddingWithCustomType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // small
            expectedType := thrift.Type(thrift.BYTE)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // big
            expectedType := thrift.Type(thrift.I64)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 3:  // medium
            expectedType := thrift.Type(thrift.I16)
            if wireType == expectedType {
                if err := x.readField3(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 4:  // biggish
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField4(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 5:  // tiny
            expectedType := thrift.Type(thrift.BYTE)
            if wireType == expectedType {
                if err := x.readField5(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MinPaddingWithCustomType) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MinPaddingWithCustomType({")
    sb.WriteString(fmt.Sprintf("Small:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Big:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Medium:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("Biggish:%s ", x.toString4()))
    sb.WriteString(fmt.Sprintf("Tiny:%s", x.toString5()))
    sb.WriteString("})")

    return sb.String()
}

type MyStruct struct {
    MyIntField int64 `thrift:"MyIntField,1" json:"MyIntField" db:"MyIntField"`
    MyStringField string `thrift:"MyStringField,2" json:"MyStringField" db:"MyStringField"`
    MajorVer int64 `thrift:"majorVer,3" json:"majorVer" db:"majorVer"`
    Data *MyDataItem `thrift:"data,4" json:"data" db:"data"`
}
// Compile time interface enforcer
var _ thrift.Struct = &MyStruct{}

func NewMyStruct() *MyStruct {
    return (&MyStruct{}).
        SetMyIntFieldNonCompat(0).
        SetMyStringFieldNonCompat("").
        SetMajorVerNonCompat(0).
        SetDataNonCompat(*NewMyDataItem())
}

func (x *MyStruct) GetMyIntFieldNonCompat() int64 {
    return x.MyIntField
}

func (x *MyStruct) GetMyIntField() int64 {
    return x.MyIntField
}

func (x *MyStruct) GetMyStringFieldNonCompat() string {
    return x.MyStringField
}

func (x *MyStruct) GetMyStringField() string {
    return x.MyStringField
}

func (x *MyStruct) GetMajorVerNonCompat() int64 {
    return x.MajorVer
}

func (x *MyStruct) GetMajorVer() int64 {
    return x.MajorVer
}

func (x *MyStruct) GetDataNonCompat() *MyDataItem {
    return x.Data
}

func (x *MyStruct) GetData() *MyDataItem {
    if !x.IsSetData() {
        return nil
    }

    return x.Data
}

func (x *MyStruct) SetMyIntFieldNonCompat(value int64) *MyStruct {
    x.MyIntField = value
    return x
}

func (x *MyStruct) SetMyIntField(value int64) *MyStruct {
    x.MyIntField = value
    return x
}

func (x *MyStruct) SetMyStringFieldNonCompat(value string) *MyStruct {
    x.MyStringField = value
    return x
}

func (x *MyStruct) SetMyStringField(value string) *MyStruct {
    x.MyStringField = value
    return x
}

func (x *MyStruct) SetMajorVerNonCompat(value int64) *MyStruct {
    x.MajorVer = value
    return x
}

func (x *MyStruct) SetMajorVer(value int64) *MyStruct {
    x.MajorVer = value
    return x
}

func (x *MyStruct) SetDataNonCompat(value MyDataItem) *MyStruct {
    x.Data = &value
    return x
}

func (x *MyStruct) SetData(value *MyDataItem) *MyStruct {
    x.Data = value
    return x
}

func (x *MyStruct) IsSetData() bool {
    return x != nil && x.Data != nil
}

func (x *MyStruct) writeField1(p thrift.Protocol) error {  // MyIntField
    if err := p.WriteFieldBegin("MyIntField", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMyIntFieldNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) writeField2(p thrift.Protocol) error {  // MyStringField
    if err := p.WriteFieldBegin("MyStringField", thrift.STRING, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMyStringFieldNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) writeField3(p thrift.Protocol) error {  // MajorVer
    if err := p.WriteFieldBegin("majorVer", thrift.I64, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetMajorVerNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) writeField4(p thrift.Protocol) error {  // Data
    if !x.IsSetData() {
        return nil
    }

    if err := p.WriteFieldBegin("data", thrift.STRUCT, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetDataNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) readField1(p thrift.Protocol) error {  // MyIntField
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetMyIntFieldNonCompat(result)
    return nil
}

func (x *MyStruct) readField2(p thrift.Protocol) error {  // MyStringField
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetMyStringFieldNonCompat(result)
    return nil
}

func (x *MyStruct) readField3(p thrift.Protocol) error {  // MajorVer
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetMajorVerNonCompat(result)
    return nil
}

func (x *MyStruct) readField4(p thrift.Protocol) error {  // Data
    result := *NewMyDataItem()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetDataNonCompat(result)
    return nil
}

func (x *MyStruct) toString1() string {  // MyIntField
    return fmt.Sprintf("%v", x.GetMyIntFieldNonCompat())
}

func (x *MyStruct) toString2() string {  // MyStringField
    return fmt.Sprintf("%v", x.GetMyStringFieldNonCompat())
}

func (x *MyStruct) toString3() string {  // MajorVer
    return fmt.Sprintf("%v", x.GetMajorVerNonCompat())
}

func (x *MyStruct) toString4() string {  // Data
    return fmt.Sprintf("%v", x.GetDataNonCompat())
}

// Deprecated: Use NewMyStruct().GetData() instead.
var MyStruct_Data_DEFAULT = NewMyStruct().GetData()

// Deprecated: Use NewMyStruct().GetData() instead.
func (x *MyStruct) DefaultGetData() *MyDataItem {
    if !x.IsSetData() {
        return NewMyDataItem()
    }
    return x.Data
}


// Deprecated: Use MyStruct.Set* methods instead or set the fields directly.
type MyStructBuilder struct {
    obj *MyStruct
}

func NewMyStructBuilder() *MyStructBuilder {
    return &MyStructBuilder{
        obj: NewMyStruct(),
    }
}

func (x *MyStructBuilder) MyIntField(value int64) *MyStructBuilder {
    x.obj.MyIntField = value
    return x
}

func (x *MyStructBuilder) MyStringField(value string) *MyStructBuilder {
    x.obj.MyStringField = value
    return x
}

func (x *MyStructBuilder) MajorVer(value int64) *MyStructBuilder {
    x.obj.MajorVer = value
    return x
}

func (x *MyStructBuilder) Data(value *MyDataItem) *MyStructBuilder {
    x.obj.Data = value
    return x
}

func (x *MyStructBuilder) Emit() *MyStruct {
    var objCopy MyStruct = *x.obj
    return &objCopy
}

func (x *MyStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MyStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // MyIntField
            expectedType := thrift.Type(thrift.I64)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // MyStringField
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 3:  // majorVer
            expectedType := thrift.Type(thrift.I64)
            if wireType == expectedType {
                if err := x.readField3(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 4:  // data
            expectedType := thrift.Type(thrift.STRUCT)
            if wireType == expectedType {
                if err := x.readField4(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MyStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MyStruct({")
    sb.WriteString(fmt.Sprintf("MyIntField:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("MyStringField:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("MajorVer:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("Data:%s", x.toString4()))
    sb.WriteString("})")

    return sb.String()
}

type MyDataItem struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &MyDataItem{}

func NewMyDataItem() *MyDataItem {
    return (&MyDataItem{})
}


// Deprecated: Use MyDataItem.Set* methods instead or set the fields directly.
type MyDataItemBuilder struct {
    obj *MyDataItem
}

func NewMyDataItemBuilder() *MyDataItemBuilder {
    return &MyDataItemBuilder{
        obj: NewMyDataItem(),
    }
}

func (x *MyDataItemBuilder) Emit() *MyDataItem {
    var objCopy MyDataItem = *x.obj
    return &objCopy
}

func (x *MyDataItem) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("MyDataItem"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MyDataItem) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MyDataItem) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MyDataItem({")
    sb.WriteString("})")

    return sb.String()
}

type Renaming struct {
    Foo int64 `thrift:"foo,1" json:"foo" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = &Renaming{}

func NewRenaming() *Renaming {
    return (&Renaming{}).
        SetFooNonCompat(0)
}

func (x *Renaming) GetFooNonCompat() int64 {
    return x.Foo
}

func (x *Renaming) GetFoo() int64 {
    return x.Foo
}

func (x *Renaming) SetFooNonCompat(value int64) *Renaming {
    x.Foo = value
    return x
}

func (x *Renaming) SetFoo(value int64) *Renaming {
    x.Foo = value
    return x
}

func (x *Renaming) writeField1(p thrift.Protocol) error {  // Foo
    if err := p.WriteFieldBegin("foo", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFooNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Renaming) readField1(p thrift.Protocol) error {  // Foo
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetFooNonCompat(result)
    return nil
}

func (x *Renaming) toString1() string {  // Foo
    return fmt.Sprintf("%v", x.GetFooNonCompat())
}


// Deprecated: Use Renaming.Set* methods instead or set the fields directly.
type RenamingBuilder struct {
    obj *Renaming
}

func NewRenamingBuilder() *RenamingBuilder {
    return &RenamingBuilder{
        obj: NewRenaming(),
    }
}

func (x *RenamingBuilder) Foo(value int64) *RenamingBuilder {
    x.obj.Foo = value
    return x
}

func (x *RenamingBuilder) Emit() *Renaming {
    var objCopy Renaming = *x.obj
    return &objCopy
}

func (x *Renaming) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("Renaming"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Renaming) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // foo
            expectedType := thrift.Type(thrift.I64)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Renaming) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Renaming({")
    sb.WriteString(fmt.Sprintf("Foo:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type AnnotatedTypes struct {
    BinaryField TBinary `thrift:"binary_field,1" json:"binary_field" db:"binary_field"`
    ListField included.SomeListOfTypeMap `thrift:"list_field,2" json:"list_field" db:"list_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &AnnotatedTypes{}

func NewAnnotatedTypes() *AnnotatedTypes {
    return (&AnnotatedTypes{}).
        SetBinaryFieldNonCompat(NewTBinary()).
        SetListFieldNonCompat(included.NewSomeListOfTypeMap())
}

func (x *AnnotatedTypes) GetBinaryFieldNonCompat() TBinary {
    return x.BinaryField
}

func (x *AnnotatedTypes) GetBinaryField() TBinary {
    if !x.IsSetBinaryField() {
        return NewTBinary()
    }

    return x.BinaryField
}

func (x *AnnotatedTypes) GetListFieldNonCompat() included.SomeListOfTypeMap {
    return x.ListField
}

func (x *AnnotatedTypes) GetListField() included.SomeListOfTypeMap {
    if !x.IsSetListField() {
        return included.NewSomeListOfTypeMap()
    }

    return x.ListField
}

func (x *AnnotatedTypes) SetBinaryFieldNonCompat(value TBinary) *AnnotatedTypes {
    x.BinaryField = value
    return x
}

func (x *AnnotatedTypes) SetBinaryField(value TBinary) *AnnotatedTypes {
    x.BinaryField = value
    return x
}

func (x *AnnotatedTypes) SetListFieldNonCompat(value included.SomeListOfTypeMap) *AnnotatedTypes {
    x.ListField = value
    return x
}

func (x *AnnotatedTypes) SetListField(value included.SomeListOfTypeMap) *AnnotatedTypes {
    x.ListField = value
    return x
}

func (x *AnnotatedTypes) IsSetBinaryField() bool {
    return x != nil && x.BinaryField != nil
}

func (x *AnnotatedTypes) IsSetListField() bool {
    return x != nil && x.ListField != nil
}

func (x *AnnotatedTypes) writeField1(p thrift.Protocol) error {  // BinaryField
    if !x.IsSetBinaryField() {
        return nil
    }

    if err := p.WriteFieldBegin("binary_field", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetBinaryFieldNonCompat()
    err := WriteTBinary(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AnnotatedTypes) writeField2(p thrift.Protocol) error {  // ListField
    if !x.IsSetListField() {
        return nil
    }

    if err := p.WriteFieldBegin("list_field", thrift.LIST, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetListFieldNonCompat()
    err := included.WriteSomeListOfTypeMap(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AnnotatedTypes) readField1(p thrift.Protocol) error {  // BinaryField
    result, err := ReadTBinary(p)
if err != nil {
    return err
}

    x.SetBinaryFieldNonCompat(result)
    return nil
}

func (x *AnnotatedTypes) readField2(p thrift.Protocol) error {  // ListField
    result, err := included.ReadSomeListOfTypeMap(p)
if err != nil {
    return err
}

    x.SetListFieldNonCompat(result)
    return nil
}

func (x *AnnotatedTypes) toString1() string {  // BinaryField
    return fmt.Sprintf("%v", x.GetBinaryFieldNonCompat())
}

func (x *AnnotatedTypes) toString2() string {  // ListField
    return fmt.Sprintf("%v", x.GetListFieldNonCompat())
}


// Deprecated: Use AnnotatedTypes.Set* methods instead or set the fields directly.
type AnnotatedTypesBuilder struct {
    obj *AnnotatedTypes
}

func NewAnnotatedTypesBuilder() *AnnotatedTypesBuilder {
    return &AnnotatedTypesBuilder{
        obj: NewAnnotatedTypes(),
    }
}

func (x *AnnotatedTypesBuilder) BinaryField(value TBinary) *AnnotatedTypesBuilder {
    x.obj.BinaryField = value
    return x
}

func (x *AnnotatedTypesBuilder) ListField(value included.SomeListOfTypeMap) *AnnotatedTypesBuilder {
    x.obj.ListField = value
    return x
}

func (x *AnnotatedTypesBuilder) Emit() *AnnotatedTypes {
    var objCopy AnnotatedTypes = *x.obj
    return &objCopy
}

func (x *AnnotatedTypes) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AnnotatedTypes"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AnnotatedTypes) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // binary_field
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // list_field
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AnnotatedTypes) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("AnnotatedTypes({")
    sb.WriteString(fmt.Sprintf("BinaryField:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("ListField:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type ForwardUsageRoot struct {
    ForwardUsageStruct *ForwardUsageStruct `thrift:"ForwardUsageStruct,1,optional" json:"ForwardUsageStruct,omitempty" db:"ForwardUsageStruct"`
    ForwardUsageByRef *ForwardUsageByRef `thrift:"ForwardUsageByRef,2,optional" json:"ForwardUsageByRef,omitempty" db:"ForwardUsageByRef"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ForwardUsageRoot{}

func NewForwardUsageRoot() *ForwardUsageRoot {
    return (&ForwardUsageRoot{})
}

func (x *ForwardUsageRoot) GetForwardUsageStructNonCompat() *ForwardUsageStruct {
    return x.ForwardUsageStruct
}

func (x *ForwardUsageRoot) GetForwardUsageStruct() *ForwardUsageStruct {
    if !x.IsSetForwardUsageStruct() {
        return nil
    }

    return x.ForwardUsageStruct
}

func (x *ForwardUsageRoot) GetForwardUsageByRefNonCompat() *ForwardUsageByRef {
    return x.ForwardUsageByRef
}

func (x *ForwardUsageRoot) GetForwardUsageByRef() *ForwardUsageByRef {
    if !x.IsSetForwardUsageByRef() {
        return nil
    }

    return x.ForwardUsageByRef
}

func (x *ForwardUsageRoot) SetForwardUsageStructNonCompat(value ForwardUsageStruct) *ForwardUsageRoot {
    x.ForwardUsageStruct = &value
    return x
}

func (x *ForwardUsageRoot) SetForwardUsageStruct(value *ForwardUsageStruct) *ForwardUsageRoot {
    x.ForwardUsageStruct = value
    return x
}

func (x *ForwardUsageRoot) SetForwardUsageByRefNonCompat(value ForwardUsageByRef) *ForwardUsageRoot {
    x.ForwardUsageByRef = &value
    return x
}

func (x *ForwardUsageRoot) SetForwardUsageByRef(value *ForwardUsageByRef) *ForwardUsageRoot {
    x.ForwardUsageByRef = value
    return x
}

func (x *ForwardUsageRoot) IsSetForwardUsageStruct() bool {
    return x != nil && x.ForwardUsageStruct != nil
}

func (x *ForwardUsageRoot) IsSetForwardUsageByRef() bool {
    return x != nil && x.ForwardUsageByRef != nil
}

func (x *ForwardUsageRoot) writeField1(p thrift.Protocol) error {  // ForwardUsageStruct
    if !x.IsSetForwardUsageStruct() {
        return nil
    }

    if err := p.WriteFieldBegin("ForwardUsageStruct", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetForwardUsageStructNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageRoot) writeField2(p thrift.Protocol) error {  // ForwardUsageByRef
    if !x.IsSetForwardUsageByRef() {
        return nil
    }

    if err := p.WriteFieldBegin("ForwardUsageByRef", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetForwardUsageByRefNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageRoot) readField1(p thrift.Protocol) error {  // ForwardUsageStruct
    result := *NewForwardUsageStruct()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetForwardUsageStructNonCompat(result)
    return nil
}

func (x *ForwardUsageRoot) readField2(p thrift.Protocol) error {  // ForwardUsageByRef
    result := *NewForwardUsageByRef()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetForwardUsageByRefNonCompat(result)
    return nil
}

func (x *ForwardUsageRoot) toString1() string {  // ForwardUsageStruct
    return fmt.Sprintf("%v", x.GetForwardUsageStructNonCompat())
}

func (x *ForwardUsageRoot) toString2() string {  // ForwardUsageByRef
    return fmt.Sprintf("%v", x.GetForwardUsageByRefNonCompat())
}

// Deprecated: Use NewForwardUsageRoot().GetForwardUsageStruct() instead.
var ForwardUsageRoot_ForwardUsageStruct_DEFAULT = NewForwardUsageRoot().GetForwardUsageStruct()

// Deprecated: Use NewForwardUsageRoot().GetForwardUsageStruct() instead.
func (x *ForwardUsageRoot) DefaultGetForwardUsageStruct() *ForwardUsageStruct {
    if !x.IsSetForwardUsageStruct() {
        return NewForwardUsageStruct()
    }
    return x.ForwardUsageStruct
}

// Deprecated: Use NewForwardUsageRoot().GetForwardUsageByRef() instead.
var ForwardUsageRoot_ForwardUsageByRef_DEFAULT = NewForwardUsageRoot().GetForwardUsageByRef()

// Deprecated: Use NewForwardUsageRoot().GetForwardUsageByRef() instead.
func (x *ForwardUsageRoot) DefaultGetForwardUsageByRef() *ForwardUsageByRef {
    if !x.IsSetForwardUsageByRef() {
        return NewForwardUsageByRef()
    }
    return x.ForwardUsageByRef
}


// Deprecated: Use ForwardUsageRoot.Set* methods instead or set the fields directly.
type ForwardUsageRootBuilder struct {
    obj *ForwardUsageRoot
}

func NewForwardUsageRootBuilder() *ForwardUsageRootBuilder {
    return &ForwardUsageRootBuilder{
        obj: NewForwardUsageRoot(),
    }
}

func (x *ForwardUsageRootBuilder) ForwardUsageStruct(value *ForwardUsageStruct) *ForwardUsageRootBuilder {
    x.obj.ForwardUsageStruct = value
    return x
}

func (x *ForwardUsageRootBuilder) ForwardUsageByRef(value *ForwardUsageByRef) *ForwardUsageRootBuilder {
    x.obj.ForwardUsageByRef = value
    return x
}

func (x *ForwardUsageRootBuilder) Emit() *ForwardUsageRoot {
    var objCopy ForwardUsageRoot = *x.obj
    return &objCopy
}

func (x *ForwardUsageRoot) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ForwardUsageRoot"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageRoot) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // ForwardUsageStruct
            expectedType := thrift.Type(thrift.STRUCT)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // ForwardUsageByRef
            expectedType := thrift.Type(thrift.STRUCT)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ForwardUsageRoot) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ForwardUsageRoot({")
    sb.WriteString(fmt.Sprintf("ForwardUsageStruct:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("ForwardUsageByRef:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type ForwardUsageStruct struct {
    Foo *ForwardUsageRoot `thrift:"foo,1,optional" json:"foo,omitempty" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ForwardUsageStruct{}

func NewForwardUsageStruct() *ForwardUsageStruct {
    return (&ForwardUsageStruct{})
}

func (x *ForwardUsageStruct) GetFooNonCompat() *ForwardUsageRoot {
    return x.Foo
}

func (x *ForwardUsageStruct) GetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
        return nil
    }

    return x.Foo
}

func (x *ForwardUsageStruct) SetFooNonCompat(value ForwardUsageRoot) *ForwardUsageStruct {
    x.Foo = &value
    return x
}

func (x *ForwardUsageStruct) SetFoo(value *ForwardUsageRoot) *ForwardUsageStruct {
    x.Foo = value
    return x
}

func (x *ForwardUsageStruct) IsSetFoo() bool {
    return x != nil && x.Foo != nil
}

func (x *ForwardUsageStruct) writeField1(p thrift.Protocol) error {  // Foo
    if !x.IsSetFoo() {
        return nil
    }

    if err := p.WriteFieldBegin("foo", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFooNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageStruct) readField1(p thrift.Protocol) error {  // Foo
    result := *NewForwardUsageRoot()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetFooNonCompat(result)
    return nil
}

func (x *ForwardUsageStruct) toString1() string {  // Foo
    return fmt.Sprintf("%v", x.GetFooNonCompat())
}

// Deprecated: Use NewForwardUsageStruct().GetFoo() instead.
var ForwardUsageStruct_Foo_DEFAULT = NewForwardUsageStruct().GetFoo()

// Deprecated: Use NewForwardUsageStruct().GetFoo() instead.
func (x *ForwardUsageStruct) DefaultGetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
        return NewForwardUsageRoot()
    }
    return x.Foo
}


// Deprecated: Use ForwardUsageStruct.Set* methods instead or set the fields directly.
type ForwardUsageStructBuilder struct {
    obj *ForwardUsageStruct
}

func NewForwardUsageStructBuilder() *ForwardUsageStructBuilder {
    return &ForwardUsageStructBuilder{
        obj: NewForwardUsageStruct(),
    }
}

func (x *ForwardUsageStructBuilder) Foo(value *ForwardUsageRoot) *ForwardUsageStructBuilder {
    x.obj.Foo = value
    return x
}

func (x *ForwardUsageStructBuilder) Emit() *ForwardUsageStruct {
    var objCopy ForwardUsageStruct = *x.obj
    return &objCopy
}

func (x *ForwardUsageStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ForwardUsageStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // foo
            expectedType := thrift.Type(thrift.STRUCT)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ForwardUsageStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ForwardUsageStruct({")
    sb.WriteString(fmt.Sprintf("Foo:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type ForwardUsageByRef struct {
    Foo *ForwardUsageRoot `thrift:"foo,1,optional" json:"foo,omitempty" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = &ForwardUsageByRef{}

func NewForwardUsageByRef() *ForwardUsageByRef {
    return (&ForwardUsageByRef{})
}

func (x *ForwardUsageByRef) GetFooNonCompat() *ForwardUsageRoot {
    return x.Foo
}

func (x *ForwardUsageByRef) GetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
        return nil
    }

    return x.Foo
}

func (x *ForwardUsageByRef) SetFooNonCompat(value ForwardUsageRoot) *ForwardUsageByRef {
    x.Foo = &value
    return x
}

func (x *ForwardUsageByRef) SetFoo(value *ForwardUsageRoot) *ForwardUsageByRef {
    x.Foo = value
    return x
}

func (x *ForwardUsageByRef) IsSetFoo() bool {
    return x != nil && x.Foo != nil
}

func (x *ForwardUsageByRef) writeField1(p thrift.Protocol) error {  // Foo
    if !x.IsSetFoo() {
        return nil
    }

    if err := p.WriteFieldBegin("foo", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFooNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageByRef) readField1(p thrift.Protocol) error {  // Foo
    result := *NewForwardUsageRoot()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetFooNonCompat(result)
    return nil
}

func (x *ForwardUsageByRef) toString1() string {  // Foo
    return fmt.Sprintf("%v", x.GetFooNonCompat())
}

// Deprecated: Use NewForwardUsageByRef().GetFoo() instead.
var ForwardUsageByRef_Foo_DEFAULT = NewForwardUsageByRef().GetFoo()

// Deprecated: Use NewForwardUsageByRef().GetFoo() instead.
func (x *ForwardUsageByRef) DefaultGetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
        return NewForwardUsageRoot()
    }
    return x.Foo
}


// Deprecated: Use ForwardUsageByRef.Set* methods instead or set the fields directly.
type ForwardUsageByRefBuilder struct {
    obj *ForwardUsageByRef
}

func NewForwardUsageByRefBuilder() *ForwardUsageByRefBuilder {
    return &ForwardUsageByRefBuilder{
        obj: NewForwardUsageByRef(),
    }
}

func (x *ForwardUsageByRefBuilder) Foo(value *ForwardUsageRoot) *ForwardUsageByRefBuilder {
    x.obj.Foo = value
    return x
}

func (x *ForwardUsageByRefBuilder) Emit() *ForwardUsageByRef {
    var objCopy ForwardUsageByRef = *x.obj
    return &objCopy
}

func (x *ForwardUsageByRef) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("ForwardUsageByRef"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageByRef) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // foo
            expectedType := thrift.Type(thrift.STRUCT)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ForwardUsageByRef) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ForwardUsageByRef({")
    sb.WriteString(fmt.Sprintf("Foo:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type IncompleteMap struct {
    Field map[int32]*IncompleteMapDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &IncompleteMap{}

func NewIncompleteMap() *IncompleteMap {
    return (&IncompleteMap{})
}

func (x *IncompleteMap) GetFieldNonCompat() map[int32]*IncompleteMapDep {
    return x.Field
}

func (x *IncompleteMap) GetField() map[int32]*IncompleteMapDep {
    if !x.IsSetField() {
        return nil
    }

    return x.Field
}

func (x *IncompleteMap) SetFieldNonCompat(value map[int32]*IncompleteMapDep) *IncompleteMap {
    x.Field = value
    return x
}

func (x *IncompleteMap) SetField(value map[int32]*IncompleteMapDep) *IncompleteMap {
    x.Field = value
    return x
}

func (x *IncompleteMap) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *IncompleteMap) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.MAP, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteMapBegin(thrift.I32, thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *IncompleteMap) readField1(p thrift.Protocol) error {  // Field
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]*IncompleteMapDep, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value *IncompleteMapDep
    {
        result := *NewIncompleteMapDep()
err := result.Read(p)
if err != nil {
    return err
}
        value = &result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.SetFieldNonCompat(result)
    return nil
}

func (x *IncompleteMap) toString1() string {  // Field
    return fmt.Sprintf("%v", x.GetFieldNonCompat())
}


// Deprecated: Use IncompleteMap.Set* methods instead or set the fields directly.
type IncompleteMapBuilder struct {
    obj *IncompleteMap
}

func NewIncompleteMapBuilder() *IncompleteMapBuilder {
    return &IncompleteMapBuilder{
        obj: NewIncompleteMap(),
    }
}

func (x *IncompleteMapBuilder) Field(value map[int32]*IncompleteMapDep) *IncompleteMapBuilder {
    x.obj.Field = value
    return x
}

func (x *IncompleteMapBuilder) Emit() *IncompleteMap {
    var objCopy IncompleteMap = *x.obj
    return &objCopy
}

func (x *IncompleteMap) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("IncompleteMap"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteMap) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            expectedType := thrift.Type(thrift.MAP)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *IncompleteMap) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("IncompleteMap({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type IncompleteMapDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &IncompleteMapDep{}

func NewIncompleteMapDep() *IncompleteMapDep {
    return (&IncompleteMapDep{})
}


// Deprecated: Use IncompleteMapDep.Set* methods instead or set the fields directly.
type IncompleteMapDepBuilder struct {
    obj *IncompleteMapDep
}

func NewIncompleteMapDepBuilder() *IncompleteMapDepBuilder {
    return &IncompleteMapDepBuilder{
        obj: NewIncompleteMapDep(),
    }
}

func (x *IncompleteMapDepBuilder) Emit() *IncompleteMapDep {
    var objCopy IncompleteMapDep = *x.obj
    return &objCopy
}

func (x *IncompleteMapDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("IncompleteMapDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteMapDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *IncompleteMapDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("IncompleteMapDep({")
    sb.WriteString("})")

    return sb.String()
}

type CompleteMap struct {
    Field map[int32]*CompleteMapDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &CompleteMap{}

func NewCompleteMap() *CompleteMap {
    return (&CompleteMap{})
}

func (x *CompleteMap) GetFieldNonCompat() map[int32]*CompleteMapDep {
    return x.Field
}

func (x *CompleteMap) GetField() map[int32]*CompleteMapDep {
    if !x.IsSetField() {
        return nil
    }

    return x.Field
}

func (x *CompleteMap) SetFieldNonCompat(value map[int32]*CompleteMapDep) *CompleteMap {
    x.Field = value
    return x
}

func (x *CompleteMap) SetField(value map[int32]*CompleteMapDep) *CompleteMap {
    x.Field = value
    return x
}

func (x *CompleteMap) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *CompleteMap) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.MAP, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteMapBegin(thrift.I32, thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *CompleteMap) readField1(p thrift.Protocol) error {  // Field
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]*CompleteMapDep, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value *CompleteMapDep
    {
        result := *NewCompleteMapDep()
err := result.Read(p)
if err != nil {
    return err
}
        value = &result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.SetFieldNonCompat(result)
    return nil
}

func (x *CompleteMap) toString1() string {  // Field
    return fmt.Sprintf("%v", x.GetFieldNonCompat())
}


// Deprecated: Use CompleteMap.Set* methods instead or set the fields directly.
type CompleteMapBuilder struct {
    obj *CompleteMap
}

func NewCompleteMapBuilder() *CompleteMapBuilder {
    return &CompleteMapBuilder{
        obj: NewCompleteMap(),
    }
}

func (x *CompleteMapBuilder) Field(value map[int32]*CompleteMapDep) *CompleteMapBuilder {
    x.obj.Field = value
    return x
}

func (x *CompleteMapBuilder) Emit() *CompleteMap {
    var objCopy CompleteMap = *x.obj
    return &objCopy
}

func (x *CompleteMap) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("CompleteMap"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteMap) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            expectedType := thrift.Type(thrift.MAP)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *CompleteMap) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("CompleteMap({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type CompleteMapDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &CompleteMapDep{}

func NewCompleteMapDep() *CompleteMapDep {
    return (&CompleteMapDep{})
}


// Deprecated: Use CompleteMapDep.Set* methods instead or set the fields directly.
type CompleteMapDepBuilder struct {
    obj *CompleteMapDep
}

func NewCompleteMapDepBuilder() *CompleteMapDepBuilder {
    return &CompleteMapDepBuilder{
        obj: NewCompleteMapDep(),
    }
}

func (x *CompleteMapDepBuilder) Emit() *CompleteMapDep {
    var objCopy CompleteMapDep = *x.obj
    return &objCopy
}

func (x *CompleteMapDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("CompleteMapDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteMapDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *CompleteMapDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("CompleteMapDep({")
    sb.WriteString("})")

    return sb.String()
}

type IncompleteList struct {
    Field []*IncompleteListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &IncompleteList{}

func NewIncompleteList() *IncompleteList {
    return (&IncompleteList{})
}

func (x *IncompleteList) GetFieldNonCompat() []*IncompleteListDep {
    return x.Field
}

func (x *IncompleteList) GetField() []*IncompleteListDep {
    if !x.IsSetField() {
        return nil
    }

    return x.Field
}

func (x *IncompleteList) SetFieldNonCompat(value []*IncompleteListDep) *IncompleteList {
    x.Field = value
    return x
}

func (x *IncompleteList) SetField(value []*IncompleteListDep) *IncompleteList {
    x.Field = value
    return x
}

func (x *IncompleteList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *IncompleteList) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *IncompleteList) readField1(p thrift.Protocol) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*IncompleteListDep, 0, size)
for i := 0; i < size; i++ {
    var elem IncompleteListDep
    {
        result := *NewIncompleteListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldNonCompat(result)
    return nil
}

func (x *IncompleteList) toString1() string {  // Field
    return fmt.Sprintf("%v", x.GetFieldNonCompat())
}


// Deprecated: Use IncompleteList.Set* methods instead or set the fields directly.
type IncompleteListBuilder struct {
    obj *IncompleteList
}

func NewIncompleteListBuilder() *IncompleteListBuilder {
    return &IncompleteListBuilder{
        obj: NewIncompleteList(),
    }
}

func (x *IncompleteListBuilder) Field(value []*IncompleteListDep) *IncompleteListBuilder {
    x.obj.Field = value
    return x
}

func (x *IncompleteListBuilder) Emit() *IncompleteList {
    var objCopy IncompleteList = *x.obj
    return &objCopy
}

func (x *IncompleteList) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("IncompleteList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteList) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *IncompleteList) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("IncompleteList({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type IncompleteListDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &IncompleteListDep{}

func NewIncompleteListDep() *IncompleteListDep {
    return (&IncompleteListDep{})
}


// Deprecated: Use IncompleteListDep.Set* methods instead or set the fields directly.
type IncompleteListDepBuilder struct {
    obj *IncompleteListDep
}

func NewIncompleteListDepBuilder() *IncompleteListDepBuilder {
    return &IncompleteListDepBuilder{
        obj: NewIncompleteListDep(),
    }
}

func (x *IncompleteListDepBuilder) Emit() *IncompleteListDep {
    var objCopy IncompleteListDep = *x.obj
    return &objCopy
}

func (x *IncompleteListDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("IncompleteListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteListDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *IncompleteListDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("IncompleteListDep({")
    sb.WriteString("})")

    return sb.String()
}

type CompleteList struct {
    Field []*CompleteListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &CompleteList{}

func NewCompleteList() *CompleteList {
    return (&CompleteList{})
}

func (x *CompleteList) GetFieldNonCompat() []*CompleteListDep {
    return x.Field
}

func (x *CompleteList) GetField() []*CompleteListDep {
    if !x.IsSetField() {
        return nil
    }

    return x.Field
}

func (x *CompleteList) SetFieldNonCompat(value []*CompleteListDep) *CompleteList {
    x.Field = value
    return x
}

func (x *CompleteList) SetField(value []*CompleteListDep) *CompleteList {
    x.Field = value
    return x
}

func (x *CompleteList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *CompleteList) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *CompleteList) readField1(p thrift.Protocol) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*CompleteListDep, 0, size)
for i := 0; i < size; i++ {
    var elem CompleteListDep
    {
        result := *NewCompleteListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldNonCompat(result)
    return nil
}

func (x *CompleteList) toString1() string {  // Field
    return fmt.Sprintf("%v", x.GetFieldNonCompat())
}


// Deprecated: Use CompleteList.Set* methods instead or set the fields directly.
type CompleteListBuilder struct {
    obj *CompleteList
}

func NewCompleteListBuilder() *CompleteListBuilder {
    return &CompleteListBuilder{
        obj: NewCompleteList(),
    }
}

func (x *CompleteListBuilder) Field(value []*CompleteListDep) *CompleteListBuilder {
    x.obj.Field = value
    return x
}

func (x *CompleteListBuilder) Emit() *CompleteList {
    var objCopy CompleteList = *x.obj
    return &objCopy
}

func (x *CompleteList) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("CompleteList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteList) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *CompleteList) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("CompleteList({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type CompleteListDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &CompleteListDep{}

func NewCompleteListDep() *CompleteListDep {
    return (&CompleteListDep{})
}


// Deprecated: Use CompleteListDep.Set* methods instead or set the fields directly.
type CompleteListDepBuilder struct {
    obj *CompleteListDep
}

func NewCompleteListDepBuilder() *CompleteListDepBuilder {
    return &CompleteListDepBuilder{
        obj: NewCompleteListDep(),
    }
}

func (x *CompleteListDepBuilder) Emit() *CompleteListDep {
    var objCopy CompleteListDep = *x.obj
    return &objCopy
}

func (x *CompleteListDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("CompleteListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteListDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *CompleteListDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("CompleteListDep({")
    sb.WriteString("})")

    return sb.String()
}

type AdaptedList struct {
    Field []*AdaptedListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &AdaptedList{}

func NewAdaptedList() *AdaptedList {
    return (&AdaptedList{})
}

func (x *AdaptedList) GetFieldNonCompat() []*AdaptedListDep {
    return x.Field
}

func (x *AdaptedList) GetField() []*AdaptedListDep {
    if !x.IsSetField() {
        return nil
    }

    return x.Field
}

func (x *AdaptedList) SetFieldNonCompat(value []*AdaptedListDep) *AdaptedList {
    x.Field = value
    return x
}

func (x *AdaptedList) SetField(value []*AdaptedListDep) *AdaptedList {
    x.Field = value
    return x
}

func (x *AdaptedList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *AdaptedList) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AdaptedList) readField1(p thrift.Protocol) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*AdaptedListDep, 0, size)
for i := 0; i < size; i++ {
    var elem AdaptedListDep
    {
        result := *NewAdaptedListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldNonCompat(result)
    return nil
}

func (x *AdaptedList) toString1() string {  // Field
    return fmt.Sprintf("%v", x.GetFieldNonCompat())
}


// Deprecated: Use AdaptedList.Set* methods instead or set the fields directly.
type AdaptedListBuilder struct {
    obj *AdaptedList
}

func NewAdaptedListBuilder() *AdaptedListBuilder {
    return &AdaptedListBuilder{
        obj: NewAdaptedList(),
    }
}

func (x *AdaptedListBuilder) Field(value []*AdaptedListDep) *AdaptedListBuilder {
    x.obj.Field = value
    return x
}

func (x *AdaptedListBuilder) Emit() *AdaptedList {
    var objCopy AdaptedList = *x.obj
    return &objCopy
}

func (x *AdaptedList) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AdaptedList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AdaptedList) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AdaptedList) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("AdaptedList({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type AdaptedListDep struct {
    Field *AdaptedList `thrift:"field,1" json:"field" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &AdaptedListDep{}

func NewAdaptedListDep() *AdaptedListDep {
    return (&AdaptedListDep{}).
        SetFieldNonCompat(*NewAdaptedList())
}

func (x *AdaptedListDep) GetFieldNonCompat() *AdaptedList {
    return x.Field
}

func (x *AdaptedListDep) GetField() *AdaptedList {
    if !x.IsSetField() {
        return nil
    }

    return x.Field
}

func (x *AdaptedListDep) SetFieldNonCompat(value AdaptedList) *AdaptedListDep {
    x.Field = &value
    return x
}

func (x *AdaptedListDep) SetField(value *AdaptedList) *AdaptedListDep {
    x.Field = value
    return x
}

func (x *AdaptedListDep) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *AdaptedListDep) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AdaptedListDep) readField1(p thrift.Protocol) error {  // Field
    result := *NewAdaptedList()
err := result.Read(p)
if err != nil {
    return err
}

    x.SetFieldNonCompat(result)
    return nil
}

func (x *AdaptedListDep) toString1() string {  // Field
    return fmt.Sprintf("%v", x.GetFieldNonCompat())
}

// Deprecated: Use NewAdaptedListDep().GetField() instead.
var AdaptedListDep_Field_DEFAULT = NewAdaptedListDep().GetField()

// Deprecated: Use NewAdaptedListDep().GetField() instead.
func (x *AdaptedListDep) DefaultGetField() *AdaptedList {
    if !x.IsSetField() {
        return NewAdaptedList()
    }
    return x.Field
}


// Deprecated: Use AdaptedListDep.Set* methods instead or set the fields directly.
type AdaptedListDepBuilder struct {
    obj *AdaptedListDep
}

func NewAdaptedListDepBuilder() *AdaptedListDepBuilder {
    return &AdaptedListDepBuilder{
        obj: NewAdaptedListDep(),
    }
}

func (x *AdaptedListDepBuilder) Field(value *AdaptedList) *AdaptedListDepBuilder {
    x.obj.Field = value
    return x
}

func (x *AdaptedListDepBuilder) Emit() *AdaptedListDep {
    var objCopy AdaptedListDep = *x.obj
    return &objCopy
}

func (x *AdaptedListDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AdaptedListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AdaptedListDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            expectedType := thrift.Type(thrift.STRUCT)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AdaptedListDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("AdaptedListDep({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type DependentAdaptedList struct {
    Field []*DependentAdaptedListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &DependentAdaptedList{}

func NewDependentAdaptedList() *DependentAdaptedList {
    return (&DependentAdaptedList{})
}

func (x *DependentAdaptedList) GetFieldNonCompat() []*DependentAdaptedListDep {
    return x.Field
}

func (x *DependentAdaptedList) GetField() []*DependentAdaptedListDep {
    if !x.IsSetField() {
        return nil
    }

    return x.Field
}

func (x *DependentAdaptedList) SetFieldNonCompat(value []*DependentAdaptedListDep) *DependentAdaptedList {
    x.Field = value
    return x
}

func (x *DependentAdaptedList) SetField(value []*DependentAdaptedListDep) *DependentAdaptedList {
    x.Field = value
    return x
}

func (x *DependentAdaptedList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *DependentAdaptedList) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetFieldNonCompat()
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedList) readField1(p thrift.Protocol) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*DependentAdaptedListDep, 0, size)
for i := 0; i < size; i++ {
    var elem DependentAdaptedListDep
    {
        result := *NewDependentAdaptedListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetFieldNonCompat(result)
    return nil
}

func (x *DependentAdaptedList) toString1() string {  // Field
    return fmt.Sprintf("%v", x.GetFieldNonCompat())
}


// Deprecated: Use DependentAdaptedList.Set* methods instead or set the fields directly.
type DependentAdaptedListBuilder struct {
    obj *DependentAdaptedList
}

func NewDependentAdaptedListBuilder() *DependentAdaptedListBuilder {
    return &DependentAdaptedListBuilder{
        obj: NewDependentAdaptedList(),
    }
}

func (x *DependentAdaptedListBuilder) Field(value []*DependentAdaptedListDep) *DependentAdaptedListBuilder {
    x.obj.Field = value
    return x
}

func (x *DependentAdaptedListBuilder) Emit() *DependentAdaptedList {
    var objCopy DependentAdaptedList = *x.obj
    return &objCopy
}

func (x *DependentAdaptedList) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("DependentAdaptedList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedList) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *DependentAdaptedList) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("DependentAdaptedList({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type DependentAdaptedListDep struct {
    Field *int16 `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &DependentAdaptedListDep{}

func NewDependentAdaptedListDep() *DependentAdaptedListDep {
    return (&DependentAdaptedListDep{})
}

func (x *DependentAdaptedListDep) GetFieldNonCompat() *int16 {
    return x.Field
}

func (x *DependentAdaptedListDep) GetField() int16 {
    if !x.IsSetField() {
        return 0
    }

    return *x.Field
}

func (x *DependentAdaptedListDep) SetFieldNonCompat(value int16) *DependentAdaptedListDep {
    x.Field = &value
    return x
}

func (x *DependentAdaptedListDep) SetField(value *int16) *DependentAdaptedListDep {
    x.Field = value
    return x
}

func (x *DependentAdaptedListDep) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *DependentAdaptedListDep) writeField1(p thrift.Protocol) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.I16, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetFieldNonCompat()
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedListDep) readField1(p thrift.Protocol) error {  // Field
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.SetFieldNonCompat(result)
    return nil
}

func (x *DependentAdaptedListDep) toString1() string {  // Field
    if x.IsSetField() {
        return fmt.Sprintf("%v", *x.GetFieldNonCompat())
    }
    return fmt.Sprintf("%v", x.GetFieldNonCompat())
}

// Deprecated: Use NewDependentAdaptedListDep().GetField() instead.
var DependentAdaptedListDep_Field_DEFAULT = NewDependentAdaptedListDep().GetField()


// Deprecated: Use DependentAdaptedListDep.Set* methods instead or set the fields directly.
type DependentAdaptedListDepBuilder struct {
    obj *DependentAdaptedListDep
}

func NewDependentAdaptedListDepBuilder() *DependentAdaptedListDepBuilder {
    return &DependentAdaptedListDepBuilder{
        obj: NewDependentAdaptedListDep(),
    }
}

func (x *DependentAdaptedListDepBuilder) Field(value *int16) *DependentAdaptedListDepBuilder {
    x.obj.Field = value
    return x
}

func (x *DependentAdaptedListDepBuilder) Emit() *DependentAdaptedListDep {
    var objCopy DependentAdaptedListDep = *x.obj
    return &objCopy
}

func (x *DependentAdaptedListDep) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("DependentAdaptedListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedListDep) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // field
            expectedType := thrift.Type(thrift.I16)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *DependentAdaptedListDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("DependentAdaptedListDep({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type AllocatorAware struct {
    AaList []int32 `thrift:"aa_list,1" json:"aa_list" db:"aa_list"`
    AaSet []int32 `thrift:"aa_set,2" json:"aa_set" db:"aa_set"`
    AaMap map[int32]int32 `thrift:"aa_map,3" json:"aa_map" db:"aa_map"`
    AaString string `thrift:"aa_string,4" json:"aa_string" db:"aa_string"`
    NotAContainer int32 `thrift:"not_a_container,5" json:"not_a_container" db:"not_a_container"`
    AaUnique int32 `thrift:"aa_unique,6" json:"aa_unique" db:"aa_unique"`
    AaShared int32 `thrift:"aa_shared,7" json:"aa_shared" db:"aa_shared"`
}
// Compile time interface enforcer
var _ thrift.Struct = &AllocatorAware{}

func NewAllocatorAware() *AllocatorAware {
    return (&AllocatorAware{}).
        SetAaListNonCompat(nil).
        SetAaSetNonCompat(nil).
        SetAaMapNonCompat(nil).
        SetAaStringNonCompat("").
        SetNotAContainerNonCompat(0).
        SetAaUniqueNonCompat(0).
        SetAaSharedNonCompat(0)
}

func (x *AllocatorAware) GetAaListNonCompat() []int32 {
    return x.AaList
}

func (x *AllocatorAware) GetAaList() []int32 {
    if !x.IsSetAaList() {
        return nil
    }

    return x.AaList
}

func (x *AllocatorAware) GetAaSetNonCompat() []int32 {
    return x.AaSet
}

func (x *AllocatorAware) GetAaSet() []int32 {
    if !x.IsSetAaSet() {
        return nil
    }

    return x.AaSet
}

func (x *AllocatorAware) GetAaMapNonCompat() map[int32]int32 {
    return x.AaMap
}

func (x *AllocatorAware) GetAaMap() map[int32]int32 {
    if !x.IsSetAaMap() {
        return nil
    }

    return x.AaMap
}

func (x *AllocatorAware) GetAaStringNonCompat() string {
    return x.AaString
}

func (x *AllocatorAware) GetAaString() string {
    return x.AaString
}

func (x *AllocatorAware) GetNotAContainerNonCompat() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware) GetNotAContainer() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware) GetAaUniqueNonCompat() int32 {
    return x.AaUnique
}

func (x *AllocatorAware) GetAaUnique() int32 {
    return x.AaUnique
}

func (x *AllocatorAware) GetAaSharedNonCompat() int32 {
    return x.AaShared
}

func (x *AllocatorAware) GetAaShared() int32 {
    return x.AaShared
}

func (x *AllocatorAware) SetAaListNonCompat(value []int32) *AllocatorAware {
    x.AaList = value
    return x
}

func (x *AllocatorAware) SetAaList(value []int32) *AllocatorAware {
    x.AaList = value
    return x
}

func (x *AllocatorAware) SetAaSetNonCompat(value []int32) *AllocatorAware {
    x.AaSet = value
    return x
}

func (x *AllocatorAware) SetAaSet(value []int32) *AllocatorAware {
    x.AaSet = value
    return x
}

func (x *AllocatorAware) SetAaMapNonCompat(value map[int32]int32) *AllocatorAware {
    x.AaMap = value
    return x
}

func (x *AllocatorAware) SetAaMap(value map[int32]int32) *AllocatorAware {
    x.AaMap = value
    return x
}

func (x *AllocatorAware) SetAaStringNonCompat(value string) *AllocatorAware {
    x.AaString = value
    return x
}

func (x *AllocatorAware) SetAaString(value string) *AllocatorAware {
    x.AaString = value
    return x
}

func (x *AllocatorAware) SetNotAContainerNonCompat(value int32) *AllocatorAware {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware) SetNotAContainer(value int32) *AllocatorAware {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware) SetAaUniqueNonCompat(value int32) *AllocatorAware {
    x.AaUnique = value
    return x
}

func (x *AllocatorAware) SetAaUnique(value int32) *AllocatorAware {
    x.AaUnique = value
    return x
}

func (x *AllocatorAware) SetAaSharedNonCompat(value int32) *AllocatorAware {
    x.AaShared = value
    return x
}

func (x *AllocatorAware) SetAaShared(value int32) *AllocatorAware {
    x.AaShared = value
    return x
}

func (x *AllocatorAware) IsSetAaList() bool {
    return x != nil && x.AaList != nil
}

func (x *AllocatorAware) IsSetAaSet() bool {
    return x != nil && x.AaSet != nil
}

func (x *AllocatorAware) IsSetAaMap() bool {
    return x != nil && x.AaMap != nil
}

func (x *AllocatorAware) writeField1(p thrift.Protocol) error {  // AaList
    if !x.IsSetAaList() {
        return nil
    }

    if err := p.WriteFieldBegin("aa_list", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaListNonCompat()
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField2(p thrift.Protocol) error {  // AaSet
    if !x.IsSetAaSet() {
        return nil
    }

    if err := p.WriteFieldBegin("aa_set", thrift.SET, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaSetNonCompat()
    if err := p.WriteSetBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteSetEnd(); err != nil {
    return thrift.PrependError("error writing set end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField3(p thrift.Protocol) error {  // AaMap
    if !x.IsSetAaMap() {
        return nil
    }

    if err := p.WriteFieldBegin("aa_map", thrift.MAP, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaMapNonCompat()
    if err := p.WriteMapBegin(thrift.I32, thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField4(p thrift.Protocol) error {  // AaString
    if err := p.WriteFieldBegin("aa_string", thrift.STRING, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaStringNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField5(p thrift.Protocol) error {  // NotAContainer
    if err := p.WriteFieldBegin("not_a_container", thrift.I32, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNotAContainerNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField6(p thrift.Protocol) error {  // AaUnique
    if err := p.WriteFieldBegin("aa_unique", thrift.I32, 6); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaUniqueNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField7(p thrift.Protocol) error {  // AaShared
    if err := p.WriteFieldBegin("aa_shared", thrift.I32, 7); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAaSharedNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) readField1(p thrift.Protocol) error {  // AaList
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.SetAaListNonCompat(result)
    return nil
}

func (x *AllocatorAware) readField2(p thrift.Protocol) error {  // AaSet
    _ /* elemType */, size, err := p.ReadSetBegin()
if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
}

setResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    setResult = append(setResult, elem)
}

if err := p.ReadSetEnd(); err != nil {
    return thrift.PrependError("error reading set end: ", err)
}
result := setResult

    x.SetAaSetNonCompat(result)
    return nil
}

func (x *AllocatorAware) readField3(p thrift.Protocol) error {  // AaMap
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]int32, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        value = result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.SetAaMapNonCompat(result)
    return nil
}

func (x *AllocatorAware) readField4(p thrift.Protocol) error {  // AaString
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetAaStringNonCompat(result)
    return nil
}

func (x *AllocatorAware) readField5(p thrift.Protocol) error {  // NotAContainer
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetNotAContainerNonCompat(result)
    return nil
}

func (x *AllocatorAware) readField6(p thrift.Protocol) error {  // AaUnique
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetAaUniqueNonCompat(result)
    return nil
}

func (x *AllocatorAware) readField7(p thrift.Protocol) error {  // AaShared
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetAaSharedNonCompat(result)
    return nil
}

func (x *AllocatorAware) toString1() string {  // AaList
    return fmt.Sprintf("%v", x.GetAaListNonCompat())
}

func (x *AllocatorAware) toString2() string {  // AaSet
    return fmt.Sprintf("%v", x.GetAaSetNonCompat())
}

func (x *AllocatorAware) toString3() string {  // AaMap
    return fmt.Sprintf("%v", x.GetAaMapNonCompat())
}

func (x *AllocatorAware) toString4() string {  // AaString
    return fmt.Sprintf("%v", x.GetAaStringNonCompat())
}

func (x *AllocatorAware) toString5() string {  // NotAContainer
    return fmt.Sprintf("%v", x.GetNotAContainerNonCompat())
}

func (x *AllocatorAware) toString6() string {  // AaUnique
    return fmt.Sprintf("%v", x.GetAaUniqueNonCompat())
}

func (x *AllocatorAware) toString7() string {  // AaShared
    return fmt.Sprintf("%v", x.GetAaSharedNonCompat())
}


// Deprecated: Use AllocatorAware.Set* methods instead or set the fields directly.
type AllocatorAwareBuilder struct {
    obj *AllocatorAware
}

func NewAllocatorAwareBuilder() *AllocatorAwareBuilder {
    return &AllocatorAwareBuilder{
        obj: NewAllocatorAware(),
    }
}

func (x *AllocatorAwareBuilder) AaList(value []int32) *AllocatorAwareBuilder {
    x.obj.AaList = value
    return x
}

func (x *AllocatorAwareBuilder) AaSet(value []int32) *AllocatorAwareBuilder {
    x.obj.AaSet = value
    return x
}

func (x *AllocatorAwareBuilder) AaMap(value map[int32]int32) *AllocatorAwareBuilder {
    x.obj.AaMap = value
    return x
}

func (x *AllocatorAwareBuilder) AaString(value string) *AllocatorAwareBuilder {
    x.obj.AaString = value
    return x
}

func (x *AllocatorAwareBuilder) NotAContainer(value int32) *AllocatorAwareBuilder {
    x.obj.NotAContainer = value
    return x
}

func (x *AllocatorAwareBuilder) AaUnique(value int32) *AllocatorAwareBuilder {
    x.obj.AaUnique = value
    return x
}

func (x *AllocatorAwareBuilder) AaShared(value int32) *AllocatorAwareBuilder {
    x.obj.AaShared = value
    return x
}

func (x *AllocatorAwareBuilder) Emit() *AllocatorAware {
    var objCopy AllocatorAware = *x.obj
    return &objCopy
}

func (x *AllocatorAware) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AllocatorAware"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := x.writeField6(p); err != nil {
        return err
    }

    if err := x.writeField7(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // aa_list
            expectedType := thrift.Type(thrift.LIST)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // aa_set
            expectedType := thrift.Type(thrift.SET)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 3:  // aa_map
            expectedType := thrift.Type(thrift.MAP)
            if wireType == expectedType {
                if err := x.readField3(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 4:  // aa_string
            expectedType := thrift.Type(thrift.STRING)
            if wireType == expectedType {
                if err := x.readField4(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 5:  // not_a_container
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField5(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 6:  // aa_unique
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField6(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 7:  // aa_shared
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField7(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AllocatorAware) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("AllocatorAware({")
    sb.WriteString(fmt.Sprintf("AaList:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("AaSet:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("AaMap:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("AaString:%s ", x.toString4()))
    sb.WriteString(fmt.Sprintf("NotAContainer:%s ", x.toString5()))
    sb.WriteString(fmt.Sprintf("AaUnique:%s ", x.toString6()))
    sb.WriteString(fmt.Sprintf("AaShared:%s", x.toString7()))
    sb.WriteString("})")

    return sb.String()
}

type AllocatorAware2 struct {
    NotAContainer int32 `thrift:"not_a_container,1" json:"not_a_container" db:"not_a_container"`
    BoxField *int32 `thrift:"box_field,2,optional" json:"box_field,omitempty" db:"box_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &AllocatorAware2{}

func NewAllocatorAware2() *AllocatorAware2 {
    return (&AllocatorAware2{}).
        SetNotAContainerNonCompat(0)
}

func (x *AllocatorAware2) GetNotAContainerNonCompat() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware2) GetNotAContainer() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware2) GetBoxFieldNonCompat() *int32 {
    return x.BoxField
}

func (x *AllocatorAware2) GetBoxField() int32 {
    if !x.IsSetBoxField() {
        return 0
    }

    return *x.BoxField
}

func (x *AllocatorAware2) SetNotAContainerNonCompat(value int32) *AllocatorAware2 {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware2) SetNotAContainer(value int32) *AllocatorAware2 {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware2) SetBoxFieldNonCompat(value int32) *AllocatorAware2 {
    x.BoxField = &value
    return x
}

func (x *AllocatorAware2) SetBoxField(value *int32) *AllocatorAware2 {
    x.BoxField = value
    return x
}

func (x *AllocatorAware2) IsSetBoxField() bool {
    return x != nil && x.BoxField != nil
}

func (x *AllocatorAware2) writeField1(p thrift.Protocol) error {  // NotAContainer
    if err := p.WriteFieldBegin("not_a_container", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetNotAContainerNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware2) writeField2(p thrift.Protocol) error {  // BoxField
    if !x.IsSetBoxField() {
        return nil
    }

    if err := p.WriteFieldBegin("box_field", thrift.I32, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetBoxFieldNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware2) readField1(p thrift.Protocol) error {  // NotAContainer
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetNotAContainerNonCompat(result)
    return nil
}

func (x *AllocatorAware2) readField2(p thrift.Protocol) error {  // BoxField
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetBoxFieldNonCompat(result)
    return nil
}

func (x *AllocatorAware2) toString1() string {  // NotAContainer
    return fmt.Sprintf("%v", x.GetNotAContainerNonCompat())
}

func (x *AllocatorAware2) toString2() string {  // BoxField
    if x.IsSetBoxField() {
        return fmt.Sprintf("%v", *x.GetBoxFieldNonCompat())
    }
    return fmt.Sprintf("%v", x.GetBoxFieldNonCompat())
}

// Deprecated: Use NewAllocatorAware2().GetBoxField() instead.
var AllocatorAware2_BoxField_DEFAULT = NewAllocatorAware2().GetBoxField()


// Deprecated: Use AllocatorAware2.Set* methods instead or set the fields directly.
type AllocatorAware2Builder struct {
    obj *AllocatorAware2
}

func NewAllocatorAware2Builder() *AllocatorAware2Builder {
    return &AllocatorAware2Builder{
        obj: NewAllocatorAware2(),
    }
}

func (x *AllocatorAware2Builder) NotAContainer(value int32) *AllocatorAware2Builder {
    x.obj.NotAContainer = value
    return x
}

func (x *AllocatorAware2Builder) BoxField(value *int32) *AllocatorAware2Builder {
    x.obj.BoxField = value
    return x
}

func (x *AllocatorAware2Builder) Emit() *AllocatorAware2 {
    var objCopy AllocatorAware2 = *x.obj
    return &objCopy
}

func (x *AllocatorAware2) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AllocatorAware2"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware2) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // not_a_container
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // box_field
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AllocatorAware2) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("AllocatorAware2({")
    sb.WriteString(fmt.Sprintf("NotAContainer:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("BoxField:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type TypedefStruct struct {
    I32Field int32 `thrift:"i32_field,1" json:"i32_field" db:"i32_field"`
    IntTypedefField IntTypedef `thrift:"IntTypedef_field,2" json:"IntTypedef_field" db:"IntTypedef_field"`
    UintTypedefField UintTypedef `thrift:"UintTypedef_field,3" json:"UintTypedef_field" db:"UintTypedef_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &TypedefStruct{}

func NewTypedefStruct() *TypedefStruct {
    return (&TypedefStruct{}).
        SetI32FieldNonCompat(0).
        SetIntTypedefFieldNonCompat(NewIntTypedef()).
        SetUintTypedefFieldNonCompat(NewUintTypedef())
}

func (x *TypedefStruct) GetI32FieldNonCompat() int32 {
    return x.I32Field
}

func (x *TypedefStruct) GetI32Field() int32 {
    return x.I32Field
}

func (x *TypedefStruct) GetIntTypedefFieldNonCompat() IntTypedef {
    return x.IntTypedefField
}

func (x *TypedefStruct) GetIntTypedefField() IntTypedef {
    return x.IntTypedefField
}

func (x *TypedefStruct) GetUintTypedefFieldNonCompat() UintTypedef {
    return x.UintTypedefField
}

func (x *TypedefStruct) GetUintTypedefField() UintTypedef {
    return x.UintTypedefField
}

func (x *TypedefStruct) SetI32FieldNonCompat(value int32) *TypedefStruct {
    x.I32Field = value
    return x
}

func (x *TypedefStruct) SetI32Field(value int32) *TypedefStruct {
    x.I32Field = value
    return x
}

func (x *TypedefStruct) SetIntTypedefFieldNonCompat(value IntTypedef) *TypedefStruct {
    x.IntTypedefField = value
    return x
}

func (x *TypedefStruct) SetIntTypedefField(value IntTypedef) *TypedefStruct {
    x.IntTypedefField = value
    return x
}

func (x *TypedefStruct) SetUintTypedefFieldNonCompat(value UintTypedef) *TypedefStruct {
    x.UintTypedefField = value
    return x
}

func (x *TypedefStruct) SetUintTypedefField(value UintTypedef) *TypedefStruct {
    x.UintTypedefField = value
    return x
}

func (x *TypedefStruct) writeField1(p thrift.Protocol) error {  // I32Field
    if err := p.WriteFieldBegin("i32_field", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetI32FieldNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) writeField2(p thrift.Protocol) error {  // IntTypedefField
    if err := p.WriteFieldBegin("IntTypedef_field", thrift.I32, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetIntTypedefFieldNonCompat()
    err := WriteIntTypedef(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) writeField3(p thrift.Protocol) error {  // UintTypedefField
    if err := p.WriteFieldBegin("UintTypedef_field", thrift.I32, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetUintTypedefFieldNonCompat()
    err := WriteUintTypedef(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) readField1(p thrift.Protocol) error {  // I32Field
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetI32FieldNonCompat(result)
    return nil
}

func (x *TypedefStruct) readField2(p thrift.Protocol) error {  // IntTypedefField
    result, err := ReadIntTypedef(p)
if err != nil {
    return err
}

    x.SetIntTypedefFieldNonCompat(result)
    return nil
}

func (x *TypedefStruct) readField3(p thrift.Protocol) error {  // UintTypedefField
    result, err := ReadUintTypedef(p)
if err != nil {
    return err
}

    x.SetUintTypedefFieldNonCompat(result)
    return nil
}

func (x *TypedefStruct) toString1() string {  // I32Field
    return fmt.Sprintf("%v", x.GetI32FieldNonCompat())
}

func (x *TypedefStruct) toString2() string {  // IntTypedefField
    return fmt.Sprintf("%v", x.GetIntTypedefFieldNonCompat())
}

func (x *TypedefStruct) toString3() string {  // UintTypedefField
    return fmt.Sprintf("%v", x.GetUintTypedefFieldNonCompat())
}


// Deprecated: Use TypedefStruct.Set* methods instead or set the fields directly.
type TypedefStructBuilder struct {
    obj *TypedefStruct
}

func NewTypedefStructBuilder() *TypedefStructBuilder {
    return &TypedefStructBuilder{
        obj: NewTypedefStruct(),
    }
}

func (x *TypedefStructBuilder) I32Field(value int32) *TypedefStructBuilder {
    x.obj.I32Field = value
    return x
}

func (x *TypedefStructBuilder) IntTypedefField(value IntTypedef) *TypedefStructBuilder {
    x.obj.IntTypedefField = value
    return x
}

func (x *TypedefStructBuilder) UintTypedefField(value UintTypedef) *TypedefStructBuilder {
    x.obj.UintTypedefField = value
    return x
}

func (x *TypedefStructBuilder) Emit() *TypedefStruct {
    var objCopy TypedefStruct = *x.obj
    return &objCopy
}

func (x *TypedefStruct) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("TypedefStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // i32_field
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 2:  // IntTypedef_field
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField2(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        case 3:  // UintTypedef_field
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField3(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *TypedefStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("TypedefStruct({")
    sb.WriteString(fmt.Sprintf("I32Field:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("IntTypedefField:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("UintTypedefField:%s", x.toString3()))
    sb.WriteString("})")

    return sb.String()
}

type StructWithDoubleUnderscores struct {
    _Field int32 `thrift:"__field,1" json:"__field" db:"__field"`
}
// Compile time interface enforcer
var _ thrift.Struct = &StructWithDoubleUnderscores{}

func NewStructWithDoubleUnderscores() *StructWithDoubleUnderscores {
    return (&StructWithDoubleUnderscores{}).
        Set_FieldNonCompat(0)
}

func (x *StructWithDoubleUnderscores) Get_FieldNonCompat() int32 {
    return x._Field
}

func (x *StructWithDoubleUnderscores) Get_Field() int32 {
    return x._Field
}

func (x *StructWithDoubleUnderscores) Set_FieldNonCompat(value int32) *StructWithDoubleUnderscores {
    x._Field = value
    return x
}

func (x *StructWithDoubleUnderscores) Set_Field(value int32) *StructWithDoubleUnderscores {
    x._Field = value
    return x
}

func (x *StructWithDoubleUnderscores) writeField1(p thrift.Protocol) error {  // _Field
    if err := p.WriteFieldBegin("__field", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Get_FieldNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *StructWithDoubleUnderscores) readField1(p thrift.Protocol) error {  // _Field
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.Set_FieldNonCompat(result)
    return nil
}

func (x *StructWithDoubleUnderscores) toString1() string {  // _Field
    return fmt.Sprintf("%v", x.Get_FieldNonCompat())
}


// Deprecated: Use StructWithDoubleUnderscores.Set* methods instead or set the fields directly.
type StructWithDoubleUnderscoresBuilder struct {
    obj *StructWithDoubleUnderscores
}

func NewStructWithDoubleUnderscoresBuilder() *StructWithDoubleUnderscoresBuilder {
    return &StructWithDoubleUnderscoresBuilder{
        obj: NewStructWithDoubleUnderscores(),
    }
}

func (x *StructWithDoubleUnderscoresBuilder) _Field(value int32) *StructWithDoubleUnderscoresBuilder {
    x.obj._Field = value
    return x
}

func (x *StructWithDoubleUnderscoresBuilder) Emit() *StructWithDoubleUnderscores {
    var objCopy StructWithDoubleUnderscores = *x.obj
    return &objCopy
}

func (x *StructWithDoubleUnderscores) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("StructWithDoubleUnderscores"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *StructWithDoubleUnderscores) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // __field
            expectedType := thrift.Type(thrift.I32)
            if wireType == expectedType {
                if err := x.readField1(p); err != nil {
                   return err
                }
            } else {
                if err := p.Skip(wireType); err != nil {
                    return err
                }
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *StructWithDoubleUnderscores) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("StructWithDoubleUnderscores({")
    sb.WriteString(fmt.Sprintf("_Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

// RegisterTypes registers types found in this file that have a thrift_uri with the passed in registry.
func RegisterTypes(registry interface {
	  RegisterType(name string, initializer func() any)
}) {
    registry.RegisterType("apache.org/thrift/fixtures/types/empty_struct", func() any { return NewEmptyStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/decorated_struct", func() any { return NewDecoratedStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ContainerStruct", func() any { return NewContainerStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CppTypeStruct", func() any { return NewCppTypeStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/VirtualStruct", func() any { return NewVirtualStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyStructWithForwardRefEnum", func() any { return NewMyStructWithForwardRefEnum() })
    registry.RegisterType("apache.org/thrift/fixtures/types/TrivialNumeric", func() any { return NewTrivialNumeric() })
    registry.RegisterType("apache.org/thrift/fixtures/types/TrivialNestedWithDefault", func() any { return NewTrivialNestedWithDefault() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ComplexString", func() any { return NewComplexString() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ComplexNestedWithDefault", func() any { return NewComplexNestedWithDefault() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MinPadding", func() any { return NewMinPadding() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MinPaddingWithCustomType", func() any { return NewMinPaddingWithCustomType() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyStruct", func() any { return NewMyStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyDataItem", func() any { return NewMyDataItem() })
    registry.RegisterType("apache.org/thrift/fixtures/types/Renaming", func() any { return NewRenaming() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AnnotatedTypes", func() any { return NewAnnotatedTypes() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ForwardUsageRoot", func() any { return NewForwardUsageRoot() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ForwardUsageStruct", func() any { return NewForwardUsageStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ForwardUsageByRef", func() any { return NewForwardUsageByRef() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteMap", func() any { return NewIncompleteMap() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteMapDep", func() any { return NewIncompleteMapDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteMap", func() any { return NewCompleteMap() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteMapDep", func() any { return NewCompleteMapDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteList", func() any { return NewIncompleteList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteListDep", func() any { return NewIncompleteListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteList", func() any { return NewCompleteList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteListDep", func() any { return NewCompleteListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AdaptedList", func() any { return NewAdaptedList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AdaptedListDep", func() any { return NewAdaptedListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/DependentAdaptedList", func() any { return NewDependentAdaptedList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/DependentAdaptedListDep", func() any { return NewDependentAdaptedListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AllocatorAware", func() any { return NewAllocatorAware() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AllocatorAware2", func() any { return NewAllocatorAware2() })
    registry.RegisterType("apache.org/thrift/fixtures/types/TypedefStruct", func() any { return NewTypedefStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/StructWithDoubleUnderscores", func() any { return NewStructWithDoubleUnderscores() })

    registry.RegisterType("apache.org/thrift/fixtures/types/has_bitwise_ops", func() any { return HasBitwiseOps(0) })
    registry.RegisterType("apache.org/thrift/fixtures/types/is_unscoped", func() any { return IsUnscoped(0) })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyForwardRefEnum", func() any { return MyForwardRefEnum(0) })
}
