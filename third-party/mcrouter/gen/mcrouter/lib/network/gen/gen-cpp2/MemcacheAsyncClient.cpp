/**
 * Autogenerated by Thrift for MemcacheService.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "mcrouter/lib/network/gen/gen-cpp2/MemcacheAsyncClient.h"

#include <thrift/lib/cpp2/gen/client_cpp.h>

namespace facebook { namespace memcache { namespace thrift {
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McAddRequest*>> Memcache_mcAdd_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McAddReply*>> Memcache_mcAdd_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McAppendRequest*>> Memcache_mcAppend_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McAppendReply*>> Memcache_mcAppend_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McCasRequest*>> Memcache_mcCas_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McCasReply*>> Memcache_mcCas_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McDecrRequest*>> Memcache_mcDecr_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McDecrReply*>> Memcache_mcDecr_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McDeleteRequest*>> Memcache_mcDelete_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McDeleteReply*>> Memcache_mcDelete_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McFlushAllRequest*>> Memcache_mcFlushAll_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McFlushAllReply*>> Memcache_mcFlushAll_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McFlushReRequest*>> Memcache_mcFlushRe_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McFlushReReply*>> Memcache_mcFlushRe_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McGatRequest*>> Memcache_mcGat_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McGatReply*>> Memcache_mcGat_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McGatsRequest*>> Memcache_mcGats_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McGatsReply*>> Memcache_mcGats_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McGetRequest*>> Memcache_mcGet_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McGetReply*>> Memcache_mcGet_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McGetsRequest*>> Memcache_mcGets_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McGetsReply*>> Memcache_mcGets_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McIncrRequest*>> Memcache_mcIncr_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McIncrReply*>> Memcache_mcIncr_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McLeaseGetRequest*>> Memcache_mcLeaseGet_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McLeaseGetReply*>> Memcache_mcLeaseGet_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McLeaseSetRequest*>> Memcache_mcLeaseSet_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McLeaseSetReply*>> Memcache_mcLeaseSet_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McMetagetRequest*>> Memcache_mcMetaget_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McMetagetReply*>> Memcache_mcMetaget_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McPrependRequest*>> Memcache_mcPrepend_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McPrependReply*>> Memcache_mcPrepend_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McReplaceRequest*>> Memcache_mcReplace_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McReplaceReply*>> Memcache_mcReplace_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McSetRequest*>> Memcache_mcSet_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McSetReply*>> Memcache_mcSet_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McTouchRequest*>> Memcache_mcTouch_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McTouchReply*>> Memcache_mcTouch_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, facebook::memcache::McVersionRequest*>> Memcache_mcVersion_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, facebook::memcache::McVersionReply*>> Memcache_mcVersion_presult;

template <typename Protocol_>
void MemcacheAsyncClient::mcAddT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McAddRequest& p_request) {

  Memcache_mcAdd_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McAddRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcAdd",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcAppendT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McAppendRequest& p_request) {

  Memcache_mcAppend_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McAppendRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcAppend",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcCasT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McCasRequest& p_request) {

  Memcache_mcCas_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McCasRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcCas",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcDecrT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McDecrRequest& p_request) {

  Memcache_mcDecr_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McDecrRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcDecr",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcDeleteT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McDeleteRequest& p_request) {

  Memcache_mcDelete_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McDeleteRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcDelete",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcFlushAllT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McFlushAllRequest& p_request) {

  Memcache_mcFlushAll_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McFlushAllRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcFlushAll",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcFlushReT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McFlushReRequest& p_request) {

  Memcache_mcFlushRe_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McFlushReRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcFlushRe",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcGatT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McGatRequest& p_request) {

  Memcache_mcGat_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McGatRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcGat",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcGatsT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McGatsRequest& p_request) {

  Memcache_mcGats_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McGatsRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcGats",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcGetT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McGetRequest& p_request) {

  Memcache_mcGet_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McGetRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcGet",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcGetsT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McGetsRequest& p_request) {

  Memcache_mcGets_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McGetsRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcGets",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcIncrT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McIncrRequest& p_request) {

  Memcache_mcIncr_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McIncrRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcIncr",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcLeaseGetT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McLeaseGetRequest& p_request) {

  Memcache_mcLeaseGet_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McLeaseGetRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcLeaseGet",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcLeaseSetT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McLeaseSetRequest& p_request) {

  Memcache_mcLeaseSet_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McLeaseSetRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcLeaseSet",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcMetagetT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McMetagetRequest& p_request) {

  Memcache_mcMetaget_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McMetagetRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcMetaget",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcPrependT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McPrependRequest& p_request) {

  Memcache_mcPrepend_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McPrependRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcPrepend",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcReplaceT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McReplaceRequest& p_request) {

  Memcache_mcReplace_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McReplaceRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcReplace",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcSetT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McSetRequest& p_request) {

  Memcache_mcSet_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McSetRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcSet",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcTouchT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McTouchRequest& p_request) {

  Memcache_mcTouch_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McTouchRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcTouch",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void MemcacheAsyncClient::mcVersionT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McVersionRequest& p_request) {

  Memcache_mcVersion_pargs args;
  args.get<0>().value = const_cast<facebook::memcache::McVersionRequest*>(&p_request);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "mcVersion",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}



void MemcacheAsyncClient::mcAdd(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McAddRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcAdd(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcAdd(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McAddRequest& p_request) {
  auto [ctx, header] = mcAddCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcAddImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcAddImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McAddRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcAddT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcAddT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcAddCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcAdd",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcAdd(facebook::memcache::McAddReply& _return, const facebook::memcache::McAddRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcAdd(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcAdd(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McAddReply& _return, const facebook::memcache::McAddRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcAddCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcAddImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcAdd(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McAddReply>>
MemcacheAsyncClient::sync_complete_mcAdd(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McAddRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcAddCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcAddImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McAddReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcAdd(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McAddReply> MemcacheAsyncClient::future_mcAdd(const facebook::memcache::McAddRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcAdd(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McAddReply> MemcacheAsyncClient::semifuture_mcAdd(const facebook::memcache::McAddRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcAdd(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McAddReply> MemcacheAsyncClient::future_mcAdd(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McAddRequest& p_request) {
  folly::Promise<facebook::memcache::McAddReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McAddReply>>(std::move(promise), recv_wrapped_mcAdd, channel_);
  mcAdd(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McAddReply> MemcacheAsyncClient::semifuture_mcAdd(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McAddRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcAdd, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcAdd(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McAddReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcAdd(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McAddRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McAddReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McAddReply>>(std::move(promise), recv_wrapped_mcAdd, channel_);
  mcAdd(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McAddReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcAdd(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McAddRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcAdd, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcAdd(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcAdd(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McAddRequest& p_request) {
  mcAdd(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcAdd(facebook::memcache::McAddReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcAdd_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcAdd(facebook::memcache::McAddReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcAdd(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcAdd(facebook::memcache::McAddReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcAdd(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcAdd(facebook::memcache::McAddReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcAdd(_return, state);
}

void MemcacheAsyncClient::mcAppend(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McAppendRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcAppend(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcAppend(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McAppendRequest& p_request) {
  auto [ctx, header] = mcAppendCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcAppendImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcAppendImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McAppendRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcAppendT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcAppendT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcAppendCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcAppend",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcAppend(facebook::memcache::McAppendReply& _return, const facebook::memcache::McAppendRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcAppend(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcAppend(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McAppendReply& _return, const facebook::memcache::McAppendRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcAppendCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcAppendImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcAppend(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McAppendReply>>
MemcacheAsyncClient::sync_complete_mcAppend(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McAppendRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcAppendCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcAppendImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McAppendReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcAppend(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McAppendReply> MemcacheAsyncClient::future_mcAppend(const facebook::memcache::McAppendRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcAppend(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McAppendReply> MemcacheAsyncClient::semifuture_mcAppend(const facebook::memcache::McAppendRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcAppend(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McAppendReply> MemcacheAsyncClient::future_mcAppend(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McAppendRequest& p_request) {
  folly::Promise<facebook::memcache::McAppendReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McAppendReply>>(std::move(promise), recv_wrapped_mcAppend, channel_);
  mcAppend(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McAppendReply> MemcacheAsyncClient::semifuture_mcAppend(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McAppendRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcAppend, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcAppend(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McAppendReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcAppend(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McAppendRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McAppendReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McAppendReply>>(std::move(promise), recv_wrapped_mcAppend, channel_);
  mcAppend(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McAppendReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcAppend(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McAppendRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcAppend, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcAppend(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcAppend(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McAppendRequest& p_request) {
  mcAppend(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcAppend(facebook::memcache::McAppendReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcAppend_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcAppend(facebook::memcache::McAppendReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcAppend(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcAppend(facebook::memcache::McAppendReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcAppend(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcAppend(facebook::memcache::McAppendReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcAppend(_return, state);
}

void MemcacheAsyncClient::mcCas(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McCasRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcCas(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcCas(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McCasRequest& p_request) {
  auto [ctx, header] = mcCasCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcCasImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcCasImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McCasRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcCasT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcCasT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcCasCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcCas",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcCas(facebook::memcache::McCasReply& _return, const facebook::memcache::McCasRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcCas(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcCas(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McCasReply& _return, const facebook::memcache::McCasRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcCasCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcCasImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcCas(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McCasReply>>
MemcacheAsyncClient::sync_complete_mcCas(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McCasRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcCasCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcCasImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McCasReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcCas(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McCasReply> MemcacheAsyncClient::future_mcCas(const facebook::memcache::McCasRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcCas(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McCasReply> MemcacheAsyncClient::semifuture_mcCas(const facebook::memcache::McCasRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcCas(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McCasReply> MemcacheAsyncClient::future_mcCas(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McCasRequest& p_request) {
  folly::Promise<facebook::memcache::McCasReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McCasReply>>(std::move(promise), recv_wrapped_mcCas, channel_);
  mcCas(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McCasReply> MemcacheAsyncClient::semifuture_mcCas(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McCasRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcCas, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcCas(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McCasReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcCas(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McCasRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McCasReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McCasReply>>(std::move(promise), recv_wrapped_mcCas, channel_);
  mcCas(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McCasReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcCas(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McCasRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcCas, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcCas(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcCas(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McCasRequest& p_request) {
  mcCas(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcCas(facebook::memcache::McCasReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcCas_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcCas(facebook::memcache::McCasReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcCas(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcCas(facebook::memcache::McCasReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcCas(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcCas(facebook::memcache::McCasReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcCas(_return, state);
}

void MemcacheAsyncClient::mcDecr(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McDecrRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcDecr(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcDecr(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McDecrRequest& p_request) {
  auto [ctx, header] = mcDecrCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcDecrImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcDecrImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McDecrRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcDecrT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcDecrT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcDecrCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcDecr",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcDecr(facebook::memcache::McDecrReply& _return, const facebook::memcache::McDecrRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcDecr(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcDecr(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McDecrReply& _return, const facebook::memcache::McDecrRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcDecrCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcDecrImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcDecr(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McDecrReply>>
MemcacheAsyncClient::sync_complete_mcDecr(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McDecrRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcDecrCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcDecrImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McDecrReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcDecr(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McDecrReply> MemcacheAsyncClient::future_mcDecr(const facebook::memcache::McDecrRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcDecr(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McDecrReply> MemcacheAsyncClient::semifuture_mcDecr(const facebook::memcache::McDecrRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcDecr(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McDecrReply> MemcacheAsyncClient::future_mcDecr(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McDecrRequest& p_request) {
  folly::Promise<facebook::memcache::McDecrReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McDecrReply>>(std::move(promise), recv_wrapped_mcDecr, channel_);
  mcDecr(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McDecrReply> MemcacheAsyncClient::semifuture_mcDecr(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McDecrRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcDecr, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcDecr(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McDecrReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcDecr(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McDecrRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McDecrReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McDecrReply>>(std::move(promise), recv_wrapped_mcDecr, channel_);
  mcDecr(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McDecrReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcDecr(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McDecrRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcDecr, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcDecr(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcDecr(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McDecrRequest& p_request) {
  mcDecr(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcDecr(facebook::memcache::McDecrReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcDecr_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcDecr(facebook::memcache::McDecrReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcDecr(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcDecr(facebook::memcache::McDecrReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcDecr(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcDecr(facebook::memcache::McDecrReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcDecr(_return, state);
}

void MemcacheAsyncClient::mcDelete(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McDeleteRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcDelete(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcDelete(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McDeleteRequest& p_request) {
  auto [ctx, header] = mcDeleteCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcDeleteImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcDeleteImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McDeleteRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcDeleteT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcDeleteT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcDeleteCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcDelete",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcDelete(facebook::memcache::McDeleteReply& _return, const facebook::memcache::McDeleteRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcDelete(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcDelete(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McDeleteReply& _return, const facebook::memcache::McDeleteRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcDeleteCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcDeleteImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcDelete(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McDeleteReply>>
MemcacheAsyncClient::sync_complete_mcDelete(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McDeleteRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcDeleteCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcDeleteImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McDeleteReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcDelete(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McDeleteReply> MemcacheAsyncClient::future_mcDelete(const facebook::memcache::McDeleteRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcDelete(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McDeleteReply> MemcacheAsyncClient::semifuture_mcDelete(const facebook::memcache::McDeleteRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcDelete(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McDeleteReply> MemcacheAsyncClient::future_mcDelete(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McDeleteRequest& p_request) {
  folly::Promise<facebook::memcache::McDeleteReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McDeleteReply>>(std::move(promise), recv_wrapped_mcDelete, channel_);
  mcDelete(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McDeleteReply> MemcacheAsyncClient::semifuture_mcDelete(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McDeleteRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcDelete, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcDelete(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McDeleteReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcDelete(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McDeleteRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McDeleteReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McDeleteReply>>(std::move(promise), recv_wrapped_mcDelete, channel_);
  mcDelete(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McDeleteReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcDelete(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McDeleteRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcDelete, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcDelete(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcDelete(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McDeleteRequest& p_request) {
  mcDelete(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcDelete(facebook::memcache::McDeleteReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcDelete_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcDelete(facebook::memcache::McDeleteReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcDelete(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcDelete(facebook::memcache::McDeleteReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcDelete(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcDelete(facebook::memcache::McDeleteReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcDelete(_return, state);
}

void MemcacheAsyncClient::mcFlushAll(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McFlushAllRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcFlushAll(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcFlushAll(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McFlushAllRequest& p_request) {
  auto [ctx, header] = mcFlushAllCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcFlushAllImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcFlushAllImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McFlushAllRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcFlushAllT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcFlushAllT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcFlushAllCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcFlushAll",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcFlushAll(facebook::memcache::McFlushAllReply& _return, const facebook::memcache::McFlushAllRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcFlushAll(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcFlushAll(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McFlushAllReply& _return, const facebook::memcache::McFlushAllRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcFlushAllCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcFlushAllImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcFlushAll(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McFlushAllReply>>
MemcacheAsyncClient::sync_complete_mcFlushAll(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McFlushAllRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcFlushAllCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcFlushAllImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McFlushAllReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcFlushAll(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McFlushAllReply> MemcacheAsyncClient::future_mcFlushAll(const facebook::memcache::McFlushAllRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcFlushAll(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McFlushAllReply> MemcacheAsyncClient::semifuture_mcFlushAll(const facebook::memcache::McFlushAllRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcFlushAll(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McFlushAllReply> MemcacheAsyncClient::future_mcFlushAll(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McFlushAllRequest& p_request) {
  folly::Promise<facebook::memcache::McFlushAllReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McFlushAllReply>>(std::move(promise), recv_wrapped_mcFlushAll, channel_);
  mcFlushAll(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McFlushAllReply> MemcacheAsyncClient::semifuture_mcFlushAll(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McFlushAllRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcFlushAll, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcFlushAll(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McFlushAllReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcFlushAll(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McFlushAllRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McFlushAllReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McFlushAllReply>>(std::move(promise), recv_wrapped_mcFlushAll, channel_);
  mcFlushAll(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McFlushAllReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcFlushAll(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McFlushAllRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcFlushAll, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcFlushAll(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcFlushAll(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McFlushAllRequest& p_request) {
  mcFlushAll(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcFlushAll(facebook::memcache::McFlushAllReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcFlushAll_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcFlushAll(facebook::memcache::McFlushAllReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcFlushAll(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcFlushAll(facebook::memcache::McFlushAllReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcFlushAll(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcFlushAll(facebook::memcache::McFlushAllReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcFlushAll(_return, state);
}

void MemcacheAsyncClient::mcFlushRe(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McFlushReRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcFlushRe(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcFlushRe(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McFlushReRequest& p_request) {
  auto [ctx, header] = mcFlushReCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcFlushReImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcFlushReImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McFlushReRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcFlushReT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcFlushReT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcFlushReCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcFlushRe",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcFlushRe(facebook::memcache::McFlushReReply& _return, const facebook::memcache::McFlushReRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcFlushRe(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcFlushRe(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McFlushReReply& _return, const facebook::memcache::McFlushReRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcFlushReCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcFlushReImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcFlushRe(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McFlushReReply>>
MemcacheAsyncClient::sync_complete_mcFlushRe(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McFlushReRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcFlushReCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcFlushReImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McFlushReReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcFlushRe(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McFlushReReply> MemcacheAsyncClient::future_mcFlushRe(const facebook::memcache::McFlushReRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcFlushRe(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McFlushReReply> MemcacheAsyncClient::semifuture_mcFlushRe(const facebook::memcache::McFlushReRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcFlushRe(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McFlushReReply> MemcacheAsyncClient::future_mcFlushRe(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McFlushReRequest& p_request) {
  folly::Promise<facebook::memcache::McFlushReReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McFlushReReply>>(std::move(promise), recv_wrapped_mcFlushRe, channel_);
  mcFlushRe(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McFlushReReply> MemcacheAsyncClient::semifuture_mcFlushRe(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McFlushReRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcFlushRe, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcFlushRe(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McFlushReReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcFlushRe(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McFlushReRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McFlushReReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McFlushReReply>>(std::move(promise), recv_wrapped_mcFlushRe, channel_);
  mcFlushRe(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McFlushReReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcFlushRe(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McFlushReRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcFlushRe, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcFlushRe(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcFlushRe(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McFlushReRequest& p_request) {
  mcFlushRe(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcFlushRe(facebook::memcache::McFlushReReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcFlushRe_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcFlushRe(facebook::memcache::McFlushReReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcFlushRe(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcFlushRe(facebook::memcache::McFlushReReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcFlushRe(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcFlushRe(facebook::memcache::McFlushReReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcFlushRe(_return, state);
}

void MemcacheAsyncClient::mcGat(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McGatRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcGat(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcGat(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McGatRequest& p_request) {
  auto [ctx, header] = mcGatCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcGatImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcGatImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McGatRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcGatT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcGatT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcGatCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcGat",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcGat(facebook::memcache::McGatReply& _return, const facebook::memcache::McGatRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcGat(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcGat(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McGatReply& _return, const facebook::memcache::McGatRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcGatCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcGatImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcGat(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McGatReply>>
MemcacheAsyncClient::sync_complete_mcGat(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McGatRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcGatCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcGatImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McGatReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcGat(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McGatReply> MemcacheAsyncClient::future_mcGat(const facebook::memcache::McGatRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcGat(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McGatReply> MemcacheAsyncClient::semifuture_mcGat(const facebook::memcache::McGatRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcGat(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McGatReply> MemcacheAsyncClient::future_mcGat(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGatRequest& p_request) {
  folly::Promise<facebook::memcache::McGatReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McGatReply>>(std::move(promise), recv_wrapped_mcGat, channel_);
  mcGat(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McGatReply> MemcacheAsyncClient::semifuture_mcGat(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGatRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcGat, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcGat(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McGatReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcGat(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGatRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McGatReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McGatReply>>(std::move(promise), recv_wrapped_mcGat, channel_);
  mcGat(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McGatReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcGat(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGatRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcGat, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcGat(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcGat(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McGatRequest& p_request) {
  mcGat(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcGat(facebook::memcache::McGatReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcGat_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcGat(facebook::memcache::McGatReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcGat(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcGat(facebook::memcache::McGatReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcGat(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcGat(facebook::memcache::McGatReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcGat(_return, state);
}

void MemcacheAsyncClient::mcGats(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McGatsRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcGats(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcGats(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McGatsRequest& p_request) {
  auto [ctx, header] = mcGatsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcGatsImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcGatsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McGatsRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcGatsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcGatsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcGatsCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcGats",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcGats(facebook::memcache::McGatsReply& _return, const facebook::memcache::McGatsRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcGats(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcGats(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McGatsReply& _return, const facebook::memcache::McGatsRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcGatsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcGatsImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcGats(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McGatsReply>>
MemcacheAsyncClient::sync_complete_mcGats(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McGatsRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcGatsCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcGatsImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McGatsReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcGats(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McGatsReply> MemcacheAsyncClient::future_mcGats(const facebook::memcache::McGatsRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcGats(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McGatsReply> MemcacheAsyncClient::semifuture_mcGats(const facebook::memcache::McGatsRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcGats(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McGatsReply> MemcacheAsyncClient::future_mcGats(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGatsRequest& p_request) {
  folly::Promise<facebook::memcache::McGatsReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McGatsReply>>(std::move(promise), recv_wrapped_mcGats, channel_);
  mcGats(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McGatsReply> MemcacheAsyncClient::semifuture_mcGats(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGatsRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcGats, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcGats(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McGatsReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcGats(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGatsRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McGatsReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McGatsReply>>(std::move(promise), recv_wrapped_mcGats, channel_);
  mcGats(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McGatsReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcGats(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGatsRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcGats, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcGats(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcGats(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McGatsRequest& p_request) {
  mcGats(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcGats(facebook::memcache::McGatsReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcGats_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcGats(facebook::memcache::McGatsReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcGats(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcGats(facebook::memcache::McGatsReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcGats(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcGats(facebook::memcache::McGatsReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcGats(_return, state);
}

void MemcacheAsyncClient::mcGet(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McGetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcGet(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcGet(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McGetRequest& p_request) {
  auto [ctx, header] = mcGetCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcGetImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcGetImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McGetRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcGetT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcGetT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcGetCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcGet",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcGet(facebook::memcache::McGetReply& _return, const facebook::memcache::McGetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcGet(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcGet(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McGetReply& _return, const facebook::memcache::McGetRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcGetCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcGetImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcGet(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McGetReply>>
MemcacheAsyncClient::sync_complete_mcGet(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McGetRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcGetCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcGetImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McGetReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcGet(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McGetReply> MemcacheAsyncClient::future_mcGet(const facebook::memcache::McGetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcGet(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McGetReply> MemcacheAsyncClient::semifuture_mcGet(const facebook::memcache::McGetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcGet(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McGetReply> MemcacheAsyncClient::future_mcGet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGetRequest& p_request) {
  folly::Promise<facebook::memcache::McGetReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McGetReply>>(std::move(promise), recv_wrapped_mcGet, channel_);
  mcGet(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McGetReply> MemcacheAsyncClient::semifuture_mcGet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGetRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcGet, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcGet(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McGetReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcGet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGetRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McGetReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McGetReply>>(std::move(promise), recv_wrapped_mcGet, channel_);
  mcGet(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McGetReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcGet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGetRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcGet, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcGet(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcGet(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McGetRequest& p_request) {
  mcGet(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcGet(facebook::memcache::McGetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcGet_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcGet(facebook::memcache::McGetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcGet(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcGet(facebook::memcache::McGetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcGet(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcGet(facebook::memcache::McGetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcGet(_return, state);
}

void MemcacheAsyncClient::mcGets(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McGetsRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcGets(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcGets(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McGetsRequest& p_request) {
  auto [ctx, header] = mcGetsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcGetsImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcGetsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McGetsRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcGetsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcGetsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcGetsCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcGets",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcGets(facebook::memcache::McGetsReply& _return, const facebook::memcache::McGetsRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcGets(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcGets(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McGetsReply& _return, const facebook::memcache::McGetsRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcGetsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcGetsImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcGets(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McGetsReply>>
MemcacheAsyncClient::sync_complete_mcGets(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McGetsRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcGetsCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcGetsImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McGetsReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcGets(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McGetsReply> MemcacheAsyncClient::future_mcGets(const facebook::memcache::McGetsRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcGets(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McGetsReply> MemcacheAsyncClient::semifuture_mcGets(const facebook::memcache::McGetsRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcGets(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McGetsReply> MemcacheAsyncClient::future_mcGets(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGetsRequest& p_request) {
  folly::Promise<facebook::memcache::McGetsReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McGetsReply>>(std::move(promise), recv_wrapped_mcGets, channel_);
  mcGets(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McGetsReply> MemcacheAsyncClient::semifuture_mcGets(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGetsRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcGets, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcGets(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McGetsReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcGets(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGetsRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McGetsReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McGetsReply>>(std::move(promise), recv_wrapped_mcGets, channel_);
  mcGets(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McGetsReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcGets(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McGetsRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcGets, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcGets(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcGets(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McGetsRequest& p_request) {
  mcGets(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcGets(facebook::memcache::McGetsReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcGets_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcGets(facebook::memcache::McGetsReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcGets(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcGets(facebook::memcache::McGetsReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcGets(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcGets(facebook::memcache::McGetsReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcGets(_return, state);
}

void MemcacheAsyncClient::mcIncr(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McIncrRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcIncr(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcIncr(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McIncrRequest& p_request) {
  auto [ctx, header] = mcIncrCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcIncrImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcIncrImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McIncrRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcIncrT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcIncrT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcIncrCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcIncr",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcIncr(facebook::memcache::McIncrReply& _return, const facebook::memcache::McIncrRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcIncr(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcIncr(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McIncrReply& _return, const facebook::memcache::McIncrRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcIncrCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcIncrImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcIncr(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McIncrReply>>
MemcacheAsyncClient::sync_complete_mcIncr(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McIncrRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcIncrCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcIncrImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McIncrReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcIncr(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McIncrReply> MemcacheAsyncClient::future_mcIncr(const facebook::memcache::McIncrRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcIncr(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McIncrReply> MemcacheAsyncClient::semifuture_mcIncr(const facebook::memcache::McIncrRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcIncr(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McIncrReply> MemcacheAsyncClient::future_mcIncr(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McIncrRequest& p_request) {
  folly::Promise<facebook::memcache::McIncrReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McIncrReply>>(std::move(promise), recv_wrapped_mcIncr, channel_);
  mcIncr(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McIncrReply> MemcacheAsyncClient::semifuture_mcIncr(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McIncrRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcIncr, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcIncr(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McIncrReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcIncr(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McIncrRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McIncrReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McIncrReply>>(std::move(promise), recv_wrapped_mcIncr, channel_);
  mcIncr(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McIncrReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcIncr(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McIncrRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcIncr, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcIncr(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcIncr(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McIncrRequest& p_request) {
  mcIncr(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcIncr(facebook::memcache::McIncrReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcIncr_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcIncr(facebook::memcache::McIncrReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcIncr(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcIncr(facebook::memcache::McIncrReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcIncr(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcIncr(facebook::memcache::McIncrReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcIncr(_return, state);
}

void MemcacheAsyncClient::mcLeaseGet(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McLeaseGetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcLeaseGet(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcLeaseGet(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McLeaseGetRequest& p_request) {
  auto [ctx, header] = mcLeaseGetCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcLeaseGetImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcLeaseGetImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McLeaseGetRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcLeaseGetT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcLeaseGetT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcLeaseGetCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcLeaseGet",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcLeaseGet(facebook::memcache::McLeaseGetReply& _return, const facebook::memcache::McLeaseGetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcLeaseGet(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcLeaseGet(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McLeaseGetReply& _return, const facebook::memcache::McLeaseGetRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcLeaseGetCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcLeaseGetImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcLeaseGet(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McLeaseGetReply>>
MemcacheAsyncClient::sync_complete_mcLeaseGet(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McLeaseGetRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcLeaseGetCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcLeaseGetImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McLeaseGetReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcLeaseGet(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McLeaseGetReply> MemcacheAsyncClient::future_mcLeaseGet(const facebook::memcache::McLeaseGetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcLeaseGet(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McLeaseGetReply> MemcacheAsyncClient::semifuture_mcLeaseGet(const facebook::memcache::McLeaseGetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcLeaseGet(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McLeaseGetReply> MemcacheAsyncClient::future_mcLeaseGet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McLeaseGetRequest& p_request) {
  folly::Promise<facebook::memcache::McLeaseGetReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McLeaseGetReply>>(std::move(promise), recv_wrapped_mcLeaseGet, channel_);
  mcLeaseGet(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McLeaseGetReply> MemcacheAsyncClient::semifuture_mcLeaseGet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McLeaseGetRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcLeaseGet, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcLeaseGet(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McLeaseGetReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcLeaseGet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McLeaseGetRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McLeaseGetReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McLeaseGetReply>>(std::move(promise), recv_wrapped_mcLeaseGet, channel_);
  mcLeaseGet(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McLeaseGetReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcLeaseGet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McLeaseGetRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcLeaseGet, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcLeaseGet(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcLeaseGet(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McLeaseGetRequest& p_request) {
  mcLeaseGet(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcLeaseGet(facebook::memcache::McLeaseGetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcLeaseGet_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcLeaseGet(facebook::memcache::McLeaseGetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcLeaseGet(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcLeaseGet(facebook::memcache::McLeaseGetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcLeaseGet(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcLeaseGet(facebook::memcache::McLeaseGetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcLeaseGet(_return, state);
}

void MemcacheAsyncClient::mcLeaseSet(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McLeaseSetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcLeaseSet(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcLeaseSet(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McLeaseSetRequest& p_request) {
  auto [ctx, header] = mcLeaseSetCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcLeaseSetImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcLeaseSetImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McLeaseSetRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcLeaseSetT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcLeaseSetT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcLeaseSetCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcLeaseSet",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcLeaseSet(facebook::memcache::McLeaseSetReply& _return, const facebook::memcache::McLeaseSetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcLeaseSet(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcLeaseSet(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McLeaseSetReply& _return, const facebook::memcache::McLeaseSetRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcLeaseSetCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcLeaseSetImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcLeaseSet(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McLeaseSetReply>>
MemcacheAsyncClient::sync_complete_mcLeaseSet(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McLeaseSetRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcLeaseSetCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcLeaseSetImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McLeaseSetReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcLeaseSet(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McLeaseSetReply> MemcacheAsyncClient::future_mcLeaseSet(const facebook::memcache::McLeaseSetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcLeaseSet(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McLeaseSetReply> MemcacheAsyncClient::semifuture_mcLeaseSet(const facebook::memcache::McLeaseSetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcLeaseSet(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McLeaseSetReply> MemcacheAsyncClient::future_mcLeaseSet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McLeaseSetRequest& p_request) {
  folly::Promise<facebook::memcache::McLeaseSetReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McLeaseSetReply>>(std::move(promise), recv_wrapped_mcLeaseSet, channel_);
  mcLeaseSet(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McLeaseSetReply> MemcacheAsyncClient::semifuture_mcLeaseSet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McLeaseSetRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcLeaseSet, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcLeaseSet(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McLeaseSetReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcLeaseSet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McLeaseSetRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McLeaseSetReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McLeaseSetReply>>(std::move(promise), recv_wrapped_mcLeaseSet, channel_);
  mcLeaseSet(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McLeaseSetReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcLeaseSet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McLeaseSetRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcLeaseSet, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcLeaseSet(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcLeaseSet(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McLeaseSetRequest& p_request) {
  mcLeaseSet(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcLeaseSet(facebook::memcache::McLeaseSetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcLeaseSet_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcLeaseSet(facebook::memcache::McLeaseSetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcLeaseSet(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcLeaseSet(facebook::memcache::McLeaseSetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcLeaseSet(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcLeaseSet(facebook::memcache::McLeaseSetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcLeaseSet(_return, state);
}

void MemcacheAsyncClient::mcMetaget(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McMetagetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcMetaget(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcMetaget(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McMetagetRequest& p_request) {
  auto [ctx, header] = mcMetagetCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcMetagetImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcMetagetImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McMetagetRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcMetagetT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcMetagetT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcMetagetCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcMetaget",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcMetaget(facebook::memcache::McMetagetReply& _return, const facebook::memcache::McMetagetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcMetaget(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcMetaget(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McMetagetReply& _return, const facebook::memcache::McMetagetRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcMetagetCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcMetagetImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcMetaget(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McMetagetReply>>
MemcacheAsyncClient::sync_complete_mcMetaget(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McMetagetRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcMetagetCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcMetagetImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McMetagetReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcMetaget(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McMetagetReply> MemcacheAsyncClient::future_mcMetaget(const facebook::memcache::McMetagetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcMetaget(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McMetagetReply> MemcacheAsyncClient::semifuture_mcMetaget(const facebook::memcache::McMetagetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcMetaget(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McMetagetReply> MemcacheAsyncClient::future_mcMetaget(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McMetagetRequest& p_request) {
  folly::Promise<facebook::memcache::McMetagetReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McMetagetReply>>(std::move(promise), recv_wrapped_mcMetaget, channel_);
  mcMetaget(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McMetagetReply> MemcacheAsyncClient::semifuture_mcMetaget(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McMetagetRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcMetaget, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcMetaget(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McMetagetReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcMetaget(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McMetagetRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McMetagetReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McMetagetReply>>(std::move(promise), recv_wrapped_mcMetaget, channel_);
  mcMetaget(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McMetagetReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcMetaget(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McMetagetRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcMetaget, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcMetaget(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcMetaget(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McMetagetRequest& p_request) {
  mcMetaget(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcMetaget(facebook::memcache::McMetagetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcMetaget_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcMetaget(facebook::memcache::McMetagetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcMetaget(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcMetaget(facebook::memcache::McMetagetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcMetaget(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcMetaget(facebook::memcache::McMetagetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcMetaget(_return, state);
}

void MemcacheAsyncClient::mcPrepend(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McPrependRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcPrepend(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcPrepend(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McPrependRequest& p_request) {
  auto [ctx, header] = mcPrependCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcPrependImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcPrependImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McPrependRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcPrependT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcPrependT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcPrependCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcPrepend",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcPrepend(facebook::memcache::McPrependReply& _return, const facebook::memcache::McPrependRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcPrepend(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcPrepend(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McPrependReply& _return, const facebook::memcache::McPrependRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcPrependCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcPrependImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcPrepend(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McPrependReply>>
MemcacheAsyncClient::sync_complete_mcPrepend(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McPrependRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcPrependCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcPrependImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McPrependReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcPrepend(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McPrependReply> MemcacheAsyncClient::future_mcPrepend(const facebook::memcache::McPrependRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcPrepend(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McPrependReply> MemcacheAsyncClient::semifuture_mcPrepend(const facebook::memcache::McPrependRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcPrepend(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McPrependReply> MemcacheAsyncClient::future_mcPrepend(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McPrependRequest& p_request) {
  folly::Promise<facebook::memcache::McPrependReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McPrependReply>>(std::move(promise), recv_wrapped_mcPrepend, channel_);
  mcPrepend(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McPrependReply> MemcacheAsyncClient::semifuture_mcPrepend(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McPrependRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcPrepend, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcPrepend(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McPrependReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcPrepend(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McPrependRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McPrependReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McPrependReply>>(std::move(promise), recv_wrapped_mcPrepend, channel_);
  mcPrepend(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McPrependReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcPrepend(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McPrependRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcPrepend, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcPrepend(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcPrepend(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McPrependRequest& p_request) {
  mcPrepend(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcPrepend(facebook::memcache::McPrependReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcPrepend_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcPrepend(facebook::memcache::McPrependReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcPrepend(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcPrepend(facebook::memcache::McPrependReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcPrepend(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcPrepend(facebook::memcache::McPrependReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcPrepend(_return, state);
}

void MemcacheAsyncClient::mcReplace(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McReplaceRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcReplace(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcReplace(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McReplaceRequest& p_request) {
  auto [ctx, header] = mcReplaceCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcReplaceImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcReplaceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McReplaceRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcReplaceT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcReplaceT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcReplaceCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcReplace",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcReplace(facebook::memcache::McReplaceReply& _return, const facebook::memcache::McReplaceRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcReplace(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcReplace(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McReplaceReply& _return, const facebook::memcache::McReplaceRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcReplaceCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcReplaceImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcReplace(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McReplaceReply>>
MemcacheAsyncClient::sync_complete_mcReplace(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McReplaceRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcReplaceCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcReplaceImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McReplaceReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcReplace(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McReplaceReply> MemcacheAsyncClient::future_mcReplace(const facebook::memcache::McReplaceRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcReplace(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McReplaceReply> MemcacheAsyncClient::semifuture_mcReplace(const facebook::memcache::McReplaceRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcReplace(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McReplaceReply> MemcacheAsyncClient::future_mcReplace(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McReplaceRequest& p_request) {
  folly::Promise<facebook::memcache::McReplaceReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McReplaceReply>>(std::move(promise), recv_wrapped_mcReplace, channel_);
  mcReplace(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McReplaceReply> MemcacheAsyncClient::semifuture_mcReplace(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McReplaceRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcReplace, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcReplace(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McReplaceReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcReplace(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McReplaceRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McReplaceReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McReplaceReply>>(std::move(promise), recv_wrapped_mcReplace, channel_);
  mcReplace(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McReplaceReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcReplace(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McReplaceRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcReplace, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcReplace(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcReplace(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McReplaceRequest& p_request) {
  mcReplace(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcReplace(facebook::memcache::McReplaceReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcReplace_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcReplace(facebook::memcache::McReplaceReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcReplace(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcReplace(facebook::memcache::McReplaceReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcReplace(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcReplace(facebook::memcache::McReplaceReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcReplace(_return, state);
}

void MemcacheAsyncClient::mcSet(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McSetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcSet(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcSet(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McSetRequest& p_request) {
  auto [ctx, header] = mcSetCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcSetImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcSetImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McSetRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcSetT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcSetT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcSetCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcSet",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcSet(facebook::memcache::McSetReply& _return, const facebook::memcache::McSetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcSet(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcSet(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McSetReply& _return, const facebook::memcache::McSetRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcSetCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcSetImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcSet(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McSetReply>>
MemcacheAsyncClient::sync_complete_mcSet(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McSetRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcSetCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcSetImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McSetReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcSet(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McSetReply> MemcacheAsyncClient::future_mcSet(const facebook::memcache::McSetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcSet(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McSetReply> MemcacheAsyncClient::semifuture_mcSet(const facebook::memcache::McSetRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcSet(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McSetReply> MemcacheAsyncClient::future_mcSet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McSetRequest& p_request) {
  folly::Promise<facebook::memcache::McSetReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McSetReply>>(std::move(promise), recv_wrapped_mcSet, channel_);
  mcSet(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McSetReply> MemcacheAsyncClient::semifuture_mcSet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McSetRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcSet, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcSet(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McSetReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcSet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McSetRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McSetReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McSetReply>>(std::move(promise), recv_wrapped_mcSet, channel_);
  mcSet(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McSetReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcSet(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McSetRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcSet, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcSet(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcSet(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McSetRequest& p_request) {
  mcSet(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcSet(facebook::memcache::McSetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcSet_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcSet(facebook::memcache::McSetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcSet(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcSet(facebook::memcache::McSetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcSet(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcSet(facebook::memcache::McSetReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcSet(_return, state);
}

void MemcacheAsyncClient::mcTouch(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McTouchRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcTouch(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcTouch(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McTouchRequest& p_request) {
  auto [ctx, header] = mcTouchCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcTouchImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcTouchImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McTouchRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcTouchT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcTouchT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcTouchCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcTouch",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcTouch(facebook::memcache::McTouchReply& _return, const facebook::memcache::McTouchRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcTouch(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcTouch(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McTouchReply& _return, const facebook::memcache::McTouchRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcTouchCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcTouchImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcTouch(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McTouchReply>>
MemcacheAsyncClient::sync_complete_mcTouch(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McTouchRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcTouchCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcTouchImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McTouchReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcTouch(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McTouchReply> MemcacheAsyncClient::future_mcTouch(const facebook::memcache::McTouchRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcTouch(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McTouchReply> MemcacheAsyncClient::semifuture_mcTouch(const facebook::memcache::McTouchRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcTouch(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McTouchReply> MemcacheAsyncClient::future_mcTouch(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McTouchRequest& p_request) {
  folly::Promise<facebook::memcache::McTouchReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McTouchReply>>(std::move(promise), recv_wrapped_mcTouch, channel_);
  mcTouch(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McTouchReply> MemcacheAsyncClient::semifuture_mcTouch(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McTouchRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcTouch, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcTouch(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McTouchReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcTouch(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McTouchRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McTouchReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McTouchReply>>(std::move(promise), recv_wrapped_mcTouch, channel_);
  mcTouch(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McTouchReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcTouch(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McTouchRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcTouch, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcTouch(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcTouch(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McTouchRequest& p_request) {
  mcTouch(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcTouch(facebook::memcache::McTouchReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcTouch_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcTouch(facebook::memcache::McTouchReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcTouch(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcTouch(facebook::memcache::McTouchReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcTouch(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcTouch(facebook::memcache::McTouchReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcTouch(_return, state);
}

void MemcacheAsyncClient::mcVersion(std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McVersionRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  mcVersion(rpcOptions, std::move(callback), p_request);
}

void MemcacheAsyncClient::mcVersion(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const facebook::memcache::McVersionRequest& p_request) {
  auto [ctx, header] = mcVersionCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  mcVersionImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_request);
}

void MemcacheAsyncClient::mcVersionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const facebook::memcache::McVersionRequest& p_request) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mcVersionT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mcVersionT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_request);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> MemcacheAsyncClient::mcVersionCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "Memcache.mcVersion",
      *header);

  return {std::move(ctx), std::move(header)};
}

void MemcacheAsyncClient::sync_mcVersion(facebook::memcache::McVersionReply& _return, const facebook::memcache::McVersionRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mcVersion(rpcOptions, _return, p_request);
}

void MemcacheAsyncClient::sync_mcVersion(apache::thrift::RpcOptions& rpcOptions, facebook::memcache::McVersionReply& _return, const facebook::memcache::McVersionRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto [ctx, header] = mcVersionCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcVersionImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);
  callback.waitUntilDone(evb);

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_mcVersion(_return, returnState);
  });
}

folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McVersionReply>>
MemcacheAsyncClient::sync_complete_mcVersion(
    apache::thrift::RpcOptions& rpcOptions,  const facebook::memcache::McVersionRequest& p_request) {
  apache::thrift::ClientReceiveState returnState;
  auto [ctx, header] = mcVersionCtx(&rpcOptions);
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  const auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* const evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  mcVersionImpl(rpcOptions, std::move(header), ctx.get(), std::move(wrappedCallback), p_request);

  callback.waitUntilDone(evb);
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctx));

  folly::Try<apache::thrift::RpcResponseComplete<facebook::memcache::McVersionReply>> tryResponse;
  if (auto* header = returnState.header()) {
    rpcOptions.setRoutingData(header->releaseRoutingData());
  }
  if (!returnState.hasResponseBuffer()) {
    assert(returnState.isException());
  	tryResponse.emplaceException(std::move(returnState.exception()));
  } else {
    tryResponse.emplace();
    tryResponse->responseContext.rpcSizeStats = returnState.getRpcSizeStats();
    if (auto* header = returnState.header()) {
      if (!header->getHeaders().empty()) {
  	    tryResponse->responseContext.headers = header->releaseHeaders();
      }
      if (auto load = header->getServerLoad()) {
        tryResponse->responseContext.serverLoad = *load;
      }
    }
    tryResponse->response.emplace();
    auto ew = folly::fibers::runInMainContext([&] {
      return recv_wrapped_mcVersion(tryResponse->response.value(), returnState);
    });
    if (ew) {
      tryResponse->response.emplaceException(std::move(ew));
    }
  }
  return tryResponse;
}

folly::Future<facebook::memcache::McVersionReply> MemcacheAsyncClient::future_mcVersion(const facebook::memcache::McVersionRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mcVersion(rpcOptions, p_request);
}

folly::SemiFuture<facebook::memcache::McVersionReply> MemcacheAsyncClient::semifuture_mcVersion(const facebook::memcache::McVersionRequest& p_request) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_mcVersion(rpcOptions, p_request);
}

folly::Future<facebook::memcache::McVersionReply> MemcacheAsyncClient::future_mcVersion(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McVersionRequest& p_request) {
  folly::Promise<facebook::memcache::McVersionReply> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<facebook::memcache::McVersionReply>>(std::move(promise), recv_wrapped_mcVersion, channel_);
  mcVersion(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<facebook::memcache::McVersionReply> MemcacheAsyncClient::semifuture_mcVersion(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McVersionRequest& p_request) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_mcVersion, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcVersion(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<facebook::memcache::McVersionReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_future_mcVersion(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McVersionRequest& p_request) {
  folly::Promise<std::pair<facebook::memcache::McVersionReply, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<facebook::memcache::McVersionReply>>(std::move(promise), recv_wrapped_mcVersion, channel_);
  mcVersion(rpcOptions, std::move(callback), p_request);
  return future;
}

folly::SemiFuture<std::pair<facebook::memcache::McVersionReply, std::unique_ptr<apache::thrift::transport::THeader>>> MemcacheAsyncClient::header_semifuture_mcVersion(apache::thrift::RpcOptions& rpcOptions, const facebook::memcache::McVersionRequest& p_request) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_mcVersion, channel_);
  auto callback = std::move(callbackAndFuture.first);
  mcVersion(rpcOptions, std::move(callback), p_request);
  return std::move(callbackAndFuture.second);
}

void MemcacheAsyncClient::mcVersion(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const facebook::memcache::McVersionRequest& p_request) {
  mcVersion(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_request);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper MemcacheAsyncClient::recv_wrapped_mcVersion(facebook::memcache::McVersionReply& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = Memcache_mcVersion_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void MemcacheAsyncClient::recv_mcVersion(facebook::memcache::McVersionReply& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mcVersion(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void MemcacheAsyncClient::recv_instance_mcVersion(facebook::memcache::McVersionReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mcVersion(_return, state);
}

folly::exception_wrapper MemcacheAsyncClient::recv_instance_wrapped_mcVersion(facebook::memcache::McVersionReply& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mcVersion(_return, state);
}


}}} // facebook::memcache::thrift
