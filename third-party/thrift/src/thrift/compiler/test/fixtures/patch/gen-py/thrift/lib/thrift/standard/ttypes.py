#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.annotation.thrift.ttypes
import thrift.annotation.java.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'StandardProtocol', 'Void', 'UriStruct', 'TypeUri', 'TypeName', 'ByteString', 'ByteBuffer', 'Uuid', 'UuidString', 'Path', 'PathSegments', 'Domain', 'DomainLabels', 'QueryString', 'QueryArgs', 'Uri']

class StandardProtocol:
  Custom = 0
  Binary = 1
  Compact = 2
  Json = 3
  SimpleJson = 4

  _VALUES_TO_NAMES = {
    0: "Custom",
    1: "Binary",
    2: "Compact",
    3: "Json",
    4: "SimpleJson",
  }

  _NAMES_TO_VALUES = {
    "Custom": 0,
    "Binary": 1,
    "Compact": 2,
    "Json": 3,
    "SimpleJson": 4,
  }

class Void:
  NoValue = 0

  _VALUES_TO_NAMES = {
    0: "NoValue",
  }

  _NAMES_TO_VALUES = {
    "NoValue": 0,
  }

class UriStruct:
  """
  The 'parsed' form of a `Uri`.
  
    {scheme}://{domain}/{path}?{query}#{fragment}
  
  Attributes:
   - scheme
   - domain
   - path
   - query
   - fragment
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.scheme = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.domain = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.domain.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.domain.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.path = []
          (_etype10, _size7) = iprot.readListBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.path.append(_elem12)
          else: 
            while iprot.peekList():
              _elem13 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.path.append(_elem13)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.query = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val20 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.query[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key21 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val22 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.query[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.fragment = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UriStruct')
    if self.scheme != None:
      oprot.writeFieldBegin('scheme', TType.STRING, 1)
      oprot.writeString(self.scheme.encode('utf-8')) if UTF8STRINGS and not isinstance(self.scheme, bytes) else oprot.writeString(self.scheme)
      oprot.writeFieldEnd()
    if self.domain != None:
      oprot.writeFieldBegin('domain', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.domain))
      for iter23 in self.domain:
        oprot.writeString(iter23.encode('utf-8')) if UTF8STRINGS and not isinstance(iter23, bytes) else oprot.writeString(iter23)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.path != None:
      oprot.writeFieldBegin('path', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.path))
      for iter24 in self.path:
        oprot.writeString(iter24.encode('utf-8')) if UTF8STRINGS and not isinstance(iter24, bytes) else oprot.writeString(iter24)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.query != None:
      oprot.writeFieldBegin('query', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.query))
      for kiter25,viter26 in self.query.items():
        oprot.writeString(kiter25.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter25, bytes) else oprot.writeString(kiter25)
        oprot.writeString(viter26.encode('utf-8')) if UTF8STRINGS and not isinstance(viter26, bytes) else oprot.writeString(viter26)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.fragment != None:
      oprot.writeFieldBegin('fragment', TType.STRING, 6)
      oprot.writeString(self.fragment.encode('utf-8')) if UTF8STRINGS and not isinstance(self.fragment, bytes) else oprot.writeString(self.fragment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'scheme' in json_obj and json_obj['scheme'] is not None:
      self.scheme = json_obj['scheme']
    if 'domain' in json_obj and json_obj['domain'] is not None:
      self.domain = []
      for _tmp_e27 in json_obj['domain']:
        self.domain.append(_tmp_e27)
    if 'path' in json_obj and json_obj['path'] is not None:
      self.path = []
      for _tmp_e28 in json_obj['path']:
        self.path.append(_tmp_e28)
    if 'query' in json_obj and json_obj['query'] is not None:
      self.query = dict_cls()
      for _tmp_k29, _tmp_v30 in json_obj['query'].items():
        _tmp_kp31 = _tmp_k29
        self.query[_tmp_kp31] = _tmp_v30
    if 'fragment' in json_obj and json_obj['fragment'] is not None:
      self.fragment = json_obj['fragment']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.scheme is not None:
      value = pprint.pformat(self.scheme, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    scheme=%s' % (value))
    if self.domain is not None:
      value = pprint.pformat(self.domain, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    domain=%s' % (value))
    if self.path is not None:
      value = pprint.pformat(self.path, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    path=%s' % (value))
    if self.query is not None:
      value = pprint.pformat(self.query, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    query=%s' % (value))
    if self.fragment is not None:
      value = pprint.pformat(self.fragment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fragment=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'scheme',
      'domain',
      'path',
      'query',
      'fragment',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.type.standard.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.UriStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.type.standard.types")
    return thrift.py3.converter.to_py3_struct(py3_types.UriStruct, self)

  def _to_py_deprecated(self):
    return self

class TypeUri(object):
  """
  Attributes:
   - uri
   - typeHashPrefixSha2_256
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  URI = 1
  TYPEHASHPREFIXSHA2_256 = 2
  
  @staticmethod
  def isUnion():
    return True

  def get_uri(self):
    assert self.field == 1
    return self.value

  def get_typeHashPrefixSha2_256(self):
    assert self.field == 2
    return self.value

  def set_uri(self, value):
    self.field = 1
    self.value = value

  def set_typeHashPrefixSha2_256(self, value):
    self.field = 2
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 4
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('uri', value)
    if self.field == 2:
      padding = ' ' * 23
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('typeHashPrefixSha2_256', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          _fbthrift_uri = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_uri(_fbthrift_uri)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          _fbthrift_typeHashPrefixSha2_256 = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_typeHashPrefixSha2_256(_fbthrift_typeHashPrefixSha2_256)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('TypeUri')
    if self.field == 1:
      oprot.writeFieldBegin('uri', TType.STRING, 1)
      uri = self.value
      oprot.writeString(uri.encode('utf-8')) if UTF8STRINGS and not isinstance(uri, bytes) else oprot.writeString(uri)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('typeHashPrefixSha2_256', TType.STRING, 2)
      typeHashPrefixSha2_256 = self.value
      oprot.writeString(typeHashPrefixSha2_256)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'uri' in obj:
      _fbthrift_uri = obj['uri']
      self.set_uri(_fbthrift_uri)
    if 'typeHashPrefixSha2_256' in obj:
      _fbthrift_typeHashPrefixSha2_256 = obj['typeHashPrefixSha2_256']
      self.set_typeHashPrefixSha2_256(_fbthrift_typeHashPrefixSha2_256)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.type.standard.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TypeUri, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.type.standard.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TypeUri, self)

  def _to_py_deprecated(self):
    return self

class TypeName(object):
  """
  Attributes:
   - boolType
   - byteType
   - i16Type
   - i32Type
   - i64Type
   - floatType
   - doubleType
   - stringType
   - binaryType
   - enumType
   - structType
   - unionType
   - exceptionType
   - listType
   - setType
   - mapType
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  BOOLTYPE = 1
  BYTETYPE = 2
  I16TYPE = 3
  I32TYPE = 4
  I64TYPE = 5
  FLOATTYPE = 6
  DOUBLETYPE = 7
  STRINGTYPE = 8
  BINARYTYPE = 9
  ENUMTYPE = 10
  STRUCTTYPE = 11
  UNIONTYPE = 12
  EXCEPTIONTYPE = 13
  LISTTYPE = 14
  SETTYPE = 15
  MAPTYPE = 16
  
  @staticmethod
  def isUnion():
    return True

  def get_boolType(self):
    assert self.field == 1
    return self.value

  def get_byteType(self):
    assert self.field == 2
    return self.value

  def get_i16Type(self):
    assert self.field == 3
    return self.value

  def get_i32Type(self):
    assert self.field == 4
    return self.value

  def get_i64Type(self):
    assert self.field == 5
    return self.value

  def get_floatType(self):
    assert self.field == 6
    return self.value

  def get_doubleType(self):
    assert self.field == 7
    return self.value

  def get_stringType(self):
    assert self.field == 8
    return self.value

  def get_binaryType(self):
    assert self.field == 9
    return self.value

  def get_enumType(self):
    assert self.field == 10
    return self.value

  def get_structType(self):
    assert self.field == 11
    return self.value

  def get_unionType(self):
    assert self.field == 12
    return self.value

  def get_exceptionType(self):
    assert self.field == 13
    return self.value

  def get_listType(self):
    assert self.field == 14
    return self.value

  def get_setType(self):
    assert self.field == 15
    return self.value

  def get_mapType(self):
    assert self.field == 16
    return self.value

  def set_boolType(self, value):
    self.field = 1
    self.value = value

  def set_byteType(self, value):
    self.field = 2
    self.value = value

  def set_i16Type(self, value):
    self.field = 3
    self.value = value

  def set_i32Type(self, value):
    self.field = 4
    self.value = value

  def set_i64Type(self, value):
    self.field = 5
    self.value = value

  def set_floatType(self, value):
    self.field = 6
    self.value = value

  def set_doubleType(self, value):
    self.field = 7
    self.value = value

  def set_stringType(self, value):
    self.field = 8
    self.value = value

  def set_binaryType(self, value):
    self.field = 9
    self.value = value

  def set_enumType(self, value):
    self.field = 10
    self.value = value

  def set_structType(self, value):
    self.field = 11
    self.value = value

  def set_unionType(self, value):
    self.field = 12
    self.value = value

  def set_exceptionType(self, value):
    self.field = 13
    self.value = value

  def set_listType(self, value):
    self.field = 14
    self.value = value

  def set_setType(self, value):
    self.field = 15
    self.value = value

  def set_mapType(self, value):
    self.field = 16
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('boolType', value)
    if self.field == 2:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('byteType', value)
    if self.field == 3:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('i16Type', value)
    if self.field == 4:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('i32Type', value)
    if self.field == 5:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('i64Type', value)
    if self.field == 6:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('floatType', value)
    if self.field == 7:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('doubleType', value)
    if self.field == 8:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('stringType', value)
    if self.field == 9:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('binaryType', value)
    if self.field == 10:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('enumType', value)
    if self.field == 11:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('structType', value)
    if self.field == 12:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('unionType', value)
    if self.field == 13:
      padding = ' ' * 14
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('exceptionType', value)
    if self.field == 14:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('listType', value)
    if self.field == 15:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('setType', value)
    if self.field == 16:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('mapType', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          _fbthrift_boolType = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_boolType(_fbthrift_boolType)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          _fbthrift_byteType = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_byteType(_fbthrift_byteType)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          _fbthrift_i16Type = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_i16Type(_fbthrift_i16Type)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          _fbthrift_i32Type = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_i32Type(_fbthrift_i32Type)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          _fbthrift_i64Type = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_i64Type(_fbthrift_i64Type)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          _fbthrift_floatType = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_floatType(_fbthrift_floatType)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          _fbthrift_doubleType = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_doubleType(_fbthrift_doubleType)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          _fbthrift_stringType = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_stringType(_fbthrift_stringType)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          _fbthrift_binaryType = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_binaryType(_fbthrift_binaryType)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          _fbthrift_enumType = TypeUri()
          _fbthrift_enumType.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_enumType(_fbthrift_enumType)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          _fbthrift_structType = TypeUri()
          _fbthrift_structType.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_structType(_fbthrift_structType)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          _fbthrift_unionType = TypeUri()
          _fbthrift_unionType.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_unionType(_fbthrift_unionType)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          _fbthrift_exceptionType = TypeUri()
          _fbthrift_exceptionType.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_exceptionType(_fbthrift_exceptionType)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          _fbthrift_listType = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_listType(_fbthrift_listType)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I32:
          _fbthrift_setType = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_setType(_fbthrift_setType)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I32:
          _fbthrift_mapType = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_mapType(_fbthrift_mapType)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('TypeName')
    if self.field == 1:
      oprot.writeFieldBegin('boolType', TType.I32, 1)
      boolType = self.value
      oprot.writeI32(boolType)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('byteType', TType.I32, 2)
      byteType = self.value
      oprot.writeI32(byteType)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('i16Type', TType.I32, 3)
      i16Type = self.value
      oprot.writeI32(i16Type)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('i32Type', TType.I32, 4)
      i32Type = self.value
      oprot.writeI32(i32Type)
      oprot.writeFieldEnd()
    if self.field == 5:
      oprot.writeFieldBegin('i64Type', TType.I32, 5)
      i64Type = self.value
      oprot.writeI32(i64Type)
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('floatType', TType.I32, 6)
      floatType = self.value
      oprot.writeI32(floatType)
      oprot.writeFieldEnd()
    if self.field == 7:
      oprot.writeFieldBegin('doubleType', TType.I32, 7)
      doubleType = self.value
      oprot.writeI32(doubleType)
      oprot.writeFieldEnd()
    if self.field == 8:
      oprot.writeFieldBegin('stringType', TType.I32, 8)
      stringType = self.value
      oprot.writeI32(stringType)
      oprot.writeFieldEnd()
    if self.field == 9:
      oprot.writeFieldBegin('binaryType', TType.I32, 9)
      binaryType = self.value
      oprot.writeI32(binaryType)
      oprot.writeFieldEnd()
    if self.field == 10:
      oprot.writeFieldBegin('enumType', TType.STRUCT, 10)
      enumType = self.value
      enumType.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 11:
      oprot.writeFieldBegin('structType', TType.STRUCT, 11)
      structType = self.value
      structType.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 12:
      oprot.writeFieldBegin('unionType', TType.STRUCT, 12)
      unionType = self.value
      unionType.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 13:
      oprot.writeFieldBegin('exceptionType', TType.STRUCT, 13)
      exceptionType = self.value
      exceptionType.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 14:
      oprot.writeFieldBegin('listType', TType.I32, 14)
      listType = self.value
      oprot.writeI32(listType)
      oprot.writeFieldEnd()
    if self.field == 15:
      oprot.writeFieldBegin('setType', TType.I32, 15)
      setType = self.value
      oprot.writeI32(setType)
      oprot.writeFieldEnd()
    if self.field == 16:
      oprot.writeFieldBegin('mapType', TType.I32, 16)
      mapType = self.value
      oprot.writeI32(mapType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'boolType' in obj:
      _fbthrift_boolType = obj['boolType']
      if not _fbthrift_boolType in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_boolType
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_boolType(_fbthrift_boolType)
    if 'byteType' in obj:
      _fbthrift_byteType = obj['byteType']
      if not _fbthrift_byteType in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_byteType
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_byteType(_fbthrift_byteType)
    if 'i16Type' in obj:
      _fbthrift_i16Type = obj['i16Type']
      if not _fbthrift_i16Type in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_i16Type
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_i16Type(_fbthrift_i16Type)
    if 'i32Type' in obj:
      _fbthrift_i32Type = obj['i32Type']
      if not _fbthrift_i32Type in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_i32Type
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_i32Type(_fbthrift_i32Type)
    if 'i64Type' in obj:
      _fbthrift_i64Type = obj['i64Type']
      if not _fbthrift_i64Type in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_i64Type
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_i64Type(_fbthrift_i64Type)
    if 'floatType' in obj:
      _fbthrift_floatType = obj['floatType']
      if not _fbthrift_floatType in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_floatType
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_floatType(_fbthrift_floatType)
    if 'doubleType' in obj:
      _fbthrift_doubleType = obj['doubleType']
      if not _fbthrift_doubleType in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_doubleType
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_doubleType(_fbthrift_doubleType)
    if 'stringType' in obj:
      _fbthrift_stringType = obj['stringType']
      if not _fbthrift_stringType in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_stringType
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_stringType(_fbthrift_stringType)
    if 'binaryType' in obj:
      _fbthrift_binaryType = obj['binaryType']
      if not _fbthrift_binaryType in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_binaryType
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_binaryType(_fbthrift_binaryType)
    if 'enumType' in obj:
      _fbthrift_enumType = TypeUri()
      _fbthrift_enumType.readFromJson(obj['enumType'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
      self.set_enumType(_fbthrift_enumType)
    if 'structType' in obj:
      _fbthrift_structType = TypeUri()
      _fbthrift_structType.readFromJson(obj['structType'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
      self.set_structType(_fbthrift_structType)
    if 'unionType' in obj:
      _fbthrift_unionType = TypeUri()
      _fbthrift_unionType.readFromJson(obj['unionType'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
      self.set_unionType(_fbthrift_unionType)
    if 'exceptionType' in obj:
      _fbthrift_exceptionType = TypeUri()
      _fbthrift_exceptionType.readFromJson(obj['exceptionType'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
      self.set_exceptionType(_fbthrift_exceptionType)
    if 'listType' in obj:
      _fbthrift_listType = obj['listType']
      if not _fbthrift_listType in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_listType
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_listType(_fbthrift_listType)
    if 'setType' in obj:
      _fbthrift_setType = obj['setType']
      if not _fbthrift_setType in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_setType
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_setType(_fbthrift_setType)
    if 'mapType' in obj:
      _fbthrift_mapType = obj['mapType']
      if not _fbthrift_mapType in Void._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Void' % _fbthrift_mapType
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_mapType(_fbthrift_mapType)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.type.standard.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TypeName, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.type.standard.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TypeName, self)

  def _to_py_deprecated(self):
    return self

ByteString = UnimplementedTypedef()
ByteBuffer = UnimplementedTypedef()
Uuid = UnimplementedTypedef()
UuidString = UnimplementedTypedef()
Path = UnimplementedTypedef()
PathSegments = UnimplementedTypedef()
Domain = UnimplementedTypedef()
DomainLabels = UnimplementedTypedef()
QueryString = UnimplementedTypedef()
QueryArgs = UnimplementedTypedef()
Uri = UnimplementedTypedef()
all_structs.append(UriStruct)
UriStruct.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'scheme', True, None, 2, ), # 1
  (2, TType.LIST, 'domain', (TType.STRING,True), None, 2, ), # 2
  None, # 3
  (4, TType.LIST, 'path', (TType.STRING,True), None, 2, ), # 4
  (5, TType.MAP, 'query', (TType.STRING,True,TType.STRING,True), None, 2, ), # 5
  (6, TType.STRING, 'fragment', True, None, 2, ), # 6
)

UriStruct.thrift_struct_annotations = {
  "thrift.uri": "facebook.com/thrift/type/Uri",
}
UriStruct.thrift_field_annotations = {
}

def UriStruct__init__(self, scheme=None, domain=None, path=None, query=None, fragment=None,):
  self.scheme = scheme
  self.domain = domain
  self.path = path
  self.query = query
  self.fragment = fragment

UriStruct.__init__ = UriStruct__init__

def UriStruct__setstate__(self, state):
  state.setdefault('scheme', None)
  state.setdefault('domain', None)
  state.setdefault('path', None)
  state.setdefault('query', None)
  state.setdefault('fragment', None)
  self.__dict__ = state

UriStruct.__getstate__ = lambda self: self.__dict__.copy()
UriStruct.__setstate__ = UriStruct__setstate__

all_structs.append(TypeUri)
TypeUri.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'uri', True, None, 2, ), # 1
  (2, TType.STRING, 'typeHashPrefixSha2_256', False, None, 2, ), # 2
)

TypeUri.thrift_struct_annotations = {
}
TypeUri.thrift_field_annotations = {
}

def TypeUri__init__(self, uri=None, typeHashPrefixSha2_256=None,):
  self.field = 0
  self.value = None
  if uri is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = uri
  if typeHashPrefixSha2_256 is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = typeHashPrefixSha2_256

TypeUri.__init__ = TypeUri__init__

all_structs.append(TypeName)
TypeName.thrift_spec = (
  None, # 0
  (1, TType.I32, 'boolType', Void, None, 2, ), # 1
  (2, TType.I32, 'byteType', Void, None, 2, ), # 2
  (3, TType.I32, 'i16Type', Void, None, 2, ), # 3
  (4, TType.I32, 'i32Type', Void, None, 2, ), # 4
  (5, TType.I32, 'i64Type', Void, None, 2, ), # 5
  (6, TType.I32, 'floatType', Void, None, 2, ), # 6
  (7, TType.I32, 'doubleType', Void, None, 2, ), # 7
  (8, TType.I32, 'stringType', Void, None, 2, ), # 8
  (9, TType.I32, 'binaryType', Void, None, 2, ), # 9
  (10, TType.STRUCT, 'enumType', [TypeUri, TypeUri.thrift_spec, True], None, 2, ), # 10
  (11, TType.STRUCT, 'structType', [TypeUri, TypeUri.thrift_spec, True], None, 2, ), # 11
  (12, TType.STRUCT, 'unionType', [TypeUri, TypeUri.thrift_spec, True], None, 2, ), # 12
  (13, TType.STRUCT, 'exceptionType', [TypeUri, TypeUri.thrift_spec, True], None, 2, ), # 13
  (14, TType.I32, 'listType', Void, None, 2, ), # 14
  (15, TType.I32, 'setType', Void, None, 2, ), # 15
  (16, TType.I32, 'mapType', Void, None, 2, ), # 16
)

TypeName.thrift_struct_annotations = {
}
TypeName.thrift_field_annotations = {
}

def TypeName__init__(self, boolType=None, byteType=None, i16Type=None, i32Type=None, i64Type=None, floatType=None, doubleType=None, stringType=None, binaryType=None, enumType=None, structType=None, unionType=None, exceptionType=None, listType=None, setType=None, mapType=None,):
  self.field = 0
  self.value = None
  if boolType is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = boolType
  if byteType is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = byteType
  if i16Type is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = i16Type
  if i32Type is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = i32Type
  if i64Type is not None:
    assert self.field == 0 and self.value is None
    self.field = 5
    self.value = i64Type
  if floatType is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = floatType
  if doubleType is not None:
    assert self.field == 0 and self.value is None
    self.field = 7
    self.value = doubleType
  if stringType is not None:
    assert self.field == 0 and self.value is None
    self.field = 8
    self.value = stringType
  if binaryType is not None:
    assert self.field == 0 and self.value is None
    self.field = 9
    self.value = binaryType
  if enumType is not None:
    assert self.field == 0 and self.value is None
    self.field = 10
    self.value = enumType
  if structType is not None:
    assert self.field == 0 and self.value is None
    self.field = 11
    self.value = structType
  if unionType is not None:
    assert self.field == 0 and self.value is None
    self.field = 12
    self.value = unionType
  if exceptionType is not None:
    assert self.field == 0 and self.value is None
    self.field = 13
    self.value = exceptionType
  if listType is not None:
    assert self.field == 0 and self.value is None
    self.field = 14
    self.value = listType
  if setType is not None:
    assert self.field == 0 and self.value is None
    self.field = 15
    self.value = setType
  if mapType is not None:
    assert self.field == 0 and self.value is None
    self.field = 16
    self.value = mapType

TypeName.__init__ = TypeName__init__

fix_spec(all_structs)
del all_structs
