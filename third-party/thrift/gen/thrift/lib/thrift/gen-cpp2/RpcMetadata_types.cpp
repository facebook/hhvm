/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/lib/thrift/gen-cpp2/RpcMetadata_types.h"
#include "thrift/lib/thrift/gen-cpp2/RpcMetadata_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/lib/thrift/gen-cpp2/RpcMetadata_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ProtocolId>::size;
folly::Range<::apache::thrift::ProtocolId const*> const TEnumTraits<::apache::thrift::ProtocolId>::values = folly::range(::apache::thrift::_ProtocolIdEnumDataStorage::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ProtocolId>::names = folly::range(::apache::thrift::_ProtocolIdEnumDataStorage::names);

char const* TEnumTraits<::apache::thrift::ProtocolId>::findName(type value) {
  using factory = ::apache::thrift::_ProtocolId_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ProtocolId>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_ProtocolId_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ProtocolId_EnumMapFactory::ValuesToNamesMapType _ProtocolId_VALUES_TO_NAMES = _ProtocolId_EnumMapFactory::makeValuesToNamesMap();
const _ProtocolId_EnumMapFactory::NamesToValuesMapType _ProtocolId_NAMES_TO_VALUES = _ProtocolId_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::RpcKind>::size;
folly::Range<::apache::thrift::RpcKind const*> const TEnumTraits<::apache::thrift::RpcKind>::values = folly::range(::apache::thrift::_RpcKindEnumDataStorage::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::RpcKind>::names = folly::range(::apache::thrift::_RpcKindEnumDataStorage::names);

char const* TEnumTraits<::apache::thrift::RpcKind>::findName(type value) {
  using factory = ::apache::thrift::_RpcKind_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::RpcKind>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_RpcKind_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _RpcKind_EnumMapFactory::ValuesToNamesMapType _RpcKind_VALUES_TO_NAMES = _RpcKind_EnumMapFactory::makeValuesToNamesMap();
const _RpcKind_EnumMapFactory::NamesToValuesMapType _RpcKind_NAMES_TO_VALUES = _RpcKind_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::RpcPriority>::size;
folly::Range<::apache::thrift::RpcPriority const*> const TEnumTraits<::apache::thrift::RpcPriority>::values = folly::range(::apache::thrift::_RpcPriorityEnumDataStorage::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::RpcPriority>::names = folly::range(::apache::thrift::_RpcPriorityEnumDataStorage::names);

char const* TEnumTraits<::apache::thrift::RpcPriority>::findName(type value) {
  using factory = ::apache::thrift::_RpcPriority_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::RpcPriority>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_RpcPriority_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _RpcPriority_EnumMapFactory::ValuesToNamesMapType _RpcPriority_VALUES_TO_NAMES = _RpcPriority_EnumMapFactory::makeValuesToNamesMap();
const _RpcPriority_EnumMapFactory::NamesToValuesMapType _RpcPriority_NAMES_TO_VALUES = _RpcPriority_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::CompressionAlgorithm>::size;
folly::Range<::apache::thrift::CompressionAlgorithm const*> const TEnumTraits<::apache::thrift::CompressionAlgorithm>::values = folly::range(::apache::thrift::_CompressionAlgorithmEnumDataStorage::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::CompressionAlgorithm>::names = folly::range(::apache::thrift::_CompressionAlgorithmEnumDataStorage::names);

char const* TEnumTraits<::apache::thrift::CompressionAlgorithm>::findName(type value) {
  using factory = ::apache::thrift::_CompressionAlgorithm_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::CompressionAlgorithm>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_CompressionAlgorithm_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _CompressionAlgorithm_EnumMapFactory::ValuesToNamesMapType _CompressionAlgorithm_VALUES_TO_NAMES = _CompressionAlgorithm_EnumMapFactory::makeValuesToNamesMap();
const _CompressionAlgorithm_EnumMapFactory::NamesToValuesMapType _CompressionAlgorithm_NAMES_TO_VALUES = _CompressionAlgorithm_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::RequestRpcMetadataFlags>::size;
folly::Range<::apache::thrift::RequestRpcMetadataFlags const*> const TEnumTraits<::apache::thrift::RequestRpcMetadataFlags>::values = folly::range(::apache::thrift::_RequestRpcMetadataFlagsEnumDataStorage::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::RequestRpcMetadataFlags>::names = folly::range(::apache::thrift::_RequestRpcMetadataFlagsEnumDataStorage::names);

char const* TEnumTraits<::apache::thrift::RequestRpcMetadataFlags>::findName(type value) {
  using factory = ::apache::thrift::_RequestRpcMetadataFlags_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::RequestRpcMetadataFlags>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_RequestRpcMetadataFlags_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _RequestRpcMetadataFlags_EnumMapFactory::ValuesToNamesMapType _RequestRpcMetadataFlags_VALUES_TO_NAMES = _RequestRpcMetadataFlags_EnumMapFactory::makeValuesToNamesMap();
const _RequestRpcMetadataFlags_EnumMapFactory::NamesToValuesMapType _RequestRpcMetadataFlags_NAMES_TO_VALUES = _RequestRpcMetadataFlags_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::InterfaceKind>::size;
folly::Range<::apache::thrift::InterfaceKind const*> const TEnumTraits<::apache::thrift::InterfaceKind>::values = folly::range(::apache::thrift::_InterfaceKindEnumDataStorage::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::InterfaceKind>::names = folly::range(::apache::thrift::_InterfaceKindEnumDataStorage::names);

char const* TEnumTraits<::apache::thrift::InterfaceKind>::findName(type value) {
  using factory = ::apache::thrift::_InterfaceKind_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::InterfaceKind>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_InterfaceKind_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _InterfaceKind_EnumMapFactory::ValuesToNamesMapType _InterfaceKind_VALUES_TO_NAMES = _InterfaceKind_EnumMapFactory::makeValuesToNamesMap();
const _InterfaceKind_EnumMapFactory::NamesToValuesMapType _InterfaceKind_NAMES_TO_VALUES = _InterfaceKind_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::NegotiationParameters>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "compressionAlgos") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
}
void TccStructTraits<::apache::thrift::RequestRpcMetadata>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "protocol") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "name") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "kind") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "seqId") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "clientTimeoutMs") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "queueTimeoutMs") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "priority") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "otherMetadata") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "host") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "url") {
    fid = 10;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "crc32c") {
    fid = 11;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "flags") {
    fid = 12;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "loadMetric") {
    fid = 13;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "compression") {
    fid = 14;
    _ftype = apache::thrift::protocol::T_I32;
  }
}
void TccStructTraits<::apache::thrift::ResponseRpcMetadata>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "protocol") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "seqId") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "otherMetadata") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "load") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "crc32c") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "compression") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_I32;
  }
}
void TccStructTraits<::apache::thrift::StreamPayloadMetadata>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "compression") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "otherMetadata") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_MAP;
  }
}
void TccStructTraits<::apache::thrift::RequestSetupMetadata>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "opaque") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "interfaceKind") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_I32;
  }
}
void TccStructTraits<::apache::thrift::HeadersPayloadContent>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "otherMetadata") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_MAP;
  }
}
void TccStructTraits<::apache::thrift::HeadersPayloadMetadata>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "compression") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

NegotiationParameters::NegotiationParameters(apache::thrift::FragileConstructor, std::uint64_t compressionAlgos__arg) :
    compressionAlgos(std::move(compressionAlgos__arg)) {
  __isset.compressionAlgos = true;
}

void NegotiationParameters::__clear() {
  // clear all fields
  compressionAlgos = 0;
  __isset = {};
}

bool NegotiationParameters::operator==(const NegotiationParameters& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.compressionAlgos != rhs.__isset.compressionAlgos) {
    return false;
  }
  if (lhs.__isset.compressionAlgos) {
    if (!(lhs.compressionAlgos == rhs.compressionAlgos)) {
      return false;
    }
  }
  return true;
}

bool NegotiationParameters::operator<(const NegotiationParameters& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.compressionAlgos != rhs.__isset.compressionAlgos) {
    return lhs.__isset.compressionAlgos < rhs.__isset.compressionAlgos;
  }
  if (lhs.__isset.compressionAlgos) {
    if (!(lhs.compressionAlgos == rhs.compressionAlgos)) {
      return lhs.compressionAlgos < rhs.compressionAlgos;
    }
  }
  return false;
}


void swap(NegotiationParameters& a, NegotiationParameters& b) {
  using ::std::swap;
  swap(a.compressionAlgos_ref().value_unchecked(), b.compressionAlgos_ref().value_unchecked());
  swap(a.__isset, b.__isset);
}

template void NegotiationParameters::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NegotiationParameters::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NegotiationParameters::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NegotiationParameters::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NegotiationParameters::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NegotiationParameters::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NegotiationParameters::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NegotiationParameters::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // apache::thrift
namespace apache { namespace thrift {

RequestRpcMetadata::RequestRpcMetadata() :
      protocol( ::apache::thrift::ProtocolId::BINARY),
      kind( ::apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE),
      seqId(0),
      clientTimeoutMs(0),
      queueTimeoutMs(0),
      priority( ::apache::thrift::RpcPriority::HIGH_IMPORTANT),
      crc32c(0),
      flags(0),
      compression( ::apache::thrift::CompressionAlgorithm::NONE) {}


RequestRpcMetadata::~RequestRpcMetadata() {}

RequestRpcMetadata::RequestRpcMetadata(apache::thrift::FragileConstructor,  ::apache::thrift::ProtocolId protocol__arg, ::std::string name__arg,  ::apache::thrift::RpcKind kind__arg, int32_t seqId__arg, int32_t clientTimeoutMs__arg, int32_t queueTimeoutMs__arg,  ::apache::thrift::RpcPriority priority__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg, ::std::string host__arg, ::std::string url__arg, std::uint32_t crc32c__arg, std::uint64_t flags__arg, ::std::string loadMetric__arg,  ::apache::thrift::CompressionAlgorithm compression__arg) :
    protocol(std::move(protocol__arg)),
    name(std::move(name__arg)),
    kind(std::move(kind__arg)),
    seqId(std::move(seqId__arg)),
    clientTimeoutMs(std::move(clientTimeoutMs__arg)),
    queueTimeoutMs(std::move(queueTimeoutMs__arg)),
    priority(std::move(priority__arg)),
    otherMetadata(std::move(otherMetadata__arg)),
    host(std::move(host__arg)),
    url(std::move(url__arg)),
    crc32c(std::move(crc32c__arg)),
    flags(std::move(flags__arg)),
    loadMetric(std::move(loadMetric__arg)),
    compression(std::move(compression__arg)) {
  __isset.protocol = true;
  __isset.name = true;
  __isset.kind = true;
  __isset.seqId = true;
  __isset.clientTimeoutMs = true;
  __isset.queueTimeoutMs = true;
  __isset.priority = true;
  __isset.otherMetadata = true;
  __isset.host = true;
  __isset.url = true;
  __isset.crc32c = true;
  __isset.flags = true;
  __isset.loadMetric = true;
  __isset.compression = true;
}

void RequestRpcMetadata::__clear() {
  // clear all fields
  protocol =  ::apache::thrift::ProtocolId::BINARY;
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  kind =  ::apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE;
  seqId = 0;
  clientTimeoutMs = 0;
  queueTimeoutMs = 0;
  priority =  ::apache::thrift::RpcPriority::HIGH_IMPORTANT;
  otherMetadata.clear();
  host = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  url = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  crc32c = 0;
  flags = 0;
  loadMetric = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  compression =  ::apache::thrift::CompressionAlgorithm::NONE;
  __isset = {};
}

bool RequestRpcMetadata::operator==(const RequestRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.protocol != rhs.__isset.protocol) {
    return false;
  }
  if (lhs.__isset.protocol) {
    if (!(lhs.protocol == rhs.protocol)) {
      return false;
    }
  }
  if (lhs.__isset.name != rhs.__isset.name) {
    return false;
  }
  if (lhs.__isset.name) {
    if (!(lhs.name == rhs.name)) {
      return false;
    }
  }
  if (lhs.__isset.kind != rhs.__isset.kind) {
    return false;
  }
  if (lhs.__isset.kind) {
    if (!(lhs.kind == rhs.kind)) {
      return false;
    }
  }
  if (lhs.__isset.seqId != rhs.__isset.seqId) {
    return false;
  }
  if (lhs.__isset.seqId) {
    if (!(lhs.seqId == rhs.seqId)) {
      return false;
    }
  }
  if (lhs.__isset.clientTimeoutMs != rhs.__isset.clientTimeoutMs) {
    return false;
  }
  if (lhs.__isset.clientTimeoutMs) {
    if (!(lhs.clientTimeoutMs == rhs.clientTimeoutMs)) {
      return false;
    }
  }
  if (lhs.__isset.queueTimeoutMs != rhs.__isset.queueTimeoutMs) {
    return false;
  }
  if (lhs.__isset.queueTimeoutMs) {
    if (!(lhs.queueTimeoutMs == rhs.queueTimeoutMs)) {
      return false;
    }
  }
  if (lhs.__isset.priority != rhs.__isset.priority) {
    return false;
  }
  if (lhs.__isset.priority) {
    if (!(lhs.priority == rhs.priority)) {
      return false;
    }
  }
  if (lhs.__isset.otherMetadata != rhs.__isset.otherMetadata) {
    return false;
  }
  if (lhs.__isset.otherMetadata) {
    if (!(lhs.otherMetadata == rhs.otherMetadata)) {
      return false;
    }
  }
  if (lhs.__isset.host != rhs.__isset.host) {
    return false;
  }
  if (lhs.__isset.host) {
    if (!(lhs.host == rhs.host)) {
      return false;
    }
  }
  if (lhs.__isset.url != rhs.__isset.url) {
    return false;
  }
  if (lhs.__isset.url) {
    if (!(lhs.url == rhs.url)) {
      return false;
    }
  }
  if (lhs.__isset.crc32c != rhs.__isset.crc32c) {
    return false;
  }
  if (lhs.__isset.crc32c) {
    if (!(lhs.crc32c == rhs.crc32c)) {
      return false;
    }
  }
  if (lhs.__isset.flags != rhs.__isset.flags) {
    return false;
  }
  if (lhs.__isset.flags) {
    if (!(lhs.flags == rhs.flags)) {
      return false;
    }
  }
  if (lhs.__isset.loadMetric != rhs.__isset.loadMetric) {
    return false;
  }
  if (lhs.__isset.loadMetric) {
    if (!(lhs.loadMetric == rhs.loadMetric)) {
      return false;
    }
  }
  if (lhs.__isset.compression != rhs.__isset.compression) {
    return false;
  }
  if (lhs.__isset.compression) {
    if (!(lhs.compression == rhs.compression)) {
      return false;
    }
  }
  return true;
}

bool RequestRpcMetadata::operator<(const RequestRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.protocol != rhs.__isset.protocol) {
    return lhs.__isset.protocol < rhs.__isset.protocol;
  }
  if (lhs.__isset.protocol) {
    if (!(lhs.protocol == rhs.protocol)) {
      return lhs.protocol < rhs.protocol;
    }
  }
  if (lhs.__isset.name != rhs.__isset.name) {
    return lhs.__isset.name < rhs.__isset.name;
  }
  if (lhs.__isset.name) {
    if (!(lhs.name == rhs.name)) {
      return lhs.name < rhs.name;
    }
  }
  if (lhs.__isset.kind != rhs.__isset.kind) {
    return lhs.__isset.kind < rhs.__isset.kind;
  }
  if (lhs.__isset.kind) {
    if (!(lhs.kind == rhs.kind)) {
      return lhs.kind < rhs.kind;
    }
  }
  if (lhs.__isset.seqId != rhs.__isset.seqId) {
    return lhs.__isset.seqId < rhs.__isset.seqId;
  }
  if (lhs.__isset.seqId) {
    if (!(lhs.seqId == rhs.seqId)) {
      return lhs.seqId < rhs.seqId;
    }
  }
  if (lhs.__isset.clientTimeoutMs != rhs.__isset.clientTimeoutMs) {
    return lhs.__isset.clientTimeoutMs < rhs.__isset.clientTimeoutMs;
  }
  if (lhs.__isset.clientTimeoutMs) {
    if (!(lhs.clientTimeoutMs == rhs.clientTimeoutMs)) {
      return lhs.clientTimeoutMs < rhs.clientTimeoutMs;
    }
  }
  if (lhs.__isset.queueTimeoutMs != rhs.__isset.queueTimeoutMs) {
    return lhs.__isset.queueTimeoutMs < rhs.__isset.queueTimeoutMs;
  }
  if (lhs.__isset.queueTimeoutMs) {
    if (!(lhs.queueTimeoutMs == rhs.queueTimeoutMs)) {
      return lhs.queueTimeoutMs < rhs.queueTimeoutMs;
    }
  }
  if (lhs.__isset.priority != rhs.__isset.priority) {
    return lhs.__isset.priority < rhs.__isset.priority;
  }
  if (lhs.__isset.priority) {
    if (!(lhs.priority == rhs.priority)) {
      return lhs.priority < rhs.priority;
    }
  }
  if (lhs.__isset.otherMetadata != rhs.__isset.otherMetadata) {
    return lhs.__isset.otherMetadata < rhs.__isset.otherMetadata;
  }
  if (lhs.__isset.otherMetadata) {
    if (!(lhs.otherMetadata == rhs.otherMetadata)) {
      return lhs.otherMetadata < rhs.otherMetadata;
    }
  }
  if (lhs.__isset.host != rhs.__isset.host) {
    return lhs.__isset.host < rhs.__isset.host;
  }
  if (lhs.__isset.host) {
    if (!(lhs.host == rhs.host)) {
      return lhs.host < rhs.host;
    }
  }
  if (lhs.__isset.url != rhs.__isset.url) {
    return lhs.__isset.url < rhs.__isset.url;
  }
  if (lhs.__isset.url) {
    if (!(lhs.url == rhs.url)) {
      return lhs.url < rhs.url;
    }
  }
  if (lhs.__isset.crc32c != rhs.__isset.crc32c) {
    return lhs.__isset.crc32c < rhs.__isset.crc32c;
  }
  if (lhs.__isset.crc32c) {
    if (!(lhs.crc32c == rhs.crc32c)) {
      return lhs.crc32c < rhs.crc32c;
    }
  }
  if (lhs.__isset.flags != rhs.__isset.flags) {
    return lhs.__isset.flags < rhs.__isset.flags;
  }
  if (lhs.__isset.flags) {
    if (!(lhs.flags == rhs.flags)) {
      return lhs.flags < rhs.flags;
    }
  }
  if (lhs.__isset.loadMetric != rhs.__isset.loadMetric) {
    return lhs.__isset.loadMetric < rhs.__isset.loadMetric;
  }
  if (lhs.__isset.loadMetric) {
    if (!(lhs.loadMetric == rhs.loadMetric)) {
      return lhs.loadMetric < rhs.loadMetric;
    }
  }
  if (lhs.__isset.compression != rhs.__isset.compression) {
    return lhs.__isset.compression < rhs.__isset.compression;
  }
  if (lhs.__isset.compression) {
    if (!(lhs.compression == rhs.compression)) {
      return lhs.compression < rhs.compression;
    }
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* RequestRpcMetadata::get_otherMetadata() const& {
  return __isset.otherMetadata ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* RequestRpcMetadata::get_otherMetadata() & {
  return __isset.otherMetadata ? std::addressof(otherMetadata) : nullptr;
}


void swap(RequestRpcMetadata& a, RequestRpcMetadata& b) {
  using ::std::swap;
  swap(a.protocol_ref().value_unchecked(), b.protocol_ref().value_unchecked());
  swap(a.name_ref().value_unchecked(), b.name_ref().value_unchecked());
  swap(a.kind_ref().value_unchecked(), b.kind_ref().value_unchecked());
  swap(a.seqId_ref().value_unchecked(), b.seqId_ref().value_unchecked());
  swap(a.clientTimeoutMs_ref().value_unchecked(), b.clientTimeoutMs_ref().value_unchecked());
  swap(a.queueTimeoutMs_ref().value_unchecked(), b.queueTimeoutMs_ref().value_unchecked());
  swap(a.priority_ref().value_unchecked(), b.priority_ref().value_unchecked());
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
  swap(a.host_ref().value_unchecked(), b.host_ref().value_unchecked());
  swap(a.url_ref().value_unchecked(), b.url_ref().value_unchecked());
  swap(a.crc32c_ref().value_unchecked(), b.crc32c_ref().value_unchecked());
  swap(a.flags_ref().value_unchecked(), b.flags_ref().value_unchecked());
  swap(a.loadMetric_ref().value_unchecked(), b.loadMetric_ref().value_unchecked());
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
  swap(a.__isset, b.__isset);
}

template void RequestRpcMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RequestRpcMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RequestRpcMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RequestRpcMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RequestRpcMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RequestRpcMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RequestRpcMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RequestRpcMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // apache::thrift
namespace apache { namespace thrift {

ResponseRpcMetadata::ResponseRpcMetadata() :
      protocol( ::apache::thrift::ProtocolId::BINARY),
      seqId(0),
      load(0),
      crc32c(0),
      compression( ::apache::thrift::CompressionAlgorithm::NONE) {}


ResponseRpcMetadata::~ResponseRpcMetadata() {}

ResponseRpcMetadata::ResponseRpcMetadata(apache::thrift::FragileConstructor,  ::apache::thrift::ProtocolId protocol__arg, int32_t seqId__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg, int64_t load__arg, std::uint32_t crc32c__arg,  ::apache::thrift::CompressionAlgorithm compression__arg) :
    protocol(std::move(protocol__arg)),
    seqId(std::move(seqId__arg)),
    otherMetadata(std::move(otherMetadata__arg)),
    load(std::move(load__arg)),
    crc32c(std::move(crc32c__arg)),
    compression(std::move(compression__arg)) {
  __isset.protocol = true;
  __isset.seqId = true;
  __isset.otherMetadata = true;
  __isset.load = true;
  __isset.crc32c = true;
  __isset.compression = true;
}

void ResponseRpcMetadata::__clear() {
  // clear all fields
  protocol =  ::apache::thrift::ProtocolId::BINARY;
  seqId = 0;
  otherMetadata.clear();
  load = 0;
  crc32c = 0;
  compression =  ::apache::thrift::CompressionAlgorithm::NONE;
  __isset = {};
}

bool ResponseRpcMetadata::operator==(const ResponseRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.protocol != rhs.__isset.protocol) {
    return false;
  }
  if (lhs.__isset.protocol) {
    if (!(lhs.protocol == rhs.protocol)) {
      return false;
    }
  }
  if (lhs.__isset.seqId != rhs.__isset.seqId) {
    return false;
  }
  if (lhs.__isset.seqId) {
    if (!(lhs.seqId == rhs.seqId)) {
      return false;
    }
  }
  if (lhs.__isset.otherMetadata != rhs.__isset.otherMetadata) {
    return false;
  }
  if (lhs.__isset.otherMetadata) {
    if (!(lhs.otherMetadata == rhs.otherMetadata)) {
      return false;
    }
  }
  if (lhs.__isset.load != rhs.__isset.load) {
    return false;
  }
  if (lhs.__isset.load) {
    if (!(lhs.load == rhs.load)) {
      return false;
    }
  }
  if (lhs.__isset.crc32c != rhs.__isset.crc32c) {
    return false;
  }
  if (lhs.__isset.crc32c) {
    if (!(lhs.crc32c == rhs.crc32c)) {
      return false;
    }
  }
  if (lhs.__isset.compression != rhs.__isset.compression) {
    return false;
  }
  if (lhs.__isset.compression) {
    if (!(lhs.compression == rhs.compression)) {
      return false;
    }
  }
  return true;
}

bool ResponseRpcMetadata::operator<(const ResponseRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.protocol != rhs.__isset.protocol) {
    return lhs.__isset.protocol < rhs.__isset.protocol;
  }
  if (lhs.__isset.protocol) {
    if (!(lhs.protocol == rhs.protocol)) {
      return lhs.protocol < rhs.protocol;
    }
  }
  if (lhs.__isset.seqId != rhs.__isset.seqId) {
    return lhs.__isset.seqId < rhs.__isset.seqId;
  }
  if (lhs.__isset.seqId) {
    if (!(lhs.seqId == rhs.seqId)) {
      return lhs.seqId < rhs.seqId;
    }
  }
  if (lhs.__isset.otherMetadata != rhs.__isset.otherMetadata) {
    return lhs.__isset.otherMetadata < rhs.__isset.otherMetadata;
  }
  if (lhs.__isset.otherMetadata) {
    if (!(lhs.otherMetadata == rhs.otherMetadata)) {
      return lhs.otherMetadata < rhs.otherMetadata;
    }
  }
  if (lhs.__isset.load != rhs.__isset.load) {
    return lhs.__isset.load < rhs.__isset.load;
  }
  if (lhs.__isset.load) {
    if (!(lhs.load == rhs.load)) {
      return lhs.load < rhs.load;
    }
  }
  if (lhs.__isset.crc32c != rhs.__isset.crc32c) {
    return lhs.__isset.crc32c < rhs.__isset.crc32c;
  }
  if (lhs.__isset.crc32c) {
    if (!(lhs.crc32c == rhs.crc32c)) {
      return lhs.crc32c < rhs.crc32c;
    }
  }
  if (lhs.__isset.compression != rhs.__isset.compression) {
    return lhs.__isset.compression < rhs.__isset.compression;
  }
  if (lhs.__isset.compression) {
    if (!(lhs.compression == rhs.compression)) {
      return lhs.compression < rhs.compression;
    }
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* ResponseRpcMetadata::get_otherMetadata() const& {
  return __isset.otherMetadata ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* ResponseRpcMetadata::get_otherMetadata() & {
  return __isset.otherMetadata ? std::addressof(otherMetadata) : nullptr;
}


void swap(ResponseRpcMetadata& a, ResponseRpcMetadata& b) {
  using ::std::swap;
  swap(a.protocol_ref().value_unchecked(), b.protocol_ref().value_unchecked());
  swap(a.seqId_ref().value_unchecked(), b.seqId_ref().value_unchecked());
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
  swap(a.load_ref().value_unchecked(), b.load_ref().value_unchecked());
  swap(a.crc32c_ref().value_unchecked(), b.crc32c_ref().value_unchecked());
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
  swap(a.__isset, b.__isset);
}

template void ResponseRpcMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ResponseRpcMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ResponseRpcMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ResponseRpcMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ResponseRpcMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ResponseRpcMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ResponseRpcMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ResponseRpcMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // apache::thrift
namespace apache { namespace thrift {

StreamPayloadMetadata::StreamPayloadMetadata(apache::thrift::FragileConstructor,  ::apache::thrift::CompressionAlgorithm compression__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg) :
    compression(std::move(compression__arg)),
    otherMetadata(std::move(otherMetadata__arg)) {
  __isset.compression = true;
  __isset.otherMetadata = true;
}

void StreamPayloadMetadata::__clear() {
  // clear all fields
  compression =  ::apache::thrift::CompressionAlgorithm::NONE;
  otherMetadata.clear();
  __isset = {};
}

bool StreamPayloadMetadata::operator==(const StreamPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.compression != rhs.__isset.compression) {
    return false;
  }
  if (lhs.__isset.compression) {
    if (!(lhs.compression == rhs.compression)) {
      return false;
    }
  }
  if (lhs.__isset.otherMetadata != rhs.__isset.otherMetadata) {
    return false;
  }
  if (lhs.__isset.otherMetadata) {
    if (!(lhs.otherMetadata == rhs.otherMetadata)) {
      return false;
    }
  }
  return true;
}

bool StreamPayloadMetadata::operator<(const StreamPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.compression != rhs.__isset.compression) {
    return lhs.__isset.compression < rhs.__isset.compression;
  }
  if (lhs.__isset.compression) {
    if (!(lhs.compression == rhs.compression)) {
      return lhs.compression < rhs.compression;
    }
  }
  if (lhs.__isset.otherMetadata != rhs.__isset.otherMetadata) {
    return lhs.__isset.otherMetadata < rhs.__isset.otherMetadata;
  }
  if (lhs.__isset.otherMetadata) {
    if (!(lhs.otherMetadata == rhs.otherMetadata)) {
      return lhs.otherMetadata < rhs.otherMetadata;
    }
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* StreamPayloadMetadata::get_otherMetadata() const& {
  return __isset.otherMetadata ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* StreamPayloadMetadata::get_otherMetadata() & {
  return __isset.otherMetadata ? std::addressof(otherMetadata) : nullptr;
}


void swap(StreamPayloadMetadata& a, StreamPayloadMetadata& b) {
  using ::std::swap;
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
  swap(a.__isset, b.__isset);
}

template void StreamPayloadMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StreamPayloadMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StreamPayloadMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StreamPayloadMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StreamPayloadMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StreamPayloadMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StreamPayloadMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StreamPayloadMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // apache::thrift
namespace apache { namespace thrift {

RequestSetupMetadata::RequestSetupMetadata(apache::thrift::FragileConstructor, apache::thrift::MetadataOpaqueMap<::std::string, ::std::string> opaque__arg,  ::apache::thrift::InterfaceKind interfaceKind__arg) :
    opaque(std::move(opaque__arg)),
    interfaceKind(std::move(interfaceKind__arg)) {
  __isset.opaque = true;
  __isset.interfaceKind = true;
}

void RequestSetupMetadata::__clear() {
  // clear all fields
  opaque.clear();
  interfaceKind =  ::apache::thrift::InterfaceKind::USER;
  __isset = {};
}

bool RequestSetupMetadata::operator==(const RequestSetupMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.opaque != rhs.__isset.opaque) {
    return false;
  }
  if (lhs.__isset.opaque) {
    if (!(lhs.opaque == rhs.opaque)) {
      return false;
    }
  }
  if (lhs.__isset.interfaceKind != rhs.__isset.interfaceKind) {
    return false;
  }
  if (lhs.__isset.interfaceKind) {
    if (!(lhs.interfaceKind == rhs.interfaceKind)) {
      return false;
    }
  }
  return true;
}

const apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>* RequestSetupMetadata::get_opaque() const& {
  return __isset.opaque ? std::addressof(opaque) : nullptr;
}

apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>* RequestSetupMetadata::get_opaque() & {
  return __isset.opaque ? std::addressof(opaque) : nullptr;
}


void swap(RequestSetupMetadata& a, RequestSetupMetadata& b) {
  using ::std::swap;
  swap(a.opaque_ref().value_unchecked(), b.opaque_ref().value_unchecked());
  swap(a.interfaceKind_ref().value_unchecked(), b.interfaceKind_ref().value_unchecked());
  swap(a.__isset, b.__isset);
}

template void RequestSetupMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RequestSetupMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RequestSetupMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RequestSetupMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RequestSetupMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RequestSetupMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RequestSetupMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RequestSetupMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // apache::thrift
namespace apache { namespace thrift {

HeadersPayloadContent::HeadersPayloadContent(apache::thrift::FragileConstructor, ::std::map<::std::string, ::std::string> otherMetadata__arg) :
    otherMetadata(std::move(otherMetadata__arg)) {
  __isset.otherMetadata = true;
}

void HeadersPayloadContent::__clear() {
  // clear all fields
  otherMetadata.clear();
  __isset = {};
}

bool HeadersPayloadContent::operator==(const HeadersPayloadContent& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.otherMetadata != rhs.__isset.otherMetadata) {
    return false;
  }
  if (lhs.__isset.otherMetadata) {
    if (!(lhs.otherMetadata == rhs.otherMetadata)) {
      return false;
    }
  }
  return true;
}

bool HeadersPayloadContent::operator<(const HeadersPayloadContent& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.otherMetadata != rhs.__isset.otherMetadata) {
    return lhs.__isset.otherMetadata < rhs.__isset.otherMetadata;
  }
  if (lhs.__isset.otherMetadata) {
    if (!(lhs.otherMetadata == rhs.otherMetadata)) {
      return lhs.otherMetadata < rhs.otherMetadata;
    }
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* HeadersPayloadContent::get_otherMetadata() const& {
  return __isset.otherMetadata ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* HeadersPayloadContent::get_otherMetadata() & {
  return __isset.otherMetadata ? std::addressof(otherMetadata) : nullptr;
}


void swap(HeadersPayloadContent& a, HeadersPayloadContent& b) {
  using ::std::swap;
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
  swap(a.__isset, b.__isset);
}

template void HeadersPayloadContent::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t HeadersPayloadContent::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t HeadersPayloadContent::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t HeadersPayloadContent::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void HeadersPayloadContent::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t HeadersPayloadContent::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t HeadersPayloadContent::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t HeadersPayloadContent::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // apache::thrift
namespace apache { namespace thrift {

HeadersPayloadMetadata::HeadersPayloadMetadata(apache::thrift::FragileConstructor,  ::apache::thrift::CompressionAlgorithm compression__arg) :
    compression(std::move(compression__arg)) {
  __isset.compression = true;
}

void HeadersPayloadMetadata::__clear() {
  // clear all fields
  compression =  ::apache::thrift::CompressionAlgorithm::NONE;
  __isset = {};
}

bool HeadersPayloadMetadata::operator==(const HeadersPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.compression != rhs.__isset.compression) {
    return false;
  }
  if (lhs.__isset.compression) {
    if (!(lhs.compression == rhs.compression)) {
      return false;
    }
  }
  return true;
}

bool HeadersPayloadMetadata::operator<(const HeadersPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.__isset.compression != rhs.__isset.compression) {
    return lhs.__isset.compression < rhs.__isset.compression;
  }
  if (lhs.__isset.compression) {
    if (!(lhs.compression == rhs.compression)) {
      return lhs.compression < rhs.compression;
    }
  }
  return false;
}


void swap(HeadersPayloadMetadata& a, HeadersPayloadMetadata& b) {
  using ::std::swap;
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
  swap(a.__isset, b.__isset);
}

template void HeadersPayloadMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t HeadersPayloadMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t HeadersPayloadMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t HeadersPayloadMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void HeadersPayloadMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t HeadersPayloadMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t HeadersPayloadMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t HeadersPayloadMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // apache::thrift
