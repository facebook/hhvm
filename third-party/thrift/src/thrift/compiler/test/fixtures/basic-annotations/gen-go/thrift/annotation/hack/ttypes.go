// Autogenerated by Thrift Compiler (facebook)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
// @generated

package hack

import (
	"bytes"
	"context"
	"sync"
	"fmt"
	thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = sync.Mutex{}
var _ = bytes.Equal
var _ = context.Background

var GoUnusedProtection__ int;

// An experimental annotation that applies a Hack wrapper to fields.
// For example:
// 
//   struct User {
//     @hack.FieldWrapper{name="MyWrapper"}
//     1: i64 id;
//   }
// 
// Attributes:
//  - Name: The name of a Hack wrapper class used to wrap the field
type FieldWrapper struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
}

func NewFieldWrapper() *FieldWrapper {
  return &FieldWrapper{}
}


func (p *FieldWrapper) GetName() string {
  return p.Name
}
type FieldWrapperBuilder struct {
  obj *FieldWrapper
}

func NewFieldWrapperBuilder() *FieldWrapperBuilder{
  return &FieldWrapperBuilder{
    obj: NewFieldWrapper(),
  }
}

func (p FieldWrapperBuilder) Emit() *FieldWrapper{
  return &FieldWrapper{
    Name: p.obj.Name,
  }
}

func (f *FieldWrapperBuilder) Name(name string) *FieldWrapperBuilder {
  f.obj.Name = name
  return f
}

func (f *FieldWrapper) SetName(name string) *FieldWrapper {
  f.Name = name
  return f
}

func (p *FieldWrapper) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FieldWrapper)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.Name = v
  }
  return nil
}

func (p *FieldWrapper) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("FieldWrapper"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FieldWrapper) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *FieldWrapper) String() string {
  if p == nil {
    return "<nil>"
  }

  nameVal := fmt.Sprintf("%v", p.Name)
  return fmt.Sprintf("FieldWrapper({Name:%s})", nameVal)
}

// An annotation that applies a Hack wrapper to fields, typedef or structs.
// For example:
// 
//   struct User {
//     @hack.FieldWrapper{name="MyWrapper"}
//     1: i64 id;
//   }
// 
// Attributes:
//  - Name: The name of a Hack wrapper class used to wrap the field
//  - UnderlyingName: When applied directly to a typedef or struct, the IDL name of the
// type will refer to the adapted type in Hack and the underlying thrift struct will be
// generated in a nested namespace and/or with a different name. By default the type/struct
// will be generated in a nested 'thrift_adapted_types' namespace with the same name,
// but both of these can be changed by setting these fields.
// Empty string enables the nested namespace and uses the IDL name for the struct.
//  - ExtraNamespace
type Wrapper struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
  UnderlyingName string `thrift:"underlyingName,2" db:"underlyingName" json:"underlyingName"`
  ExtraNamespace string `thrift:"extraNamespace,3" db:"extraNamespace" json:"extraNamespace"`
}

func NewWrapper() *Wrapper {
  return &Wrapper{
    ExtraNamespace: "thrift_adapted_types",
  }
}


func (p *Wrapper) GetName() string {
  return p.Name
}

func (p *Wrapper) GetUnderlyingName() string {
  return p.UnderlyingName
}

func (p *Wrapper) GetExtraNamespace() string {
  return p.ExtraNamespace
}
type WrapperBuilder struct {
  obj *Wrapper
}

func NewWrapperBuilder() *WrapperBuilder{
  return &WrapperBuilder{
    obj: NewWrapper(),
  }
}

func (p WrapperBuilder) Emit() *Wrapper{
  return &Wrapper{
    Name: p.obj.Name,
    UnderlyingName: p.obj.UnderlyingName,
    ExtraNamespace: p.obj.ExtraNamespace,
  }
}

func (w *WrapperBuilder) Name(name string) *WrapperBuilder {
  w.obj.Name = name
  return w
}

func (w *WrapperBuilder) UnderlyingName(underlyingName string) *WrapperBuilder {
  w.obj.UnderlyingName = underlyingName
  return w
}

func (w *WrapperBuilder) ExtraNamespace(extraNamespace string) *WrapperBuilder {
  w.obj.ExtraNamespace = extraNamespace
  return w
}

func (w *Wrapper) SetName(name string) *Wrapper {
  w.Name = name
  return w
}

func (w *Wrapper) SetUnderlyingName(underlyingName string) *Wrapper {
  w.UnderlyingName = underlyingName
  return w
}

func (w *Wrapper) SetExtraNamespace(extraNamespace string) *Wrapper {
  w.ExtraNamespace = extraNamespace
  return w
}

func (p *Wrapper) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    case 3:
      if err := p.ReadField3(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Wrapper)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.Name = v
  }
  return nil
}

func (p *Wrapper)  ReadField2(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 2: ", err)
  } else {
    p.UnderlyingName = v
  }
  return nil
}

func (p *Wrapper)  ReadField3(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 3: ", err)
  } else {
    p.ExtraNamespace = v
  }
  return nil
}

func (p *Wrapper) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Wrapper"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := p.writeField2(oprot); err != nil { return err }
  if err := p.writeField3(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Wrapper) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *Wrapper) writeField2(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("underlyingName", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:underlyingName: ", p), err) }
  if err := oprot.WriteString(string(p.UnderlyingName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.underlyingName (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:underlyingName: ", p), err) }
  return err
}

func (p *Wrapper) writeField3(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("extraNamespace", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:extraNamespace: ", p), err) }
  if err := oprot.WriteString(string(p.ExtraNamespace)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.extraNamespace (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:extraNamespace: ", p), err) }
  return err
}

func (p *Wrapper) String() string {
  if p == nil {
    return "<nil>"
  }

  nameVal := fmt.Sprintf("%v", p.Name)
  underlyingNameVal := fmt.Sprintf("%v", p.UnderlyingName)
  extraNamespaceVal := fmt.Sprintf("%v", p.ExtraNamespace)
  return fmt.Sprintf("Wrapper({Name:%s UnderlyingName:%s ExtraNamespace:%s})", nameVal, underlyingNameVal, extraNamespaceVal)
}

// An annotation that applies a Hack adapter to types. For example:
// @hack.Adapter{name="\\TimestampAdapter"}
// typedef i64 Timestamp;
// 
//   struct User {
//     1: Timestamp account_creation_time;
//   }
// 
// Here the field `account_creation_time` will have type TimestampAdapter::THackType instead of i64.
// 
// in hack:
// ```
// final class TimestampAdapter implements IThriftAdapter {
//   const type TThriftType = int;
//   const type THackType = Time;
//   public static function fromThrift(int $seconds)[]: Time {
//     return Time::fromEpochSeconds($seconds);
//   }
//   public static function toThrift(Time $time): int {
//     return $hack_value->asFullSecondsSinceEpoch();
//   }
// }
// ```
// elsewhere in hack:
// ```
// function timeSinceCreated(Document $doc): Duration {
//   // $doc->created_time is of type Time
//   return Duration::between(Time::now(), $doc->created_time);
// }
// ```
// This completely replaces the underlying type of a thrift for a custom implementation and uses
// the specified adapter to convert to and from the underlying Thrift type during (de)serialization.
// 
// Attributes:
//  - Name: The name of a Hack adapter class that implements IThriftAdapter
type Adapter struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
}

func NewAdapter() *Adapter {
  return &Adapter{}
}


func (p *Adapter) GetName() string {
  return p.Name
}
type AdapterBuilder struct {
  obj *Adapter
}

func NewAdapterBuilder() *AdapterBuilder{
  return &AdapterBuilder{
    obj: NewAdapter(),
  }
}

func (p AdapterBuilder) Emit() *Adapter{
  return &Adapter{
    Name: p.obj.Name,
  }
}

func (a *AdapterBuilder) Name(name string) *AdapterBuilder {
  a.obj.Name = name
  return a
}

func (a *Adapter) SetName(name string) *Adapter {
  a.Name = name
  return a
}

func (p *Adapter) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Adapter)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.Name = v
  }
  return nil
}

func (p *Adapter) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Adapter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Adapter) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *Adapter) String() string {
  if p == nil {
    return "<nil>"
  }

  nameVal := fmt.Sprintf("%v", p.Name)
  return fmt.Sprintf("Adapter({Name:%s})", nameVal)
}

// Attributes:
//  - Reason
type SkipCodegen struct {
  Reason string `thrift:"reason,1" db:"reason" json:"reason"`
}

func NewSkipCodegen() *SkipCodegen {
  return &SkipCodegen{}
}


func (p *SkipCodegen) GetReason() string {
  return p.Reason
}
type SkipCodegenBuilder struct {
  obj *SkipCodegen
}

func NewSkipCodegenBuilder() *SkipCodegenBuilder{
  return &SkipCodegenBuilder{
    obj: NewSkipCodegen(),
  }
}

func (p SkipCodegenBuilder) Emit() *SkipCodegen{
  return &SkipCodegen{
    Reason: p.obj.Reason,
  }
}

func (s *SkipCodegenBuilder) Reason(reason string) *SkipCodegenBuilder {
  s.obj.Reason = reason
  return s
}

func (s *SkipCodegen) SetReason(reason string) *SkipCodegen {
  s.Reason = reason
  return s
}

func (p *SkipCodegen) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SkipCodegen)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.Reason = v
  }
  return nil
}

func (p *SkipCodegen) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("SkipCodegen"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SkipCodegen) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("reason", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:reason: ", p), err) }
  if err := oprot.WriteString(string(p.Reason)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.reason (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:reason: ", p), err) }
  return err
}

func (p *SkipCodegen) String() string {
  if p == nil {
    return "<nil>"
  }

  reasonVal := fmt.Sprintf("%v", p.Reason)
  return fmt.Sprintf("SkipCodegen({Reason:%s})", reasonVal)
}

// This annotation is mainly used to rename symbols which can result in symbol
// conflict errors in Hack codegen.
// For ex: reserved keywords in Hack language, symbols with similar names from
// other files in Hack
// 
// Attributes:
//  - Name
//  - Reason
type Name struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
  Reason string `thrift:"reason,2" db:"reason" json:"reason"`
}

func NewName() *Name {
  return &Name{}
}


func (p *Name) GetName() string {
  return p.Name
}

func (p *Name) GetReason() string {
  return p.Reason
}
type NameBuilder struct {
  obj *Name
}

func NewNameBuilder() *NameBuilder{
  return &NameBuilder{
    obj: NewName(),
  }
}

func (p NameBuilder) Emit() *Name{
  return &Name{
    Name: p.obj.Name,
    Reason: p.obj.Reason,
  }
}

func (n *NameBuilder) Name(name string) *NameBuilder {
  n.obj.Name = name
  return n
}

func (n *NameBuilder) Reason(reason string) *NameBuilder {
  n.obj.Reason = reason
  return n
}

func (n *Name) SetName(name string) *Name {
  n.Name = name
  return n
}

func (n *Name) SetReason(reason string) *Name {
  n.Reason = reason
  return n
}

func (p *Name) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Name)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.Name = v
  }
  return nil
}

func (p *Name)  ReadField2(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 2: ", err)
  } else {
    p.Reason = v
  }
  return nil
}

func (p *Name) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Name"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := p.writeField2(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Name) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *Name) writeField2(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("reason", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:reason: ", p), err) }
  if err := oprot.WriteString(string(p.Reason)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.reason (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:reason: ", p), err) }
  return err
}

func (p *Name) String() string {
  if p == nil {
    return "<nil>"
  }

  nameVal := fmt.Sprintf("%v", p.Name)
  reasonVal := fmt.Sprintf("%v", p.Reason)
  return fmt.Sprintf("Name({Name:%s Reason:%s})", nameVal, reasonVal)
}

// This annotation is for adding Hack attributes to union enums.
// 
// Attributes:
//  - Attributes
type UnionEnumAttributes struct {
  Attributes []string `thrift:"attributes,1" db:"attributes" json:"attributes"`
}

func NewUnionEnumAttributes() *UnionEnumAttributes {
  return &UnionEnumAttributes{}
}


func (p *UnionEnumAttributes) GetAttributes() []string {
  return p.Attributes
}
type UnionEnumAttributesBuilder struct {
  obj *UnionEnumAttributes
}

func NewUnionEnumAttributesBuilder() *UnionEnumAttributesBuilder{
  return &UnionEnumAttributesBuilder{
    obj: NewUnionEnumAttributes(),
  }
}

func (p UnionEnumAttributesBuilder) Emit() *UnionEnumAttributes{
  return &UnionEnumAttributes{
    Attributes: p.obj.Attributes,
  }
}

func (u *UnionEnumAttributesBuilder) Attributes(attributes []string) *UnionEnumAttributesBuilder {
  u.obj.Attributes = attributes
  return u
}

func (u *UnionEnumAttributes) SetAttributes(attributes []string) *UnionEnumAttributes {
  u.Attributes = attributes
  return u
}

func (p *UnionEnumAttributes) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UnionEnumAttributes)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.Attributes =  tSlice
  for i := 0; i < size; i ++ {
    var _elem0 string
    if v, err := iprot.ReadString(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
    } else {
      _elem0 = v
    }
    p.Attributes = append(p.Attributes, _elem0)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *UnionEnumAttributes) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("UnionEnumAttributes"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UnionEnumAttributes) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("attributes", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:attributes: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRING, len(p.Attributes)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Attributes {
    if err := oprot.WriteString(string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:attributes: ", p), err) }
  return err
}

func (p *UnionEnumAttributes) String() string {
  if p == nil {
    return "<nil>"
  }

  attributesVal := fmt.Sprintf("%v", p.Attributes)
  return fmt.Sprintf("UnionEnumAttributes({Attributes:%s})", attributesVal)
}

// This annotation is for using a custom trait for structs.
// 
// Attributes:
//  - Name
type StructTrait struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
}

func NewStructTrait() *StructTrait {
  return &StructTrait{}
}


func (p *StructTrait) GetName() string {
  return p.Name
}
type StructTraitBuilder struct {
  obj *StructTrait
}

func NewStructTraitBuilder() *StructTraitBuilder{
  return &StructTraitBuilder{
    obj: NewStructTrait(),
  }
}

func (p StructTraitBuilder) Emit() *StructTrait{
  return &StructTrait{
    Name: p.obj.Name,
  }
}

func (s *StructTraitBuilder) Name(name string) *StructTraitBuilder {
  s.obj.Name = name
  return s
}

func (s *StructTrait) SetName(name string) *StructTrait {
  s.Name = name
  return s
}

func (p *StructTrait) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *StructTrait)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.Name = v
  }
  return nil
}

func (p *StructTrait) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("StructTrait"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *StructTrait) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *StructTrait) String() string {
  if p == nil {
    return "<nil>"
  }

  nameVal := fmt.Sprintf("%v", p.Name)
  return fmt.Sprintf("StructTrait({Name:%s})", nameVal)
}

// This annotation is for adding Hack attributes.
// * Where to use: field or struct type
// * Value: add attributes like `JSEnum` to structs or fields
// * Example:
// 
// ```
// // In thrift
// enum MyEnum {
//   ALLOWED = 1,
//   THIS_IS_ALLOWED  =  2,
//   THIS_IS_ALLOWED_2 = 3,
// }(
//   hack.attributes=
//     "\JSEnum(shape('name' => 'MyEnum')),
//     \GraphQLEnum('MyEnum', 'Description for my enum',)"
// )
// struct MyThriftStruct {
//   1: string foo (hack.attributes = "FieldAttribute");
//   2: string bar;
//   3: string baz;
// } (hack.attributes = "ClassAttribute")
// ```
// ```
// //thrift compiler will generate this for you
// <<\JSEnum(shape('name' => 'MyEnum')),
// \GraphQLEnum('MyEnum', 'Description for my enum',)>>
// enum MyEnum: int {
//  ALLOWED = 1;
//  THIS_IS_ALLOWED = 2;
//  THIS_IS_ALLOWED_2 = 3;
// }
// <<ClassAttribute>>
// class MyThriftStruct implements \IThriftStruct {
//  ....
//  <<FieldAttribute>>
//  public string $foo;
//  ....
// }
// ```
// 
// Attributes:
//  - Attributes
type Attributes struct {
  Attributes []string `thrift:"attributes,1" db:"attributes" json:"attributes"`
}

func NewAttributes() *Attributes {
  return &Attributes{}
}


func (p *Attributes) GetAttributes() []string {
  return p.Attributes
}
type AttributesBuilder struct {
  obj *Attributes
}

func NewAttributesBuilder() *AttributesBuilder{
  return &AttributesBuilder{
    obj: NewAttributes(),
  }
}

func (p AttributesBuilder) Emit() *Attributes{
  return &Attributes{
    Attributes: p.obj.Attributes,
  }
}

func (a *AttributesBuilder) Attributes(attributes []string) *AttributesBuilder {
  a.obj.Attributes = attributes
  return a
}

func (a *Attributes) SetAttributes(attributes []string) *Attributes {
  a.Attributes = attributes
  return a
}

func (p *Attributes) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Attributes)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.Attributes =  tSlice
  for i := 0; i < size; i ++ {
    var _elem1 string
    if v, err := iprot.ReadString(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
    } else {
      _elem1 = v
    }
    p.Attributes = append(p.Attributes, _elem1)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Attributes) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Attributes"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Attributes) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("attributes", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:attributes: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRING, len(p.Attributes)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Attributes {
    if err := oprot.WriteString(string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:attributes: ", p), err) }
  return err
}

func (p *Attributes) String() string {
  if p == nil {
    return "<nil>"
  }

  attributesVal := fmt.Sprintf("%v", p.Attributes)
  return fmt.Sprintf("Attributes({Attributes:%s})", attributesVal)
}

type StructAsTrait struct {
}

func NewStructAsTrait() *StructAsTrait {
  return &StructAsTrait{}
}

type StructAsTraitBuilder struct {
  obj *StructAsTrait
}

func NewStructAsTraitBuilder() *StructAsTraitBuilder{
  return &StructAsTraitBuilder{
    obj: NewStructAsTrait(),
  }
}

func (p StructAsTraitBuilder) Emit() *StructAsTrait{
  return &StructAsTrait{
  }
}

func (p *StructAsTrait) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *StructAsTrait) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("StructAsTrait"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *StructAsTrait) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("StructAsTrait({})")
}

// This annotation is to generate an entity as internal
type ModuleInternal struct {
}

func NewModuleInternal() *ModuleInternal {
  return &ModuleInternal{}
}

type ModuleInternalBuilder struct {
  obj *ModuleInternal
}

func NewModuleInternalBuilder() *ModuleInternalBuilder{
  return &ModuleInternalBuilder{
    obj: NewModuleInternal(),
  }
}

func (p ModuleInternalBuilder) Emit() *ModuleInternal{
  return &ModuleInternal{
  }
}

func (p *ModuleInternal) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ModuleInternal) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("ModuleInternal"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ModuleInternal) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("ModuleInternal({})")
}

