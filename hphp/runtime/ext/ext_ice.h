/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010- Facebook, Inc. (http://www.facebook.com)         |
   | Copyright (c) 1997-2010 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/

#ifndef __EXT_ICE_H__
#define __EXT_ICE_H__

// >>>>>> Generated by idl.php. Do NOT modify. <<<<<<

#include <runtime/base/base_includes.h>
#include <stdlib.h>
#include <map>
#include <string.h>
#include <iostream>
#include <Ice/Ice.h>
#include <runtime/base/externals.h>
#include <IceUtil/Shared.h>
#include <IceUtil/Handle.h>
#include <list>
#include <set>
#include <runtime/ext/ext_variable.h>
using namespace std;

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

		Object f_ice_find(CStrRef ice_name = null);
		bool f_ice_register(CObjRef ice_object = null, CStrRef ice_name = null, int64 expires = null);
		Object f_ice_initialize();
		Object f_icephp_defineexception(CStrRef id = null, CStrRef name = null, CVarRef base = null, CVarRef members = null);
		String f_icephp_stringifyexception(CObjRef value = null, CObjRef target = null);
		String f_icephp_stringify(CObjRef value = null, CObjRef target = null);
		Object f_icephp_declareclass(CStrRef id = null);
		Object f_icephp_definesequence(CStrRef id = null, CVarRef elementtype = null);
		Object f_icephp_defineproxy(CObjRef classobj);
		Object f_icephp_defineclass(CStrRef id, CStrRef name, bool isabstract = true, CObjRef base = null, CVarRef interfaces = null, CVarRef members = null);
		void f_icephp_defineoperation(CObjRef classobj = null, CStrRef funname = null, int mode = null, int sendmode = null, CVarRef inparams = null, CVarRef outparams = null, CVarRef returntype = null, CVarRef exceptions = null);
		/*Ice.php中创建基本类型 ，如
		$IcePHP__t_string=create_typeinfobyid(0)
		*/
		Variant f_create_typeinfobyid(int id = 0);

		///////////////////////////////////////////////////////////////////////////////
		//new ice hzg 20130603	
		/*
			声明新建的ice对象的类
			所有新生声明的ice类，前面都带有P_
		*/
		class P_TypeInfo;
		class P_PrimitiveInfo;
		class P_ClassInfo;
		class P_DataMember;
		class P_ClassMethod;
		class P_ExceptionInfo;
		class P_SequenceInfo; 
		typedef P_DataMember* P_DataMemberPtr;	
		typedef P_ClassInfo* P_ClassInfoPtr;
		typedef std::vector<P_ClassInfoPtr> P_ClassInfoList;
		typedef P_TypeInfo* P_TypeInfoPtr;
		typedef std::vector<P_DataMemberPtr> P_DataMemberList;
		typedef std::vector<P_TypeInfoPtr> P_TypeInfoList;
		typedef P_SequenceInfo* P_SequenceInfoPtr;
		typedef P_ExceptionInfo* P_ExceptionInfoPtr;
		typedef P_ClassMethod* P_ClassMethodPtr;
		typedef std::map<std::string,P_ClassMethodPtr> P_ClassMethodMap;
		typedef std::vector<P_ExceptionInfoPtr> P_ExceptionInfoList;
		class P_IceObjectFactoryWrapper;
		typedef IceUtil::Handle<P_IceObjectFactoryWrapper> P_IceObjectFactoryWrapperPtr;
		////////////////////////////////////////////////////////////////////////////////
		// class ICE
		class IceObjectFactoryWrapper;
		class IcePHP_Class_method;
		typedef IceUtil::Handle<IceObjectFactoryWrapper> IceObjectFactoryWrapperPtr;
		class ExceptionInfo;
		typedef ExceptionInfo* ExceptionInfoPtr;
		class ResultCls;
		typedef list<ResultCls*> ResultList;

		//typedef IceUtil::Handle<ExceptionInfo> ExceptionInfoPtr;
		typedef std::vector<ExceptionInfoPtr> ExceptionInfoList;
		class PrimitiveInfo;
		class c_IcePHP_class;
		FORWARD_DECLARE_CLASS_BUILTIN(ICE);
		/*
		ice通过ice_initialize函数实例化的类，所有的Ice操作都基于该类
		*/
		class c_ICE : public ExtObjectData ,public Sweepable{
			public:
				DECLARE_CLASS(ICE, ICE, ObjectData)
				//封装Ice Api中的通讯器，许多的ice调用操作需要该对象
					Ice::CommunicatorPtr communicatorPtr;
				/*
				old factoryWrapper ,deleted!
				旧的工厂容器，已经删除
				*/
				IceObjectFactoryWrapperPtr factoryWrapper; 
				//new ice hzg 20130603
				/*
					新的工厂容器，工厂容器中主要封装的是类信息，类需要添加到工厂中才可以操作
				*/
				P_IceObjectFactoryWrapperPtr p_factoryWrapper; 

				// need to implement
			public: c_ICE(const ObjectStaticCallbacks *cb = &cw_ICE);
			public: ~c_ICE();
			public: void t___construct();
				DECLARE_METHOD_INVOKE_HELPERS(__construct);
			public: Object t_stringtoproxy(CStrRef str);
				DECLARE_METHOD_INVOKE_HELPERS(stringtoproxy);

				// implemented by HPHP
			public: c_ICE *create();
			public: c_IcePHP_class* p_cict;
		};

		/////////////////////////////////////////////////////////////////////////////
		// class UnmarshalCallback
		class UnmarshalCallback {
				public:

						virtual ~UnmarshalCallback();
						//virtual void unmarshaled(zval*, zval*, void* TSRMLS_DC) = 0;
		};
		typedef IceUtil::Handle<UnmarshalCallback> UnmarshalCallbackPtr;

		///////////////////////////////////////////////////////////////////////////////
		// class TypeInfo
		/*
			Ice类型的基类,如基本类型PrimitiveInfo和对象类型ClassInfo，SequenceInfo都继承该类
		*/
		FORWARD_DECLARE_CLASS_BUILTIN(TypeInfo);
		class c_TypeInfo : public ExtObjectData , public UnmarshalCallback , public Sweepable{
				public:
						DECLARE_CLASS(TypeInfo, TypeInfo, ObjectData)

								// need to implement
				public: c_TypeInfo(const ObjectStaticCallbacks *cb = &cw_TypeInfo);
				public: ~c_TypeInfo();
				public: void t___construct();
						DECLARE_METHOD_INVOKE_HELPERS(__construct);

						// implemented by HPHP
				public: c_TypeInfo *create();

						//		virtual std::string getId();
						/*
							判断该类型是否是对象类型,true（对象类型),false未使用对象类型
						*/
						virtual bool usesClasses();
						/*
							封装数据
						*/
						virtual void marshal(const Ice::OutputStreamPtr& out,Variant &inParams){};
						/*
							解封装数据，ice返回数据后，从InputStream中解封装数据
							ResultCls * rcs 该指针中保存了解封装的数据
						*/
						virtual void unmarshal(const Ice::InputStreamPtr& in,ResultCls * rcs){};
						/*
							将解封装后的数据ResultCls * rcs，转换为hhvm中的对象
						*/
						virtual void unmarshaled(ResultCls *result){};
						/*
							输出类型的值，如echo $a;
						*/
						virtual string  print(int objcount,Variant &inParams){};
						/*
							TypeInfo的类型枚举类型
							PrimitiveInfo 基本类型
							Ice_ClassInfo 对象类型
							SequenceInfo 列表类型
							ExceptionInfo 异常类型
						*/
						enum Kind{
								PrimitiveInfo,
								Ice_ClassInfo,
								SequenceInfo,
								ExceptionInfo
						};
						/*
							保存该对象的typeInfo属于哪种类型
						*/
						Kind c_kind;
				/*
					 将TypeInfo多态转换成某种子类
				*/
				public: c_TypeInfo *getc_type();
				/*
					封装新的typeInfo信息
				*/
				public: P_TypeInfoPtr p_typeInfo;
				/*
					保存typeInfo的id,id 值每种类型中保持唯一
				*/
				public: std::string id;

		};
		typedef c_TypeInfo* TypeInfoPtr;
		//typedef IceUtil::Handle<c_TypeInfo> TypeInfoPtr;
		///////////////////////////////////////////////////////////////////////////////

		///////////////////////////////////////////////////////////////////
		// class DataMemberInfo

		class DataMember {
				public:
						std::string name;
						TypeInfoPtr type;  
						public:DataMember(){};
						public:~DataMember(){};
		};
		//typedef IceUtil::Handle<DataMember> DataMemberPtr;
		typedef DataMember* DataMemberPtr;
		typedef std::vector<DataMemberPtr> DataMemberList;

		/////////////////////////////////////////////////////////////////////////////
		// class ClassInfo

		class Ice_ClassInfo;
		typedef Ice_ClassInfo* Ice_ClassInfoPtr;
		//typedef IceUtil::Handle<Ice_ClassInfo> Ice_ClassInfoPtr;
		typedef std::vector<Ice_ClassInfoPtr> Ice_ClassInfoList;

		typedef std::vector<TypeInfoPtr> TypeInfoList;
		typedef std::map<unsigned int, Ice::ObjectPtr> ObjectMap;

		// class IcePHP_Class_method
		class IcePHP_Class_method {
				public:
						IcePHP_Class_method();
						~IcePHP_Class_method();
						//Ice_ClassInfoPtr cls;
						std::string name;
		};

		/*
			通过defineclass定义的类型，以Ice_ClassInfo类型保存
		*/
		class Ice_ClassInfo : public c_TypeInfo {
				public:
						Ice_ClassInfo(){
								c_kind = c_TypeInfo::Ice_ClassInfo;
						};
						~Ice_ClassInfo(){
						};
						////wanghong add at 20130606 kuohao////
						virtual std::string getId() const;
						virtual bool usesClasses(){};
						virtual void marshal(const Ice::OutputStreamPtr& out,Variant &inParams){};
						virtual void unmarshal(const Ice::InputStreamPtr& in,ResultCls * rcs){};
						virtual string  print(int objcount,Variant &inParams){};
						virtual void unmarshaled(ResultCls *result){};
						//////////////////////////////////////
						std::string id;
						std::map<std::string,IcePHP_Class_method*>  methodMap;
		};

		///////////////////////////////////////////////////////////////////
		// class SequenceInfo
		/*
			defineSequence 的类型
		*/
		class SequenceInfo : public c_TypeInfo {
				public:
				public:SequenceInfo();
				public:~SequenceInfo(){};
					   virtual bool usesClasses(){};
					   virtual void marshal(const Ice::OutputStreamPtr& out,Variant &inParams){};
					   virtual void unmarshal(const Ice::InputStreamPtr& in,ResultCls * rcs){};
					   virtual string  print(int objcount,Variant &inParams){};
					   virtual void unmarshaled(ResultCls *result){};
					   
					   void marshalPrimitiveSequence(const Ice::OutputStreamPtr& out,Variant &inParams,HPHP::PrimitiveInfo *primitiveInfo){};
					   //wanghong add zhushi
					   std::string id;
					   //TypeInfoPtr elementType;
		};
		//typedef IceUtil::Handle<SequenceInfo> SequenceInfoPtr;
		typedef SequenceInfo* SequenceInfoPtr;

		///////////////////////////////////////////////////////////////////
		// class PrimitiveInfo
		/*
			基本类型如
			$IcePHP__t_string=create_typeinfobyid(0);
			$IcePHP__t_long=create_typeinfobyid(1);
			$IcePHP__t_int=create_typeinfobyid(2);
			目前实现了就是上面的3种类型
		*/
		class PrimitiveInfo : public c_TypeInfo{
				public:
						PrimitiveInfo(int type);
						~PrimitiveInfo(){
						//	printf("primitiveInfo destory!");
						};
						virtual std::string getId() const;
						virtual void marshal(const Ice::OutputStreamPtr& out,Variant &inParams){};
						virtual void unmarshal(const Ice::InputStreamPtr& in,ResultCls * rcs){};
						virtual string  print(int objcount,Variant &inParams){};		
						virtual void unmarshaled(ResultCls *result){};

						enum Kind
						{
								KindBool,
								KindByte,
								KindShort,
								KindInt,
								KindLong,
								KindFloat,
								KindDouble,
								KindString
						};
						Kind kind;
		};
		//typedef IceUtil::Handle<PrimitiveInfo> PrimitiveInfoPtr;
		typedef PrimitiveInfo* PrimitiveInfoPtr;

		///////////////////////////////////////////////////////////////////////////////
		// class Proxy
		/*
			Ice的proxy对象，所有的调用都基于该类
		*/
FORWARD_DECLARE_CLASS_BUILTIN(Proxy);
class c_Proxy : public ExtObjectDataFlags<ObjectData::HasCall> {
 public:
  DECLARE_CLASS(Proxy, Proxy, ObjectData)
  /*
  	 封装Ice Api 的通讯器对象
  */
  Ice::CommunicatorPtr communicatorPtr;
  /*
  	封装Ice Api的Proxy对象
  */
  Ice::ObjectPrx objectPrx;
  /*
  	classInfo and factoryWrapper old code delete !
  */
  Ice_ClassInfoPtr classInfo; 
  IceObjectFactoryWrapperPtr factoryWrapper;
  // new icd hzg 20130603
  /*	
  	p_factoryWrapper 保存的是对象工厂的容器
  	p_classInfo 是在checkedcast中保存与proxy对应的类信息
  */
  P_IceObjectFactoryWrapperPtr p_factoryWrapper;
  P_ClassInfoPtr p_classInfo; 

  // need to implement
  public: c_Proxy(const ObjectStaticCallbacks *cb = &cw_Proxy);
  //public: c_Proxy(const c_Proxy& cp);
  public: ~c_Proxy();
  public: void t___construct();
  DECLARE_METHOD_INVOKE_HELPERS(__construct);
  public: Variant t___call(Variant name, Variant args);
  DECLARE_METHOD_INVOKE_HELPERS(__call);
  public: Variant doCall(Variant v_name, Variant v_arguments, bool fatal);
  public: Object t_ice_oneway();
  DECLARE_METHOD_INVOKE_HELPERS(ice_oneway);
  public: Object t_ice_datagram();
  DECLARE_METHOD_INVOKE_HELPERS(ice_datagram);
  public: Object t_ice_istwoway();
  DECLARE_METHOD_INVOKE_HELPERS(ice_istwoway);
  public: Object t_ice_secure(bool secure = false);
  DECLARE_METHOD_INVOKE_HELPERS(ice_secure);
  public: Object t_ice_timeout(int64 lasttime = null);
  DECLARE_METHOD_INVOKE_HELPERS(ice_timeout);
  public: Object t_ice_context(CArrRef ctx = null);
  DECLARE_METHOD_INVOKE_HELPERS(ice_context);
  public: Object t_ice_checkedcast(CStrRef classid, CVarRef facetOrCtx = null, CVarRef ctx = null);
  DECLARE_METHOD_INVOKE_HELPERS(ice_checkedcast);
  public: Object t_ice_uncheckedcast(CStrRef classid, CVarRef facet = null);
  DECLARE_METHOD_INVOKE_HELPERS(ice_uncheckedcast);
  //std::map<Ice::ObjectPrx,ProxyInfo*> pMap;
  //ProxyInfo *pxInfo;
  /*
  	priPx and p_cict have deleted!
  */
  c_Proxy *priPx;
  public: c_IcePHP_class* p_cict;
  // implemented by HPHP
  public: c_Proxy *create();
		};

		///////////////////////////////////////////////////////////////////////////////
		// class IcePHP_class

		FORWARD_DECLARE_CLASS_BUILTIN(IcePHP_class);
		/*
			最开始时保存Hiphop_Ice_t_classMap保存ice声明的所有对象，但是会遇到销毁问题，所以该类已经过时不用
		*/
		class c_IcePHP_class : public ExtObjectData,public Sweepable  {
				public:
						DECLARE_CLASS(IcePHP_class, IcePHP_class, ObjectData)

								// need to implement
				public: c_IcePHP_class(const ObjectStaticCallbacks *cb = &cw_IcePHP_class);
				public: ~c_IcePHP_class();
				public: void t___construct();
						DECLARE_METHOD_INVOKE_HELPERS(__construct);

						// implemented by HPHP
				public: c_IcePHP_class *create();

				public:
						std::map<std::string,Ice_ClassInfoPtr> classInfoMap;
						//Array methodMap;
		};
		/*
			删除不用delete!
		*/
		class ProxyInfo{
				public:
						ProxyInfo(){};
						static ProxyInfo* m_pInstance1;
						static ProxyInfo* GetInstance();
						c_Proxy* getProxyInfo(std::string proxyInfo); 
						typedef std::map<std::string,c_Proxy*> ProxyMap;
						ProxyMap proxyMap;
		};
		//////////////////////////////////////////////////////////////////////////////
		/*
			old code delete!
			第一个版本的类：
			IceObjectReader
			IceReadObjectCallback
			IceObjectFactory
			IceObjectFactoryWrapper
			IceObjectWriter
		*/
		//Ice stream function 
		class IceObjectReader :public Ice::ObjectReader{
				public:
						string classId;
						ResultList resultList;	
						Ice_ClassInfoPtr classInfo;
						IceObjectReader(const string &classId);
						virtual void read(const Ice::InputStreamPtr& in, bool rid){};
		};

		class IceReadObjectCallback : public Ice::ReadObjectCallback{
				public:
						string className;
						ResultCls * rcs;
						IceReadObjectCallback(const string className,ResultCls * rcs);
						virtual void invoke(const Ice::ObjectPtr& p){};
		};

		class IceObjectFactory : public Ice::ObjectFactory{
				public:
						IceObjectFactory();
						virtual Ice::ObjectPtr create(const string& type){};
						virtual void destroy(){};

		};

		class IceObjectFactoryWrapper : public Ice::ObjectFactory{
				public:
						Ice::ObjectFactoryPtr _factory;
						IceObjectFactoryWrapper(){};
						virtual Ice::ObjectPtr create(const string& type){};
						virtual void destroy(){};
						void setFactory(const Ice::ObjectFactoryPtr& factory){};

		};

		class IceObjectWriter : public Ice::ObjectWriter{
				public:
						Variant inParams;
						Ice_ClassInfoPtr classInfo;
						IceObjectWriter(const Ice_ClassInfoPtr &classInfo,Variant &inParams); 
						virtual void  write(const Ice::OutputStreamPtr& out) const{};
		};
		typedef IceUtil::Handle<IceObjectWriter> IceObjectWriterPtr;
		typedef IceUtil::Handle<IceObjectReader> IceObjectReaderPtr;
		typedef IceUtil::Handle<IceReadObjectCallback> IceReadObjectCallbackPtr;
		///////////////////////////////////////////////////////////////////////////////
		/*
			icephp_defineexception 中声明的异常类的对象
		*/
		class ExceptionInfo : public c_TypeInfo {
				public:
						ExceptionInfo();
						~ExceptionInfo();

						std::string id;

						virtual void marshal(const Ice::OutputStreamPtr& out,Variant &inParams){};
						virtual void unmarshal(const Ice::InputStreamPtr& in,ResultCls * rcs){};
						virtual string  print(int objcount,Variant &inParams){};
		};
		/////////////////////////////////////////////////////////////////
		//extern std::map<std::string,Ice_ClassInfoPtr> classInfoMap;
		extern std::map<std::string,ExceptionInfoPtr> exceptionInfoMap;
		/*
			旧版本中获取hiphopice_classmap对象的函数
		*/
		c_IcePHP_class* get_hiphopice_classmap();
		/*
			getClassInfoPtrById和getExceptionInfoPtrById新版中已经不用
		*/
		Ice_ClassInfoPtr getClassInfoPtrById(std::string classId);
		ExceptionInfoPtr getExceptionInfoPtrById(std::string exceptionId);
		/*
			将HPHP::String转换为std::string
		*/
		std::string getHPHPStringToStdString(HPHP::String hphpstring);
		
		/*
			封装返回结果的类，采用链表模式封装对象
			Variant result 保存的是返回的解析结果；
			ResultList next 对象，列表等，保存的是对象，属性等信息的下级信息，是一个树状结构
			bool flag;主要用于对象操作，如果类对象是空，那么flag为true ，如果不为空则为false,默认是true ,在读取时会更新状态
		*/
		class ResultCls{
				public:
						Variant result;
						ResultList next;
						bool flag;
						ResultCls(){
								ResultList rlist;
								next=rlist;
								result=Variant();
								flag=true;
						};
						~ResultCls(){
							for(ResultList::iterator itr=next.begin();itr!=next.end();itr++){
									ResultCls *resultCls=*itr;
									delete resultCls;
									resultCls = NULL;
							}
						};
		};

		/*
			Ice的通讯器持久对象；
			每个线程中会保存一个通讯器对象，持久化ice
			factoryWrapperClassSet 保存ID的名字，如果没有重复则插入保存到对象中
			proxyObjectMap key保存的是ice的地址，value保存的是proxy的对象
			p_iceObjectFactoryWrapperPtr 持久化的工厂对象
		*/
		class Ice_Communicator : public SweepableResourceData{
			public:Ice_Communicator(){
				cp=NULL;
			};
			public:~Ice_Communicator(){};
			public:Ice::CommunicatorPtr cp;
			public:std::set<std::string> factoryWrapperClassSet;
			//old code delete
			public:IceObjectFactoryWrapperPtr ifwp;
			//new ice hzg 20130603
			public:P_IceObjectFactoryWrapperPtr p_iceObjectFactoryWrapperPtr;
			public:std::map<std::string,Ice::ObjectPrx> proxyObjectMap;
			public:Ice::ObjectPrx getProxyByName(std::string name){
						   std::map<std::string,Ice::ObjectPrx>::const_iterator iter = proxyObjectMap.find(name);
						   if (iter == proxyObjectMap.end()) {
								   return NULL;
						   }
						   return iter->second;
			};

		};
		/*
			获取当前的线程id
		*/
		char * getCurrentTid();
		/*
			获取当前的线程的通讯器对象
		*/
		Ice_Communicator * getIce_CommunicatorByMap();
		
		/////////20130529///////////////////////////////////////////////////////////////////////
		/*
			如下的对象都是第二个版本中新建的内容，主要是针对对象销毁出现的问题而制定的，将所有的对象信息封装到持久化对象中！
			设计思路为:
			每种类型的类别在定义时会放入到Map中，Key是id,Value是对象的TypeInfo，每个TypeInfo只分配一次地址，每次定义对象时，只刷新地址内的值！
			所有的类型信息均从持久化的对象中取，如果没有则抛出error提示类型不存在！
		*/
		
		/*
			Ice持久化对象的封装类
			typeInfo保存对象的信息
		*/
		class IceStoreMsg : public SweepableResourceData{
			public:IceStoreMsg(){};
			public:~IceStoreMsg(){};
			public:P_TypeInfo* typeInfo;
		};
		/*
			所有持久化类别的基类
			enum Kind 枚举TypeInfo下的所有子类的类别
			typeKind 保存子类的类别
			usesClasses() 判断是否使用对象，默认是false，子类中有响应的函数会进行覆盖
			marshal 封装对象通过outstream流传入到ice后台中,inParams是传入的值
			unmarshal 解封装对象，将inputstream的对象封装到ResultCls中，将解析的值封装到rcs指针中
			unmarshaled 将unmarshal解封装的对象，再次解封装，转换成 hhvm认识的对象通过根的result返回对象，解封装后的数据封装到result中
			print 将对象打印结果如 ：echo $a; 参数：objcount是循环的次数如object #10；inParams传入的对象内容，如$a
		*/
		class P_TypeInfo{
			public:std::string id;	
			public:P_TypeInfo(){};
			public:~P_TypeInfo(){};
			       enum Kind{
				       P_PrimitiveInfo,
				       P_ClassInfo,
				       P_SequenceInfo,
				       P_ExceptionInfo
			       };
			       Kind typeKind;
			       //virtual functions
			       virtual bool usesClasses(){
					return false;
				};
			       virtual void marshal(const Ice::OutputStreamPtr& out,Variant &inParams){};
			       virtual void unmarshal(const Ice::InputStreamPtr& in,ResultCls * rcs){};
			       virtual void unmarshaled(ResultCls *result){};
			       virtual string  print(int objcount,Variant &inParams){};

		};
		
		/*
			基本类型
			目前只支持如下4种基本类型
			$IcePHP__t_string；$IcePHP__t_long$；IcePHP__t_int，IcePHP__t_double
			pkind 保存的基本类型中的类型
			enum PrimitiveKind是基本类型中的枚举类型
		*/
		class P_PrimitiveInfo : public P_TypeInfo{
			public:
				P_PrimitiveInfo(int type){
					pkind = type;
					typeKind = P_TypeInfo::P_PrimitiveInfo;
				};
				~P_PrimitiveInfo(){};
				enum PrimitiveKind
				{
					KindBool,
					KindByte,
					KindShort,
					KindInt,
					KindLong,
					KindFloat,
					KindDouble,
					KindString
				};
				PrimitiveKind pkind;
				static std::string getP_PrimitiveInfoType(int type);
				//virtual functions
				virtual bool usesClasses(){
					return false;
				};
				virtual void marshal(const Ice::OutputStreamPtr& out,Variant &inParams);
				virtual void unmarshal(const Ice::InputStreamPtr& in,ResultCls * rcs);
				virtual void unmarshaled(ResultCls *result);
				virtual string  print(int objcount,Variant &inParams);

		};
		
		/*
			类对象
			name类名
			isAbstract是否是抽象的
			base 基类列表（目前未实现）
			interfaces 接口列表（目前未实现）
			members 封装类下的成员的列表
			defined 是否定义
			methodMap 封装类下的方法Map,key是函数名，Value是封装方法信息的对象
			clearDataMemberList() 清空类下的成员变量列表信息
		*/
		class P_ClassInfo : public P_TypeInfo {
			public:
				P_ClassInfo(){
					typeKind = P_TypeInfo::P_ClassInfo;
				};
				~P_ClassInfo(){};	
				std::string name;
				bool isAbstract;
				P_ClassInfoPtr base;
				P_ClassInfoList interfaces;
				P_DataMemberList members;
				bool defined;
				P_ClassMethodMap methodMap;
				void clearDataMemberList();
			       //virtual functions
			       virtual bool usesClasses(){
					return true;
				};
			       virtual void marshal(const Ice::OutputStreamPtr& out,Variant &inParams);
			       virtual void unmarshal(const Ice::InputStreamPtr& in,ResultCls * rcs);
			       virtual void unmarshaled(ResultCls *result);
			       virtual string  print(int objcount,Variant &inParams);


		};
		
		/*
				封装类的成员信息
				name是成员名称
				type是成员的类型
		*/
		class P_DataMember {
			public:
				P_DataMember(){};
				~P_DataMember(){};
				std::string name;
				P_TypeInfoPtr type;  
		};
		
		/*
			封装类方法的对象
			name是方法名称
			mode是ice的模式
			sendMode发送模式
			inParams输入参数集合
			outParams 输出参数集合（类似引用方式，未实现）
			returnType 封装返回类型
			exceptionList 封装异常列表
			returnsClasses 返回值是否是类
			sendsClasses 传入的参数是否是类
		*/
		class P_ClassMethod {
			public:
				P_ClassMethod(){
					mode=0;
					sendMode=0;
					returnType=NULL;
					returnsClasses=false;
					sendsClasses=false;
				};
				~P_ClassMethod(){};
				std::string name;
				int mode;
				int sendMode;
				P_TypeInfoList inParams;
				P_TypeInfoList outParams;
				P_TypeInfoPtr returnType;
				P_ExceptionInfoList exceptionList;
				bool returnsClasses ;
				bool sendsClasses ;
		};	

		/*
			异常类型
			name:异常类的名称
			p_usesClasses 是否使用类（目前未用）
			base 异常类父类(未实现）
			members 异常类的成员变量集合
			clearDataMemberList 清空类下的成员变量信息
			目前异常类只支持一层，不支持继承
		*/
		class P_ExceptionInfo : public P_TypeInfo {
			public:
				P_ExceptionInfo(){
					typeKind=P_TypeInfo::P_ExceptionInfo;
				};
				~P_ExceptionInfo(){};

				std::string name;
				bool p_usesClasses;
				P_ExceptionInfoPtr base;
				P_DataMemberList members;	
				void clearDataMemberList();
			       //virtual functions
			       virtual bool usesClasses(){};
			       virtual void marshal(const Ice::OutputStreamPtr& out,Variant &inParams);
			       virtual void unmarshal(const Ice::InputStreamPtr& in,ResultCls * rcs);
			       virtual void unmarshaled(ResultCls *result);
			       virtual string  print(int objcount,Variant &inParams);

		};
		
		/*
			列表类型
			elementType 列表元素的类型
			marshalPrimitiveSequence 列表封装基本类型传入到ice服务中
			marshal 实现的是列表封装对象类型传入到ice 服务中
		*/
		class P_SequenceInfo : public P_TypeInfo {
			public:
				P_SequenceInfo(){
					typeKind = P_TypeInfo::P_SequenceInfo;
				};
				~P_SequenceInfo(){};	
				P_TypeInfoPtr elementType;
			       //virtual functions
			       virtual bool usesClasses(){
					return elementType->usesClasses();
				};
			       void marshalPrimitiveSequence(const Ice::OutputStreamPtr& out,Variant &inParams,HPHP::P_PrimitiveInfo *primitiveInfo);
			       virtual void marshal(const Ice::OutputStreamPtr& out,Variant &inParams);
			       virtual void unmarshal(const Ice::InputStreamPtr& in,ResultCls * rcs);
			       virtual void unmarshaled(ResultCls *result);
			       virtual string  print(int objcount,Variant &inParams);

		};
		
		/*
			将c_typeInfo转换成p_typeInfo
			也就是将 hhvm页面支持的类型转换成内部的持久化后的对象类型
		*/
		P_TypeInfoPtr c_TypeInfoToP_TypeInfoPtr(c_TypeInfo* typeInfo);
		///////////////////////////////////////////////////////////////////////////////
		//new Ice stream function 
		/*
			ice返回对象信息一般调用这么几步
			(1)将类的名称加入到FactoryWrapper中
			(2)加入后，可以通过IceObjectRead对象中的read进行异步读取
			(3)通过IceReadObjectCallback中的invoke函数接收回调的返回值
		*/
		/*
				读取对象的类
				classId 保存类的id
				resultList 将read出的数据封装到resultList中，然后在invoke 中封装到ResultCls 的next中
				read函数是ice识别到有该类的调用read读取数据
		*/
		class P_IceObjectReader :public Ice::ObjectReader{
				public:
						string classId;
						ResultList resultList;	
						P_ClassInfoPtr classInfo;
						P_IceObjectReader(const string &classId);
						virtual void read(const Ice::InputStreamPtr& in, bool rid);
		};
		
		/*
			ice读取信息的回调函数封装类
			rcs 封装一个类对象的返回值信息
			className 类的名称
			invoke 函数是通过read函数，回答函数中可以获取返回的对象值
		*/
		class P_IceReadObjectCallback : public Ice::ReadObjectCallback{
				public:
						string className;
						ResultCls * rcs;
						P_IceReadObjectCallback(const string className,ResultCls * rcs);
						virtual void invoke(const Ice::ObjectPtr& p);
		};

		/*
			封装一个类的信息的工厂对象
		*/
		class P_IceObjectFactory : public Ice::ObjectFactory{
				public:
						P_IceObjectFactory();
						virtual Ice::ObjectPtr create(const string& type);
						virtual void destroy(){};

		};

		/*
			将一个对象的工厂对象信息封装到P_IceObjectFactoryWrapper容器中
		*/
		class P_IceObjectFactoryWrapper : public Ice::ObjectFactory{
				public:
						Ice::ObjectFactoryPtr _factory;
						P_IceObjectFactoryWrapper(){};
						virtual Ice::ObjectPtr create(const string& type);
						virtual void destroy(){};
						void setFactory(const Ice::ObjectFactoryPtr& factory);

		};

		/*
			将对象的参数传入到ice后端的对象
			write 函数是将数据传入到后端，也需要工厂类的支持
			classInfo 保存传入数据的类型
			inParams 传入的数据
		*/
		class P_IceObjectWriter : public Ice::ObjectWriter{
				public:
						Variant inParams;
						P_ClassInfoPtr classInfo;
						P_IceObjectWriter(const P_ClassInfoPtr &classInfo,Variant &inParams); 
						virtual void  write(const Ice::OutputStreamPtr& out) const;
		};
		typedef IceUtil::Handle<P_IceObjectWriter> P_IceObjectWriterPtr;
		typedef IceUtil::Handle<P_IceObjectReader> P_IceObjectReaderPtr;
		typedef IceUtil::Handle<P_IceReadObjectCallback> P_IceReadObjectCallbackPtr;
		/*
			getP_ClassInfoPtrById 根据id 获取持久化的类对象信息
			getP_ExceptionInfoPtrById 根据id获取持久化的异常类对象信息
		*/
		P_ClassInfoPtr getP_ClassInfoPtrById(const string &classId);
		P_ExceptionInfoPtr getP_ExceptionInfoPtrById(const string &exceptionId);
		///////////////////////////////////////////////////////////////////////////////
}

#endif // __EXT_ICE_H__

