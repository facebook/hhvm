<?php

///////////////////////////////////////////////////////////////////////////////
// helpers

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflector.php )
 *
 * Reflector is an interface implemented by all exportable Reflection
 * classes.
 *
 */
interface Reflector {
  public function __toString();
}

class ReflectionException extends Exception {
}

///////////////////////////////////////////////////////////////////////////////
// parameter

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionparameter.php )
 *
 * The ReflectionParameter class retrieves information about a function's
 * or method's parameters.
 *
 * To introspect function parameters, first create an instance of the
 * ReflectionFunction or ReflectionMethod classes and then use their
 * ReflectionFunctionAbstract::getParameters() method to retrieve an array
 * of parameters.
 *
 */
class ReflectionParameter implements Reflector {
  public $info;

  public function __construct($func, $param) {
    if ($func && $param) {
      $params = $func->getParameters();
      $this->info = $params[$param]->info;
    }
  }

  public function __toString() {
    // TODO
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionparameter.export.php )
 *
 * Exports. WarningThis function is currently not documented; only its
 * argument list is available.
 *
 * @func       mixed   The function name.
 * @param      mixed   The parameter name.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   The exported reflection.
 */
  public static function export($func, $param, $ret=false) {
    $obj = new ReflectionParameter($func, $param);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionparameter.getname.php
 * )
 *
 * Gets the name of the parameter.
 *
 * @return     mixed   The name of the reflected parameter.
 */
  public function getName() {
    return $this->info['name'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.ispassedbyreference.php )
 *
 * Checks if the parameter is passed in by reference. WarningThis function
 * is currently not documented; only its argument list is available.
 *
 * @return     mixed   TRUE if the parameter is passed in by reference,
 *                     otherwise FALSE
 */
  public function isPassedByReference() {
    return isset($this->info['ref']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.getdeclaringclass.php )
 *
 * Gets the declaring class. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   A ReflectionClass object.
 */
  public function getDeclaringClass() {
    if (empty($this->info['class'])) {
      return null;
    }
    return new ReflectionClass($this->info['class']);
  }

  public function getDeclaringFunction() {
    if (empty($this->info['class'])) {
      return new ReflectionFunction($this->info['function']);
    }
    return new ReflectionMethod($this->info['class'], $this->info['function']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionparameter.getclass.php
 * )
 *
 * Gets a class. WarningThis function is currently not documented; only
 * its argument list is available.
 *
 * @return     mixed   A ReflectionClass object.
 */
  public function getClass() {
    if (empty($this->info['type'])) {
      return null;
    }
    $ltype = strtolower($this->info['type']);
    if (hphp_scalar_typehints_enabled()) {
      $nonClassTypehints = array(
        'bool' => 1,
        'boolean' => 1,
        'int' => 1,
        'integer' => 1,
        'real' => 1,
        'double' => 1,
        'float' => 1,
        'string' => 1,
        'array' => 1
      );
      if (isset($nonClassTypehints[$ltype])) {
        return null;
      }
    } else if ($ltype === 'array') {
      return null;
    }
    return new ReflectionClass($this->info['type']);
  }

  public function getTypehintText() {
    if (isset($this->info['type_hint'])) {
      return $this->info['type_hint'];
    }
    return '';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionparameter.isarray.php
 * )
 *
 * Checks if the parameter expects an array.
 *
 * @return     mixed   TRUE if an array is expected, FALSE otherwise.
 */
  public function isArray() {
    return $this->info['type'] == 'array';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.allowsnull.php )
 *
 * Checks whether the parameter allows NULL. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @return     mixed   TRUE if NULL is allowed, otherwise FALSE
 */
  public function allowsNull() {
    return isset($this->info['nullable']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.isoptional.php )
 *
 * Checks if the parameter is optional.
 *
 * @return     mixed   TRUE if the parameter is optional, otherwise FALSE
 */
  public function isOptional() {
    return array_key_exists('default', $this->info);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.isdefaultvalueavailable.php
 * )
 *
 * Checks if a default value for the parameter is available.
 *
 * @return     mixed   TRUE if a default value is available, otherwise
 *                     FALSE
 */
  public function isDefaultValueAvailable() {
    return array_key_exists('default', $this->info);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.getdefaultvalue.php )
 *
 * Gets the default value of the parameter for a user-defined function or
 * method. If the parameter is not optional a ReflectionException will be
 * thrown.
 *
 * @return     mixed   The parameters default value.
 */
  public function getDefaultValue() {
    if (!$this->isOptional()) {
      throw new ReflectionException('Parameter is not optional');
    }
    $defaultValue = $this->info['default'];
    if ($defaultValue instanceof stdclass) {
      if (isset($defaultValue->class)) {
        return hphp_get_class_constant($defaultValue->class,
                                       $defaultValue->name);
      }
      hphp_throw_fatal_error($defaultValue->msg);
    }
    return $defaultValue;
  }

  public function getDefaultValueText() {
    if (isset($this->info['defaultText'])) {
      return $this->info['defaultText'];
    }
    return '';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.getposition.php )
 *
 * Gets the position of the parameter.
 *
 * @return     mixed   The position of the parameter, left to right,
 *                     starting at position #0.
 */
  public function getPosition() {
    return $this->info['index'];
  }

  public function getAttribute($name) {
    $attrs = $this->info['attributes'];
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributes() {
    return $this->info['attributes'];
  }

  public function getAttributeRecursive($name) {
    $attrs = $this->getAttributesRecursive();
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributesRecursive() {
    if (!isset($this->info['class'])) {
      return $this->getAttributes();
    }

    $attrs = array();
    $class = $this->getDeclaringClass();
    $function_name = $this->info['function'];
    $index = $this->info['index'];
    self::collectAttributes(&$attrs, $class, $function_name, $index);
    return $attrs;
  }

  private static function collectAttributes(&$attrs, $class, $function_name,
                                            $index) {
    if ($class->hasMethod($function_name)) {
      $method = $class->getMethod($function_name);
      $params = $method->getParameters();
      if (count($params) >= $index) {
        $attrs += $params[$index]->getAttributes();
      }
    }

    $parent = $class->getParentClass();
    if ($parent) {
      self::collectAttributes(
        &$attrs,
        $parent,
        $function_name,
        $index);
    }
  }
}

///////////////////////////////////////////////////////////////////////////////

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/class.reflectionfunctionabstract.php )
 *
 * A parent class to ReflectionFunction, read its description for details.
 *
 */
class ReflectionFunctionAbstract {
  public $info;

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getname.php )
 *
 * Get the name of the function. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The name of the function.
 */
  public function getName() {
    return $this->info['name'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.isinternal.php )
 *
 * Checks whether the function is internal, as opposed to user-defined.
 * WarningThis function is currently not documented; only its argument list
 * is available.
 *
 * @return     mixed   TRUE if it's internal, otherwise FALSE
 */
  public function isInternal() {
    return isset($this->info['internal']);
  }

  public function getClosure() {
    return $this->info['closure'];
  }

  public function isClosure() {
    return !empty($this->info['is_closure']);
  }

  public function isGenerator() {
    return !empty($this->info['is_generator']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.isuserdefined.php )
 *
 * Checks whether the function is user-defined, as opposed to internal.
 * WarningThis function is currently not documented; only its argument list
 * is available.
 *
 * @return     mixed   TRUE if it's user-defined, otherwise false;
 */
  public function isUserDefined() {
    return !isset($this->info['internal']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getfilename.php )
 *
 * Gets the file name from a user-defined function. WarningThis function
 * is currently not documented; only its argument list is available.
 *
 * @return     mixed   The file name.
 */
  public function getFileName() {
    return $this->info['file'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getstartline.php )
 *
 * Gets the starting line number of the function. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @return     mixed   The starting line number.
 */
  public function getStartLine() {
    return $this->info['line1'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getendline.php )
 *
 * Get the ending line number. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The ending line number of the user defined class, or
 *                     FALSE if unknown.
 */
  public function getEndLine() {
    return $this->info['line2'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getdoccomment.php )
 *
 * Get a Doc comment from a function. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @return     mixed   The doc comment if it exists, otherwise FALSE
 */
  public function getDocComment() {
    return $this->info['doc'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getstaticvariables.php
 * )
 *
 * Get the static variables. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   An array of static variables.
 */
  public function getStaticVariables() {
    return $this->info['static_variables'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.returnsreference.php
 * )
 *
 * Checks whether the function returns a reference. WarningThis function
 * is currently not documented; only its argument list is available.
 *
 * @return     mixed   TRUE if it returns a reference, otherwise FALSE
 */
  public function returnsReference() {
    return isset($this->info['ref']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getparameters.php )
 *
 * Get the parameters as an array of ReflectionParameter. WarningThis
 * function is currently not documented; only its argument list is
 * available.
 *
 * @return     mixed   The parameters, as a ReflectionParameter object.
 */
  public function getParameters() {
    $ret = array();
    foreach ($this->info['params'] as $name => $info) {
      $param = new ReflectionParameter(null, null);
      $param->info = $info;
      $ret[] = $param;
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getnumberofparameters.php
 * )
 *
 * Get the number of parameters that a function defines, both optional and
 * required. WarningThis function is currently not documented; only its
 * argument list is available.
 *
 * @return     mixed   The number of parameters.
 */
  public function getNumberOfParameters() {
    return count($this->info['params']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getnumberofrequiredparameters.php
 * )
 *
 * Get the number of required parameters that a function defines.
 * WarningThis function is currently not documented; only its argument list
 * is available.
 *
 * @return     mixed   The number of required parameters.
 */
  public function getNumberOfRequiredParameters() {
    $count = 0;
    $params = $this->getParameters();
    foreach ($params as $name => $param) {
      if ($param->isOptional()) {
        break;
      }
      $count++;
    }
    return $count;
  }

  public function getReturnTypehintText() {
    if (isset($this->info['return_type'])) {
      return $this->info['return_type'];
    }
    return '';
  }
}

///////////////////////////////////////////////////////////////////////////////
// function

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionfunction.php )
 *
 * The ReflectionFunction class reports information about a function.
 *
 * Parent class ReflectionFunctionAbstract has the same methods except
 * invoke(), invokeArgs(), export() and isDisabled().
 *
 */
class ReflectionFunction extends ReflectionFunctionAbstract
implements Reflector {
  const IS_DEPRECATED = 262144;

  public function __construct($name) {
    if ($name instanceof Closure) {
      $this->info = hphp_get_closure_info($name);
    } else {
      $this->info = hphp_get_function_info($name);
      if (empty($this->info)) {
        throw new ReflectionException("Function $name does not exist");
      }
    }
  }

  public function __toString() {
    //TODO
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionfunction.export.php )
 *
 * Exports a Reflected function. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @name       mixed   The reflection to export.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   If the return parameter is set to TRUE, then the
 *                     export is returned as a string, otherwise NULL is
 *                     returned.
 */
  public static function export($name, $ret=false) {
    $obj = new ReflectionFunction($name);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionfunction.invoke.php )
 *
 * Invokes a reflected function.
 *
 */
  public function invoke() {
    $args = func_get_args();
    if (isset($this->info['closureobj'])) {
      $closure = $this->info['closureobj'];
      return hphp_invoke_method($closure, get_class($closure),
                                '__invoke', $args);
    }
    return hphp_invoke($this->info['name'], $args);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunction.invokeargs.php )
 *
 * Invokes args. WarningThis function is currently not documented; only
 * its argument list is available.
 *
 * @args       mixed   The args to invoke.
 */
  public function invokeArgs($args) {
    if (isset($this->info['closureobj'])) {
      $closure = $this->info['closureobj'];
      return hphp_invoke_method($closure, get_class($closure),
                                '__invoke', array_values($args));
    }
    return hphp_invoke($this->info['name'], array_values($args));
  }

  public function getAttribute($name) {
    $attrs = $this->info['attributes'];
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributes() {
    return $this->info['attributes'];
  }

  public function getAttributeRecursive($name) {
    $attrs = $this->info['attributes'];
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributesRecursive() {
    return $this->info['attributes'];
  }
}

///////////////////////////////////////////////////////////////////////////////
// class

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionclass.php )
 *
 * The ReflectionClass class reports information about a class.
 *
 */
class ReflectionClass implements Reflector {
  const IS_IMPLICIT_ABSTRACT = 16 ;
  const IS_EXPLICIT_ABSTRACT = 32 ;
  const IS_FINAL = 64 ;

  public $name;
  private $info = null;
  private static $fetched = array();

  public function __construct($name) {
    if (is_object($name)) {
      $name = get_class($name);
    }

    $this->name = hphp_get_original_class_name($name);
    if (empty($this->name)) {
      throw new ReflectionException("Class $name does not exist");
    }
  }

  private function fetch($what) {
    if (!$this->info) {
      $this->info = self::fetch_recur($this->name);
      $this->info['properties'] += $this->info['private_properties'];
    }
    return $this->info[$what];
  }

  private static function fetch_recur($name) {
    if (isset(self::$fetched[$name])) return self::$fetched[$name];
    $info = hphp_get_class_info($name);
    if (empty($info)) {
      throw new ReflectionException("Class $name does not exist");
    }

    $info['attributes_rec'] = $info['attributes'];

    $abstract = isset($info['abstract']) || isset($info['interface']);
    // flattening the trees, so it's easier for lookups
    foreach ($info['interfaces'] as $interface => $_) {
      $p = self::fetch_recur($interface);
      if ($abstract) $info['methods'] += $p['methods'];
      $info['constants'] += $p['constants'];
      $info['interfaces'] += $p['interfaces'];
    }

    $parent = $info['parent'];
    if (!empty($parent)) {
      $p = self::fetch_recur($parent);
      if (isset($p['interface'])) {
        $info['interfaces'][$parent] = 1;
      } else {
        $info['properties'] += $p['properties'];
      }
      $info['methods'] += $p['methods'];
      $info['constants']  += $p['constants'];
      $info['interfaces'] += $p['interfaces'];
      $info['attributes_rec'] += $p['attributes_rec'];
    }
    self::$fetched[$name] = $info;
    return $info;
  }

  private function check($what) {
    if (!$this->info) {
      $this->info = self::fetch_recur($this->name);
    }
    return isset($this->info[$what]);
  }

  private function test($what, $name) {
    $v = $this->fetch($what);
    return $v && isset($v[$name]);
  }

  public function __toString() {
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.export.php )
 *
 * Exports a reflected class. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @name       mixed   The reflection to export.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   If the return parameter is set to TRUE, then the
 *                     export is returned as a string, otherwise NULL is
 *                     returned.
 */
  public static function export($name, $ret=false) {
    $obj = new ReflectionClass($name);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getname.php )
 *
 * Gets the class name. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @return     mixed   The class name.
 */
  public function getName() {
    return $this->name;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.isinternal.php )
 *
 * Checks whether the class is internal, as opposed to user-defined.
 * WarningThis function is currently not documented; only its argument list
 * is available.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isInternal() {
    return $this->check('internal');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.isuserdefined.php )
 *
 * Checks whether the class is user-defined, as opposed to internal.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isUserDefined() {
    return !$this->check('internal');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.isinstantiable.php )
 *
 * Checks if the class is instanciable. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isInstantiable() {
    return !$this->check('abstract');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.hasconstant.php
 * )
 *
 * Checks whether the class has a specific constant defined or not.
 *
 * @name       mixed   The name of the constant being checked for.
 *
 * @return     mixed   TRUE if the constant is defined, otherwise FALSE.
 */
  public function hasConstant($name) {
    return $this->test('constants', $name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.hasmethod.php )
 *
 * Checks whether a specific method is defined in a class.
 *
 * @name       mixed   Name of the method being checked for.
 *
 * @return     mixed   TRUE if it has the method, otherwise FALSE
 */
  public function hasMethod($name) {
    return $this->test('methods', strtolower($name));
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.hasproperty.php
 * )
 *
 * Checks whether the specified property is defined.
 *
 * @name       mixed   Name of the property being checked for.
 *
 * @return     mixed   TRUE if it has the property, otherwise FALSE
 */
  public function hasProperty($name) {
    return $this->test('properties', $name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getfilename.php
 * )
 *
 * Gets the filename of the file in which the class has been defined.
 *
 * @return     mixed   Returns the filename of the file in which the class
 *                     has been defined. If the class is defined in the PHP
 *                     core or in a PHP extension, FALSE is returned.
 */
  public function getFileName() {
    return $this->fetch('file');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getstartline.php
 * )
 *
 * Get the starting line number. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The starting line number, as an integer.
 */
  public function getStartLine() {
    return $this->fetch('line1');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getendline.php )
 *
 * Gets end line number from a user-defined class definition.
 *
 * @return     mixed   The ending line number of the user defined class, or
 *                     FALSE if unknown.
 */
  public function getEndLine() {
    return $this->fetch('line2');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getdoccomment.php )
 *
 * Gets doc comments from a class. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The doc comment if it exists, otherwise FALSE
 */
  public function getDocComment() {
    return $this->fetch('doc');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getconstructor.php )
 *
 * Gets the constructor from a class. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @return     mixed   A ReflectionMethod object.
 */
  public function getConstructor() {
    if ($this->hasMethod('__construct')) {
      return $this->getMethod('__construct');
    }
    if (!$this->isTrait() && $this->hasMethod($name = $this->name)) {
      return $this->getMethod($name);
    }
    return null;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getmethod.php )
 *
 * Gets a ReflectionMethod about a method. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @name       mixed   The method name to reflect.
 *
 * @return     mixed   A ReflectionMethod.
 */
  public function getMethod($name) {
    if (!$this->info) {
      $method = hphp_get_method_info($this->name, $name);
    } else {
      $lname = strtolower($name);
      $methods = $this->info['methods'];
      if (isset($methods[$lname])) $method = $methods[$lname];
    }
    if (empty($method)) {
      $class = $this->name;
      throw new ReflectionException("Method $class::$name does not exist");
    }

    $ret = new ReflectionMethod(null, null);
    $ret->info  = $method;
    $ret->name  = $method['name'];
    $ret->class = $method['class'];
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getmethods.php )
 *
 * Gets a list of methods. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @filter     mixed   Any combination of ReflectionMethod::IS_STATIC,
 *                     ReflectionMethod::IS_PUBLIC,
 *                     ReflectionMethod::IS_PROTECTED,
 *                     ReflectionMethod::IS_PRIVATE,
 *                     ReflectionMethod::IS_ABSTRACT,
 *                     ReflectionMethod::IS_FINAL.
 *
 * @return     mixed   An array of methods.
 */
  public function getMethods($filter = 0xFFFF) {
    $ret = array();
    $methods = $this->fetch('methods');
    foreach ($methods as $name => $_) {
      $m = $this->getMethod($name);
      if ((($filter & ReflectionMethod::IS_PUBLIC))    && $m->isPublic()    ||
          (($filter & ReflectionMethod::IS_PROTECTED)) && $m->isProtected() ||
          (($filter & ReflectionMethod::IS_PRIVATE))   && $m->isPrivate()   ||
          (($filter & ReflectionMethod::IS_STATIC))    && $m->isStatic()    ||
          (($filter & ReflectionMethod::IS_FINAL))     && $m->isFinal()     ||
          (($filter & ReflectionMethod::IS_ABSTRACT    && $m->isAbstract()))) {
        $ret[] = $m;
      }
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getproperty.php
 * )
 *
 * Gets a property. WarningThis function is currently not documented; only
 * its argument list is available.
 *
 * @name       mixed   The property name.
 *
 * @return     mixed   A ReflectionProperty.
 */
  public function getProperty($name) {
    $properties = $this->fetch('properties');
    if (!isset($properties[$name])) {
      $class = $this->info['name'];
      throw new ReflectionException("Property $class::$name does not exist");
    }

    $ret = new ReflectionProperty(null, null);
    $ret->info  = $properties[$name];
    $ret->name  = $name;
    $ret->class = $this->info['name'];
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getproperties.php )
 *
 * Retrieves reflected properties.
 *
 * @return     mixed   An array of ReflectionProperty objects.
 */
  public function getProperties($filter = 0xFFFF) {
    $ret = array();
    foreach ($this->fetch('properties') as $name => $_) {
      $p = $this->getProperty($name);
      if (($filter & ReflectionProperty::IS_PUBLIC)    && $p->isPublic()    ||
          ($filter & ReflectionProperty::IS_PROTECTED) && $p->isProtected() ||
          ($filter & ReflectionProperty::IS_PRIVATE)   && $p->isPrivate()   ||
          ($filter & ReflectionProperty::IS_STATIC)    && $p->isStatic()) {
        $ret[] = $p;
      }
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getconstants.php
 * )
 *
 * Gets defined constants from a class. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @return     mixed   An array of constants.
 */
  public function getConstants() {
    return $this->fetch('constants');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getconstant.php
 * )
 *
 * Gets the defined constants. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @name       mixed
 */
  public function getConstant($name) {
    $constants = $this->fetch('constants');
    if (!isset($constants[$name])) {
      $class = $this->info['name'];
      throw new ReflectionException("Class constant $class::$name does not exist");
    }
    return $constants[$name];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getinterfaces.php )
 *
 * Gets the interfaces.
 *
 * @return     mixed   An associative array of interfaces, with keys as
 *                     interface names and the array values as
 *                     ReflectionClass objects.
 */
  public function getInterfaces() {
    $ret = array();
    foreach ($this->fetch('interfaces') as $name => $_) {
      $cls = new ReflectionClass($name);
      if ($cls->isInterface()) {
        $ret[$cls->getName()] = $cls;
      }
    }
    return $ret;
  }

  public function getTraits() {
    $ret = array();
    foreach ($this->fetch('traits') as $name => $_) {
      $cls = new ReflectionClass($name);
      if ($cls->isTrait()) {
        $ret[$cls->getName()] = $cls;
      }
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getinterfacenames.php )
 *
 * Get the interface names.
 *
 * @return     mixed   A numerical array with interface names as the
 *                     values.
 */
  public function getInterfaceNames() {
    $ret = array();
    foreach ($this->fetch('interfaces') as $name => $_) {
      $cls = new ReflectionClass($name);
      if ($cls->isInterface()) {
        $ret[] = $cls->getName();
      }
    }
    return $ret;
  }

  public function getTraitNames() {
    $ret = array();
    foreach ($this->fetch('traits') as $name => $_) {
      $cls = new ReflectionClass($name);
      if ($cls->isTrait()) {
        $ret[] = $cls->getName();
      }
    }
    return $ret;
  }

  public function getTraitAliases() {
    $ret = array();
    foreach ($this->fetch('trait_aliases') as $old_name => $new_name) {
      $ret[$old_name] = $new_name;
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.isinterface.php
 * )
 *
 * Checks whether the class is an interface. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isInterface() {
    return $this->check('interface');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.isabstract.php )
 *
 * Checks if the class is abstract.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isAbstract() {
    return $this->check('abstract');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.isfinal.php )
 *
 * Checks if a class is final.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isFinal() {
    return $this->check('final');
  }

  public function isTrait() {
    return $this->check('trait');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getmodifiers.php
 * )
 *
 * WarningThis function is currently not documented; only its argument
 * list is available.
 *
 */
  public function getModifiers() {
    return $this->fetch('modifiers');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.isinstance.php )
 *
 * Checks if an object is an instance of a class.
 *
 * @obj        mixed   The object being compared to.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isInstance($obj) {
    return hphp_instanceof($obj, $this->name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.newinstance.php
 * )
 *
 * Creates a new cass instance of the class, the given arguments are
 * passed to the class constructor.
 *
 */
  public function newInstance() {
    $args = func_get_args();
    return hphp_create_object($this->name, $args);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.newinstanceargs.php )
 *
 * Creates a new cass instance of the class, the given arguments are
 * passed to the class constructor. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @args       mixed   The parameters to be passed to the class constructor
 *                     as an array.
 *
 * @return     mixed   Returns a new instance of the class.
 */
  public function newInstanceArgs($args) {
    return hphp_create_object($this->name, array_values($args));
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.newinstancewithoutconstructor.php )
 *
 * Creates a new instance of the class without invoking the constructor.
 *
 * @return     mixed   Returns a new instance of the class.
 */
  public function newInstanceWithoutConstructor() {
    return hphp_create_object_without_constructor($this->name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getparentclass.php )
 *
 * WarningThis function is currently not documented; only its argument
 * list is available.
 *
 * @return     mixed   A ReflectionClass.
 */
  public function getParentClass() {
    $parent = $this->fetch('parent');
    if (empty($parent)) {
      return false;
    }
    return new ReflectionClass($parent);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.issubclassof.php
 * )
 *
 * Checks if the class is a subclass of a specified class.
 *
 * @cls        mixed   The class name being checked against.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isSubclassOf($cls) {
    if ($cls instanceof ReflectionClass) {
      $cls = $cls->name;
    }
    foreach ($this->fetch('interfaces') as $name => $_) {
      if (strcasecmp($cls, $name) == 0) {
        return true;
      }
    }
    $parent = $this->fetch('parent');
    if (empty($parent)) {
      return false;
    }
    if (strcasecmp($cls, $parent) == 0) {
      return true;
    }
    return $this->getParentClass()->isSubclassOf($cls);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getstaticproperties.php )
 *
 * Get the static properties. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The static properties, as an array.
 */
  public function getStaticProperties() {
    $ret = array();
    foreach ($this->getProperties() as $prop) {
      if ($prop->isStatic()) {
        $ret[$prop->name] = $prop;
      }
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getstaticpropertyvalue.php )
 *
 * Gets the static property values. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @name       mixed
 * @default    mixed
 */
  public function getStaticPropertyValue($name, $default = null) {
    if ($this->hasProperty($name) &&
        $this->getProperty($name)->isStatic()) {
      return hphp_get_static_property($this->name, $name);
    }
    return $default;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.setstaticpropertyvalue.php )
 *
 * Sets static property value. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @name       mixed   Property name.
 * @value      mixed   New property value.
 *
 * @return     mixed   No value is returned.
 */
  public function setStaticPropertyValue($name, $value) {
    hphp_set_static_property($this->name, $name, $value);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getdefaultproperties.php )
 *
 * Gets default properties from a class. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @return     mixed   An array of default properties.
 */
  public function getDefaultProperties() {
    $ret = array();
    foreach ($this->getProperties() as $prop) {
      if ($prop->isDefault()) {
        $ret[$prop->name] = $prop;
      }
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.isiterateable.php )
 *
 * Checks whether the class is iterateable.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isIterateable() {
    return $this->isSubclassOf('ArrayAccess');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.implementsinterface.php )
 *
 * Checks whether it implements an interface.
 *
 * @cls        mixed   The interface name.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function implementsInterface($cls) {
    if ($cls instanceof ReflectionClass) {
      $cls = $cls->name;
    }
    if (!interface_exists($cls)) {
      throw new ReflectionException("$cls is not an Interface");
    }
    foreach ($this->fetch('interfaces') as $name => $_) {
      if (strcasecmp($cls, $name) == 0) {
        return true;
      }
    }
    return false;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getextension.php
 * )
 *
 * Gets an extensions ReflectionExtension object. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @return     mixed   A ReflectionExtension object.
 */
  public function getExtension() {
    return $this->fetch('extension');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getextensionname.php )
 *
 * Gets an extensions name. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The extensions name.
 */
  public function getExtensionName() {
    return $this->fetch('extension')->getName();
  }

  public function getAttribute($name) {
    $attrs = $this->fetch('attributes');
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributes() {
    return $this->fetch('attributes');
  }

  public function getAttributeRecursive($name) {
    $attrs = $this->fetch('attributes_rec');
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributesRecursive() {
    return $this->fetch('attributes_rec');
  }
}

///////////////////////////////////////////////////////////////////////////////
// object

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionobject.php )
 *
 * The ReflectionObject class reports information about an object.
 *
 */
class ReflectionObject extends ReflectionClass {
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionobject.export.php )
 *
 * Exports a reflection. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @obj        mixed   The reflection to export.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   If the return parameter is set to TRUE, then the
 *                     export is returned as a string, otherwise NULL is
 *                     returned.
 */
  public static function export($obj, $ret=false) {
    $obj = new ReflectionObject($obj);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }
}

///////////////////////////////////////////////////////////////////////////////
// property

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionproperty.php )
 *
 * The ReflectionProperty class reports information about a classes
 * properties.
 *
 */
class ReflectionProperty implements Reflector {
  const IS_STATIC = 1;
  const IS_PUBLIC = 256;
  const IS_PROTECTED = 512;
  const IS_PRIVATE = 1024;

  public $info;
  public $name;
  public $class;

  public function __construct($cls, $name) {
    if ($cls && $name) {
      if (!is_object($cls)) {
        $cls = new ReflectionClass($cls);
      } else {
        $cls = new ReflectionClass(get_class($cls));
      }
      $prop = $cls->getProperty($name);
      if ($prop) {
        $this->info  = $prop->info;
        $this->name  = $prop->name;
        $this->class = $prop->class;
      }
    }
  }

  public function __toString() {
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.export.php )
 *
 * Exports a reflection. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @cls        mixed   The reflection to export.
 * @name       mixed   The property name.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 */
  public static function export($cls, $name, $ret=false) {
    if (!is_object($cls)) {
      $cls = new ReflectionClass($cls);
    } else {
      $cls = new ReflectionClass(get_class($cls));
    }
    $obj = $cls->getProperty($name);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.getname.php )
 *
 * Gets the properties name. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The name of the reflected property.
 */
  public function getName() {
    return $this->info['name'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.ispublic.php
 * )
 *
 * Checks whether the property is public.
 *
 * @return     mixed   TRUE if the property is public, FALSE otherwise.
 */
  public function isPublic() {
    return $this->info['access'] == 'public';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.isprivate.php
 * )
 *
 * Checks whether the property is private.
 *
 * @return     mixed   TRUE if the property is private, FALSE otherwise.
 */
  public function isPrivate() {
    return $this->info['access'] == 'private';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionproperty.isprotected.php )
 *
 * Checks whether the property is protected.
 *
 * @return     mixed   TRUE if the property is protected, FALSE otherwise.
 */
  public function isProtected() {
    return $this->info['access'] == 'protected';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.isstatic.php
 * )
 *
 * Checks whether the property is static.
 *
 * @return     mixed   TRUE if the property is static, FALSE otherwise.
 */
  public function isStatic() {
    return isset($this->info['static']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.isdefault.php
 * )
 *
 * Checks whether the property is the default.
 *
 * @return     mixed   TRUE if the property was declared at compile-time,
 *                     or FALSE if it was created at run-time.
 */
  public function isDefault() {
    return $this->info['default'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionproperty.setaccessible.php )
 *
 * Sets a property to be accessible. For example, it may allow protected
 * and private properties to be accessed.
 *
 * @return     mixed   No value is returned.
 */
  public function setAccessible($accessible) {
    throw new ReflectionException(__METHOD__." is not supported");
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionproperty.getmodifiers.php )
 *
 * Gets the modifiers. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @return     mixed   A numeric representation of the modifiers.
 */
  public function getModifiers() {
    return $this->info['modifiers'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.getvalue.php
 * )
 *
 * Gets the properties value. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @obj        mixed   The object being reflected.
 *
 * @return     mixed   The current value of the property.
 */
  public function getValue($obj = null) {
    if ($this->isStatic()) {
      return hphp_get_static_property($this->info['class'],
                                      $this->info['name']);
    }
    if ($obj) {
      return hphp_get_property($obj, $this->info['class'],
                               $this->info['name']);
    }
    return null;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.setvalue.php
 * )
 *
 * Sets (changes) a properties value. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @obj        mixed   The object name.
 * @value      mixed   The new value.
 *
 * @return     mixed   No value is returned.
 */
  public function setValue($obj, $value) {
    if ($this->isStatic()) {
      hphp_set_static_property($this->info['class'], $this->info['name'],
                               $value);
    } else {
      hphp_set_property($obj, $this->info['class'], $this->info['name'],
                        $value);
    }
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionproperty.getdeclaringclass.php )
 *
 * Gets the declaring class. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   A ReflectionClass object.
 */
  public function getDeclaringClass() {
    if (empty($this->info['class'])) {
      return null;
    }
    return new ReflectionClass($this->info['class']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionproperty.getdoccomment.php )
 *
 * Gets the doc comment. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @return     mixed   The doc comment.
 */
  public function getDocComment() {
    return $this->info['doc'];
  }

  public function getTypehintText() {
    if (isset($this->info['type'])) {
      return $this->info['type'];
    }
    return '';
  }
}

///////////////////////////////////////////////////////////////////////////////
// method

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionmethod.php )
 *
 * The ReflectionMethod class reports information about a method.
 *
 */
class ReflectionMethod extends ReflectionFunctionAbstract
implements Reflector {
  const IS_STATIC = 1;
  const IS_PUBLIC = 256;
  const IS_PROTECTED = 512;
  const IS_PRIVATE = 1024;
  const IS_ABSTRACT = 2;
  const IS_FINAL = 4;

  public $name;
  public $class;

  public function __construct($cls, $name = '') {
    if (!$name && is_string($cls)) {
      $arr = explode('::', $cls);
      if (count($arr) == 2) {
        $cls = $arr[0];
        $name = $arr[1];
      }
    }
    if ($cls && $name) {
      $method = hphp_get_method_info($cls, $name);
      if (!$method) {
        throw new ReflectionException("Method $cls::$name does not exist");
      }

      $this->info  = $method;
      $this->name  = $method['name'];
      $this->class = $method['class'];
    }
  }

  public function __toString() {
    //TODO
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.export.php )
 *
 * Exports a ReflectionMethod. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @cls        mixed   The class name.
 * @name       mixed   The name of the method.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   If the return parameter is set to TRUE, then the
 *                     export is returned as a string, otherwise NULL is
 *                     returned.
 */
  public static function export($cls, $name, $ret=false) {
    if (!is_object($cls)) {
      $cls = new ReflectionClass($cls);
    } else {
      $cls = new ReflectionClass(get_class($cls));
    }
    $obj = $cls->getMethod($name);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.invoke.php )
 *
 * Invokes a reflected method.
 *
 * @obj        mixed   The object to invoke the method on. In case of
 *                     static methods, you can pass null to this parameter.
 *
 * @return     mixed   Returns the method result.
 */
  public function invoke($obj) {
    $args = func_get_args();
    array_shift($args);
    return hphp_invoke_method($obj, $this->info['class'], $this->info['name'],
                              $args);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.invokeargs.php
 * )
 *
 * Invoke arguments.
 *
 * @obj        mixed   The object to invoke the method on. In case of
 *                     static methods, you can pass null to this parameter.
 * @args       mixed   The parameters to be passed to the function, as an
 *                     array.
 *
 * @return     mixed   Returns the method result.
 */
  public function invokeArgs($obj, $args) {
    return hphp_invoke_method($obj, $this->info['class'], $this->info['name'],
                              array_values($args));
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.isfinal.php )
 *
 * Checks if the method is final.
 *
 * @return     mixed   TRUE if the method is final, otherwise FALSE
 */
  public function isFinal() {
    return isset($this->info['final']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.isabstract.php
 * )
 *
 * Checks if the method is abstract.
 *
 * @return     mixed   TRUE if the method is abstract, otherwise FALSE
 */
  public function isAbstract() {
    return isset($this->info['abstract']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.ispublic.php )
 *
 * Checks if the method is public.
 *
 * @return     mixed   TRUE if the method is public, otherwise FALSE
 */
  public function isPublic() {
    return $this->info['access'] == "public";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.isprivate.php )
 *
 * Checks if the method is private. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   TRUE if the method is private, otherwise FALSE
 */
  public function isPrivate() {
    return $this->info['access'] == "private";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.isprotected.php
 * )
 *
 * Checks if the method is protected.
 *
 * @return     mixed   TRUE if the method is protected, otherwise FALSE
 */
  public function isProtected() {
    return $this->info['access'] == "protected";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.isstatic.php )
 *
 * Checks if the method is static.
 *
 * @return     mixed   TRUE if the method is static, otherwise FALSE
 */
  public function isStatic() {
    return isset($this->info['static']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionmethod.isconstructor.php )
 *
 * Checks if the method is a constructor.
 *
 * @return     mixed   TRUE if the method is a constructor, otherwise FALSE
 */
  public function isConstructor() {
    return isset($this->info['constructor']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionmethod.isdestructor.php )
 *
 * Checks if the method is a destructor.
 *
 * @return     mixed   TRUE if the method is a destructor, otherwise FALSE
 */
  public function isDestructor() {
    return $this->getName() == '__destruct';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionmethod.getmodifiers.php )
 *
 * Gets the method modifiers.
 *
 * @return     mixed   A numeric representation of the modifiers. The
 *                     modifiers are listed below. The actual meanings of
 *                     these modifiers are described in the predefined
 *                     constants. ReflectionMethod modifiers value constant
 *                     1 ReflectionMethod::IS_STATIC 2
 *                     ReflectionMethod::IS_ABSTRACT 4
 *                     ReflectionMethod::IS_FINAL 256
 *                     ReflectionMethod::IS_PUBLIC 512
 *                     ReflectionMethod::IS_PROTECTED 1024
 *                     ReflectionMethod::IS_PRIVATE
 */
  public function getModifiers() {
    return $this->info['modifiers'];
  }

  public function getClosure() {
    return $this->info['closure'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionmethod.getdeclaringclass.php )
 *
 * Gets the declaring class for the reflected method.
 *
 * @return     mixed   A ReflectionClass object of the class that the
 *                     reflected method is part of.
 */
  public function getDeclaringClass() {
    if (empty($this->info['class'])) {
      return null;
    }
    return new ReflectionClass($this->info['class']);
  }

  public function getAttribute($name) {
    $attrs = $this->info['attributes'];
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributes() {
    return $this->info['attributes'];
  }

  public function getAttributeRecursive($name) {
    $attrs = $this->info['attributes'];
    if (isset($attrs[$name])) {
      return $attrs[$name];
    }
    $p = get_parent_class($this->class);
    if ($p === false) {
      return null;
    }
    $rm = new ReflectionMethod($p, $this->name);
    if ($rm->isPrivate()) {
      return null;
    }
    return $rm->getAttributeRecursive($name);
  }

  public function getAttributesRecursive() {
    $attrs = $this->info['attributes'];
    $p = get_parent_class($this->class);
    if ($p !== false) {
      $rm = new ReflectionMethod($p, $this->name);
      if (!$rm->isPrivate()) {
        $attrs += $rm->getAttributesRecursive();
      }
    }
    return $attrs;
  }
}

///////////////////////////////////////////////////////////////////////////////
// extension

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionextension.php )
 *
 * The ReflectionExtension class reports information about an extension.
 *
 */
class ReflectionExtension implements Reflector {
  private $name;
  private $info;

  public function __construct($name) {
    $this->info = hphp_get_extension_info($name);
  }

  public function __toString() {
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionextension.export.php )
 *
 * Exports a reflected extension. The output format of this function is
 * the same as the CLI argument --re [extension].
 *
 * @name       mixed   The reflection to export.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   If the return parameter is set to TRUE, then the
 *                     export is returned as a string, otherwise NULL is
 *                     returned.
 */
  public static function export($name, $ret=false) {
    $obj = new ReflectionExtension($name);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionextension.getname.php
 * )
 *
 * Gets the extensions name.
 *
 * @return     mixed   The extensions name.
 */
  public function getName() {
    return $this->info['name'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getversion.php )
 *
 * Gets the version of the extension.
 *
 * @return     mixed   The version of the extension.
 */
  public function getVersion() {
    return $this->info['version'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getfunctions.php )
 *
 * Get defined functions from an extension.
 *
 * @return     mixed   An associative array of ReflectionFunction objects,
 *                     for each function defined in the extension with the
 *                     keys being the function names. If no function are
 *                     defined, an empty array is returned.
 */
  public function getFunctions() {
    return $this->info['functions'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getconstants.php )
 *
 * Get defined constants from an extension.
 *
 * @return     mixed   An associative array with constant names as keys.
 */
  public function getConstants() {
    return $this->info['constants'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getinientries.php )
 *
 * Get the ini entries for an extension.
 *
 * @return     mixed   An associative array with the ini entries as keys,
 *                     with their defined values as values.
 */
  public function getINIEntries() {
    return $this->info['ini'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getclasses.php )
 *
 * Gets a list of classes from an extension.
 *
 * @return     mixed   An array of ReflectionClass objects, one for each
 *                     class within the extension. If no classes are
 *                     defined, an empty array is returned.
 */
  public function getClasses() {
    return $this->info['classes'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getclassnames.php )
 *
 * Gets a listing of class names as defined in the extension.
 *
 * @return     mixed   An array of class names, as defined in the
 *                     extension. If no classes are defined, an empty array
 *                     is returned.
 */
  public function getClassNames() {
    $ret = array();
    foreach ($this->info['classes'] as $cls) {
      $ret[] = $cls->getName();
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionextension.info.php )
 *
 * Gets information about an extension.
 *
 * @return     mixed   Information about the extension.
 */
  public function info() {
    return $this->info['info'];
  }
}
