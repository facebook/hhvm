#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/enums/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

# pyre-unsafe

import typing as __T  # sometimes `t` is used as a field name

from thrift import Thrift
from thrift.protocol.TProtocol import TProtocolBase

__property__ = property  # sometimes `property` is used as a field name


UTF8STRINGS: bool


class Metasyntactic(int):
    FOO: __T.ClassVar[Metasyntactic]
    BAR: __T.ClassVar[Metasyntactic]
    BAZ: __T.ClassVar[Metasyntactic]
    BAX: __T.ClassVar[Metasyntactic]

    _VALUES_TO_NAMES: __T.ClassVar[__T.Dict[Metasyntactic, str]]
    _NAMES_TO_VALUES: __T.ClassVar[__T.Dict[str, Metasyntactic]]


class MyEnum1(int):
    ME1_0: __T.ClassVar[MyEnum1]
    ME1_1: __T.ClassVar[MyEnum1]
    ME1_2: __T.ClassVar[MyEnum1]
    ME1_3: __T.ClassVar[MyEnum1]
    ME1_5: __T.ClassVar[MyEnum1]
    ME1_6: __T.ClassVar[MyEnum1]

    _VALUES_TO_NAMES: __T.ClassVar[__T.Dict[MyEnum1, str]]
    _NAMES_TO_VALUES: __T.ClassVar[__T.Dict[str, MyEnum1]]


class MyEnum2(int):
    ME2_0: __T.ClassVar[MyEnum2]
    ME2_1: __T.ClassVar[MyEnum2]
    ME2_2: __T.ClassVar[MyEnum2]

    _VALUES_TO_NAMES: __T.ClassVar[__T.Dict[MyEnum2, str]]
    _NAMES_TO_VALUES: __T.ClassVar[__T.Dict[str, MyEnum2]]


class MyEnum3(int):
    ME3_0: __T.ClassVar[MyEnum3]
    ME3_1: __T.ClassVar[MyEnum3]
    ME3_N2: __T.ClassVar[MyEnum3]
    ME3_N1: __T.ClassVar[MyEnum3]
    ME3_9: __T.ClassVar[MyEnum3]
    ME3_10: __T.ClassVar[MyEnum3]

    _VALUES_TO_NAMES: __T.ClassVar[__T.Dict[MyEnum3, str]]
    _NAMES_TO_VALUES: __T.ClassVar[__T.Dict[str, MyEnum3]]


class MyEnum4(int):
    ME4_A: __T.ClassVar[MyEnum4]
    ME4_B: __T.ClassVar[MyEnum4]
    ME4_C: __T.ClassVar[MyEnum4]
    ME4_D: __T.ClassVar[MyEnum4]

    _VALUES_TO_NAMES: __T.ClassVar[__T.Dict[MyEnum4, str]]
    _NAMES_TO_VALUES: __T.ClassVar[__T.Dict[str, MyEnum4]]


class MyBitmaskEnum1(int):
    ONE: __T.ClassVar[MyBitmaskEnum1]
    TWO: __T.ClassVar[MyBitmaskEnum1]
    FOUR: __T.ClassVar[MyBitmaskEnum1]

    _VALUES_TO_NAMES: __T.ClassVar[__T.Dict[MyBitmaskEnum1, str]]
    _NAMES_TO_VALUES: __T.ClassVar[__T.Dict[str, MyBitmaskEnum1]]


class MyBitmaskEnum2(int):
    ONE: __T.ClassVar[MyBitmaskEnum2]
    TWO: __T.ClassVar[MyBitmaskEnum2]
    FOUR: __T.ClassVar[MyBitmaskEnum2]

    _VALUES_TO_NAMES: __T.ClassVar[__T.Dict[MyBitmaskEnum2, str]]
    _NAMES_TO_VALUES: __T.ClassVar[__T.Dict[str, MyBitmaskEnum2]]


class SomeStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self, *,
        reasonable: Metasyntactic = ...,
        fine: Metasyntactic = ...,
        questionable: Metasyntactic = ...,
        tags: __T.Set[int] = ...
    ) -> None:
        ...

    @__property__
    def reasonable(self) -> Metasyntactic: ...
    @reasonable.setter
    def reasonable(self, value: Metasyntactic) -> None: ...
    @__property__
    def fine(self) -> Metasyntactic: ...
    @fine.setter
    def fine(self, value: Metasyntactic) -> None: ...
    @__property__
    def questionable(self) -> Metasyntactic: ...
    @questionable.setter
    def questionable(self, value: Metasyntactic) -> None: ...
    @__property__
    def tags(self) -> __T.Set[int]: ...
    @tags.setter
    def tags(self, value: __T.Set[int]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "test.fixtures.enums.module.thrift_types.SomeStruct": ...   # type: ignore
    def _to_mutable_python(self) -> "test.fixtures.enums.module.thrift_mutable_types.SomeStruct": ...   # type: ignore
    def _to_py3(self) -> "test.fixtures.enums.module.types.SomeStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> SomeStruct: ...


class MyStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self, *,
        me2_3: MyEnum2 = ...,
        me3_n3: MyEnum3 = ...,
        me1_t1: MyEnum1 = ...,
        me1_t2: MyEnum1 = ...
    ) -> None:
        ...

    @__property__
    def me2_3(self) -> MyEnum2: ...
    @me2_3.setter
    def me2_3(self, value: MyEnum2) -> None: ...
    @__property__
    def me3_n3(self) -> MyEnum3: ...
    @me3_n3.setter
    def me3_n3(self, value: MyEnum3) -> None: ...
    @__property__
    def me1_t1(self) -> MyEnum1: ...
    @me1_t1.setter
    def me1_t1(self, value: MyEnum1) -> None: ...
    @__property__
    def me1_t2(self) -> MyEnum1: ...
    @me1_t2.setter
    def me1_t2(self, value: MyEnum1) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "test.fixtures.enums.module.thrift_types.MyStruct": ...   # type: ignore
    def _to_mutable_python(self) -> "test.fixtures.enums.module.thrift_mutable_types.MyStruct": ...   # type: ignore
    def _to_py3(self) -> "test.fixtures.enums.module.types.MyStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> MyStruct: ...


