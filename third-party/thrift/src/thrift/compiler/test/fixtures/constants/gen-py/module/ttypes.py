#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException



import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
from thrift.Thrift import expand_thrift_spec as __EXPAND_THRIFT_SPEC
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'EmptyEnum', 'City', 'Company', 'Internship', 'Range', 'struct1', 'struct2', 'struct3', 'struct4', 'union1', 'union2', 'MyCompany', 'MyStringIdentifier', 'MyIntIdentifier', 'MyMapIdentifier']

class EmptyEnum:

  _VALUES_TO_NAMES = {
  }

  _NAMES_TO_VALUES = {
  }

class City:
  NYC = 0
  MPK = 1
  SEA = 2
  LON = 3

  _VALUES_TO_NAMES = {
    0: "NYC",
    1: "MPK",
    2: "SEA",
    3: "LON",
  }

  _NAMES_TO_VALUES = {
    "NYC": 0,
    "MPK": 1,
    "SEA": 2,
    "LON": 3,
  }

class Company:
  FACEBOOK = 0
  WHATSAPP = 1
  OCULUS = 2
  INSTAGRAM = 3

  _VALUES_TO_NAMES = {
    0: "FACEBOOK",
    1: "WHATSAPP",
    2: "OCULUS",
    3: "INSTAGRAM",
  }

  _NAMES_TO_VALUES = {
    "FACEBOOK": 0,
    "WHATSAPP": 1,
    "OCULUS": 2,
    "INSTAGRAM": 3,
  }

class Internship:
  r"""
  Attributes:
   - weeks
   - title
   - employer
   - compensation
   - school
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.weeks = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.title = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.employer = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.compensation = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.school = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Internship')
    if self.weeks != None:
      oprot.writeFieldBegin('weeks', TType.I32, 1)
      oprot.writeI32(self.weeks)
      oprot.writeFieldEnd()
    if self.title != None:
      oprot.writeFieldBegin('title', TType.STRING, 2)
      oprot.writeString(self.title.encode('utf-8')) if UTF8STRINGS and not isinstance(self.title, bytes) else oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.employer != None:
      oprot.writeFieldBegin('employer', TType.I32, 3)
      oprot.writeI32(self.employer)
      oprot.writeFieldEnd()
    if self.compensation != None:
      oprot.writeFieldBegin('compensation', TType.DOUBLE, 4)
      oprot.writeDouble(self.compensation)
      oprot.writeFieldEnd()
    if self.school != None:
      oprot.writeFieldBegin('school', TType.STRING, 5)
      oprot.writeString(self.school.encode('utf-8')) if UTF8STRINGS and not isinstance(self.school, bytes) else oprot.writeString(self.school)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.weeks is not None:
      value = pprint.pformat(self.weeks, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    weeks=%s' % (value))
    if self.title is not None:
      value = pprint.pformat(self.title, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    title=%s' % (value))
    if self.employer is not None:
      value = pprint.pformat(self.employer, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    employer=%s' % (value))
    if self.compensation is not None:
      value = pprint.pformat(self.compensation, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    compensation=%s' % (value))
    if self.school is not None:
      value = pprint.pformat(self.school, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    school=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'weeks',
      'title',
      'employer',
      'compensation',
      'school',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Internship, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Internship, self)

  def _to_py_deprecated(self):
    return self

class Range:
  r"""
  Attributes:
   - min
   - max
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.min = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.max = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Range')
    if self.min != None:
      oprot.writeFieldBegin('min', TType.I32, 1)
      oprot.writeI32(self.min)
      oprot.writeFieldEnd()
    if self.max != None:
      oprot.writeFieldBegin('max', TType.I32, 2)
      oprot.writeI32(self.max)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.min is not None:
      value = pprint.pformat(self.min, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    min=%s' % (value))
    if self.max is not None:
      value = pprint.pformat(self.max, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    max=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'min',
      'max',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Range, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Range, self)

  def _to_py_deprecated(self):
    return self

class struct1:
  r"""
  Attributes:
   - a
   - b
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.a = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.b = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('struct1')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.I32, 1)
      oprot.writeI32(self.a)
      oprot.writeFieldEnd()
    if self.b != None:
      oprot.writeFieldBegin('b', TType.STRING, 2)
      oprot.writeString(self.b.encode('utf-8')) if UTF8STRINGS and not isinstance(self.b, bytes) else oprot.writeString(self.b)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    if self.b is not None:
      value = pprint.pformat(self.b, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    b=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
      'b',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.struct1, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.struct1, self)

  def _to_py_deprecated(self):
    return self

class struct2:
  r"""
  Attributes:
   - a
   - b
   - c
   - d
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.a = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.b = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.c = struct1()
          self.c.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.d = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readI32()
              self.d.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI32()
              self.d.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('struct2')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.I32, 1)
      oprot.writeI32(self.a)
      oprot.writeFieldEnd()
    if self.b != None:
      oprot.writeFieldBegin('b', TType.STRING, 2)
      oprot.writeString(self.b.encode('utf-8')) if UTF8STRINGS and not isinstance(self.b, bytes) else oprot.writeString(self.b)
      oprot.writeFieldEnd()
    if self.c != None:
      oprot.writeFieldBegin('c', TType.STRUCT, 3)
      self.c.write(oprot)
      oprot.writeFieldEnd()
    if self.d != None:
      oprot.writeFieldBegin('d', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.d))
      for iter7 in self.d:
        oprot.writeI32(iter7)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    if self.b is not None:
      value = pprint.pformat(self.b, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    b=%s' % (value))
    if self.c is not None:
      value = pprint.pformat(self.c, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    c=%s' % (value))
    if self.d is not None:
      value = pprint.pformat(self.d, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    d=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
      'b',
      'c',
      'd',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.struct2, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.struct2, self)

  def _to_py_deprecated(self):
    return self

class struct3:
  r"""
  Attributes:
   - a
   - b
   - c
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.a = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.b = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.c = struct2()
          self.c.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('struct3')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.STRING, 1)
      oprot.writeString(self.a.encode('utf-8')) if UTF8STRINGS and not isinstance(self.a, bytes) else oprot.writeString(self.a)
      oprot.writeFieldEnd()
    if self.b != None:
      oprot.writeFieldBegin('b', TType.I32, 2)
      oprot.writeI32(self.b)
      oprot.writeFieldEnd()
    if self.c != None:
      oprot.writeFieldBegin('c', TType.STRUCT, 3)
      self.c.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    if self.b is not None:
      value = pprint.pformat(self.b, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    b=%s' % (value))
    if self.c is not None:
      value = pprint.pformat(self.c, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    c=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
      'b',
      'c',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.struct3, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.struct3, self)

  def _to_py_deprecated(self):
    return self

class struct4:
  r"""
  Attributes:
   - a
   - b
   - c
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.a = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.b = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.c = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('struct4')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.I32, 1)
      oprot.writeI32(self.a)
      oprot.writeFieldEnd()
    if self.b != None:
      oprot.writeFieldBegin('b', TType.DOUBLE, 2)
      oprot.writeDouble(self.b)
      oprot.writeFieldEnd()
    if self.c != None:
      oprot.writeFieldBegin('c', TType.BYTE, 3)
      oprot.writeByte(self.c)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    if self.b is not None:
      value = pprint.pformat(self.b, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    b=%s' % (value))
    if self.c is not None:
      value = pprint.pformat(self.c, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    c=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
      'b',
      'c',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.struct4, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.struct4, self)

  def _to_py_deprecated(self):
    return self

class union1(object):
  r"""
  Attributes:
   - i
   - d
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  I = 1
  D = 2
  
  @staticmethod
  def isUnion():
    return True

  def get_i(self):
    assert self.field == 1
    return self.value

  def get_d(self):
    assert self.field == 2
    return self.value

  def set_i(self, value):
    self.field = 1
    self.value = value

  def set_d(self, value):
    self.field = 2
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 2
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('i', value)
    if self.field == 2:
      padding = ' ' * 2
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('d', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          _fbthrift_i = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_i(_fbthrift_i)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          _fbthrift_d = iprot.readDouble()
          assert self.field == 0 and self.value is None
          self.set_d(_fbthrift_d)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('union1')
    if self.field == 1:
      oprot.writeFieldBegin('i', TType.I32, 1)
      i = self.value
      oprot.writeI32(i)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('d', TType.DOUBLE, 2)
      d = self.value
      oprot.writeDouble(d)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.union1, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.union1, self)

  def _to_py_deprecated(self):
    return self

class union2(object):
  r"""
  Attributes:
   - i
   - d
   - s
   - u
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  I = 1
  D = 2
  S = 3
  U = 4
  
  @staticmethod
  def isUnion():
    return True

  def get_i(self):
    assert self.field == 1
    return self.value

  def get_d(self):
    assert self.field == 2
    return self.value

  def get_s(self):
    assert self.field == 3
    return self.value

  def get_u(self):
    assert self.field == 4
    return self.value

  def set_i(self, value):
    self.field = 1
    self.value = value

  def set_d(self, value):
    self.field = 2
    self.value = value

  def set_s(self, value):
    self.field = 3
    self.value = value

  def set_u(self, value):
    self.field = 4
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 2
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('i', value)
    if self.field == 2:
      padding = ' ' * 2
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('d', value)
    if self.field == 3:
      padding = ' ' * 2
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('s', value)
    if self.field == 4:
      padding = ' ' * 2
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('u', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          _fbthrift_i = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_i(_fbthrift_i)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          _fbthrift_d = iprot.readDouble()
          assert self.field == 0 and self.value is None
          self.set_d(_fbthrift_d)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          _fbthrift_s = struct1()
          _fbthrift_s.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_s(_fbthrift_s)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          _fbthrift_u = union1()
          _fbthrift_u.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_u(_fbthrift_u)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('union2')
    if self.field == 1:
      oprot.writeFieldBegin('i', TType.I32, 1)
      i = self.value
      oprot.writeI32(i)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('d', TType.DOUBLE, 2)
      d = self.value
      oprot.writeDouble(d)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('s', TType.STRUCT, 3)
      s = self.value
      s.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('u', TType.STRUCT, 4)
      u = self.value
      u.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.union2, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.union2, self)

  def _to_py_deprecated(self):
    return self

MyCompany = Company
MyStringIdentifier = UnimplementedTypedef()
MyIntIdentifier = UnimplementedTypedef()
MyMapIdentifier = UnimplementedTypedef()
all_structs.append(Internship)
Internship.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'weeks', None, None, 0, ), # 1
  (2, TType.STRING, 'title', True, None, 2, ), # 2
  (3, TType.I32, 'employer', Company, None, 1, ), # 3
  (4, TType.DOUBLE, 'compensation', None, None, 1, ), # 4
  (5, TType.STRING, 'school', True, None, 1, ), # 5
)))

Internship.thrift_struct_annotations = {
}
Internship.thrift_field_annotations = {
}

def Internship__init__(self, weeks=None, title=None, employer=None, compensation=None, school=None,):
  self.weeks = weeks
  self.title = title
  self.employer = employer
  self.compensation = compensation
  self.school = school

Internship.__init__ = Internship__init__

def Internship__setstate__(self, state):
  state.setdefault('weeks', None)
  state.setdefault('title', None)
  state.setdefault('employer', None)
  state.setdefault('compensation', None)
  state.setdefault('school', None)
  self.__dict__ = state

Internship.__getstate__ = lambda self: self.__dict__.copy()
Internship.__setstate__ = Internship__setstate__

all_structs.append(Range)
Range.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'min', None, None, 0, ), # 1
  (2, TType.I32, 'max', None, None, 0, ), # 2
)))

Range.thrift_struct_annotations = {
}
Range.thrift_field_annotations = {
}

def Range__init__(self, min=None, max=None,):
  self.min = min
  self.max = max

Range.__init__ = Range__init__

def Range__setstate__(self, state):
  state.setdefault('min', None)
  state.setdefault('max', None)
  self.__dict__ = state

Range.__getstate__ = lambda self: self.__dict__.copy()
Range.__setstate__ = Range__setstate__

all_structs.append(struct1)
struct1.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'a', None, 1234567, 2, ), # 1
  (2, TType.STRING, 'b', True, "<uninitialized>", 2, ), # 2
)))

struct1.thrift_struct_annotations = {
}
struct1.thrift_field_annotations = {
}

def struct1__init__(self, a=struct1.thrift_spec[1][4], b=struct1.thrift_spec[2][4],):
  self.a = a
  self.b = b

struct1.__init__ = struct1__init__

def struct1__setstate__(self, state):
  state.setdefault('a', 1234567)
  state.setdefault('b', "<uninitialized>")
  self.__dict__ = state

struct1.__getstate__ = lambda self: self.__dict__.copy()
struct1.__setstate__ = struct1__setstate__

all_structs.append(struct2)
struct2.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'a', None, None, 2, ), # 1
  (2, TType.STRING, 'b', True, None, 2, ), # 2
  (3, TType.STRUCT, 'c', [struct1, struct1.thrift_spec, False], None, 2, ), # 3
  (4, TType.LIST, 'd', (TType.I32,None), None, 2, ), # 4
)))

struct2.thrift_struct_annotations = {
}
struct2.thrift_field_annotations = {
}

def struct2__init__(self, a=None, b=None, c=None, d=None,):
  self.a = a
  self.b = b
  self.c = c
  self.d = d

struct2.__init__ = struct2__init__

def struct2__setstate__(self, state):
  state.setdefault('a', None)
  state.setdefault('b', None)
  state.setdefault('c', None)
  state.setdefault('d', None)
  self.__dict__ = state

struct2.__getstate__ = lambda self: self.__dict__.copy()
struct2.__setstate__ = struct2__setstate__

all_structs.append(struct3)
struct3.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'a', True, None, 2, ), # 1
  (2, TType.I32, 'b', None, None, 2, ), # 2
  (3, TType.STRUCT, 'c', [struct2, struct2.thrift_spec, False], None, 2, ), # 3
)))

struct3.thrift_struct_annotations = {
}
struct3.thrift_field_annotations = {
}

def struct3__init__(self, a=None, b=None, c=None,):
  self.a = a
  self.b = b
  self.c = c

struct3.__init__ = struct3__init__

def struct3__setstate__(self, state):
  state.setdefault('a', None)
  state.setdefault('b', None)
  state.setdefault('c', None)
  self.__dict__ = state

struct3.__getstate__ = lambda self: self.__dict__.copy()
struct3.__setstate__ = struct3__setstate__

all_structs.append(struct4)
struct4.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'a', None, None, 2, ), # 1
  (2, TType.DOUBLE, 'b', None, None, 1, ), # 2
  (3, TType.BYTE, 'c', None, None, 1, ), # 3
)))

struct4.thrift_struct_annotations = {
}
struct4.thrift_field_annotations = {
}

def struct4__init__(self, a=None, b=None, c=None,):
  self.a = a
  self.b = b
  self.c = c

struct4.__init__ = struct4__init__

def struct4__setstate__(self, state):
  state.setdefault('a', None)
  state.setdefault('b', None)
  state.setdefault('c', None)
  self.__dict__ = state

struct4.__getstate__ = lambda self: self.__dict__.copy()
struct4.__setstate__ = struct4__setstate__

all_structs.append(union1)
union1.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'i', None, None, 2, ), # 1
  (2, TType.DOUBLE, 'd', None, None, 2, ), # 2
)))

union1.thrift_struct_annotations = {
}
union1.thrift_field_annotations = {
}

def union1__init__(self, i=None, d=None,):
  self.field = 0
  self.value = None
  if i is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = i
  if d is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = d

union1.__init__ = union1__init__

all_structs.append(union2)
union2.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'i', None, None, 2, ), # 1
  (2, TType.DOUBLE, 'd', None, None, 2, ), # 2
  (3, TType.STRUCT, 's', [struct1, struct1.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'u', [union1, union1.thrift_spec, True], None, 2, ), # 4
)))

union2.thrift_struct_annotations = {
}
union2.thrift_field_annotations = {
}

def union2__init__(self, i=None, d=None, s=None, u=None,):
  self.field = 0
  self.value = None
  if i is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = i
  if d is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = d
  if s is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = s
  if u is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = u

union2.__init__ = union2__init__

fix_spec(all_structs)
del all_structs
