/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/enums/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */

#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>

namespace apache::thrift {
namespace ident {
struct reasonable;
struct fine;
struct questionable;
struct tags;
struct me2_3;
struct me3_n3;
struct me1_t1;
struct me1_t2;
} // namespace ident
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_reasonable
#define APACHE_THRIFT_ACCESSOR_reasonable
APACHE_THRIFT_DEFINE_ACCESSOR(reasonable);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fine
#define APACHE_THRIFT_ACCESSOR_fine
APACHE_THRIFT_DEFINE_ACCESSOR(fine);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_questionable
#define APACHE_THRIFT_ACCESSOR_questionable
APACHE_THRIFT_DEFINE_ACCESSOR(questionable);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tags
#define APACHE_THRIFT_ACCESSOR_tags
APACHE_THRIFT_DEFINE_ACCESSOR(tags);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_me2_3
#define APACHE_THRIFT_ACCESSOR_me2_3
APACHE_THRIFT_DEFINE_ACCESSOR(me2_3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_me3_n3
#define APACHE_THRIFT_ACCESSOR_me3_n3
APACHE_THRIFT_DEFINE_ACCESSOR(me3_n3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_me1_t1
#define APACHE_THRIFT_ACCESSOR_me1_t1
APACHE_THRIFT_DEFINE_ACCESSOR(me1_t1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_me1_t2
#define APACHE_THRIFT_ACCESSOR_me1_t2
APACHE_THRIFT_DEFINE_ACCESSOR(me1_t2);
#endif
} // namespace detail
} // namespace apache::thrift

// BEGIN declare_enums
namespace test::fixtures::enums {

/** Glean {"file": "thrift/compiler/test/fixtures/enums/src/module.thrift", "name": "Metasyntactic", "kind": "enum" } */
enum class Metasyntactic {
  FOO = 1,
  BAR = 2,
  BAZ = 3,
  BAX = 4,
};

/** Glean {"file": "thrift/compiler/test/fixtures/enums/src/module.thrift", "name": "MyEnum1", "kind": "enum" } */
enum class MyEnum1 {
  ME1_0 = 0,
  ME1_1 = 1,
  ME1_2 = 2,
  ME1_3 = 3,
  ME1_5 = 5,
  ME1_6 = 6,
};

/** Glean {"file": "thrift/compiler/test/fixtures/enums/src/module.thrift", "name": "MyEnum2", "kind": "enum" } */
enum class MyEnum2 {
  ME2_0 = 0,
  ME2_1 = 1,
  ME2_2 = 2,
};

/** Glean {"file": "thrift/compiler/test/fixtures/enums/src/module.thrift", "name": "MyEnum3", "kind": "enum" } */
enum class MyEnum3 {
  ME3_0 = 0,
  ME3_1 = 1,
  ME3_N2 = -2,
  ME3_N1 = -1,
  ME3_9 = 9,
  ME3_10 = 10,
};

/** Glean {"file": "thrift/compiler/test/fixtures/enums/src/module.thrift", "name": "MyEnum4", "kind": "enum" } */
enum class MyEnum4 {
  ME4_A = 2147483645,
  ME4_B = 2147483646,
  ME4_C = 2147483647,
  ME4_D = -2147483648,
};

/** Glean {"file": "thrift/compiler/test/fixtures/enums/src/module.thrift", "name": "MyBitmaskEnum1", "kind": "enum" } */
enum class MyBitmaskEnum1 {
  ONE = 1,
  TWO = 2,
  FOUR = 4,
};
inline constexpr MyBitmaskEnum1 operator&(MyBitmaskEnum1 a, MyBitmaskEnum1 b) {
  using E = MyBitmaskEnum1;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr MyBitmaskEnum1& operator&=(MyBitmaskEnum1& a, MyBitmaskEnum1 b) {
  return a = a & b;
}

inline constexpr MyBitmaskEnum1 operator|(MyBitmaskEnum1 a, MyBitmaskEnum1 b) {
  using E = MyBitmaskEnum1;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr MyBitmaskEnum1& operator|=(MyBitmaskEnum1& a, MyBitmaskEnum1 b) {
  return a = a | b;
}

inline constexpr MyBitmaskEnum1 operator^(MyBitmaskEnum1 a, MyBitmaskEnum1 b) {
  using E = MyBitmaskEnum1;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr MyBitmaskEnum1& operator^=(MyBitmaskEnum1& a, MyBitmaskEnum1 b) {
  return a = a ^ b;
}

inline constexpr MyBitmaskEnum1 operator~(MyBitmaskEnum1 a) {
  using E = MyBitmaskEnum1;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}
/** Glean {"file": "thrift/compiler/test/fixtures/enums/src/module.thrift", "name": "MyBitmaskEnum2", "kind": "enum" } */
enum class MyBitmaskEnum2 {
  ONE = 1,
  TWO = 2,
  FOUR = 4,
};
inline constexpr MyBitmaskEnum2 operator&(MyBitmaskEnum2 a, MyBitmaskEnum2 b) {
  using E = MyBitmaskEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr MyBitmaskEnum2& operator&=(MyBitmaskEnum2& a, MyBitmaskEnum2 b) {
  return a = a & b;
}

inline constexpr MyBitmaskEnum2 operator|(MyBitmaskEnum2 a, MyBitmaskEnum2 b) {
  using E = MyBitmaskEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr MyBitmaskEnum2& operator|=(MyBitmaskEnum2& a, MyBitmaskEnum2 b) {
  return a = a | b;
}

inline constexpr MyBitmaskEnum2 operator^(MyBitmaskEnum2 a, MyBitmaskEnum2 b) {
  using E = MyBitmaskEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr MyBitmaskEnum2& operator^=(MyBitmaskEnum2& a, MyBitmaskEnum2 b) {
  return a = a ^ b;
}

inline constexpr MyBitmaskEnum2 operator~(MyBitmaskEnum2 a) {
  using E = MyBitmaskEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}
} // namespace test::fixtures::enums

template<> struct std::hash<::test::fixtures::enums::Metasyntactic> :
  ::apache::thrift::detail::enum_hash<::test::fixtures::enums::Metasyntactic> {};
template<> struct std::hash<::test::fixtures::enums::MyEnum1> :
  ::apache::thrift::detail::enum_hash<::test::fixtures::enums::MyEnum1> {};
template<> struct std::hash<::test::fixtures::enums::MyEnum2> :
  ::apache::thrift::detail::enum_hash<::test::fixtures::enums::MyEnum2> {};
template<> struct std::hash<::test::fixtures::enums::MyEnum3> :
  ::apache::thrift::detail::enum_hash<::test::fixtures::enums::MyEnum3> {};
template<> struct std::hash<::test::fixtures::enums::MyEnum4> :
  ::apache::thrift::detail::enum_hash<::test::fixtures::enums::MyEnum4> {};
template<> struct std::hash<::test::fixtures::enums::MyBitmaskEnum1> :
  ::apache::thrift::detail::enum_hash<::test::fixtures::enums::MyBitmaskEnum1> {};
template<> struct std::hash<::test::fixtures::enums::MyBitmaskEnum2> :
  ::apache::thrift::detail::enum_hash<::test::fixtures::enums::MyBitmaskEnum2> {};

namespace apache::thrift {

template <> struct TEnumTraits<::test::fixtures::enums::Metasyntactic> {
  using type = ::test::fixtures::enums::Metasyntactic;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;
  static const std::string_view __fbthrift_module_name_internal_do_not_use;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  FOLLY_ERASE static std::string_view typeName() noexcept {
    return "Metasyntactic";
  }

  FOLLY_ERASE static constexpr std::string_view moduleName() noexcept {
    return "module";
  }

  FOLLY_ERASE static constexpr std::string_view __fbthrift_thrift_uri() noexcept {
    return "test.dev/fixtures/enums/Metasyntactic";
  }

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::FOO; }
  static constexpr type max() { return type::BAX; }
};

template <> struct TEnumTraits<::test::fixtures::enums::MyEnum1> {
  using type = ::test::fixtures::enums::MyEnum1;

  static constexpr std::size_t const size = 6;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;
  static const std::string_view __fbthrift_module_name_internal_do_not_use;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  FOLLY_ERASE static std::string_view typeName() noexcept {
    return "MyEnum1";
  }

  FOLLY_ERASE static constexpr std::string_view moduleName() noexcept {
    return "module";
  }

  FOLLY_ERASE static constexpr std::string_view __fbthrift_thrift_uri() noexcept {
    return "test.dev/fixtures/enums/MyEnum1";
  }

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::ME1_0; }
  static constexpr type max() { return type::ME1_6; }
};

template <> struct TEnumTraits<::test::fixtures::enums::MyEnum2> {
  using type = ::test::fixtures::enums::MyEnum2;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;
  static const std::string_view __fbthrift_module_name_internal_do_not_use;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  FOLLY_ERASE static std::string_view typeName() noexcept {
    return "MyEnum2";
  }

  FOLLY_ERASE static constexpr std::string_view moduleName() noexcept {
    return "module";
  }

  FOLLY_ERASE static constexpr std::string_view __fbthrift_thrift_uri() noexcept {
    return "test.dev/fixtures/enums/MyEnum2";
  }

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::ME2_0; }
  static constexpr type max() { return type::ME2_2; }
};

template <> struct TEnumTraits<::test::fixtures::enums::MyEnum3> {
  using type = ::test::fixtures::enums::MyEnum3;

  static constexpr std::size_t const size = 6;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;
  static const std::string_view __fbthrift_module_name_internal_do_not_use;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  FOLLY_ERASE static std::string_view typeName() noexcept {
    return "MyEnum3";
  }

  FOLLY_ERASE static constexpr std::string_view moduleName() noexcept {
    return "module";
  }

  FOLLY_ERASE static constexpr std::string_view __fbthrift_thrift_uri() noexcept {
    return "test.dev/fixtures/enums/MyEnum3";
  }

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::ME3_N2; }
  static constexpr type max() { return type::ME3_10; }
};

template <> struct TEnumTraits<::test::fixtures::enums::MyEnum4> {
  using type = ::test::fixtures::enums::MyEnum4;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;
  static const std::string_view __fbthrift_module_name_internal_do_not_use;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  FOLLY_ERASE static std::string_view typeName() noexcept {
    return "MyEnum4";
  }

  FOLLY_ERASE static constexpr std::string_view moduleName() noexcept {
    return "module";
  }

  FOLLY_ERASE static constexpr std::string_view __fbthrift_thrift_uri() noexcept {
    return "test.dev/fixtures/enums/MyEnum4";
  }

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::ME4_D; }
  static constexpr type max() { return type::ME4_C; }
};

template <> struct TEnumTraits<::test::fixtures::enums::MyBitmaskEnum1> {
  using type = ::test::fixtures::enums::MyBitmaskEnum1;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;
  static const std::string_view __fbthrift_module_name_internal_do_not_use;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  FOLLY_ERASE static std::string_view typeName() noexcept {
    return "MyBitmaskEnum1";
  }

  FOLLY_ERASE static constexpr std::string_view moduleName() noexcept {
    return "module";
  }

  FOLLY_ERASE static constexpr std::string_view __fbthrift_thrift_uri() noexcept {
    return "test.dev/fixtures/enums/MyBitmaskEnum1";
  }

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::ONE; }
  static constexpr type max() { return type::FOUR; }
};

template <> struct TEnumTraits<::test::fixtures::enums::MyBitmaskEnum2> {
  using type = ::test::fixtures::enums::MyBitmaskEnum2;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;
  static const std::string_view __fbthrift_module_name_internal_do_not_use;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  FOLLY_ERASE static std::string_view typeName() noexcept {
    return "MyBitmaskEnum2";
  }

  FOLLY_ERASE static constexpr std::string_view moduleName() noexcept {
    return "module";
  }

  FOLLY_ERASE static constexpr std::string_view __fbthrift_thrift_uri() noexcept {
    return "test.dev/fixtures/enums/MyBitmaskEnum2";
  }

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::ONE; }
  static constexpr type max() { return type::FOUR; }
};

} // namespace apache::thrift
// END declare_enums
// BEGIN forward_declare
namespace test::fixtures::enums {
class SomeStruct;
class MyStruct;
} // namespace test::fixtures::enums
// END forward_declare
namespace apache::thrift::detail::annotation {
} // namespace apache::thrift::detail::annotation

namespace apache::thrift::detail::qualifier {
} // namespace apache::thrift::detail::qualifier

// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace test::fixtures::enums {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;


/** Glean {"file": "thrift/compiler/test/fixtures/enums/src/module.thrift", "name": "SomeStruct", "kind": "struct" } */
class SomeStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static std::string_view __fbthrift_thrift_uri();
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  template <class ...>
  FOLLY_ERASE static constexpr std::string_view __fbthrift_get_module_name() noexcept {
    return "module";
  }
  static constexpr std::size_t __fbthrift_num_fields = 4;

  static constexpr const int16_t __fbthrift_reflection_field_ids[] = {0,1,2,3,4};

  using __fbthrift_reflection_idents = folly::tag_t<
    ::apache::thrift::ident::reasonable,
    ::apache::thrift::ident::fine,
    ::apache::thrift::ident::questionable,
    ::apache::thrift::ident::tags
  >;

  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::enum_t<::test::fixtures::enums::Metasyntactic>,
    ::apache::thrift::type::enum_t<::test::fixtures::enums::Metasyntactic>,
    ::apache::thrift::type::enum_t<::test::fixtures::enums::Metasyntactic>,
    ::apache::thrift::type::set<::apache::thrift::type::i32_t>
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = SomeStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;
  static constexpr bool __fbthrift_cpp2_uses_op_encode =
    false;


 public:

  SomeStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SomeStruct(apache::thrift::FragileConstructor, ::test::fixtures::enums::Metasyntactic reasonable__arg, ::test::fixtures::enums::Metasyntactic fine__arg, ::test::fixtures::enums::Metasyntactic questionable__arg, ::std::set<::std::int32_t> tags__arg);

  SomeStruct(SomeStruct&&) noexcept;

  SomeStruct(const SomeStruct& src);


  SomeStruct& operator=(SomeStruct&&) noexcept;
  SomeStruct& operator=(const SomeStruct& src);

  ~SomeStruct();

 private:
  ::test::fixtures::enums::Metasyntactic __fbthrift_field_reasonable;
 private:
  ::test::fixtures::enums::Metasyntactic __fbthrift_field_fine;
 private:
  ::test::fixtures::enums::Metasyntactic __fbthrift_field_questionable;
 private:
  ::std::set<::std::int32_t> __fbthrift_field_tags;
 private:
  apache::thrift::detail::isset_bitset<4, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const SomeStruct&) const;
  bool operator<(const SomeStruct&) const;

  /** Glean { "field": "reasonable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> reasonable_ref() const& {
    return {this->__fbthrift_field_reasonable, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "reasonable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> reasonable_ref() & {
    return {this->__fbthrift_field_reasonable, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "reasonable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> reasonable_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_reasonable), __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "reasonable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> reasonable() const& {
    return {this->__fbthrift_field_reasonable, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "reasonable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> reasonable() & {
    return {this->__fbthrift_field_reasonable, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "reasonable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> reasonable() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_reasonable), __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "fine" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> fine_ref() const& {
    return {this->__fbthrift_field_fine, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "fine" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> fine_ref() & {
    return {this->__fbthrift_field_fine, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "fine" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> fine_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_fine), __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "fine" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> fine() const& {
    return {this->__fbthrift_field_fine, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "fine" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> fine() & {
    return {this->__fbthrift_field_fine, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "fine" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> fine() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_fine), __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "questionable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> questionable_ref() const& {
    return {this->__fbthrift_field_questionable, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "questionable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> questionable_ref() & {
    return {this->__fbthrift_field_questionable, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "questionable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> questionable_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_questionable), __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "questionable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> questionable() const& {
    return {this->__fbthrift_field_questionable, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "questionable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> questionable() & {
    return {this->__fbthrift_field_questionable, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "questionable" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::Metasyntactic>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> questionable() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_questionable), __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "tags" } */
  template <typename..., typename fbthrift_T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> tags_ref() const& {
    return {this->__fbthrift_field_tags, __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "tags" } */
  template <typename..., typename fbthrift_T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> tags_ref() & {
    return {this->__fbthrift_field_tags, __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "tags" } */
  template <typename..., typename fbthrift_T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> tags_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_tags), __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "tags" } */
  template <typename..., typename fbthrift_T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> tags() const& {
    return {this->__fbthrift_field_tags, __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "tags" } */
  template <typename..., typename fbthrift_T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> tags() & {
    return {this->__fbthrift_field_tags, __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "tags" } */
  template <typename..., typename fbthrift_T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> tags() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_tags), __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "reasonable" } */
  [[deprecated("Use `FOO.reasonable().value()` instead of `FOO.get_reasonable()`")]]
  ::test::fixtures::enums::Metasyntactic get_reasonable() const;

  /** Glean { "field": "reasonable" } */
  [[deprecated("Use `FOO.reasonable() = BAR` instead of `FOO.set_reasonable(BAR)`")]]
  ::test::fixtures::enums::Metasyntactic& set_reasonable(::test::fixtures::enums::Metasyntactic reasonable_);

  /** Glean { "field": "fine" } */
  [[deprecated("Use `FOO.fine().value()` instead of `FOO.get_fine()`")]]
  ::test::fixtures::enums::Metasyntactic get_fine() const;

  /** Glean { "field": "fine" } */
  [[deprecated("Use `FOO.fine() = BAR` instead of `FOO.set_fine(BAR)`")]]
  ::test::fixtures::enums::Metasyntactic& set_fine(::test::fixtures::enums::Metasyntactic fine_);

  /** Glean { "field": "questionable" } */
  [[deprecated("Use `FOO.questionable().value()` instead of `FOO.get_questionable()`")]]
  ::test::fixtures::enums::Metasyntactic get_questionable() const;

  /** Glean { "field": "questionable" } */
  [[deprecated("Use `FOO.questionable() = BAR` instead of `FOO.set_questionable(BAR)`")]]
  ::test::fixtures::enums::Metasyntactic& set_questionable(::test::fixtures::enums::Metasyntactic questionable_);

  /** Glean { "field": "tags" } */
  [[deprecated("Use `FOO.tags().value()` instead of `FOO.get_tags()`")]]
  const ::std::set<::std::int32_t>& get_tags() const&;

  /** Glean { "field": "tags" } */
  [[deprecated("Use `FOO.tags().value()` instead of `FOO.get_tags()`")]]
  ::std::set<::std::int32_t> get_tags() &&;

  /** Glean { "field": "tags" } */
  template <typename T_SomeStruct_tags_struct_setter = ::std::set<::std::int32_t>>
  [[deprecated("Use `FOO.tags() = BAR` instead of `FOO.set_tags(BAR)`")]]
  ::std::set<::std::int32_t>& set_tags(T_SomeStruct_tags_struct_setter&& tags_) {
    tags_ref() = std::forward<T_SomeStruct_tags_struct_setter>(tags_);
    return __fbthrift_field_tags;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<SomeStruct>;
  friend void swap(SomeStruct& a, SomeStruct& b);
};

template <class Protocol_>
unsigned long SomeStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


/** Glean {"file": "thrift/compiler/test/fixtures/enums/src/module.thrift", "name": "MyStruct", "kind": "struct" } */
class MyStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static std::string_view __fbthrift_thrift_uri();
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  template <class ...>
  FOLLY_ERASE static constexpr std::string_view __fbthrift_get_module_name() noexcept {
    return "module";
  }
  static constexpr std::size_t __fbthrift_num_fields = 4;

  static constexpr const int16_t __fbthrift_reflection_field_ids[] = {0,1,2,4,6};

  using __fbthrift_reflection_idents = folly::tag_t<
    ::apache::thrift::ident::me2_3,
    ::apache::thrift::ident::me3_n3,
    ::apache::thrift::ident::me1_t1,
    ::apache::thrift::ident::me1_t2
  >;

  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::enum_t<::test::fixtures::enums::MyEnum2>,
    ::apache::thrift::type::enum_t<::test::fixtures::enums::MyEnum3>,
    ::apache::thrift::type::enum_t<::test::fixtures::enums::MyEnum1>,
    ::apache::thrift::type::enum_t<::test::fixtures::enums::MyEnum1>
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = MyStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;
  static constexpr bool __fbthrift_cpp2_uses_op_encode =
    false;


 public:

  MyStruct() :
      __fbthrift_field_me2_3(static_cast< ::test::fixtures::enums::MyEnum2>(3)),
      __fbthrift_field_me3_n3(static_cast< ::test::fixtures::enums::MyEnum3>(-3)),
      __fbthrift_field_me1_t1( ::test::fixtures::enums::MyEnum1::ME1_1),
      __fbthrift_field_me1_t2( ::test::fixtures::enums::MyEnum1::ME1_1) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MyStruct(apache::thrift::FragileConstructor, ::test::fixtures::enums::MyEnum2 me2_3__arg, ::test::fixtures::enums::MyEnum3 me3_n3__arg, ::test::fixtures::enums::MyEnum1 me1_t1__arg, ::test::fixtures::enums::MyEnum1 me1_t2__arg);

  MyStruct(MyStruct&&) = default;

  MyStruct(const MyStruct&) = default;


  MyStruct& operator=(MyStruct&&) = default;

  MyStruct& operator=(const MyStruct&) = default;
 private:
  ::test::fixtures::enums::MyEnum2 __fbthrift_field_me2_3;
 private:
  ::test::fixtures::enums::MyEnum3 __fbthrift_field_me3_n3;
 private:
  ::test::fixtures::enums::MyEnum1 __fbthrift_field_me1_t1;
 private:
  ::test::fixtures::enums::MyEnum1 __fbthrift_field_me1_t2;
 private:
  apache::thrift::detail::isset_bitset<4, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const MyStruct&) const;
  bool operator<(const MyStruct&) const;

  /** Glean { "field": "me2_3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum2>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> me2_3_ref() const& {
    return {this->__fbthrift_field_me2_3, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "me2_3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum2>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> me2_3_ref() & {
    return {this->__fbthrift_field_me2_3, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "me2_3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum2>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> me2_3_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_me2_3), __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "me2_3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum2>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> me2_3() const& {
    return {this->__fbthrift_field_me2_3, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "me2_3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum2>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> me2_3() & {
    return {this->__fbthrift_field_me2_3, __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "me2_3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum2>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> me2_3() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_me2_3), __isset.at(0), __isset.bit(0)};
  }

  /** Glean { "field": "me3_n3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum3>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> me3_n3_ref() const& {
    return {this->__fbthrift_field_me3_n3, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "me3_n3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum3>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> me3_n3_ref() & {
    return {this->__fbthrift_field_me3_n3, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "me3_n3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum3>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> me3_n3_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_me3_n3), __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "me3_n3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum3>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> me3_n3() const& {
    return {this->__fbthrift_field_me3_n3, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "me3_n3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum3>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> me3_n3() & {
    return {this->__fbthrift_field_me3_n3, __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "me3_n3" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum3>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> me3_n3() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_me3_n3), __isset.at(1), __isset.bit(1)};
  }

  /** Glean { "field": "me1_t1" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> me1_t1_ref() const& {
    return {this->__fbthrift_field_me1_t1, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "me1_t1" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> me1_t1_ref() & {
    return {this->__fbthrift_field_me1_t1, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "me1_t1" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> me1_t1_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_me1_t1), __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "me1_t1" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> me1_t1() const& {
    return {this->__fbthrift_field_me1_t1, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "me1_t1" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> me1_t1() & {
    return {this->__fbthrift_field_me1_t1, __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "me1_t1" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> me1_t1() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_me1_t1), __isset.at(2), __isset.bit(2)};
  }

  /** Glean { "field": "me1_t2" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> me1_t2_ref() const& {
    return {this->__fbthrift_field_me1_t2, __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "me1_t2" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> me1_t2_ref() & {
    return {this->__fbthrift_field_me1_t2, __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "me1_t2" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> me1_t2_ref() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_me1_t2), __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "me1_t2" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const fbthrift_T&> me1_t2() const& {
    return {this->__fbthrift_field_me1_t2, __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "me1_t2" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&> me1_t2() & {
    return {this->__fbthrift_field_me1_t2, __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "me1_t2" } */
  template <typename..., typename fbthrift_T = ::test::fixtures::enums::MyEnum1>
  FOLLY_ERASE ::apache::thrift::field_ref<fbthrift_T&&> me1_t2() && {
    return {static_cast<fbthrift_T&&>(this->__fbthrift_field_me1_t2), __isset.at(3), __isset.bit(3)};
  }

  /** Glean { "field": "me2_3" } */
  [[deprecated("Use `FOO.me2_3().value()` instead of `FOO.get_me2_3()`")]]
  ::test::fixtures::enums::MyEnum2 get_me2_3() const;

  /** Glean { "field": "me2_3" } */
  [[deprecated("Use `FOO.me2_3() = BAR` instead of `FOO.set_me2_3(BAR)`")]]
  ::test::fixtures::enums::MyEnum2& set_me2_3(::test::fixtures::enums::MyEnum2 me2_3_);

  /** Glean { "field": "me3_n3" } */
  [[deprecated("Use `FOO.me3_n3().value()` instead of `FOO.get_me3_n3()`")]]
  ::test::fixtures::enums::MyEnum3 get_me3_n3() const;

  /** Glean { "field": "me3_n3" } */
  [[deprecated("Use `FOO.me3_n3() = BAR` instead of `FOO.set_me3_n3(BAR)`")]]
  ::test::fixtures::enums::MyEnum3& set_me3_n3(::test::fixtures::enums::MyEnum3 me3_n3_);

  /** Glean { "field": "me1_t1" } */
  [[deprecated("Use `FOO.me1_t1().value()` instead of `FOO.get_me1_t1()`")]]
  ::test::fixtures::enums::MyEnum1 get_me1_t1() const;

  /** Glean { "field": "me1_t1" } */
  [[deprecated("Use `FOO.me1_t1() = BAR` instead of `FOO.set_me1_t1(BAR)`")]]
  ::test::fixtures::enums::MyEnum1& set_me1_t1(::test::fixtures::enums::MyEnum1 me1_t1_);

  /** Glean { "field": "me1_t2" } */
  [[deprecated("Use `FOO.me1_t2().value()` instead of `FOO.get_me1_t2()`")]]
  ::test::fixtures::enums::MyEnum1 get_me1_t2() const;

  /** Glean { "field": "me1_t2" } */
  [[deprecated("Use `FOO.me1_t2() = BAR` instead of `FOO.set_me1_t2(BAR)`")]]
  ::test::fixtures::enums::MyEnum1& set_me1_t2(::test::fixtures::enums::MyEnum1 me1_t2_);

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<MyStruct>;
  friend void swap(MyStruct& a, MyStruct& b);
};

template <class Protocol_>
unsigned long MyStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


} // namespace test::fixtures::enums

namespace apache::thrift::detail {
template <> struct TSchemaAssociation<::test::fixtures::enums::SomeStruct, false> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -5845067048472914545;
  static constexpr ::std::string_view definitionKey = {"\x93\x4a\xa0\x85\x17\xa4\xb7\x92\x02\x00\xa6\x67\xd4\x32\x27\x22", 16};
};
template <> struct TSchemaAssociation<::test::fixtures::enums::MyStruct, false> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -5845067048472914545;
  static constexpr ::std::string_view definitionKey = {"\x97\xcb\x20\xa9\x5a\xe5\x75\x5e\x40\x04\x41\x41\xa2\x08\xba\xd4", 16};
};
template <> struct TSchemaAssociation<::test::fixtures::enums::Metasyntactic, true> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -5845067048472914545;
  static constexpr ::std::string_view definitionKey = {"\xca\x4c\xfd\x9e\x95\x8d\xf2\x95\x11\xc4\xd8\x01\xcc\x20\x83\x6a", 16};
};
template <> struct TSchemaAssociation<::test::fixtures::enums::MyEnum1, true> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -5845067048472914545;
  static constexpr ::std::string_view definitionKey = {"\xfc\x4a\x61\x6f\x90\xde\x04\xd5\x1e\x39\x9a\xf6\xc0\x9b\xcc\x2f", 16};
};
template <> struct TSchemaAssociation<::test::fixtures::enums::MyEnum2, true> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -5845067048472914545;
  static constexpr ::std::string_view definitionKey = {"\x8a\x84\x44\xdb\x4c\x02\xd1\x2c\x32\xa6\x6c\x5d\x87\x31\xf9\x2a", 16};
};
template <> struct TSchemaAssociation<::test::fixtures::enums::MyEnum3, true> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -5845067048472914545;
  static constexpr ::std::string_view definitionKey = {"\x57\xc8\xc9\xb1\xd7\xd8\x9a\x71\x0d\x8a\x9c\x84\x34\x64\x4b\xff", 16};
};
template <> struct TSchemaAssociation<::test::fixtures::enums::MyEnum4, true> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -5845067048472914545;
  static constexpr ::std::string_view definitionKey = {"\x0f\x71\x87\x1c\xba\xcd\x9d\x09\x3d\xfe\x1b\x36\xc5\xd2\xff\xa1", 16};
};
template <> struct TSchemaAssociation<::test::fixtures::enums::MyBitmaskEnum1, true> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -5845067048472914545;
  static constexpr ::std::string_view definitionKey = {"\xb4\xb0\x7c\xca\xaf\xad\xbc\x19\xa6\xd9\x97\x9e\xd1\x9d\x50\x2d", 16};
};
template <> struct TSchemaAssociation<::test::fixtures::enums::MyBitmaskEnum2, true> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -5845067048472914545;
  static constexpr ::std::string_view definitionKey = {"\x01\x9a\x96\x6b\x9a\x14\x63\xfb\x42\x04\x3a\x6b\x11\x75\x26\xce", 16};
};
} // namespace apache::thrift::detail
