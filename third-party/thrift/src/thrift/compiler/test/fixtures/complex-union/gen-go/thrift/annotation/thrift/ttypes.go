// Autogenerated by Thrift Compiler (facebook)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
// @generated

package thrift

import (
	"bytes"
	"context"
	"sync"
	"fmt"
	thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = sync.Mutex{}
var _ = bytes.Equal
var _ = context.Background

var GoUnusedProtection__ int;

// Indicates a definition/feature may change in incompatible ways.
type Beta struct {
}

func NewBeta() *Beta {
  return &Beta{}
}

type BetaBuilder struct {
  obj *Beta
}

func NewBetaBuilder() *BetaBuilder{
  return &BetaBuilder{
    obj: NewBeta(),
  }
}

func (p BetaBuilder) Emit() *Beta{
  return &Beta{
  }
}

func (p *Beta) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Beta) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Beta"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Beta) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("Beta({})")
}

// Indicates a definition/feature should only be used with permission, may
// only work in specific contexts, and may change in incompatible ways without
// notice.
type Experimental struct {
}

func NewExperimental() *Experimental {
  return &Experimental{}
}

type ExperimentalBuilder struct {
  obj *Experimental
}

func NewExperimentalBuilder() *ExperimentalBuilder{
  return &ExperimentalBuilder{
    obj: NewExperimental(),
  }
}

func (p ExperimentalBuilder) Emit() *Experimental{
  return &Experimental{
  }
}

func (p *Experimental) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Experimental) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Experimental"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Experimental) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("Experimental({})")
}

// Indicates a definition/feature should only be used in an ephemeral testing
// enviornment.
// 
// Such enviornments only store serialized values temporarly and strictly
// control which versions of Thrift definitions are used, so 'compatibility'
// is not a concern.
type Testing struct {
}

func NewTesting() *Testing {
  return &Testing{}
}

type TestingBuilder struct {
  obj *Testing
}

func NewTestingBuilder() *TestingBuilder{
  return &TestingBuilder{
    obj: NewTesting(),
  }
}

func (p TestingBuilder) Emit() *Testing{
  return &Testing{
  }
}

func (p *Testing) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Testing) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Testing"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Testing) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("Testing({})")
}

// Indicates a definition/feature should no longer be used.
// 
// Attributes:
//  - Message
type Deprecated struct {
  Message string `thrift:"message,1" db:"message" json:"message"`
}

func NewDeprecated() *Deprecated {
  return &Deprecated{}
}


func (p *Deprecated) GetMessage() string {
  return p.Message
}
type DeprecatedBuilder struct {
  obj *Deprecated
}

func NewDeprecatedBuilder() *DeprecatedBuilder{
  return &DeprecatedBuilder{
    obj: NewDeprecated(),
  }
}

func (p DeprecatedBuilder) Emit() *Deprecated{
  return &Deprecated{
    Message: p.obj.Message,
  }
}

func (d *DeprecatedBuilder) Message(message string) *DeprecatedBuilder {
  d.obj.Message = message
  return d
}

func (d *Deprecated) SetMessage(message string) *Deprecated {
  d.Message = message
  return d
}

func (p *Deprecated) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Deprecated)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.Message = v
  }
  return nil
}

func (p *Deprecated) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Deprecated"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Deprecated) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("message", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err) }
  if err := oprot.WriteString(string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err) }
  return err
}

func (p *Deprecated) String() string {
  if p == nil {
    return "<nil>"
  }

  messageVal := fmt.Sprintf("%v", p.Message)
  return fmt.Sprintf("Deprecated({Message:%s})", messageVal)
}

// Annotate a thrift structured or enum to indicate if ids or values should not
// be used.
// 
// For example, you may want to mark ids as deprecated, or these ids
// might be reserved for other use cases or annotations.
// 
// The resolved set of disallowed ids is the union of the values in `ids` and
// the range of values represented in `id_ranges`. Example:
// 
//  // These ids are not allowed: 3, 8, half-open ranges [10, 15), [20, 30)
//  @thrift.ReserveIds{ids = [3, 8], id_ranges = {10: 15, 20: 30}}
//  struct Foo {
//    ...
//    3: i64 f; // Build failure: 3 cannot be used
//  }
// 
// Attributes:
//  - Ids: Individual ids that cannot be used.
//  - IdRanges: Represents ranges of ids that cannot be used.
// 
// Each (key: value) pair represents the half-open range `[key, value)`,
// where `key` is included and `value` is not. For example, the map
// `{10: 15, 20: 30}` represents the union of id/value ranges `[10, 15)` and
// `[20, 30)`.
type ReserveIds struct {
  Ids []int32 `thrift:"ids,1" db:"ids" json:"ids"`
  IdRanges map[int32]int32 `thrift:"id_ranges,2" db:"id_ranges" json:"id_ranges"`
}

func NewReserveIds() *ReserveIds {
  return &ReserveIds{}
}


func (p *ReserveIds) GetIds() []int32 {
  return p.Ids
}

func (p *ReserveIds) GetIdRanges() map[int32]int32 {
  return p.IdRanges
}
type ReserveIdsBuilder struct {
  obj *ReserveIds
}

func NewReserveIdsBuilder() *ReserveIdsBuilder{
  return &ReserveIdsBuilder{
    obj: NewReserveIds(),
  }
}

func (p ReserveIdsBuilder) Emit() *ReserveIds{
  return &ReserveIds{
    Ids: p.obj.Ids,
    IdRanges: p.obj.IdRanges,
  }
}

func (r *ReserveIdsBuilder) Ids(ids []int32) *ReserveIdsBuilder {
  r.obj.Ids = ids
  return r
}

func (r *ReserveIdsBuilder) IdRanges(idRanges map[int32]int32) *ReserveIdsBuilder {
  r.obj.IdRanges = idRanges
  return r
}

func (r *ReserveIds) SetIds(ids []int32) *ReserveIds {
  r.Ids = ids
  return r
}

func (r *ReserveIds) SetIdRanges(idRanges map[int32]int32) *ReserveIds {
  r.IdRanges = idRanges
  return r
}

func (p *ReserveIds) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    case 2:
      if err := p.ReadField2(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReserveIds)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int32, 0, size)
  p.Ids =  tSlice
  for i := 0; i < size; i ++ {
    var _elem0 int32
    if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
    } else {
      _elem0 = v
    }
    p.Ids = append(p.Ids, _elem0)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ReserveIds)  ReadField2(iprot thrift.Protocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[int32]int32, size)
  p.IdRanges =  tMap
  for i := 0; i < size; i ++ {
    var _key1 int32
    if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
    } else {
      _key1 = v
    }
    var _val2 int32
    if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
    } else {
      _val2 = v
    }
    p.IdRanges[_key1] = _val2
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *ReserveIds) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("ReserveIds"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := p.writeField2(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReserveIds) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("ids", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ids: ", p), err) }
  if err := oprot.WriteListBegin(thrift.I32, len(p.Ids)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Ids {
    if err := oprot.WriteI32(int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ids: ", p), err) }
  return err
}

func (p *ReserveIds) writeField2(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("id_ranges", thrift.MAP, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:id_ranges: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.I32, thrift.I32, len(p.IdRanges)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.IdRanges {
    if err := oprot.WriteI32(int32(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteI32(int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:id_ranges: ", p), err) }
  return err
}

func (p *ReserveIds) String() string {
  if p == nil {
    return "<nil>"
  }

  idsVal := fmt.Sprintf("%v", p.Ids)
  idRangesVal := fmt.Sprintf("%v", p.IdRanges)
  return fmt.Sprintf("ReserveIds({Ids:%s IdRanges:%s})", idsVal, idRangesVal)
}

// Indicates additional backward compatibility restrictions, beyond the
// standard Thrift required 'wire' compatibility.
// 
// Attributes:
//  - FieldName
type RequiresBackwardCompatibility struct {
  FieldName bool `thrift:"field_name,1" db:"field_name" json:"field_name"`
}

func NewRequiresBackwardCompatibility() *RequiresBackwardCompatibility {
  return &RequiresBackwardCompatibility{}
}


func (p *RequiresBackwardCompatibility) GetFieldName() bool {
  return p.FieldName
}
type RequiresBackwardCompatibilityBuilder struct {
  obj *RequiresBackwardCompatibility
}

func NewRequiresBackwardCompatibilityBuilder() *RequiresBackwardCompatibilityBuilder{
  return &RequiresBackwardCompatibilityBuilder{
    obj: NewRequiresBackwardCompatibility(),
  }
}

func (p RequiresBackwardCompatibilityBuilder) Emit() *RequiresBackwardCompatibility{
  return &RequiresBackwardCompatibility{
    FieldName: p.obj.FieldName,
  }
}

func (r *RequiresBackwardCompatibilityBuilder) FieldName(fieldName bool) *RequiresBackwardCompatibilityBuilder {
  r.obj.FieldName = fieldName
  return r
}

func (r *RequiresBackwardCompatibility) SetFieldName(fieldName bool) *RequiresBackwardCompatibility {
  r.FieldName = fieldName
  return r
}

func (p *RequiresBackwardCompatibility) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RequiresBackwardCompatibility)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadBool(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.FieldName = v
  }
  return nil
}

func (p *RequiresBackwardCompatibility) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("RequiresBackwardCompatibility"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RequiresBackwardCompatibility) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("field_name", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field_name: ", p), err) }
  if err := oprot.WriteBool(bool(p.FieldName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.field_name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field_name: ", p), err) }
  return err
}

func (p *RequiresBackwardCompatibility) String() string {
  if p == nil {
    return "<nil>"
  }

  fieldNameVal := fmt.Sprintf("%v", p.FieldName)
  return fmt.Sprintf("RequiresBackwardCompatibility({FieldName:%s})", fieldNameVal)
}

// Disables testing features.
type NoTesting struct {
}

func NewNoTesting() *NoTesting {
  return &NoTesting{}
}

type NoTestingBuilder struct {
  obj *NoTesting
}

func NewNoTestingBuilder() *NoTestingBuilder{
  return &NoTestingBuilder{
    obj: NewNoTesting(),
  }
}

func (p NoTestingBuilder) Emit() *NoTesting{
  return &NoTesting{
  }
}

func (p *NoTesting) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoTesting) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("NoTesting"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoTesting) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NoTesting({})")
}

// Disables experimental features.
type NoExperimental struct {
}

func NewNoExperimental() *NoExperimental {
  return &NoExperimental{}
}

type NoExperimentalBuilder struct {
  obj *NoExperimental
}

func NewNoExperimentalBuilder() *NoExperimentalBuilder{
  return &NoExperimentalBuilder{
    obj: NewNoExperimental(),
  }
}

func (p NoExperimentalBuilder) Emit() *NoExperimental{
  return &NoExperimental{
  }
}

func (p *NoExperimental) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoExperimental) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("NoExperimental"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoExperimental) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NoExperimental({})")
}

// Disables @Beta features.
type NoBeta struct {
}

func NewNoBeta() *NoBeta {
  return &NoBeta{}
}

type NoBetaBuilder struct {
  obj *NoBeta
}

func NewNoBetaBuilder() *NoBetaBuilder{
  return &NoBetaBuilder{
    obj: NewNoBeta(),
  }
}

func (p NoBetaBuilder) Emit() *NoBeta{
  return &NoBeta{
  }
}

func (p *NoBeta) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoBeta) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("NoBeta"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoBeta) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NoBeta({})")
}

// Indicates a definition/feature must not depend directly on an unreleased
// or testing definition/feature.
type Released struct {
}

func NewReleased() *Released {
  return &Released{}
}

type ReleasedBuilder struct {
  obj *Released
}

func NewReleasedBuilder() *ReleasedBuilder{
  return &ReleasedBuilder{
    obj: NewReleased(),
  }
}

func (p ReleasedBuilder) Emit() *Released{
  return &Released{
  }
}

func (p *Released) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Released) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Released"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Released) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("Released({})")
}

// Disables legacy features.
type NoLegacy struct {
}

func NewNoLegacy() *NoLegacy {
  return &NoLegacy{}
}

type NoLegacyBuilder struct {
  obj *NoLegacy
}

func NewNoLegacyBuilder() *NoLegacyBuilder{
  return &NoLegacyBuilder{
    obj: NewNoLegacy(),
  }
}

func (p NoLegacyBuilder) Emit() *NoLegacy{
  return &NoLegacy{
  }
}

func (p *NoLegacy) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoLegacy) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("NoLegacy"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoLegacy) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NoLegacy({})")
}

// Disables @Deprecated features.
// 
// Should only be enabled in `test` versions, as deprecated implies removing
// the feature will break current usage (otherwise it would be legacy or
// deleted).
type NoDeprecated struct {
}

func NewNoDeprecated() *NoDeprecated {
  return &NoDeprecated{}
}

type NoDeprecatedBuilder struct {
  obj *NoDeprecated
}

func NewNoDeprecatedBuilder() *NoDeprecatedBuilder{
  return &NoDeprecatedBuilder{
    obj: NewNoDeprecated(),
  }
}

func (p NoDeprecatedBuilder) Emit() *NoDeprecated{
  return &NoDeprecated{
  }
}

func (p *NoDeprecated) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NoDeprecated) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("NoDeprecated"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NoDeprecated) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NoDeprecated({})")
}

// An annotation that changes the field qualifier from 'none' to 'terse'.
// A terse field is eligible to skip serialization, when it equals to the
// intrinsic default value. It also clears to the intrinsic default value
// before deserialization to distinguish between if a terse field was skipped
// or missing during serialization. This is different from an unqualified
// field, as an unqualified field is always serialized regardless of its value,
// and it is not cleared before deserialization.
// 
// The annotation can be only used to annotate an unqualified field, and when
// it is annotating a struct or exception, it changes all unqualified fields to
// terse fields. Note, the annotation can not be used for union.
type TerseWrite struct {
}

func NewTerseWrite() *TerseWrite {
  return &TerseWrite{}
}

type TerseWriteBuilder struct {
  obj *TerseWrite
}

func NewTerseWriteBuilder() *TerseWriteBuilder{
  return &TerseWriteBuilder{
    obj: NewTerseWrite(),
  }
}

func (p TerseWriteBuilder) Emit() *TerseWrite{
  return &TerseWrite{
  }
}

func (p *TerseWrite) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TerseWrite) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("TerseWrite"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TerseWrite) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("TerseWrite({})")
}

// Indicates that a field's value should never be stored on the stack.
type Box struct {
}

func NewBox() *Box {
  return &Box{}
}

type BoxBuilder struct {
  obj *Box
}

func NewBoxBuilder() *BoxBuilder{
  return &BoxBuilder{
    obj: NewBox(),
  }
}

func (p BoxBuilder) Emit() *Box{
  return &Box{
  }
}

func (p *Box) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Box) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Box"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Box) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("Box({})")
}

type Mixin struct {
}

func NewMixin() *Mixin {
  return &Mixin{}
}

type MixinBuilder struct {
  obj *Mixin
}

func NewMixinBuilder() *MixinBuilder{
  return &MixinBuilder{
    obj: NewMixin(),
  }
}

func (p MixinBuilder) Emit() *Mixin{
  return &Mixin{
  }
}

func (p *Mixin) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Mixin) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("Mixin"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Mixin) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("Mixin({})")
}

// Option to serialize thrift struct in ascending field id order.
// 
// This can potentially make serialized data size smaller in compact protocol,
// since compact protocol can write deltas between subsequent field ids.
type SerializeInFieldIdOrder struct {
}

func NewSerializeInFieldIdOrder() *SerializeInFieldIdOrder {
  return &SerializeInFieldIdOrder{}
}

type SerializeInFieldIdOrderBuilder struct {
  obj *SerializeInFieldIdOrder
}

func NewSerializeInFieldIdOrderBuilder() *SerializeInFieldIdOrderBuilder{
  return &SerializeInFieldIdOrderBuilder{
    obj: NewSerializeInFieldIdOrder(),
  }
}

func (p SerializeInFieldIdOrderBuilder) Emit() *SerializeInFieldIdOrder{
  return &SerializeInFieldIdOrder{
  }
}

func (p *SerializeInFieldIdOrder) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SerializeInFieldIdOrder) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("SerializeInFieldIdOrder"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SerializeInFieldIdOrder) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("SerializeInFieldIdOrder({})")
}

// Indicates an enum is a bitmask and should support bit-wise operators.
type BitmaskEnum struct {
}

func NewBitmaskEnum() *BitmaskEnum {
  return &BitmaskEnum{}
}

type BitmaskEnumBuilder struct {
  obj *BitmaskEnum
}

func NewBitmaskEnumBuilder() *BitmaskEnumBuilder{
  return &BitmaskEnumBuilder{
    obj: NewBitmaskEnum(),
  }
}

func (p BitmaskEnumBuilder) Emit() *BitmaskEnum{
  return &BitmaskEnum{
  }
}

func (p *BitmaskEnum) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *BitmaskEnum) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("BitmaskEnum"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *BitmaskEnum) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("BitmaskEnum({})")
}

// Enables all released v1 features.
type V1 struct {
}

func NewV1() *V1 {
  return &V1{}
}

type V1Builder struct {
  obj *V1
}

func NewV1Builder() *V1Builder{
  return &V1Builder{
    obj: NewV1(),
  }
}

func (p V1Builder) Emit() *V1{
  return &V1{
  }
}

func (p *V1) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *V1) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("v1"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *V1) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("V1({})")
}

// Enables all beta v1 features.
// 
// Beta features are guaranteed to *not* break unrelated Thrift features
// so they should be relatively safe to test alongside other beta or
// released Thrift features.
type V1beta struct {
}

func NewV1beta() *V1beta {
  return &V1beta{}
}

type V1betaBuilder struct {
  obj *V1beta
}

func NewV1betaBuilder() *V1betaBuilder{
  return &V1betaBuilder{
    obj: NewV1beta(),
  }
}

func (p V1betaBuilder) Emit() *V1beta{
  return &V1beta{
  }
}

func (p *V1beta) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *V1beta) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("v1beta"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *V1beta) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("V1beta({})")
}

// Enables all experimental v1 features.
// 
// Use with *caution* and only with explicit permission. This may enable
// features may change significantly without notice or not work correctly
// in all contexts.
type V1alpha struct {
}

func NewV1alpha() *V1alpha {
  return &V1alpha{}
}

type V1alphaBuilder struct {
  obj *V1alpha
}

func NewV1alphaBuilder() *V1alphaBuilder{
  return &V1alphaBuilder{
    obj: NewV1alpha(),
  }
}

func (p V1alphaBuilder) Emit() *V1alpha{
  return &V1alpha{
  }
}

func (p *V1alpha) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *V1alpha) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("v1alpha"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *V1alpha) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("V1alpha({})")
}

// Enables experimental features, even those that are known to break common
// use cases.
type V1test struct {
}

func NewV1test() *V1test {
  return &V1test{}
}

type V1testBuilder struct {
  obj *V1test
}

func NewV1testBuilder() *V1testBuilder{
  return &V1testBuilder{
    obj: NewV1test(),
  }
}

func (p V1testBuilder) Emit() *V1test{
  return &V1test{
  }
}

func (p *V1test) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *V1test) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("v1test"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *V1test) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("V1test({})")
}

// Specifies the field where the exception message is stored. The field
// is used to generate an additional method to get it.
// 
// Attributes:
//  - Field
type ExceptionMessage struct {
  Field string `thrift:"field,1" db:"field" json:"field"`
}

func NewExceptionMessage() *ExceptionMessage {
  return &ExceptionMessage{}
}


func (p *ExceptionMessage) GetField() string {
  return p.Field
}
type ExceptionMessageBuilder struct {
  obj *ExceptionMessage
}

func NewExceptionMessageBuilder() *ExceptionMessageBuilder{
  return &ExceptionMessageBuilder{
    obj: NewExceptionMessage(),
  }
}

func (p ExceptionMessageBuilder) Emit() *ExceptionMessage{
  return &ExceptionMessage{
    Field: p.obj.Field,
  }
}

func (e *ExceptionMessageBuilder) Field(field string) *ExceptionMessageBuilder {
  e.obj.Field = field
  return e
}

func (e *ExceptionMessage) SetField(field string) *ExceptionMessage {
  e.Field = field
  return e
}

func (p *ExceptionMessage) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ExceptionMessage)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.Field = v
  }
  return nil
}

func (p *ExceptionMessage) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("ExceptionMessage"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ExceptionMessage) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("field", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field: ", p), err) }
  if err := oprot.WriteString(string(p.Field)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.field (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field: ", p), err) }
  return err
}

func (p *ExceptionMessage) String() string {
  if p == nil {
    return "<nil>"
  }

  fieldVal := fmt.Sprintf("%v", p.Field)
  return fmt.Sprintf("ExceptionMessage({Field:%s})", fieldVal)
}

// Generates a const of type schema. Struct containing the schema of the
// annotated type. Optionally specify name to override default
// schema<structName>.
// 
// Attributes:
//  - Name
type GenerateRuntimeSchema struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
}

func NewGenerateRuntimeSchema() *GenerateRuntimeSchema {
  return &GenerateRuntimeSchema{}
}


func (p *GenerateRuntimeSchema) GetName() string {
  return p.Name
}
type GenerateRuntimeSchemaBuilder struct {
  obj *GenerateRuntimeSchema
}

func NewGenerateRuntimeSchemaBuilder() *GenerateRuntimeSchemaBuilder{
  return &GenerateRuntimeSchemaBuilder{
    obj: NewGenerateRuntimeSchema(),
  }
}

func (p GenerateRuntimeSchemaBuilder) Emit() *GenerateRuntimeSchema{
  return &GenerateRuntimeSchema{
    Name: p.obj.Name,
  }
}

func (g *GenerateRuntimeSchemaBuilder) Name(name string) *GenerateRuntimeSchemaBuilder {
  g.obj.Name = name
  return g
}

func (g *GenerateRuntimeSchema) SetName(name string) *GenerateRuntimeSchema {
  g.Name = name
  return g
}

func (p *GenerateRuntimeSchema) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GenerateRuntimeSchema)  ReadField1(iprot thrift.Protocol) error {
  if v, err := iprot.ReadString(); err != nil {
    return thrift.PrependError("error reading field 1: ", err)
  } else {
    p.Name = v
  }
  return nil
}

func (p *GenerateRuntimeSchema) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("GenerateRuntimeSchema"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GenerateRuntimeSchema) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *GenerateRuntimeSchema) String() string {
  if p == nil {
    return "<nil>"
  }

  nameVal := fmt.Sprintf("%v", p.Name)
  return fmt.Sprintf("GenerateRuntimeSchema({Name:%s})", nameVal)
}

// Indicates that a field's value should never be stored on the stack, and that
// identical values can be shared in immutable contexts.
type InternBox struct {
}

func NewInternBox() *InternBox {
  return &InternBox{}
}

type InternBoxBuilder struct {
  obj *InternBox
}

func NewInternBoxBuilder() *InternBoxBuilder{
  return &InternBoxBuilder{
    obj: NewInternBox(),
  }
}

func (p InternBoxBuilder) Emit() *InternBox{
  return &InternBox{
  }
}

func (p *InternBox) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *InternBox) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("InternBox"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *InternBox) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("InternBox({})")
}

