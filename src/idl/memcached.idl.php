<?php
/**
 * Automatically generated by running "php schema.php memcached".
 *
 * You may modify the file, but re-running schema.php against this file will
 * standardize the format without losing your schema changes. It does lose
 * any changes that are not part of schema. Use "note" field to comment on
 * schema itself, and "note" fields are not used in any code generation but
 * only staying within this file.
 *
 * @nolint
 */
///////////////////////////////////////////////////////////////////////////////
// Preamble: C++ code inserted at beginning of ext_{name}.h

DefinePreamble(<<<CPP
#include <libmemcached/memcached.h>
CPP
);

///////////////////////////////////////////////////////////////////////////////
// Constants
//
// array (
//   'name' => name of the constant
//   'type' => type of the constant
//   'note' => additional note about this constant's schema
// )


///////////////////////////////////////////////////////////////////////////////
// Functions
//
// array (
//   'name'   => name of the function
//   'desc'   => description of the function's purpose
//   'flags'  => attributes of the function, see base.php for possible values
//   'opt'    => optimization callback function's name for compiler
//   'note'   => additional note about this function's schema
//   'return' =>
//      array (
//        'type'  => return type, use Reference for ref return
//        'desc'  => description of the return value
//      )
//   'args'   => arguments
//      array (
//        'name'  => name of the argument
//        'type'  => type of the argument, use Reference for output parameter
//        'value' => default value of the argument
//        'desc'  => description of the argument
//      )
// )


///////////////////////////////////////////////////////////////////////////////
// Classes
//
// BeginClass
// array (
//   'name'   => name of the class
//   'desc'   => description of the class's purpose
//   'flags'  => attributes of the class, see base.php for possible values
//   'note'   => additional note about this class's schema
//   'parent' => parent class name, if any
//   'ifaces' => array of interfaces tihs class implements
//   'bases'  => extra internal and special base classes this class requires
//   'footer' => extra C++ inserted at end of class declaration
// )
//
// DefineConstant(..)
// DefineConstant(..)
// ...
// DefineFunction(..)
// DefineFunction(..)
// ...
// DefineProperty
// DefineProperty
//
// array (
//   'name'  => name of the property
//   'type'  => type of the property
//   'flags' => attributes of the property
//   'desc'  => description of the property
//   'note'  => additional note about this property's schema
// )
//
// EndClass()

///////////////////////////////////////////////////////////////////////////////

BeginClass(
  array(
    'name'   => "Memcached",
    'bases'  => array('Sweepable'),
    'desc'   => "Represents a connection to a set of memcached servers.",
    'flags'  =>  HasDocComment,
    'footer' => <<<EOT

 private:
  class Impl {
  public:
    Impl();
    ~Impl();

    memcached_st memcached;
    bool compression;
    int serializer;
    int rescode;
  };
  typedef boost::shared_ptr<Impl> ImplPtr;
  ImplPtr m_impl;

  bool handleError(memcached_return status);
  void toPayload(CVarRef value, std::vector<char> &payload, uint32 &flags);
  bool toObject(Variant& value, const memcached_result_st &result);
  memcached_return doCacheCallback(CVarRef callback, CStrRef key,
                                   Variant& value);
  bool getMultiImpl(CStrRef server_key, CArrRef keys, bool enableCas,
                    Array *returnValue);
  bool fetchImpl(memcached_result_st &result, Array &item);
  typedef memcached_return_t (*SetOperation)(memcached_st *,
      const char *, size_t, const char *, size_t, const char *, size_t,
      time_t, uint32_t);
  bool setOperationImpl(SetOperation op, CStrRef server_key,
                        CStrRef key, CVarRef value, int expiration);
  typedef memcached_return_t (*IncDecOperation)(memcached_st *,
      const char *, size_t, uint32_t, uint64_t *);
  Variant incDecOperationImpl(IncDecOperation op, CStrRef key, int64 offset);

  typedef std::map<std::string, ImplPtr> ImplMap;
  static DECLARE_THREAD_LOCAL(ImplMap, s_persistentMap);
EOT
,
  ));

DefineConstant(
  array(
    'name'   => "OPT_COMPRESSION",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_SERIALIZER",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "SERIALIZER_PHP",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "SERIALIZER_IGBINARY",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "SERIALIZER_JSON",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_PREFIX_KEY",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_HASH",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "HASH_DEFAULT",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "HASH_MD5",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "HASH_CRC",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "HASH_FNV1_64",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "HASH_FNV1A_64",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "HASH_FNV1_32",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "HASH_FNV1A_32",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "HASH_HSIEH",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "HASH_MURMUR",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_DISTRIBUTION",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "DISTRIBUTION_MODULA",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "DISTRIBUTION_CONSISTENT",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_LIBKETAMA_COMPATIBLE",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_BUFFER_WRITES",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_BINARY_PROTOCOL",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_NO_BLOCK",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_TCP_NODELAY",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_SOCKET_SEND_SIZE",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_SOCKET_RECV_SIZE",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_CONNECT_TIMEOUT",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_RETRY_TIMEOUT",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_SEND_TIMEOUT",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_RECV_TIMEOUT",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_POLL_TIMEOUT",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_CACHE_LOOKUPS",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "OPT_SERVER_FAILURE_LIMIT",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "HAVE_IGBINARY",
    'type'   => Boolean,
  ));

DefineConstant(
  array(
    'name'   => "HAVE_JSON",
    'type'   => Boolean,
  ));

DefineConstant(
  array(
    'name'   => "GET_PRESERVE_ORDER",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_SUCCESS",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_FAILURE",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_HOST_LOOKUP_FAILURE",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_UNKNOWN_READ_FAILURE",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_PROTOCOL_ERROR",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_CLIENT_ERROR",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_SERVER_ERROR",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_WRITE_FAILURE",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_DATA_EXISTS",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_NOTSTORED",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_NOTFOUND",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_PARTIAL_READ",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_SOME_ERRORS",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_NO_SERVERS",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_END",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_ERRNO",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_BUFFERED",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_TIMEOUT",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_BAD_KEY_PROVIDED",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_CONNECTION_SOCKET_CREATE_FAILURE",
    'type'   => Int32,
  ));

DefineConstant(
  array(
    'name'   => "RES_PAYLOAD_FAILURE",
    'type'   => Int32,
  ));

DefineFunction(
  array(
    'name'   => "__construct",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => null,
    ),
    'args'   => array(
      array(
        'name'   => "persistent_id",
        'type'   => String,
        'value'  => "null_string",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "add",
    'desc'   => "Memcached::add() is similar to Memcached::set(), but the operation fails if the key already exists on the server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTSTORED if the key already exists.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key under which to store the value.",
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
        'desc'   => "The value to store.",
      ),
      array(
        'name'   => "expiration",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The expiration time, defaults to 0. See Expiration Times for more info.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "addByKey",
    'desc'   => "Memcached::addByKey() is functionally equivalent to Memcached::add(), except that the free-form server_key can be used to map the key to a specific server. This is useful if you need to keep a bunch of related keys on a certain server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTSTORED if the key already exists.",
    ),
    'args'   => array(
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key under which to store the value.",
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
        'desc'   => "The value to store.",
      ),
      array(
        'name'   => "expiration",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The expiration time, defaults to 0. See Expiration Times for more info.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "addServer",
    'desc'   => "Memcached::addServer() adds the specified server to the server pool. No connection is established to the server at this time, but if you are using consistent key distribution option (via Memcached::DISTRIBUTION_CONSISTENT or Memcached::OPT_LIBKETAMA_COMPATIBLE), some of the internal data structures will have to be updated. Thus, if you need to add multiple servers, it is better to use Memcached::addServers() as the update then happens only once.\n\nThe same server may appear multiple times in the server pool, because no duplication checks are made. This is not advisable; instead, use the weight option to increase the selection weighting of this server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "host",
        'type'   => String,
        'desc'   => "The hostname of the memcache server. If the hostname is invalid, data-related operations will set Memcached::RES_HOST_LOOKUP_FAILURE result code.",
      ),
      array(
        'name'   => "port",
        'type'   => Int32,
        'desc'   => "The port on which memcache is running. Usually, this is 11211.",
      ),
      array(
        'name'   => "weight",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The weight of the server relative to the total weight of all the servers in the pool. This controls the probability of the server being selected for operations. This is used only with consistent distribution option and usually corresponds to the amount of memory available to memcache on that server.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "addServers",
    'desc'   => "Memcached::addServers() adds servers to the server pool. Each entry in servers is supposed to be an array containing hostname, port, and, optionally, weight of the server. No connection is established to the servers at this time.\n\nThe same server may appear multiple times in the server pool, because no duplication checks are made. This is not advisable; instead, use the weight option to increase the selection weighting of this server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "servers",
        'type'   => VariantVec,
        'desc'   => "Array of the servers to add to the pool.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "append",
    'desc'   => "Memcached::append() appends the given value string to the value of an existing item. The reason that value is forced to be a string is that appending mixed types is not well-defined.\n\nIf the Memcached::OPT_COMPRESSION is enabled, the operation will fail and a warning will be issued, because appending compressed data to a value that is potentially already compressed is not possible.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTSTORED if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key under which to store the value.",
      ),
      array(
        'name'   => "value",
        'type'   => String,
        'desc'   => "The string to append.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "appendByKey",
    'desc'   => "Memcached::appendByKey() is functionally equivalent to Memcached::append(), except that the free-form server_key can be used to map the key to a specific server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTSTORED if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key under which to store the value.",
      ),
      array(
        'name'   => "value",
        'type'   => String,
        'desc'   => "The string to append.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "cas",
    'desc'   => "Memcached::cas() performs a \"check and set\" operation, so that the item will be stored only if no other client has updated it since it was last fetched by this client. The check is done via the cas_token parameter which is a unique 64-bit value assigned to the existing item by memcache. See the documentation for Memcached::get*() methods for how to obtain this token. Note that the token is represented as a double due to the limitations of PHP's integer space.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_DATA_EXISTS if the item you are trying to store has been modified since you last fetched it.",
    ),
    'args'   => array(
      array(
        'name'   => "cas_token",
        'type'   => Double,
        'desc'   => "Unique value associated with the existing item. Generated by memcache.",
      ),
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key under which to store the value.",
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
        'desc'   => "The value to store.",
      ),
      array(
        'name'   => "expiration",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The expiration time, defaults to 0. See Expiration Times for more info.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "casByKey",
    'desc'   => "Memcached::casByKey() is functionally equivalent to Memcached::cas(), except that the free-form server_key can be used to map the key to a specific server. This is useful if you need to keep a bunch of related keys on a certain server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_DATA_EXISTS if the item you are trying to store has been modified since you last fetched it.",
    ),
    'args'   => array(
      array(
        'name'   => "cas_token",
        'type'   => Double,
        'desc'   => "Unique value associated with the existing item. Generated by memcache.",
      ),
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key under which to store the value.",
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
        'desc'   => "The value to store.",
      ),
      array(
        'name'   => "expiration",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The expiration time, defaults to 0. See Expiration Times for more info.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "decrement",
    'desc'   => "Memcached::decrement() decrements a numeric item's value by the specified offset. If the item's value is not numeric, it is treated as if the value were 0. If the operation would decrease the value below 0, the new value will be 0. Memcached::decrement() will fail if the item does not exist.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns item's new value on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTFOUND if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key of the item to decrement.",
      ),
      array(
        'name'   => "offset",
        'type'   => Int64,
        'value'  => "1",
        'desc'   => "The amount by which to decrement the item's value.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "delete",
    'desc'   => "Memcached::delete() deletes the key from the server. The time parameter is the amount of time in seconds (or Unix time until which) the client wishes the server to refuse add and replace commands for this key. For this amount of time, the item is put into a delete queue, which means that it won't possible to retrieve it by the get command, but add and replace command with this key will also fail (the set command will succeed, however). After the time passes, the item is finally deleted from server memory. The parameter time defaults to 0 (which means that the item will be deleted immediately and further storage commands with this key will succeed).",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTFOUND if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key to be deleted.",
      ),
      array(
        'name'   => "time",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The amount of time the server will wait to delete the item.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "deleteByKey",
    'desc'   => "Memcached::deleteByKey() is functionally equivalent to Memcached::delete(), except that the free-form server_key can be used to map the key to a specific server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTFOUND if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key to be deleted.",
      ),
      array(
        'name'   => "time",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The amount of time the server will wait to delete the item.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "fetch",
    'desc'   => "Memcached::fetch() retrieves the next result from the last request.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the next result or FALSE otherwise. The Memcached::getResultCode() will return Memcached::RES_END if result set is exhausted.",
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_ALL",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "fetchAll",
    'desc'   => "Memcached::fetchAll() retrieves all the remaining results from the last request.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the results or FALSE on failure. Use Memcached::getResultCode() if necessary.",
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_ALL",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "flush",
    'desc'   => "Memcached::flush() invalidates all existing cache items immediately (by default) or after the delay specified. After invalidation none of the items will be returned in response to a retrieval command (unless it's stored again under the same key after Memcached::flush() has invalidated the items). The flush does not actually free all the memory taken up by the existing items; that will happen gradually as new items are stored.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. Use Memcached::getResultCode() if necessary.",
    ),
    'args'   => array(
      array(
        'name'   => "delay",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "Numer of seconds to wait before invalidating the items.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "get",
    'desc'   => "Memcached::get() returns the item that was previously stored under the key. If the item is found and cas_token variable is provided, it will contain the CAS token value for the item. See Memcached::cas() for how to use CAS tokens. Read-through caching callback may be specified via cache_cb parameter.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the value stored in the cache or FALSE otherwise. The Memcached::getResultCode() will return Memcached::RES_NOTFOUND if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key of the item to retrieve.",
      ),
      array(
        'name'   => "cache_cb",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "Read-through caching callback or NULL.",
      ),
      array(
        'name'   => "cas_token",
        'type'   => Variant | Reference,
        'value'  => "null_variant",
        'desc'   => "The variable to store the CAS token in.",
      ),
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_ALL",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "getByKey",
    'desc'   => "Memcached::getByKey() is functionally equivalent to Memcached::get(), except that the free-form server_key can be used to map the key to a specific server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the value stored in the cache or FALSE otherwise. The Memcached::getResultCode() will return Memcached::RES_NOTFOUND if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key of the item to fetch.",
      ),
      array(
        'name'   => "cache_cb",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "Read-through caching callback or NULL",
      ),
      array(
        'name'   => "cas_token",
        'type'   => Variant | Reference,
        'value'  => "null_variant",
        'desc'   => "The variable to store the CAS token in.",
      ),
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_ALL",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "getDelayed",
    'desc'   => "Memcached::getDelayed() issues a request to memcache for multiple items the keys of which are specified in the keys array. The method does not wait for response and returns right away. When you are ready to collect the items, call either Memcached::fetch() or Memcached::fetchAll(). If with_cas is true, the CAS token values will also be requested.\n\nInstead of fetching the results explicitly, you can specify a result callback via value_cb parameter.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. Use Memcached::getResultCode() if necessary.",
    ),
    'args'   => array(
      array(
        'name'   => "keys",
        'type'   => StringVec,
        'desc'   => "Array of keys to request.",
      ),
      array(
        'name'   => "with_cas",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Whether to request CAS token values also.",
      ),
      array(
        'name'   => "value_cb",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "The result callback or NULL.",
      ),
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_ALL",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "getDelayedByKey",
    'desc'   => "Memcached::getDelayedByKey() is functionally equivalent to Memcached::getDelayed(), except that the free-form server_key can be used to map the keys to a specific server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. Use Memcached::getResultCode() if necessary.",
    ),
    'args'   => array(
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
      array(
        'name'   => "keys",
        'type'   => StringVec,
        'desc'   => "Array of keys to request.",
      ),
      array(
        'name'   => "with_cas",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Whether to request CAS token values also.",
      ),
      array(
        'name'   => "value_cb",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "The result callback or NULL.",
      ),
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_ALL",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "getMulti",
    'desc'   => "Memcached::getMulti() is similar to Memcached::get(), but instead of a single key item, it retrieves multiple items the keys of which are specified in the keys array. If cas_tokens variable is provided, it is filled with the CAS token values for the found items.\n\nUnlike Memcached::get() it is not possible to specify a read-through cache callback for Memcached::getMulti(), because the memcache protocol does not provide information on which keys were not found in the multi-key request.\n\nThe flags parameter can be used to specify additional options for Memcached::getMulti(). Currently, the only available option is Memcached::GET_PRESERVE_ORDER that ensures that the keys are returned in the same order as they were requested in.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the array of found items or FALSE on failure. Use Memcached::getResultCode() if necessary.",
    ),
    'args'   => array(
      array(
        'name'   => "keys",
        'type'   => StringVec,
        'desc'   => "Array of keys to retrieve.",
      ),
      array(
        'name'   => "cas_tokens",
        'type'   => Variant | Reference,
        'value'  => "null_variant",
        'desc'   => "The variable to store the CAS tokens for the found items.",
      ),
      array(
        'name'   => "flags",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The flags for the get operation.",
      ),
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_ALL",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "getMultiByKey",
    'desc'   => "Memcached::getMultiByKey() is functionally equivalent to Memcached::getMulti(), except that the free-form server_key can be used to map the keys to a specific server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the array of found items or FALSE on failure. Use Memcached::getResultCode() if necessary.",
    ),
    'args'   => array(
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
      array(
        'name'   => "keys",
        'type'   => StringVec,
        'desc'   => "Array of keys to retrieve.",
      ),
      array(
        'name'   => "cas_tokens",
        'type'   => Variant | Reference,
        'value'  => "null_variant",
        'desc'   => "The variable to store the CAS tokens for the found items.",
      ),
      array(
        'name'   => "flags",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The flags for the get operation.",
      ),
    ),
    'taint_observer' => array(
      'set_mask'   => "TAINT_BIT_ALL",
      'clear_mask' => "TAINT_BIT_NONE",
    ),
  ));

DefineFunction(
  array(
    'name'   => "getOption",
    'desc'   => "This method returns the value of a Memcached option. Some options correspond to the ones defined by libmemcached, and some are specific to the extension. See Memcached Constants for more information.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the value of the requested option, or FALSE on error.",
    ),
    'args'   => array(
      array(
        'name'   => "option",
        'type'   => Int32,
        'desc'   => "One of the Memcached::OPT_* constants.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "getResultCode",
    'desc'   => "Memcached::getResultCode() returns one of the Memcached::RES_* constants that is the result of the last executed Memcached method.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int32,
      'desc'   => "Result code of the last Memcached operation.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "getResultMessage",
    'desc'   => "Memcached::getResultMessage() returns a string that describes the result code of the last executed Memcached method.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "Message describing the result of the last Memcached operation.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "getServerByKey",
    'desc'   => "Memcached::getServerByKey() returns the server that would be selected by a particular server_key in all the Memcached::*ByKey() operations.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns TRUE on success or FALSE on failure. Use Memcached::getResultCode() if necessary.",
    ),
    'args'   => array(
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "getServerList",
    'desc'   => "Memcached::getServerList() returns the list of all servers that are in its server pool.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => VariantVec,
      'desc'   => "The list of all servers in the server pool.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "getStats",
    'desc'   => "Memcached::getStats() returns an array containing the state of all available memcache servers. See ï¿½ memcache protocol specification for details on these statistics.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Array of server statistics, one entry per server.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "getVersion",
    'desc'   => "Memcached::getVersion() returns an array containing the version info for all available memcache servers.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Array of server versions, one entry per server.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "increment",
    'desc'   => "Memcached::increment() increments a numeric item's value by the specified offset. If the item's value is not numeric, it is treated as if the value were 0. Memcached::increment() will fail if the item does not exist.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns new item's value on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTFOUND if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key of the item to increment.",
      ),
      array(
        'name'   => "offset",
        'type'   => Int64,
        'value'  => "1",
        'desc'   => "The amount by which to increment the item's value.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "prepend",
    'desc'   => "Memcached::prepend() prepends the given value string to the value of an existing item. The reason that value is forced to be a string is that prepending mixed types is not well-defined.\n\nIf the Memcached::OPT_COMPRESSION is enabled, the operation will fail and a warning will be issued, because prepending compressed data to a value that is potentially already compressed is not possible.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTSTORED if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key of the item to prepend the data to.",
      ),
      array(
        'name'   => "value",
        'type'   => String,
        'desc'   => "The string to prepend.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "prependByKey",
    'desc'   => "Memcached::prependByKey() is functionally equivalent to Memcached::prepend(), except that the free-form server_key can be used to map the key to a specific server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTSTORED if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key of the item to prepend the data to.",
      ),
      array(
        'name'   => "value",
        'type'   => String,
        'desc'   => "The string to prepend.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "replace",
    'desc'   => "Memcached::replace() is similar to Memcached::set(), but the operation fails if the key does not exist on the server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTSTORED if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key under which to store the value.",
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
        'desc'   => "The value to store.",
      ),
      array(
        'name'   => "expiration",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The expiration time, defaults to 0. See Expiration Times for more info.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "replaceByKey",
    'desc'   => "Memcached::replaceByKey() is functionally equivalent to Memcached::replace(), except that the free-form server_key can be used to map the key to a specific server. This is useful if you need to keep a bunch of related keys on a certain server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. The Memcached::getResultCode() will return Memcached::RES_NOTSTORED if the key does not exist.",
    ),
    'args'   => array(
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key under which to store the value.",
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
        'desc'   => "The value to store.",
      ),
      array(
        'name'   => "expiration",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The expiration time, defaults to 0. See Expiration Times for more info.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "set",
    'desc'   => "Memcached::set() stores the value on a memcache server under the specified key. The expiration parameter can be used to control when the value is considered expired.\n\nThe value can be any valid PHP type except for resources, because those cannot be represented in a serialized form. If the Memcached::OPT_COMPRESSION option is turned on, the serialized value will also be compressed before storage.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. Use Memcached::getResultCode() if necessary.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key under which to store the value.",
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
        'desc'   => "The value to store.",
      ),
      array(
        'name'   => "expiration",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The expiration time, defaults to 0. See Expiration Times for more info.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "setByKey",
    'desc'   => "Memcached::setByKey() is functionally equivalent to Memcached::set(), except that the free-form server_key can be used to map the key to a specific server. This is useful if you need to keep a bunch of related keys on a certain server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. Use Memcached::getResultCode() if necessary.",
    ),
    'args'   => array(
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
      array(
        'name'   => "key",
        'type'   => String,
        'desc'   => "The key under which to store the value.",
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
        'desc'   => "The value to store.",
      ),
      array(
        'name'   => "expiration",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The expiration time, defaults to 0. See Expiration Times for more info.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "setMulti",
    'desc'   => "Memcached::setMulti() is similar to Memcached::set(), but instead of a single key/value item, it works on multiple items specified in items. The expiration time applies to all the items at once.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. Use Memcached::getResultCode() if necessary.",
    ),
    'args'   => array(
      array(
        'name'   => "items",
        'type'   => VariantMap,
        'desc'   => "An array of key/value pairs to store on the server.",
      ),
      array(
        'name'   => "expiration",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The expiration time, defaults to 0. See Expiration Times for more info.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "setMultiByKey",
    'desc'   => "Memcached::setMultiByKey() is functionally equivalent to Memcached::setMulti(), except that the free-form server_key can be used to map the keys from items to a specific server. This is useful if you need to keep a bunch of related keys on a certain server.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. Use Memcached::getResultCode() if necessary.",
    ),
    'args'   => array(
      array(
        'name'   => "server_key",
        'type'   => String,
        'desc'   => "The key identifying the server to store the value on.",
      ),
      array(
        'name'   => "items",
        'type'   => VariantMap,
        'desc'   => "An array of key/value pairs to store on the server.",
      ),
      array(
        'name'   => "expiration",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The expiration time, defaults to 0. See Expiration Times for more info.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "setOption",
    'desc'   => "This method sets the value of a Memcached option. Some options correspond to the ones defined by libmemcached, and some are specific to the extension. See Memcached Constants for more information.\n\nThe options listed below require values specified via constants.\n\nMemcached::OPT_HASH requires Memcached::HASH_* values.\n\nMemcached::OPT_DISTRIBUTION requires Memcached::DISTRIBUTION_* values.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "option",
        'type'   => Int32,
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "__destruct",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
  ));

EndClass(
);
