#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/types/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import thrift.py3.types
import importlib
from collections.abc import Sequence

"""
    This is a helper module to define py3 container types.
    All types defined here are re-exported in the parent `.types` module.
    Only `import` types defined here via the parent `.types` module.
    If you `import` them directly from here, you will get nasty import errors.
"""

import apache.thrift.fixtures.types.module.types as _apache_thrift_fixtures_types_module_types
import apache.thrift.fixtures.types.included.types as _apache_thrift_fixtures_types_included_types

def get_types_reflection():
    return importlib.import_module(
        "apache.thrift.fixtures.types.module.types_reflection"
    )

__all__ = []

class List__i64(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i64):
            _py_obj = list(items)
        elif items:
            check_method = List__i64.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, List__i64)

    @staticmethod
    def check_container_item(item:object):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i64()


Sequence.register(List__i64)
__all__.append('List__i64')

class List__i32(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i32):
            _py_obj = list(items)
        elif items:
            check_method = List__i32.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, List__i32)

    @staticmethod
    def check_container_item(item:object):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i32()


Sequence.register(List__i32)
__all__.append('List__i32')

class std_list__List__i32(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, std_list__List__i32):
            _py_obj = list(items)
        elif items:
            check_method = std_list__List__i32.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, std_list__List__i32)

    @staticmethod
    def check_container_item(item:object):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_list__List__i32()


Sequence.register(std_list__List__i32)
__all__.append('std_list__List__i32')

class std_deque__List__i32(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, std_deque__List__i32):
            _py_obj = list(items)
        elif items:
            check_method = std_deque__List__i32.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, std_deque__List__i32)

    @staticmethod
    def check_container_item(item:object):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_deque__List__i32()


Sequence.register(std_deque__List__i32)
__all__.append('std_deque__List__i32')

class folly_fbvector__List__i32(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_fbvector__List__i32):
            _py_obj = list(items)
        elif items:
            check_method = folly_fbvector__List__i32.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, folly_fbvector__List__i32)

    @staticmethod
    def check_container_item(item:object):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_fbvector__List__i32()


Sequence.register(folly_fbvector__List__i32)
__all__.append('folly_fbvector__List__i32')

class folly_small_vector__List__i32(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_small_vector__List__i32):
            _py_obj = list(items)
        elif items:
            check_method = folly_small_vector__List__i32.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, folly_small_vector__List__i32)

    @staticmethod
    def check_container_item(item:object):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_small_vector__List__i32()


Sequence.register(folly_small_vector__List__i32)
__all__.append('folly_small_vector__List__i32')

class std_list_int32_t__List__i32(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, std_list_int32_t__List__i32):
            _py_obj = list(items)
        elif items:
            check_method = std_list_int32_t__List__i32.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, std_list_int32_t__List__i32)

    @staticmethod
    def check_container_item(item:object):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_list_int32_t__List__i32()


Sequence.register(std_list_int32_t__List__i32)
__all__.append('std_list_int32_t__List__i32')

class List__std_unordered_map__Map__i32_string(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__std_unordered_map__Map__i32_string):
            _py_obj = list(items)
        elif items:
            check_method = List__std_unordered_map__Map__i32_string.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, List__std_unordered_map__Map__i32_string)

    @staticmethod
    def check_container_item(item:object):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[int, str]")
        if not isinstance(item, _apache_thrift_fixtures_types_module_types.std_unordered_map__Map__i32_string):
            item = _apache_thrift_fixtures_types_module_types.std_unordered_map__Map__i32_string(item)
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__std_unordered_map__Map__i32_string()


Sequence.register(List__std_unordered_map__Map__i32_string)
__all__.append('List__std_unordered_map__Map__i32_string')

class _std_list__List__IncompleteListDep(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, _std_list__List__IncompleteListDep):
            _py_obj = list(items)
        elif items:
            check_method = _std_list__List__IncompleteListDep.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, _std_list__List__IncompleteListDep)

    @staticmethod
    def check_container_item(item:object):
        if not (
            isinstance(item, _apache_thrift_fixtures_types_module_types.IncompleteListDep)
        ):
            raise TypeError(f"{item!r} is not of type _apache_thrift_fixtures_types_module_types.IncompleteListDep")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___std_list__List__IncompleteListDep()


Sequence.register(_std_list__List__IncompleteListDep)
__all__.append('_std_list__List__IncompleteListDep')

class folly_small_vector__List__CompleteListDep(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_small_vector__List__CompleteListDep):
            _py_obj = list(items)
        elif items:
            check_method = folly_small_vector__List__CompleteListDep.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, folly_small_vector__List__CompleteListDep)

    @staticmethod
    def check_container_item(item:object):
        if not (
            isinstance(item, _apache_thrift_fixtures_types_module_types.CompleteListDep)
        ):
            raise TypeError(f"{item!r} is not of type _apache_thrift_fixtures_types_module_types.CompleteListDep")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_small_vector__List__CompleteListDep()


Sequence.register(folly_small_vector__List__CompleteListDep)
__all__.append('folly_small_vector__List__CompleteListDep')

class List__AdaptedListDep(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__AdaptedListDep):
            _py_obj = list(items)
        elif items:
            check_method = List__AdaptedListDep.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, List__AdaptedListDep)

    @staticmethod
    def check_container_item(item:object):
        if not (
            isinstance(item, _apache_thrift_fixtures_types_module_types.AdaptedListDep)
        ):
            raise TypeError(f"{item!r} is not of type _apache_thrift_fixtures_types_module_types.AdaptedListDep")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__AdaptedListDep()


Sequence.register(List__AdaptedListDep)
__all__.append('List__AdaptedListDep')

class List__DependentAdaptedListDep(thrift.py3.types.List):
    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__DependentAdaptedListDep):
            _py_obj = list(items)
        elif items:
            check_method = List__DependentAdaptedListDep.check_container_item
            _py_obj = [check_method(item) for item in items]
        else:
            _py_obj = []

        super().__init__(_py_obj, List__DependentAdaptedListDep)

    @staticmethod
    def check_container_item(item:object):
        if not (
            isinstance(item, _apache_thrift_fixtures_types_module_types.DependentAdaptedListDep)
        ):
            raise TypeError(f"{item!r} is not of type _apache_thrift_fixtures_types_module_types.DependentAdaptedListDep")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__DependentAdaptedListDep()


Sequence.register(List__DependentAdaptedListDep)
__all__.append('List__DependentAdaptedListDep')

