/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/python_capi/src/containers.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "thrift/compiler/test/fixtures/python_capi/gen-cpp2/containers_types.h"
#include "thrift/compiler/test/fixtures/python_capi/gen-cpp2/containers_types_custom_protocol.h"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/python_capi/gen-cpp2/containers_data.h"
[[maybe_unused]] static constexpr std::string_view kModuleName = "containers";


#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test::fixtures::python_capi::TemplateLists>::translateFieldName(
    std::string_view _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test::fixtures::python_capi::TemplateLists>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache
#endif


namespace test::fixtures::python_capi {

std::string_view TemplateLists::__fbthrift_thrift_uri() {
  return "test.dev/fixtures/python_capi/TemplateLists";
}

std::string_view TemplateLists::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<TemplateLists>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view TemplateLists::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<TemplateLists>::name;
}

TemplateLists::TemplateLists(const TemplateLists&) = default;
TemplateLists& TemplateLists::operator=(const TemplateLists&) = default;
TemplateLists::TemplateLists() {
}


TemplateLists::~TemplateLists() {}

TemplateLists::TemplateLists([[maybe_unused]] TemplateLists&& other) noexcept :
    __fbthrift_field_std_string(std::move(other.__fbthrift_field_std_string)),
    __fbthrift_field_deque_string(std::move(other.__fbthrift_field_deque_string)),
    __fbthrift_field_small_vector_iobuf(std::move(other.__fbthrift_field_small_vector_iobuf)),
    __fbthrift_field_nested_small_vector(std::move(other.__fbthrift_field_nested_small_vector)),
    __fbthrift_field_small_vector_tensor(std::move(other.__fbthrift_field_small_vector_tensor)),
    __isset(other.__isset) {
}

TemplateLists& TemplateLists::operator=([[maybe_unused]] TemplateLists&& other) noexcept {
    this->__fbthrift_field_std_string = std::move(other.__fbthrift_field_std_string);
    this->__fbthrift_field_deque_string = std::move(other.__fbthrift_field_deque_string);
    this->__fbthrift_field_small_vector_iobuf = std::move(other.__fbthrift_field_small_vector_iobuf);
    this->__fbthrift_field_nested_small_vector = std::move(other.__fbthrift_field_nested_small_vector);
    this->__fbthrift_field_small_vector_tensor = std::move(other.__fbthrift_field_small_vector_tensor);
    __isset = other.__isset;
    return *this;
}


TemplateLists::TemplateLists(apache::thrift::FragileConstructor, std::vector<::std::string> std_string__arg, std::deque<::std::string> deque_string__arg, ::test::fixtures::python_capi::small_vector_iobuf small_vector_iobuf__arg, folly::small_vector<::test::fixtures::python_capi::fbvector_string> nested_small_vector__arg, folly::fbvector<::test::fixtures::python_capi::fbvector_fbvector_string> small_vector_tensor__arg) :
    __fbthrift_field_std_string(std::move(std_string__arg)),
    __fbthrift_field_deque_string(std::move(deque_string__arg)),
    __fbthrift_field_small_vector_iobuf(std::move(small_vector_iobuf__arg)),
    __fbthrift_field_nested_small_vector(std::move(nested_small_vector__arg)),
    __fbthrift_field_small_vector_tensor(std::move(small_vector_tensor__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
}

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION
#endif

void TemplateLists::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_std_string.clear();
  this->__fbthrift_field_deque_string.clear();
  this->__fbthrift_field_small_vector_iobuf.clear();
  this->__fbthrift_field_nested_small_vector.clear();
  this->__fbthrift_field_small_vector_tensor.clear();
  __isset = {};
}

void TemplateLists::__fbthrift_clear_terse_fields() {
}

bool TemplateLists::__fbthrift_is_empty() const {
  return false;
}




const std::vector<::std::string>* TemplateLists::get_std_string() const& {
  return std_string_ref().has_value() ? std::addressof(__fbthrift_field_std_string) : nullptr;
}

std::vector<::std::string>* TemplateLists::get_std_string() & {
  return std_string_ref().has_value() ? std::addressof(__fbthrift_field_std_string) : nullptr;
}

const std::deque<::std::string>& TemplateLists::get_deque_string() const& {
  return __fbthrift_field_deque_string;
}

std::deque<::std::string> TemplateLists::get_deque_string() && {
  return static_cast<std::deque<::std::string>&&>(__fbthrift_field_deque_string);
}

const ::test::fixtures::python_capi::small_vector_iobuf& TemplateLists::get_small_vector_iobuf() const& {
  return __fbthrift_field_small_vector_iobuf;
}

::test::fixtures::python_capi::small_vector_iobuf TemplateLists::get_small_vector_iobuf() && {
  return static_cast<::test::fixtures::python_capi::small_vector_iobuf&&>(__fbthrift_field_small_vector_iobuf);
}

const folly::small_vector<::test::fixtures::python_capi::fbvector_string>& TemplateLists::get_nested_small_vector() const& {
  return __fbthrift_field_nested_small_vector;
}

folly::small_vector<::test::fixtures::python_capi::fbvector_string> TemplateLists::get_nested_small_vector() && {
  return static_cast<folly::small_vector<::test::fixtures::python_capi::fbvector_string>&&>(__fbthrift_field_nested_small_vector);
}

const folly::fbvector<::test::fixtures::python_capi::fbvector_fbvector_string>& TemplateLists::get_small_vector_tensor() const& {
  return __fbthrift_field_small_vector_tensor;
}

folly::fbvector<::test::fixtures::python_capi::fbvector_fbvector_string> TemplateLists::get_small_vector_tensor() && {
  return static_cast<folly::fbvector<::test::fixtures::python_capi::fbvector_fbvector_string>&&>(__fbthrift_field_small_vector_tensor);
}

void swap([[maybe_unused]] TemplateLists& a, [[maybe_unused]] TemplateLists& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_std_string, b.__fbthrift_field_std_string);
  swap(a.__fbthrift_field_deque_string, b.__fbthrift_field_deque_string);
  swap(a.__fbthrift_field_small_vector_iobuf, b.__fbthrift_field_small_vector_iobuf);
  swap(a.__fbthrift_field_nested_small_vector, b.__fbthrift_field_nested_small_vector);
  swap(a.__fbthrift_field_small_vector_tensor, b.__fbthrift_field_small_vector_tensor);
  swap(a.__isset, b.__isset);
}



} // namespace test::fixtures::python_capi

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test::fixtures::python_capi::TemplateSets>::translateFieldName(
    std::string_view _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test::fixtures::python_capi::TemplateSets>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache
#endif


namespace test::fixtures::python_capi {

std::string_view TemplateSets::__fbthrift_thrift_uri() {
  return "test.dev/fixtures/python_capi/TemplateSets";
}

std::string_view TemplateSets::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<TemplateSets>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view TemplateSets::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<TemplateSets>::name;
}

TemplateSets::TemplateSets(const TemplateSets&) = default;
TemplateSets& TemplateSets::operator=(const TemplateSets&) = default;
TemplateSets::TemplateSets() {
}


TemplateSets::~TemplateSets() {}

TemplateSets::TemplateSets([[maybe_unused]] TemplateSets&& other) noexcept :
    __fbthrift_field_std_set(std::move(other.__fbthrift_field_std_set)),
    __fbthrift_field_std_unordered(std::move(other.__fbthrift_field_std_unordered)),
    __fbthrift_field_folly_fast(std::move(other.__fbthrift_field_folly_fast)),
    __fbthrift_field_folly_node(std::move(other.__fbthrift_field_folly_node)),
    __fbthrift_field_folly_value(std::move(other.__fbthrift_field_folly_value)),
    __fbthrift_field_folly_vector(std::move(other.__fbthrift_field_folly_vector)),
    __fbthrift_field_folly_sorted_vector(std::move(other.__fbthrift_field_folly_sorted_vector)),
    __isset(other.__isset) {
}

TemplateSets& TemplateSets::operator=([[maybe_unused]] TemplateSets&& other) noexcept {
    this->__fbthrift_field_std_set = std::move(other.__fbthrift_field_std_set);
    this->__fbthrift_field_std_unordered = std::move(other.__fbthrift_field_std_unordered);
    this->__fbthrift_field_folly_fast = std::move(other.__fbthrift_field_folly_fast);
    this->__fbthrift_field_folly_node = std::move(other.__fbthrift_field_folly_node);
    this->__fbthrift_field_folly_value = std::move(other.__fbthrift_field_folly_value);
    this->__fbthrift_field_folly_vector = std::move(other.__fbthrift_field_folly_vector);
    this->__fbthrift_field_folly_sorted_vector = std::move(other.__fbthrift_field_folly_sorted_vector);
    __isset = other.__isset;
    return *this;
}


TemplateSets::TemplateSets(apache::thrift::FragileConstructor, std::set<::std::string> std_set__arg, std::unordered_set<::std::string> std_unordered__arg, folly::F14FastSet<::std::string> folly_fast__arg, folly::F14NodeSet<::std::string> folly_node__arg, folly::F14ValueSet<::std::string> folly_value__arg, folly::F14VectorSet<::std::string> folly_vector__arg, folly::sorted_vector_set<::std::string> folly_sorted_vector__arg) :
    __fbthrift_field_std_set(std::move(std_set__arg)),
    __fbthrift_field_std_unordered(std::move(std_unordered__arg)),
    __fbthrift_field_folly_fast(std::move(folly_fast__arg)),
    __fbthrift_field_folly_node(std::move(folly_node__arg)),
    __fbthrift_field_folly_value(std::move(folly_value__arg)),
    __fbthrift_field_folly_vector(std::move(folly_vector__arg)),
    __fbthrift_field_folly_sorted_vector(std::move(folly_sorted_vector__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
}

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION
#endif

void TemplateSets::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_std_set.clear();
  this->__fbthrift_field_std_unordered.clear();
  this->__fbthrift_field_folly_fast.clear();
  this->__fbthrift_field_folly_node.clear();
  this->__fbthrift_field_folly_value.clear();
  this->__fbthrift_field_folly_vector.clear();
  this->__fbthrift_field_folly_sorted_vector.clear();
  __isset = {};
}

void TemplateSets::__fbthrift_clear_terse_fields() {
}

bool TemplateSets::__fbthrift_is_empty() const {
  return false;
}

bool TemplateSets::operator==([[maybe_unused]] const TemplateSets& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool TemplateSets::operator<([[maybe_unused]] const TemplateSets& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const std::set<::std::string>& TemplateSets::get_std_set() const& {
  return __fbthrift_field_std_set;
}

std::set<::std::string> TemplateSets::get_std_set() && {
  return static_cast<std::set<::std::string>&&>(__fbthrift_field_std_set);
}

const std::unordered_set<::std::string>& TemplateSets::get_std_unordered() const& {
  return __fbthrift_field_std_unordered;
}

std::unordered_set<::std::string> TemplateSets::get_std_unordered() && {
  return static_cast<std::unordered_set<::std::string>&&>(__fbthrift_field_std_unordered);
}

const folly::F14FastSet<::std::string>& TemplateSets::get_folly_fast() const& {
  return __fbthrift_field_folly_fast;
}

folly::F14FastSet<::std::string> TemplateSets::get_folly_fast() && {
  return static_cast<folly::F14FastSet<::std::string>&&>(__fbthrift_field_folly_fast);
}

const folly::F14NodeSet<::std::string>& TemplateSets::get_folly_node() const& {
  return __fbthrift_field_folly_node;
}

folly::F14NodeSet<::std::string> TemplateSets::get_folly_node() && {
  return static_cast<folly::F14NodeSet<::std::string>&&>(__fbthrift_field_folly_node);
}

const folly::F14ValueSet<::std::string>& TemplateSets::get_folly_value() const& {
  return __fbthrift_field_folly_value;
}

folly::F14ValueSet<::std::string> TemplateSets::get_folly_value() && {
  return static_cast<folly::F14ValueSet<::std::string>&&>(__fbthrift_field_folly_value);
}

const folly::F14VectorSet<::std::string>& TemplateSets::get_folly_vector() const& {
  return __fbthrift_field_folly_vector;
}

folly::F14VectorSet<::std::string> TemplateSets::get_folly_vector() && {
  return static_cast<folly::F14VectorSet<::std::string>&&>(__fbthrift_field_folly_vector);
}

const folly::sorted_vector_set<::std::string>& TemplateSets::get_folly_sorted_vector() const& {
  return __fbthrift_field_folly_sorted_vector;
}

folly::sorted_vector_set<::std::string> TemplateSets::get_folly_sorted_vector() && {
  return static_cast<folly::sorted_vector_set<::std::string>&&>(__fbthrift_field_folly_sorted_vector);
}

void swap([[maybe_unused]] TemplateSets& a, [[maybe_unused]] TemplateSets& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_std_set, b.__fbthrift_field_std_set);
  swap(a.__fbthrift_field_std_unordered, b.__fbthrift_field_std_unordered);
  swap(a.__fbthrift_field_folly_fast, b.__fbthrift_field_folly_fast);
  swap(a.__fbthrift_field_folly_node, b.__fbthrift_field_folly_node);
  swap(a.__fbthrift_field_folly_value, b.__fbthrift_field_folly_value);
  swap(a.__fbthrift_field_folly_vector, b.__fbthrift_field_folly_vector);
  swap(a.__fbthrift_field_folly_sorted_vector, b.__fbthrift_field_folly_sorted_vector);
  swap(a.__isset, b.__isset);
}



} // namespace test::fixtures::python_capi

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test::fixtures::python_capi::TemplateMaps>::translateFieldName(
    std::string_view _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test::fixtures::python_capi::TemplateMaps>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache
#endif


namespace test::fixtures::python_capi {

std::string_view TemplateMaps::__fbthrift_thrift_uri() {
  return "test.dev/fixtures/python_capi/TemplateMaps";
}

std::string_view TemplateMaps::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<TemplateMaps>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view TemplateMaps::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<TemplateMaps>::name;
}

TemplateMaps::TemplateMaps(const TemplateMaps&) = default;
TemplateMaps& TemplateMaps::operator=(const TemplateMaps&) = default;
TemplateMaps::TemplateMaps() {
}


TemplateMaps::~TemplateMaps() {}

TemplateMaps::TemplateMaps([[maybe_unused]] TemplateMaps&& other) noexcept :
    __fbthrift_field_std_map(std::move(other.__fbthrift_field_std_map)),
    __fbthrift_field_std_unordered(std::move(other.__fbthrift_field_std_unordered)),
    __fbthrift_field_folly_fast(std::move(other.__fbthrift_field_folly_fast)),
    __fbthrift_field_folly_node(std::move(other.__fbthrift_field_folly_node)),
    __fbthrift_field_folly_value(std::move(other.__fbthrift_field_folly_value)),
    __fbthrift_field_folly_vector(std::move(other.__fbthrift_field_folly_vector)),
    __fbthrift_field_folly_sorted_vector(std::move(other.__fbthrift_field_folly_sorted_vector)),
    __isset(other.__isset) {
}

TemplateMaps& TemplateMaps::operator=([[maybe_unused]] TemplateMaps&& other) noexcept {
    this->__fbthrift_field_std_map = std::move(other.__fbthrift_field_std_map);
    this->__fbthrift_field_std_unordered = std::move(other.__fbthrift_field_std_unordered);
    this->__fbthrift_field_folly_fast = std::move(other.__fbthrift_field_folly_fast);
    this->__fbthrift_field_folly_node = std::move(other.__fbthrift_field_folly_node);
    this->__fbthrift_field_folly_value = std::move(other.__fbthrift_field_folly_value);
    this->__fbthrift_field_folly_vector = std::move(other.__fbthrift_field_folly_vector);
    this->__fbthrift_field_folly_sorted_vector = std::move(other.__fbthrift_field_folly_sorted_vector);
    __isset = other.__isset;
    return *this;
}


TemplateMaps::TemplateMaps(apache::thrift::FragileConstructor, std::map<::std::string, ::std::string> std_map__arg, std::unordered_map<::std::string, ::std::string> std_unordered__arg, folly::F14FastMap<::std::string, ::std::string> folly_fast__arg, folly::F14NodeMap<::std::string, ::std::string> folly_node__arg, folly::F14ValueMap<::std::string, ::std::string> folly_value__arg, folly::F14VectorMap<::std::string, ::std::string> folly_vector__arg, folly::sorted_vector_map<::std::string, ::std::string> folly_sorted_vector__arg) :
    __fbthrift_field_std_map(std::move(std_map__arg)),
    __fbthrift_field_std_unordered(std::move(std_unordered__arg)),
    __fbthrift_field_folly_fast(std::move(folly_fast__arg)),
    __fbthrift_field_folly_node(std::move(folly_node__arg)),
    __fbthrift_field_folly_value(std::move(folly_value__arg)),
    __fbthrift_field_folly_vector(std::move(folly_vector__arg)),
    __fbthrift_field_folly_sorted_vector(std::move(folly_sorted_vector__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
}

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION
#endif

void TemplateMaps::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_std_map.clear();
  this->__fbthrift_field_std_unordered.clear();
  this->__fbthrift_field_folly_fast.clear();
  this->__fbthrift_field_folly_node.clear();
  this->__fbthrift_field_folly_value.clear();
  this->__fbthrift_field_folly_vector.clear();
  this->__fbthrift_field_folly_sorted_vector.clear();
  __isset = {};
}

void TemplateMaps::__fbthrift_clear_terse_fields() {
}

bool TemplateMaps::__fbthrift_is_empty() const {
  return false;
}

bool TemplateMaps::operator==([[maybe_unused]] const TemplateMaps& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool TemplateMaps::operator<([[maybe_unused]] const TemplateMaps& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const std::map<::std::string, ::std::string>& TemplateMaps::get_std_map() const& {
  return __fbthrift_field_std_map;
}

std::map<::std::string, ::std::string> TemplateMaps::get_std_map() && {
  return static_cast<std::map<::std::string, ::std::string>&&>(__fbthrift_field_std_map);
}

const std::unordered_map<::std::string, ::std::string>& TemplateMaps::get_std_unordered() const& {
  return __fbthrift_field_std_unordered;
}

std::unordered_map<::std::string, ::std::string> TemplateMaps::get_std_unordered() && {
  return static_cast<std::unordered_map<::std::string, ::std::string>&&>(__fbthrift_field_std_unordered);
}

const folly::F14FastMap<::std::string, ::std::string>& TemplateMaps::get_folly_fast() const& {
  return __fbthrift_field_folly_fast;
}

folly::F14FastMap<::std::string, ::std::string> TemplateMaps::get_folly_fast() && {
  return static_cast<folly::F14FastMap<::std::string, ::std::string>&&>(__fbthrift_field_folly_fast);
}

const folly::F14NodeMap<::std::string, ::std::string>& TemplateMaps::get_folly_node() const& {
  return __fbthrift_field_folly_node;
}

folly::F14NodeMap<::std::string, ::std::string> TemplateMaps::get_folly_node() && {
  return static_cast<folly::F14NodeMap<::std::string, ::std::string>&&>(__fbthrift_field_folly_node);
}

const folly::F14ValueMap<::std::string, ::std::string>& TemplateMaps::get_folly_value() const& {
  return __fbthrift_field_folly_value;
}

folly::F14ValueMap<::std::string, ::std::string> TemplateMaps::get_folly_value() && {
  return static_cast<folly::F14ValueMap<::std::string, ::std::string>&&>(__fbthrift_field_folly_value);
}

const folly::F14VectorMap<::std::string, ::std::string>& TemplateMaps::get_folly_vector() const& {
  return __fbthrift_field_folly_vector;
}

folly::F14VectorMap<::std::string, ::std::string> TemplateMaps::get_folly_vector() && {
  return static_cast<folly::F14VectorMap<::std::string, ::std::string>&&>(__fbthrift_field_folly_vector);
}

const folly::sorted_vector_map<::std::string, ::std::string>& TemplateMaps::get_folly_sorted_vector() const& {
  return __fbthrift_field_folly_sorted_vector;
}

folly::sorted_vector_map<::std::string, ::std::string> TemplateMaps::get_folly_sorted_vector() && {
  return static_cast<folly::sorted_vector_map<::std::string, ::std::string>&&>(__fbthrift_field_folly_sorted_vector);
}

void swap([[maybe_unused]] TemplateMaps& a, [[maybe_unused]] TemplateMaps& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_std_map, b.__fbthrift_field_std_map);
  swap(a.__fbthrift_field_std_unordered, b.__fbthrift_field_std_unordered);
  swap(a.__fbthrift_field_folly_fast, b.__fbthrift_field_folly_fast);
  swap(a.__fbthrift_field_folly_node, b.__fbthrift_field_folly_node);
  swap(a.__fbthrift_field_folly_value, b.__fbthrift_field_folly_value);
  swap(a.__fbthrift_field_folly_vector, b.__fbthrift_field_folly_vector);
  swap(a.__fbthrift_field_folly_sorted_vector, b.__fbthrift_field_folly_sorted_vector);
  swap(a.__isset, b.__isset);
}



} // namespace test::fixtures::python_capi

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test::fixtures::python_capi::TWrapped>::translateFieldName(
    std::string_view _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test::fixtures::python_capi::TWrapped>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache
#endif


namespace test::fixtures::python_capi {

std::string_view TWrapped::__fbthrift_thrift_uri() {
  return "test.dev/fixtures/python_capi/TWrapped";
}

std::string_view TWrapped::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<TWrapped>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view TWrapped::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<TWrapped>::name;
}

TWrapped::TWrapped(const TWrapped&) = default;
TWrapped& TWrapped::operator=(const TWrapped&) = default;
TWrapped::TWrapped() {
}


TWrapped::~TWrapped() {}

TWrapped::TWrapped([[maybe_unused]] TWrapped&& other) noexcept :
    __fbthrift_field_fieldA(std::move(other.__fbthrift_field_fieldA)),
    __fbthrift_field_fieldB(std::move(other.__fbthrift_field_fieldB)),
    __isset(other.__isset) {
}

TWrapped& TWrapped::operator=([[maybe_unused]] TWrapped&& other) noexcept {
    this->__fbthrift_field_fieldA = std::move(other.__fbthrift_field_fieldA);
    this->__fbthrift_field_fieldB = std::move(other.__fbthrift_field_fieldB);
    __isset = other.__isset;
    return *this;
}


TWrapped::TWrapped(apache::thrift::FragileConstructor, ::std::string fieldA__arg, ::std::string fieldB__arg) :
    __fbthrift_field_fieldA(std::move(fieldA__arg)),
    __fbthrift_field_fieldB(std::move(fieldB__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION
#endif

void TWrapped::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_fieldA = apache::thrift::StringTraits<::std::string>::fromStringLiteral("");
  this->__fbthrift_field_fieldB = apache::thrift::StringTraits<::std::string>::fromStringLiteral("");
  __isset = {};
}

void TWrapped::__fbthrift_clear_terse_fields() {
}

bool TWrapped::__fbthrift_is_empty() const {
  return false;
}

bool TWrapped::operator==([[maybe_unused]] const TWrapped& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool TWrapped::operator<([[maybe_unused]] const TWrapped& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] TWrapped& a, [[maybe_unused]] TWrapped& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_fieldA, b.__fbthrift_field_fieldA);
  swap(a.__fbthrift_field_fieldB, b.__fbthrift_field_fieldB);
  swap(a.__isset, b.__isset);
}



} // namespace test::fixtures::python_capi

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test::fixtures::python_capi::IndirectionA>::translateFieldName(
    std::string_view _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test::fixtures::python_capi::IndirectionA>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache
#endif


namespace test::fixtures::python_capi {

std::string_view IndirectionA::__fbthrift_thrift_uri() {
  return "test.dev/fixtures/python_capi/IndirectionA";
}

std::string_view IndirectionA::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<IndirectionA>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view IndirectionA::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<IndirectionA>::name;
}

IndirectionA::IndirectionA(const IndirectionA&) = default;
IndirectionA& IndirectionA::operator=(const IndirectionA&) = default;
IndirectionA::IndirectionA() {
}


IndirectionA::~IndirectionA() {}

IndirectionA::IndirectionA([[maybe_unused]] IndirectionA&& other) noexcept :
    __fbthrift_field_lst(std::move(other.__fbthrift_field_lst)),
    __isset(other.__isset) {
}

IndirectionA& IndirectionA::operator=([[maybe_unused]] IndirectionA&& other) noexcept {
    this->__fbthrift_field_lst = std::move(other.__fbthrift_field_lst);
    __isset = other.__isset;
    return *this;
}


IndirectionA::IndirectionA(apache::thrift::FragileConstructor, ::test::fixtures::python_capi::ListOfWrapped lst__arg) :
    __fbthrift_field_lst(std::move(lst__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION
#endif

void IndirectionA::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_lst.clear();
  __isset = {};
}

void IndirectionA::__fbthrift_clear_terse_fields() {
}

bool IndirectionA::__fbthrift_is_empty() const {
  return false;
}

bool IndirectionA::operator==([[maybe_unused]] const IndirectionA& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool IndirectionA::operator<([[maybe_unused]] const IndirectionA& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::test::fixtures::python_capi::ListOfWrapped& IndirectionA::get_lst() const& {
  return __fbthrift_field_lst;
}

::test::fixtures::python_capi::ListOfWrapped IndirectionA::get_lst() && {
  return static_cast<::test::fixtures::python_capi::ListOfWrapped&&>(__fbthrift_field_lst);
}

void swap([[maybe_unused]] IndirectionA& a, [[maybe_unused]] IndirectionA& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_lst, b.__fbthrift_field_lst);
  swap(a.__isset, b.__isset);
}


static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IndirectionA,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::test::fixtures::python_capi::ListOfWrapped>,
    "inconsistent use of json option");

} // namespace test::fixtures::python_capi

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test::fixtures::python_capi::IndirectionB>::translateFieldName(
    std::string_view _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test::fixtures::python_capi::IndirectionB>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache
#endif


namespace test::fixtures::python_capi {

std::string_view IndirectionB::__fbthrift_thrift_uri() {
  return "test.dev/fixtures/python_capi/IndirectionB";
}

std::string_view IndirectionB::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<IndirectionB>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view IndirectionB::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<IndirectionB>::name;
}

IndirectionB::IndirectionB(const IndirectionB&) = default;
IndirectionB& IndirectionB::operator=(const IndirectionB&) = default;
IndirectionB::IndirectionB() {
}


IndirectionB::~IndirectionB() {}

IndirectionB::IndirectionB([[maybe_unused]] IndirectionB&& other) noexcept :
    __fbthrift_field_lst(std::move(other.__fbthrift_field_lst)),
    __isset(other.__isset) {
}

IndirectionB& IndirectionB::operator=([[maybe_unused]] IndirectionB&& other) noexcept {
    this->__fbthrift_field_lst = std::move(other.__fbthrift_field_lst);
    __isset = other.__isset;
    return *this;
}


IndirectionB::IndirectionB(apache::thrift::FragileConstructor, ::test::fixtures::python_capi::VecOfWrapped lst__arg) :
    __fbthrift_field_lst(std::move(lst__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION
#endif

void IndirectionB::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_lst.clear();
  __isset = {};
}

void IndirectionB::__fbthrift_clear_terse_fields() {
}

bool IndirectionB::__fbthrift_is_empty() const {
  return false;
}

bool IndirectionB::operator==([[maybe_unused]] const IndirectionB& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool IndirectionB::operator<([[maybe_unused]] const IndirectionB& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::test::fixtures::python_capi::VecOfWrapped& IndirectionB::get_lst() const& {
  return __fbthrift_field_lst;
}

::test::fixtures::python_capi::VecOfWrapped IndirectionB::get_lst() && {
  return static_cast<::test::fixtures::python_capi::VecOfWrapped&&>(__fbthrift_field_lst);
}

void swap([[maybe_unused]] IndirectionB& a, [[maybe_unused]] IndirectionB& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_lst, b.__fbthrift_field_lst);
  swap(a.__isset, b.__isset);
}


static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IndirectionB,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::test::fixtures::python_capi::VecOfWrapped>,
    "inconsistent use of json option");

} // namespace test::fixtures::python_capi

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test::fixtures::python_capi::IndirectionC>::translateFieldName(
    std::string_view _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test::fixtures::python_capi::IndirectionC>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache
#endif


namespace test::fixtures::python_capi {

std::string_view IndirectionC::__fbthrift_thrift_uri() {
  return "test.dev/fixtures/python_capi/IndirectionC";
}

std::string_view IndirectionC::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<IndirectionC>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view IndirectionC::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<IndirectionC>::name;
}

IndirectionC::IndirectionC(const IndirectionC&) = default;
IndirectionC& IndirectionC::operator=(const IndirectionC&) = default;
IndirectionC::IndirectionC() {
}


IndirectionC::~IndirectionC() {}

IndirectionC::IndirectionC([[maybe_unused]] IndirectionC&& other) noexcept :
    __fbthrift_field_lst(std::move(other.__fbthrift_field_lst)),
    __isset(other.__isset) {
}

IndirectionC& IndirectionC::operator=([[maybe_unused]] IndirectionC&& other) noexcept {
    this->__fbthrift_field_lst = std::move(other.__fbthrift_field_lst);
    __isset = other.__isset;
    return *this;
}


IndirectionC::IndirectionC(apache::thrift::FragileConstructor, ::test::fixtures::python_capi::ListOfWrappedAlias lst__arg) :
    __fbthrift_field_lst(std::move(lst__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION
#endif

void IndirectionC::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_lst.clear();
  __isset = {};
}

void IndirectionC::__fbthrift_clear_terse_fields() {
}

bool IndirectionC::__fbthrift_is_empty() const {
  return false;
}

bool IndirectionC::operator==([[maybe_unused]] const IndirectionC& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool IndirectionC::operator<([[maybe_unused]] const IndirectionC& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::test::fixtures::python_capi::ListOfWrappedAlias& IndirectionC::get_lst() const& {
  return __fbthrift_field_lst;
}

::test::fixtures::python_capi::ListOfWrappedAlias IndirectionC::get_lst() && {
  return static_cast<::test::fixtures::python_capi::ListOfWrappedAlias&&>(__fbthrift_field_lst);
}

void swap([[maybe_unused]] IndirectionC& a, [[maybe_unused]] IndirectionC& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_lst, b.__fbthrift_field_lst);
  swap(a.__isset, b.__isset);
}


static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IndirectionC,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::test::fixtures::python_capi::ListOfWrappedAlias>,
    "inconsistent use of json option");

} // namespace test::fixtures::python_capi

namespace test::fixtures::python_capi { namespace {
[[maybe_unused]] FOLLY_ERASE void validateAdapters() {
}
}} // namespace test::fixtures::python_capi
namespace apache::thrift::detail::annotation {
}
