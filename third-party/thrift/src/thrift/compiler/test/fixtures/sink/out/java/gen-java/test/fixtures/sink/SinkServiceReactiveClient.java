/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

package test.fixtures.sink;

import static com.facebook.swift.service.SwiftConstants.STICKY_HASH_KEY;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import org.apache.thrift.protocol.*;
import org.apache.thrift.ClientPushMetadata;
import org.apache.thrift.InteractionCreate;
import org.apache.thrift.InteractionTerminate;
import com.facebook.thrift.client.ResponseWrapper;
import com.facebook.thrift.client.RpcOptions;
import com.facebook.thrift.util.Readers;

public class SinkServiceReactiveClient 
  implements SinkService.Reactive {
  private static final AtomicLong _interactionCounter = new AtomicLong(0);

  protected final org.apache.thrift.ProtocolId _protocolId;
  protected final reactor.core.publisher.Mono<? extends com.facebook.thrift.client.RpcClient> _rpcClient;
  protected final reactor.core.publisher.Mono<Map<String, String>> _headersMono;
  protected final reactor.core.publisher.Mono<Map<String, String>> _persistentHeadersMono;
  protected final Set<Long> _activeInteractions;

  private static final TField _method_SINK_TFIELD = new TField("payload", TType.STRUCT, (short)0);
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _method_EXCEPTION_READERS = java.util.Collections.emptyMap();
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _method_STREAM_EXCEPTION_READERS = java.util.Collections.emptyMap();
  private static final TField _methodAndReponse_SINK_TFIELD = new TField("payload", TType.STRUCT, (short)0);
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodAndReponse_EXCEPTION_READERS = java.util.Collections.emptyMap();
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodAndReponse_STREAM_EXCEPTION_READERS = java.util.Collections.emptyMap();
  private static final TField _methodThrow_SINK_TFIELD = new TField("payload", TType.STRUCT, (short)0);
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodThrow_EXCEPTION_READERS = new HashMap<>();
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodThrow_STREAM_EXCEPTION_READERS = java.util.Collections.emptyMap();
  private static final com.facebook.thrift.payload.Reader _methodThrow_EXCEPTION_READER0 = Readers.wrap(test.fixtures.sink.InitialException.asReader());
  private static final TField _methodSinkThrow_SINK_TFIELD = new TField("payload", TType.STRUCT, (short)0);
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodSinkThrow_EXCEPTION_READERS = java.util.Collections.emptyMap();
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodSinkThrow_STREAM_EXCEPTION_READERS = java.util.Collections.emptyMap();
  private static final TField _methodFinalThrow_SINK_TFIELD = new TField("payload", TType.STRUCT, (short)0);
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodFinalThrow_EXCEPTION_READERS = java.util.Collections.emptyMap();
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodFinalThrow_STREAM_EXCEPTION_READERS = new HashMap<>();
  private static final com.facebook.thrift.payload.Reader _methodFinalThrow_STREAM_EXCEPTION_READER0 = Readers.wrap(test.fixtures.sink.SinkException2.asReader());
  private static final TField _methodBothThrow_SINK_TFIELD = new TField("payload", TType.STRUCT, (short)0);
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodBothThrow_EXCEPTION_READERS = java.util.Collections.emptyMap();
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodBothThrow_STREAM_EXCEPTION_READERS = new HashMap<>();
  private static final com.facebook.thrift.payload.Reader _methodBothThrow_STREAM_EXCEPTION_READER0 = Readers.wrap(test.fixtures.sink.SinkException2.asReader());
  private static final TField _methodFast_SINK_TFIELD = new TField("payload", TType.STRUCT, (short)0);
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodFast_EXCEPTION_READERS = java.util.Collections.emptyMap();
  private static final java.util.Map<Short, com.facebook.thrift.payload.Reader> _methodFast_STREAM_EXCEPTION_READERS = java.util.Collections.emptyMap();

  static {
    _methodThrow_EXCEPTION_READERS.put((short)1, _methodThrow_EXCEPTION_READER0);
    _methodFinalThrow_STREAM_EXCEPTION_READERS.put((short)1, _methodFinalThrow_STREAM_EXCEPTION_READER0);
    _methodBothThrow_STREAM_EXCEPTION_READERS.put((short)1, _methodBothThrow_STREAM_EXCEPTION_READER0);
  }

  public SinkServiceReactiveClient(org.apache.thrift.ProtocolId _protocolId, reactor.core.publisher.Mono<? extends com.facebook.thrift.client.RpcClient> _rpcClient) {
    
    this._protocolId = _protocolId;
    this._rpcClient = _rpcClient;
    this._headersMono = reactor.core.publisher.Mono.empty();
    this._persistentHeadersMono = reactor.core.publisher.Mono.empty();
    this._activeInteractions = ConcurrentHashMap.newKeySet();
  }

  public SinkServiceReactiveClient(org.apache.thrift.ProtocolId _protocolId, reactor.core.publisher.Mono<? extends com.facebook.thrift.client.RpcClient> _rpcClient, Map<String, String> _headers, Map<String, String> _persistentHeaders) {
    this(_protocolId, _rpcClient, reactor.core.publisher.Mono.just(_headers != null ? _headers : java.util.Collections.emptyMap()), reactor.core.publisher.Mono.just(_persistentHeaders != null ? _persistentHeaders : java.util.Collections.emptyMap()), new AtomicLong(), ConcurrentHashMap.newKeySet());
  }

  public SinkServiceReactiveClient(org.apache.thrift.ProtocolId _protocolId, reactor.core.publisher.Mono<? extends com.facebook.thrift.client.RpcClient> _rpcClient, reactor.core.publisher.Mono<Map<String, String>> _headersMono, reactor.core.publisher.Mono<Map<String, String>> _persistentHeadersMono) {
    this(_protocolId, _rpcClient, _headersMono, _persistentHeadersMono, new AtomicLong(), ConcurrentHashMap.newKeySet());
  }

  public SinkServiceReactiveClient(org.apache.thrift.ProtocolId _protocolId, reactor.core.publisher.Mono<? extends com.facebook.thrift.client.RpcClient> _rpcClient, Map<String, String> _headers, Map<String, String> _persistentHeaders, AtomicLong interactionCounter, Set<Long> activeInteractions) {
    this(_protocolId,_rpcClient, reactor.core.publisher.Mono.just(_headers != null ? _headers : java.util.Collections.emptyMap()), reactor.core.publisher.Mono.just(_persistentHeaders != null ? _persistentHeaders : java.util.Collections.emptyMap()), interactionCounter, activeInteractions);
  }

  public SinkServiceReactiveClient(org.apache.thrift.ProtocolId _protocolId, reactor.core.publisher.Mono<? extends com.facebook.thrift.client.RpcClient> _rpcClient, reactor.core.publisher.Mono<Map<String, String>> _headersMono, reactor.core.publisher.Mono<Map<String, String>> _persistentHeadersMono, AtomicLong interactionCounter, Set<Long> activeInteractions) {
    
    this._protocolId = _protocolId;
    this._rpcClient = _rpcClient;
    this._headersMono = _headersMono;
    this._persistentHeadersMono = _persistentHeadersMono;
    this._activeInteractions = activeInteractions;
  }

  @java.lang.Override
  public void dispose() {}


  private com.facebook.thrift.payload.Writer _createmethodWriter() {
    return oprot -> {
      try {

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private com.facebook.thrift.payload.Writer _createmethodSinkWriter(test.fixtures.sink.SinkPayload _p) {
    return oprot -> {
      try {
        oprot.writeFieldBegin(_method_SINK_TFIELD);
        _p.write0(oprot);
        oprot.writeFieldEnd();

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private static final com.facebook.thrift.payload.Reader _method_READER = Readers.wrap(test.fixtures.sink.FinalResponse.asReader());


  @java.lang.Override
  public reactor.core.publisher.Mono<ResponseWrapper<test.fixtures.sink.FinalResponse>> methodWrapper( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
    return _rpcClient
      .flatMapMany(_rpc -> getHeaders(rpcOptions).flatMapMany(headers -> {
        org.apache.thrift.RequestRpcMetadata _metadata = new org.apache.thrift.RequestRpcMetadata.Builder()
                .setName("method")
                .setKind(org.apache.thrift.RpcKind.SINK)
                .setOtherMetadata(headers)
                .setProtocol(_protocolId)
                .build();

            com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse> _crp =
                com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodWriter(),
                    _method_READER,
                    _method_EXCEPTION_READERS,
                    _method_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap());

            reactor.core.publisher.Flux<com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse>> _sink =
              reactor.core.publisher.Mono.just(_crp).concatWith(reactor.core.publisher.Flux.from(payloads)
                .map(_p -> com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodSinkWriter(_p),
                    _method_READER,
                    _method_EXCEPTION_READERS,
                    _method_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap())));

            return _rpc
                .streamingRequestStreamingResponse(_sink, rpcOptions)
                .doOnNext(_p -> {if(_p.getException() != null) throw reactor.core.Exceptions.propagate(_p.getException());})
                .filter((_p) -> ((com.facebook.thrift.model.StreamResponse)_p.getData()).isSetData())
                .map(_p -> ResponseWrapper.create(((com.facebook.thrift.model.StreamResponse<Void, test.fixtures.sink.FinalResponse>)_p.getData()).getData(), _p.getHeaders(), _p.getBinaryHeaders()));
      })).single();
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> method( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
      return methodWrapper( payloads, rpcOptions).map(_p -> _p.getData());
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> method( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads) {
      return method( payloads, com.facebook.thrift.client.RpcOptions.EMPTY);
  }

  private com.facebook.thrift.payload.Writer _createmethodAndReponseWriter() {
    return oprot -> {
      try {

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private com.facebook.thrift.payload.Writer _createmethodAndReponseSinkWriter(test.fixtures.sink.SinkPayload _p) {
    return oprot -> {
      try {
        oprot.writeFieldBegin(_methodAndReponse_SINK_TFIELD);
        _p.write0(oprot);
        oprot.writeFieldEnd();

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private static final com.facebook.thrift.payload.Reader _methodAndReponse_READER = Readers.wrap(test.fixtures.sink.FinalResponse.asReader());

  private static final com.facebook.thrift.payload.Reader _methodAndReponse_FIRST_READER = Readers.wrap(test.fixtures.sink.InitialResponse.asReader());

  @java.lang.Override
  public reactor.core.publisher.Flux<ResponseWrapper<com.facebook.thrift.model.StreamResponse<test.fixtures.sink.InitialResponse,test.fixtures.sink.FinalResponse>>> methodAndReponseWrapper( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
    return _rpcClient
      .flatMapMany(_rpc -> getHeaders(rpcOptions).flatMapMany(headers -> {
        org.apache.thrift.RequestRpcMetadata _metadata = new org.apache.thrift.RequestRpcMetadata.Builder()
                .setName("methodAndReponse")
                .setKind(org.apache.thrift.RpcKind.SINK)
                .setOtherMetadata(headers)
                .setProtocol(_protocolId)
                .build();

            com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse> _crp =
                com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodAndReponseWriter(),
                    _methodAndReponse_READER,
                    _methodAndReponse_FIRST_READER,
                    _methodAndReponse_EXCEPTION_READERS,
                    _methodAndReponse_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap());

            reactor.core.publisher.Flux<com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse>> _sink =
              reactor.core.publisher.Mono.just(_crp).concatWith(reactor.core.publisher.Flux.from(payloads)
                .map(_p -> com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodAndReponseSinkWriter(_p),
                    _methodAndReponse_READER,
                    _methodAndReponse_FIRST_READER,
                    _methodAndReponse_EXCEPTION_READERS,
                    _methodAndReponse_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap())));

            return _rpc
                .streamingRequestStreamingResponse(_sink, rpcOptions)
                .doOnNext(_p -> {if(_p.getException() != null) throw reactor.core.Exceptions.propagate(_p.getException());})
                .map(_p -> ResponseWrapper.create(((com.facebook.thrift.model.StreamResponse<test.fixtures.sink.InitialResponse,test.fixtures.sink.FinalResponse>)_p.getData()), _p.getHeaders(), _p.getBinaryHeaders()));
      }));
  }

  @java.lang.Override
  public reactor.core.publisher.Flux<com.facebook.thrift.model.StreamResponse<test.fixtures.sink.InitialResponse,test.fixtures.sink.FinalResponse>> methodAndReponse( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
      return methodAndReponseWrapper( payloads, rpcOptions).map(_p -> _p.getData());
  }

  @java.lang.Override
  public reactor.core.publisher.Flux<com.facebook.thrift.model.StreamResponse<test.fixtures.sink.InitialResponse,test.fixtures.sink.FinalResponse>> methodAndReponse( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads) {
      return methodAndReponse( payloads, com.facebook.thrift.client.RpcOptions.EMPTY);
  }

  private com.facebook.thrift.payload.Writer _createmethodThrowWriter() {
    return oprot -> {
      try {

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private com.facebook.thrift.payload.Writer _createmethodThrowSinkWriter(test.fixtures.sink.SinkPayload _p) {
    return oprot -> {
      try {
        oprot.writeFieldBegin(_methodThrow_SINK_TFIELD);
        _p.write0(oprot);
        oprot.writeFieldEnd();

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private static final com.facebook.thrift.payload.Reader _methodThrow_READER = Readers.wrap(test.fixtures.sink.FinalResponse.asReader());


  @java.lang.Override
  public reactor.core.publisher.Mono<ResponseWrapper<test.fixtures.sink.FinalResponse>> methodThrowWrapper( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
    return _rpcClient
      .flatMapMany(_rpc -> getHeaders(rpcOptions).flatMapMany(headers -> {
        org.apache.thrift.RequestRpcMetadata _metadata = new org.apache.thrift.RequestRpcMetadata.Builder()
                .setName("methodThrow")
                .setKind(org.apache.thrift.RpcKind.SINK)
                .setOtherMetadata(headers)
                .setProtocol(_protocolId)
                .build();

            com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse> _crp =
                com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodThrowWriter(),
                    _methodThrow_READER,
                    _methodThrow_EXCEPTION_READERS,
                    _methodThrow_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap());

            reactor.core.publisher.Flux<com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse>> _sink =
              reactor.core.publisher.Mono.just(_crp).concatWith(reactor.core.publisher.Flux.from(payloads)
                .map(_p -> com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodThrowSinkWriter(_p),
                    _methodThrow_READER,
                    _methodThrow_EXCEPTION_READERS,
                    _methodThrow_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap())));

            return _rpc
                .streamingRequestStreamingResponse(_sink, rpcOptions)
                .doOnNext(_p -> {if(_p.getException() != null) throw reactor.core.Exceptions.propagate(_p.getException());})
                .filter((_p) -> ((com.facebook.thrift.model.StreamResponse)_p.getData()).isSetData())
                .map(_p -> ResponseWrapper.create(((com.facebook.thrift.model.StreamResponse<Void, test.fixtures.sink.FinalResponse>)_p.getData()).getData(), _p.getHeaders(), _p.getBinaryHeaders()));
      })).single();
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> methodThrow( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
      return methodThrowWrapper( payloads, rpcOptions).map(_p -> _p.getData());
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> methodThrow( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads) {
      return methodThrow( payloads, com.facebook.thrift.client.RpcOptions.EMPTY);
  }

  private com.facebook.thrift.payload.Writer _createmethodSinkThrowWriter() {
    return oprot -> {
      try {

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private com.facebook.thrift.payload.Writer _createmethodSinkThrowSinkWriter(test.fixtures.sink.SinkPayload _p) {
    return oprot -> {
      try {
        oprot.writeFieldBegin(_methodSinkThrow_SINK_TFIELD);
        _p.write0(oprot);
        oprot.writeFieldEnd();

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private static final com.facebook.thrift.payload.Reader _methodSinkThrow_READER = Readers.wrap(test.fixtures.sink.FinalResponse.asReader());


  @java.lang.Override
  public reactor.core.publisher.Mono<ResponseWrapper<test.fixtures.sink.FinalResponse>> methodSinkThrowWrapper( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
    return _rpcClient
      .flatMapMany(_rpc -> getHeaders(rpcOptions).flatMapMany(headers -> {
        org.apache.thrift.RequestRpcMetadata _metadata = new org.apache.thrift.RequestRpcMetadata.Builder()
                .setName("methodSinkThrow")
                .setKind(org.apache.thrift.RpcKind.SINK)
                .setOtherMetadata(headers)
                .setProtocol(_protocolId)
                .build();

            com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse> _crp =
                com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodSinkThrowWriter(),
                    _methodSinkThrow_READER,
                    _methodSinkThrow_EXCEPTION_READERS,
                    _methodSinkThrow_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap());

            reactor.core.publisher.Flux<com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse>> _sink =
              reactor.core.publisher.Mono.just(_crp).concatWith(reactor.core.publisher.Flux.from(payloads)
                .map(_p -> com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodSinkThrowSinkWriter(_p),
                    _methodSinkThrow_READER,
                    _methodSinkThrow_EXCEPTION_READERS,
                    _methodSinkThrow_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap())));

            return _rpc
                .streamingRequestStreamingResponse(_sink, rpcOptions)
                .doOnNext(_p -> {if(_p.getException() != null) throw reactor.core.Exceptions.propagate(_p.getException());})
                .filter((_p) -> ((com.facebook.thrift.model.StreamResponse)_p.getData()).isSetData())
                .map(_p -> ResponseWrapper.create(((com.facebook.thrift.model.StreamResponse<Void, test.fixtures.sink.FinalResponse>)_p.getData()).getData(), _p.getHeaders(), _p.getBinaryHeaders()));
      })).single();
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> methodSinkThrow( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
      return methodSinkThrowWrapper( payloads, rpcOptions).map(_p -> _p.getData());
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> methodSinkThrow( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads) {
      return methodSinkThrow( payloads, com.facebook.thrift.client.RpcOptions.EMPTY);
  }

  private com.facebook.thrift.payload.Writer _createmethodFinalThrowWriter() {
    return oprot -> {
      try {

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private com.facebook.thrift.payload.Writer _createmethodFinalThrowSinkWriter(test.fixtures.sink.SinkPayload _p) {
    return oprot -> {
      try {
        oprot.writeFieldBegin(_methodFinalThrow_SINK_TFIELD);
        _p.write0(oprot);
        oprot.writeFieldEnd();

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private static final com.facebook.thrift.payload.Reader _methodFinalThrow_READER = Readers.wrap(test.fixtures.sink.FinalResponse.asReader());


  @java.lang.Override
  public reactor.core.publisher.Mono<ResponseWrapper<test.fixtures.sink.FinalResponse>> methodFinalThrowWrapper( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
    return _rpcClient
      .flatMapMany(_rpc -> getHeaders(rpcOptions).flatMapMany(headers -> {
        org.apache.thrift.RequestRpcMetadata _metadata = new org.apache.thrift.RequestRpcMetadata.Builder()
                .setName("methodFinalThrow")
                .setKind(org.apache.thrift.RpcKind.SINK)
                .setOtherMetadata(headers)
                .setProtocol(_protocolId)
                .build();

            com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse> _crp =
                com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodFinalThrowWriter(),
                    _methodFinalThrow_READER,
                    _methodFinalThrow_EXCEPTION_READERS,
                    _methodFinalThrow_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap());

            reactor.core.publisher.Flux<com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse>> _sink =
              reactor.core.publisher.Mono.just(_crp).concatWith(reactor.core.publisher.Flux.from(payloads)
                .map(_p -> com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodFinalThrowSinkWriter(_p),
                    _methodFinalThrow_READER,
                    _methodFinalThrow_EXCEPTION_READERS,
                    _methodFinalThrow_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap())));

            return _rpc
                .streamingRequestStreamingResponse(_sink, rpcOptions)
                .doOnNext(_p -> {if(_p.getException() != null) throw reactor.core.Exceptions.propagate(_p.getException());})
                .filter((_p) -> ((com.facebook.thrift.model.StreamResponse)_p.getData()).isSetData())
                .map(_p -> ResponseWrapper.create(((com.facebook.thrift.model.StreamResponse<Void, test.fixtures.sink.FinalResponse>)_p.getData()).getData(), _p.getHeaders(), _p.getBinaryHeaders()));
      })).single();
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> methodFinalThrow( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
      return methodFinalThrowWrapper( payloads, rpcOptions).map(_p -> _p.getData());
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> methodFinalThrow( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads) {
      return methodFinalThrow( payloads, com.facebook.thrift.client.RpcOptions.EMPTY);
  }

  private com.facebook.thrift.payload.Writer _createmethodBothThrowWriter() {
    return oprot -> {
      try {

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private com.facebook.thrift.payload.Writer _createmethodBothThrowSinkWriter(test.fixtures.sink.SinkPayload _p) {
    return oprot -> {
      try {
        oprot.writeFieldBegin(_methodBothThrow_SINK_TFIELD);
        _p.write0(oprot);
        oprot.writeFieldEnd();

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private static final com.facebook.thrift.payload.Reader _methodBothThrow_READER = Readers.wrap(test.fixtures.sink.FinalResponse.asReader());


  @java.lang.Override
  public reactor.core.publisher.Mono<ResponseWrapper<test.fixtures.sink.FinalResponse>> methodBothThrowWrapper( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
    return _rpcClient
      .flatMapMany(_rpc -> getHeaders(rpcOptions).flatMapMany(headers -> {
        org.apache.thrift.RequestRpcMetadata _metadata = new org.apache.thrift.RequestRpcMetadata.Builder()
                .setName("methodBothThrow")
                .setKind(org.apache.thrift.RpcKind.SINK)
                .setOtherMetadata(headers)
                .setProtocol(_protocolId)
                .build();

            com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse> _crp =
                com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodBothThrowWriter(),
                    _methodBothThrow_READER,
                    _methodBothThrow_EXCEPTION_READERS,
                    _methodBothThrow_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap());

            reactor.core.publisher.Flux<com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse>> _sink =
              reactor.core.publisher.Mono.just(_crp).concatWith(reactor.core.publisher.Flux.from(payloads)
                .map(_p -> com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodBothThrowSinkWriter(_p),
                    _methodBothThrow_READER,
                    _methodBothThrow_EXCEPTION_READERS,
                    _methodBothThrow_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap())));

            return _rpc
                .streamingRequestStreamingResponse(_sink, rpcOptions)
                .doOnNext(_p -> {if(_p.getException() != null) throw reactor.core.Exceptions.propagate(_p.getException());})
                .filter((_p) -> ((com.facebook.thrift.model.StreamResponse)_p.getData()).isSetData())
                .map(_p -> ResponseWrapper.create(((com.facebook.thrift.model.StreamResponse<Void, test.fixtures.sink.FinalResponse>)_p.getData()).getData(), _p.getHeaders(), _p.getBinaryHeaders()));
      })).single();
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> methodBothThrow( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
      return methodBothThrowWrapper( payloads, rpcOptions).map(_p -> _p.getData());
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> methodBothThrow( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads) {
      return methodBothThrow( payloads, com.facebook.thrift.client.RpcOptions.EMPTY);
  }

  private com.facebook.thrift.payload.Writer _createmethodFastWriter() {
    return oprot -> {
      try {

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private com.facebook.thrift.payload.Writer _createmethodFastSinkWriter(test.fixtures.sink.SinkPayload _p) {
    return oprot -> {
      try {
        oprot.writeFieldBegin(_methodFast_SINK_TFIELD);
        _p.write0(oprot);
        oprot.writeFieldEnd();

      } catch (Throwable _e) {
        com.facebook.thrift.util.NettyUtil.releaseIfByteBufTProtocol(oprot);
        throw reactor.core.Exceptions.propagate(_e);
      }
    };
  }

  private static final com.facebook.thrift.payload.Reader _methodFast_READER = Readers.wrap(test.fixtures.sink.FinalResponse.asReader());


  @java.lang.Override
  public reactor.core.publisher.Mono<ResponseWrapper<test.fixtures.sink.FinalResponse>> methodFastWrapper( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
    return _rpcClient
      .flatMapMany(_rpc -> getHeaders(rpcOptions).flatMapMany(headers -> {
        org.apache.thrift.RequestRpcMetadata _metadata = new org.apache.thrift.RequestRpcMetadata.Builder()
                .setName("methodFast")
                .setKind(org.apache.thrift.RpcKind.SINK)
                .setOtherMetadata(headers)
                .setProtocol(_protocolId)
                .build();

            com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse> _crp =
                com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodFastWriter(),
                    _methodFast_READER,
                    _methodFast_EXCEPTION_READERS,
                    _methodFast_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap());

            reactor.core.publisher.Flux<com.facebook.thrift.payload.ClientRequestPayload<test.fixtures.sink.FinalResponse>> _sink =
              reactor.core.publisher.Mono.just(_crp).concatWith(reactor.core.publisher.Flux.from(payloads)
                .map(_p -> com.facebook.thrift.payload.ClientRequestPayload.create(
                    "SinkService",
                    _createmethodFastSinkWriter(_p),
                    _methodFast_READER,
                    _methodFast_EXCEPTION_READERS,
                    _methodFast_STREAM_EXCEPTION_READERS,
                    _metadata,
                    java.util.Collections.emptyMap())));

            return _rpc
                .streamingRequestStreamingResponse(_sink, rpcOptions)
                .doOnNext(_p -> {if(_p.getException() != null) throw reactor.core.Exceptions.propagate(_p.getException());})
                .filter((_p) -> ((com.facebook.thrift.model.StreamResponse)_p.getData()).isSetData())
                .map(_p -> ResponseWrapper.create(((com.facebook.thrift.model.StreamResponse<Void, test.fixtures.sink.FinalResponse>)_p.getData()).getData(), _p.getHeaders(), _p.getBinaryHeaders()));
      })).single();
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> methodFast( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads, com.facebook.thrift.client.RpcOptions rpcOptions) {
      return methodFastWrapper( payloads, rpcOptions).map(_p -> _p.getData());
  }

  @java.lang.Override
  public reactor.core.publisher.Mono<test.fixtures.sink.FinalResponse> methodFast( org.reactivestreams.Publisher<test.fixtures.sink.SinkPayload> payloads) {
      return methodFast( payloads, com.facebook.thrift.client.RpcOptions.EMPTY);
  }


  private reactor.core.publisher.Mono<Map<String, String>> getHeaders(com.facebook.thrift.client.RpcOptions rpcOptions) {
      Map<String, String> requestHeaders = new HashMap<>();
      if (rpcOptions.getRequestHeaders() != null && !rpcOptions.getRequestHeaders().isEmpty()) {
          requestHeaders.putAll(rpcOptions.getRequestHeaders());
      }

      return _headersMono.defaultIfEmpty(java.util.Collections.emptyMap()).zipWith(_persistentHeadersMono.defaultIfEmpty(java.util.Collections.emptyMap()), (headers, persistentHeaders) -> {
          Map<String, String> result = new HashMap<>();
          result.putAll(requestHeaders);
          result.putAll(headers);
          result.putAll(persistentHeaders);
          return result;
      });
  }
}
