/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010- Facebook, Inc. (http://www.facebook.com)         |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <php/classes/exception.h>
#include <php/classes/exception.fws.h>

// Dependencies
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>
namespace hphp_impl_starter {}

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

/* preface starts */
extern CallInfo ci_;
/* preface finishes */
/* SRC: classes/exception.php line 277 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_UnexpectedValueException
Variant c_UnexpectedValueException::os_getInit(CStrRef s) {
  return c_RuntimeException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_UnexpectedValueException
Variant c_UnexpectedValueException::os_get(CStrRef s) {
  return c_RuntimeException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_UnexpectedValueException
Variant &c_UnexpectedValueException::os_lval(CStrRef s) {
  return c_RuntimeException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_UnexpectedValueException
void c_UnexpectedValueException::o_getArray(Array &props, bool pubOnly) const {
  c_RuntimeException::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_UnexpectedValueException
void c_UnexpectedValueException::o_setArray(CArrRef props) {
  c_RuntimeException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_UnexpectedValueException
Variant * c_UnexpectedValueException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_UnexpectedValueException
Variant * c_UnexpectedValueException::o_realPropPublic(CStrRef s, int flags) const {
  return c_RuntimeException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_UnexpectedValueException
Variant * c_UnexpectedValueException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_UnexpectedValueException
Variant c_UnexpectedValueException::os_constant(const char *s) {
  return c_RuntimeException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_UnexpectedValueException
IMPLEMENT_CLASS(UnexpectedValueException)
bool c_UnexpectedValueException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 1:
      HASH_INSTANCEOF(0x5AA2EE582E0D3849LL, NAMSTR(s_sys_ss7c2432f2, "UnexpectedValueException"));
      break;
    case 4:
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      HASH_INSTANCEOF(0x1078CB3118A8B3DCLL, NAMSTR(s_sys_ss5e40e701, "RuntimeException"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_UnexpectedValueException::cloneImpl() {
  c_UnexpectedValueException *obj = NEWOBJ(c_UnexpectedValueException)();
  c_UnexpectedValueException::cloneSet(obj);
  return obj;
}
void c_UnexpectedValueException::cloneSet(ObjectData *cl) {
  c_UnexpectedValueException *clone = static_cast<c_UnexpectedValueException*>(cl);
  c_RuntimeException::cloneSet(clone);
}
bool c_UnexpectedValueException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_RuntimeException::os_get_call_info(mcp, hash);
}
bool c_UnexpectedValueException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_UnexpectedValueException = {
  c_UnexpectedValueException::os_getInit,
  c_UnexpectedValueException::os_get,
  c_UnexpectedValueException::os_lval,
  c_UnexpectedValueException::os_invoke,
  c_UnexpectedValueException::os_constant,
  c_UnexpectedValueException::os_get_call_info
};
void c_UnexpectedValueException::init() {
  c_RuntimeException::init();
}
/* SRC: classes/exception.php line 251 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OverflowException
Variant c_OverflowException::os_getInit(CStrRef s) {
  return c_RuntimeException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_OverflowException
Variant c_OverflowException::os_get(CStrRef s) {
  return c_RuntimeException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OverflowException
Variant &c_OverflowException::os_lval(CStrRef s) {
  return c_RuntimeException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_OverflowException
void c_OverflowException::o_getArray(Array &props, bool pubOnly) const {
  c_RuntimeException::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_OverflowException
void c_OverflowException::o_setArray(CArrRef props) {
  c_RuntimeException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_OverflowException
Variant * c_OverflowException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OverflowException
Variant * c_OverflowException::o_realPropPublic(CStrRef s, int flags) const {
  return c_RuntimeException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OverflowException
Variant * c_OverflowException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_OverflowException
Variant c_OverflowException::os_constant(const char *s) {
  return c_RuntimeException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_OverflowException
IMPLEMENT_CLASS(OverflowException)
bool c_OverflowException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 1:
      HASH_INSTANCEOF(0x0E4CCE95F6A727D9LL, NAMSTR(s_sys_ssbc297b7f, "OverflowException"));
      break;
    case 4:
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      HASH_INSTANCEOF(0x1078CB3118A8B3DCLL, NAMSTR(s_sys_ss5e40e701, "RuntimeException"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_OverflowException::cloneImpl() {
  c_OverflowException *obj = NEWOBJ(c_OverflowException)();
  c_OverflowException::cloneSet(obj);
  return obj;
}
void c_OverflowException::cloneSet(ObjectData *cl) {
  c_OverflowException *clone = static_cast<c_OverflowException*>(cl);
  c_RuntimeException::cloneSet(clone);
}
bool c_OverflowException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_RuntimeException::os_get_call_info(mcp, hash);
}
bool c_OverflowException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_OverflowException = {
  c_OverflowException::os_getInit,
  c_OverflowException::os_get,
  c_OverflowException::os_lval,
  c_OverflowException::os_invoke,
  c_OverflowException::os_constant,
  c_OverflowException::os_get_call_info
};
void c_OverflowException::init() {
  c_RuntimeException::init();
}
/* SRC: classes/exception.php line 243 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OutOfBoundsException
Variant c_OutOfBoundsException::os_getInit(CStrRef s) {
  return c_RuntimeException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_OutOfBoundsException
Variant c_OutOfBoundsException::os_get(CStrRef s) {
  return c_RuntimeException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OutOfBoundsException
Variant &c_OutOfBoundsException::os_lval(CStrRef s) {
  return c_RuntimeException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_OutOfBoundsException
void c_OutOfBoundsException::o_getArray(Array &props, bool pubOnly) const {
  c_RuntimeException::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_OutOfBoundsException
void c_OutOfBoundsException::o_setArray(CArrRef props) {
  c_RuntimeException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_OutOfBoundsException
Variant * c_OutOfBoundsException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OutOfBoundsException
Variant * c_OutOfBoundsException::o_realPropPublic(CStrRef s, int flags) const {
  return c_RuntimeException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OutOfBoundsException
Variant * c_OutOfBoundsException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_OutOfBoundsException
Variant c_OutOfBoundsException::os_constant(const char *s) {
  return c_RuntimeException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_OutOfBoundsException
IMPLEMENT_CLASS(OutOfBoundsException)
bool c_OutOfBoundsException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 1:
      HASH_INSTANCEOF(0x227C70ED5B143841LL, NAMSTR(s_sys_ss0c50ad86, "OutOfBoundsException"));
      break;
    case 4:
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      HASH_INSTANCEOF(0x1078CB3118A8B3DCLL, NAMSTR(s_sys_ss5e40e701, "RuntimeException"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_OutOfBoundsException::cloneImpl() {
  c_OutOfBoundsException *obj = NEWOBJ(c_OutOfBoundsException)();
  c_OutOfBoundsException::cloneSet(obj);
  return obj;
}
void c_OutOfBoundsException::cloneSet(ObjectData *cl) {
  c_OutOfBoundsException *clone = static_cast<c_OutOfBoundsException*>(cl);
  c_RuntimeException::cloneSet(clone);
}
bool c_OutOfBoundsException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_RuntimeException::os_get_call_info(mcp, hash);
}
bool c_OutOfBoundsException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_OutOfBoundsException = {
  c_OutOfBoundsException::os_getInit,
  c_OutOfBoundsException::os_get,
  c_OutOfBoundsException::os_lval,
  c_OutOfBoundsException::os_invoke,
  c_OutOfBoundsException::os_constant,
  c_OutOfBoundsException::os_get_call_info
};
void c_OutOfBoundsException::init() {
  c_RuntimeException::init();
}
/* SRC: classes/exception.php line 173 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LogicException
Variant c_LogicException::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_LogicException
Variant c_LogicException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LogicException
Variant &c_LogicException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_LogicException
void c_LogicException::o_getArray(Array &props, bool pubOnly) const {
  c_Exception::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_LogicException
void c_LogicException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_LogicException
Variant * c_LogicException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LogicException
Variant * c_LogicException::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LogicException
Variant * c_LogicException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_LogicException
Variant c_LogicException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_LogicException
IMPLEMENT_CLASS(LogicException)
bool c_LogicException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 3) {
    case 0:
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      break;
    case 3:
      HASH_INSTANCEOF(0x4860DC2F9B0E6D4BLL, NAMSTR(s_sys_ssa37fe34e, "LogicException"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_LogicException::cloneImpl() {
  c_LogicException *obj = NEWOBJ(c_LogicException)();
  c_LogicException::cloneSet(obj);
  return obj;
}
void c_LogicException::cloneSet(ObjectData *cl) {
  c_LogicException *clone = static_cast<c_LogicException*>(cl);
  c_Exception::cloneSet(clone);
}
bool c_LogicException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_Exception::os_get_call_info(mcp, hash);
}
bool c_LogicException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_LogicException = {
  c_LogicException::os_getInit,
  c_LogicException::os_get,
  c_LogicException::os_lval,
  c_LogicException::os_invoke,
  c_LogicException::os_constant,
  c_LogicException::os_get_call_info
};
void c_LogicException::init() {
  c_Exception::init();
}
/* SRC: classes/exception.php line 259 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_RangeException
Variant c_RangeException::os_getInit(CStrRef s) {
  return c_RuntimeException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_RangeException
Variant c_RangeException::os_get(CStrRef s) {
  return c_RuntimeException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_RangeException
Variant &c_RangeException::os_lval(CStrRef s) {
  return c_RuntimeException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_RangeException
void c_RangeException::o_getArray(Array &props, bool pubOnly) const {
  c_RuntimeException::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_RangeException
void c_RangeException::o_setArray(CArrRef props) {
  c_RuntimeException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_RangeException
Variant * c_RangeException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_RangeException
Variant * c_RangeException::o_realPropPublic(CStrRef s, int flags) const {
  return c_RuntimeException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_RangeException
Variant * c_RangeException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_RangeException
Variant c_RangeException::os_constant(const char *s) {
  return c_RuntimeException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_RangeException
IMPLEMENT_CLASS(RangeException)
bool c_RangeException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_INSTANCEOF(0x6AF83706F76A9D53LL, NAMSTR(s_sys_ss6e6aaece, "RangeException"));
      break;
    case 4:
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      HASH_INSTANCEOF(0x1078CB3118A8B3DCLL, NAMSTR(s_sys_ss5e40e701, "RuntimeException"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_RangeException::cloneImpl() {
  c_RangeException *obj = NEWOBJ(c_RangeException)();
  c_RangeException::cloneSet(obj);
  return obj;
}
void c_RangeException::cloneSet(ObjectData *cl) {
  c_RangeException *clone = static_cast<c_RangeException*>(cl);
  c_RuntimeException::cloneSet(clone);
}
bool c_RangeException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_RuntimeException::os_get_call_info(mcp, hash);
}
bool c_RangeException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_RangeException = {
  c_RangeException::os_getInit,
  c_RangeException::os_get,
  c_RangeException::os_lval,
  c_RangeException::os_invoke,
  c_RangeException::os_constant,
  c_RangeException::os_get_call_info
};
void c_RangeException::init() {
  c_RuntimeException::init();
}
/* SRC: classes/exception.php line 211 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_InvalidArgumentException
Variant c_InvalidArgumentException::os_getInit(CStrRef s) {
  return c_LogicException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_InvalidArgumentException
Variant c_InvalidArgumentException::os_get(CStrRef s) {
  return c_LogicException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_InvalidArgumentException
Variant &c_InvalidArgumentException::os_lval(CStrRef s) {
  return c_LogicException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_InvalidArgumentException
void c_InvalidArgumentException::o_getArray(Array &props, bool pubOnly) const {
  c_LogicException::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_InvalidArgumentException
void c_InvalidArgumentException::o_setArray(CArrRef props) {
  c_LogicException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_InvalidArgumentException
Variant * c_InvalidArgumentException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_InvalidArgumentException
Variant * c_InvalidArgumentException::o_realPropPublic(CStrRef s, int flags) const {
  return c_LogicException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_InvalidArgumentException
Variant * c_InvalidArgumentException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_InvalidArgumentException
Variant c_InvalidArgumentException::os_constant(const char *s) {
  return c_LogicException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_InvalidArgumentException
IMPLEMENT_CLASS(InvalidArgumentException)
bool c_InvalidArgumentException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_INSTANCEOF(0x4860DC2F9B0E6D4BLL, NAMSTR(s_sys_ssa37fe34e, "LogicException"));
      break;
    case 4:
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      break;
    case 5:
      HASH_INSTANCEOF(0x085A4F6FD393D475LL, NAMSTR(s_sys_ss079dd82d, "InvalidArgumentException"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_InvalidArgumentException::cloneImpl() {
  c_InvalidArgumentException *obj = NEWOBJ(c_InvalidArgumentException)();
  c_InvalidArgumentException::cloneSet(obj);
  return obj;
}
void c_InvalidArgumentException::cloneSet(ObjectData *cl) {
  c_InvalidArgumentException *clone = static_cast<c_InvalidArgumentException*>(cl);
  c_LogicException::cloneSet(clone);
}
bool c_InvalidArgumentException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_LogicException::os_get_call_info(mcp, hash);
}
bool c_InvalidArgumentException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_InvalidArgumentException = {
  c_InvalidArgumentException::os_getInit,
  c_InvalidArgumentException::os_get,
  c_InvalidArgumentException::os_lval,
  c_InvalidArgumentException::os_invoke,
  c_InvalidArgumentException::os_constant,
  c_InvalidArgumentException::os_get_call_info
};
void c_InvalidArgumentException::init() {
  c_LogicException::init();
}
/* SRC: classes/exception.php line 268 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_UnderflowException
Variant c_UnderflowException::os_getInit(CStrRef s) {
  return c_RuntimeException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_UnderflowException
Variant c_UnderflowException::os_get(CStrRef s) {
  return c_RuntimeException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_UnderflowException
Variant &c_UnderflowException::os_lval(CStrRef s) {
  return c_RuntimeException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_UnderflowException
void c_UnderflowException::o_getArray(Array &props, bool pubOnly) const {
  c_RuntimeException::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_UnderflowException
void c_UnderflowException::o_setArray(CArrRef props) {
  c_RuntimeException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_UnderflowException
Variant * c_UnderflowException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_UnderflowException
Variant * c_UnderflowException::o_realPropPublic(CStrRef s, int flags) const {
  return c_RuntimeException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_UnderflowException
Variant * c_UnderflowException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_UnderflowException
Variant c_UnderflowException::os_constant(const char *s) {
  return c_RuntimeException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_UnderflowException
IMPLEMENT_CLASS(UnderflowException)
bool c_UnderflowException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 4:
      HASH_INSTANCEOF(0x5E623FEAF7B068D4LL, NAMSTR(s_sys_ssb8a9ecc6, "UnderflowException"));
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      HASH_INSTANCEOF(0x1078CB3118A8B3DCLL, NAMSTR(s_sys_ss5e40e701, "RuntimeException"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_UnderflowException::cloneImpl() {
  c_UnderflowException *obj = NEWOBJ(c_UnderflowException)();
  c_UnderflowException::cloneSet(obj);
  return obj;
}
void c_UnderflowException::cloneSet(ObjectData *cl) {
  c_UnderflowException *clone = static_cast<c_UnderflowException*>(cl);
  c_RuntimeException::cloneSet(clone);
}
bool c_UnderflowException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_RuntimeException::os_get_call_info(mcp, hash);
}
bool c_UnderflowException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_UnderflowException = {
  c_UnderflowException::os_getInit,
  c_UnderflowException::os_get,
  c_UnderflowException::os_lval,
  c_UnderflowException::os_invoke,
  c_UnderflowException::os_constant,
  c_UnderflowException::os_get_call_info
};
void c_UnderflowException::init() {
  c_RuntimeException::init();
}
/* SRC: classes/exception.php line 227 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OutOfRangeException
Variant c_OutOfRangeException::os_getInit(CStrRef s) {
  return c_LogicException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_OutOfRangeException
Variant c_OutOfRangeException::os_get(CStrRef s) {
  return c_LogicException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OutOfRangeException
Variant &c_OutOfRangeException::os_lval(CStrRef s) {
  return c_LogicException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_OutOfRangeException
void c_OutOfRangeException::o_getArray(Array &props, bool pubOnly) const {
  c_LogicException::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_OutOfRangeException
void c_OutOfRangeException::o_setArray(CArrRef props) {
  c_LogicException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_OutOfRangeException
Variant * c_OutOfRangeException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OutOfRangeException
Variant * c_OutOfRangeException::o_realPropPublic(CStrRef s, int flags) const {
  return c_LogicException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OutOfRangeException
Variant * c_OutOfRangeException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_OutOfRangeException
Variant c_OutOfRangeException::os_constant(const char *s) {
  return c_LogicException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_OutOfRangeException
IMPLEMENT_CLASS(OutOfRangeException)
bool c_OutOfRangeException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_INSTANCEOF(0x4860DC2F9B0E6D4BLL, NAMSTR(s_sys_ssa37fe34e, "LogicException"));
      break;
    case 4:
      HASH_INSTANCEOF(0x622D4DF07E2A01FCLL, NAMSTR(s_sys_ss0a60a5a3, "OutOfRangeException"));
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_OutOfRangeException::cloneImpl() {
  c_OutOfRangeException *obj = NEWOBJ(c_OutOfRangeException)();
  c_OutOfRangeException::cloneSet(obj);
  return obj;
}
void c_OutOfRangeException::cloneSet(ObjectData *cl) {
  c_OutOfRangeException *clone = static_cast<c_OutOfRangeException*>(cl);
  c_LogicException::cloneSet(clone);
}
bool c_OutOfRangeException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_LogicException::os_get_call_info(mcp, hash);
}
bool c_OutOfRangeException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_OutOfRangeException = {
  c_OutOfRangeException::os_getInit,
  c_OutOfRangeException::os_get,
  c_OutOfRangeException::os_lval,
  c_OutOfRangeException::os_invoke,
  c_OutOfRangeException::os_constant,
  c_OutOfRangeException::os_get_call_info
};
void c_OutOfRangeException::init() {
  c_LogicException::init();
}
/* SRC: classes/exception.php line 193 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_BadMethodCallException
Variant c_BadMethodCallException::os_getInit(CStrRef s) {
  return c_BadFunctionCallException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_BadMethodCallException
Variant c_BadMethodCallException::os_get(CStrRef s) {
  return c_BadFunctionCallException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_BadMethodCallException
Variant &c_BadMethodCallException::os_lval(CStrRef s) {
  return c_BadFunctionCallException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_BadMethodCallException
void c_BadMethodCallException::o_getArray(Array &props, bool pubOnly) const {
  c_BadFunctionCallException::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_BadMethodCallException
void c_BadMethodCallException::o_setArray(CArrRef props) {
  c_BadFunctionCallException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_BadMethodCallException
Variant * c_BadMethodCallException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_BadMethodCallException
Variant * c_BadMethodCallException::o_realPropPublic(CStrRef s, int flags) const {
  return c_BadFunctionCallException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_BadMethodCallException
Variant * c_BadMethodCallException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_BadMethodCallException
Variant c_BadMethodCallException::os_constant(const char *s) {
  return c_BadFunctionCallException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_BadMethodCallException
IMPLEMENT_CLASS(BadMethodCallException)
bool c_BadMethodCallException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 0:
      HASH_INSTANCEOF(0x06335FF83CDEA590LL, NAMSTR(s_sys_ss033e1025, "BadMethodCallException"));
      break;
    case 3:
      HASH_INSTANCEOF(0x4860DC2F9B0E6D4BLL, NAMSTR(s_sys_ssa37fe34e, "LogicException"));
      break;
    case 4:
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      break;
    case 6:
      HASH_INSTANCEOF(0x66282FC8E4EF4E46LL, NAMSTR(s_sys_ss57956ee3, "BadFunctionCallException"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_BadMethodCallException::cloneImpl() {
  c_BadMethodCallException *obj = NEWOBJ(c_BadMethodCallException)();
  c_BadMethodCallException::cloneSet(obj);
  return obj;
}
void c_BadMethodCallException::cloneSet(ObjectData *cl) {
  c_BadMethodCallException *clone = static_cast<c_BadMethodCallException*>(cl);
  c_BadFunctionCallException::cloneSet(clone);
}
bool c_BadMethodCallException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_BadFunctionCallException::os_get_call_info(mcp, hash);
}
bool c_BadMethodCallException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_BadMethodCallException = {
  c_BadMethodCallException::os_getInit,
  c_BadMethodCallException::os_get,
  c_BadMethodCallException::os_lval,
  c_BadMethodCallException::os_invoke,
  c_BadMethodCallException::os_constant,
  c_BadMethodCallException::os_get_call_info
};
void c_BadMethodCallException::init() {
  c_BadFunctionCallException::init();
}
/* SRC: classes/exception.php line 235 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_RuntimeException
Variant c_RuntimeException::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_RuntimeException
Variant c_RuntimeException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_RuntimeException
Variant &c_RuntimeException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_RuntimeException
void c_RuntimeException::o_getArray(Array &props, bool pubOnly) const {
  c_Exception::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_RuntimeException
void c_RuntimeException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_RuntimeException
Variant * c_RuntimeException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_RuntimeException
Variant * c_RuntimeException::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_RuntimeException
Variant * c_RuntimeException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_RuntimeException
Variant c_RuntimeException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_RuntimeException
IMPLEMENT_CLASS(RuntimeException)
bool c_RuntimeException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 3) {
    case 0:
      HASH_INSTANCEOF(0x1078CB3118A8B3DCLL, NAMSTR(s_sys_ss5e40e701, "RuntimeException"));
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_RuntimeException::cloneImpl() {
  c_RuntimeException *obj = NEWOBJ(c_RuntimeException)();
  c_RuntimeException::cloneSet(obj);
  return obj;
}
void c_RuntimeException::cloneSet(ObjectData *cl) {
  c_RuntimeException *clone = static_cast<c_RuntimeException*>(cl);
  c_Exception::cloneSet(clone);
}
bool c_RuntimeException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_Exception::os_get_call_info(mcp, hash);
}
bool c_RuntimeException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_RuntimeException = {
  c_RuntimeException::os_getInit,
  c_RuntimeException::os_get,
  c_RuntimeException::os_lval,
  c_RuntimeException::os_invoke,
  c_RuntimeException::os_constant,
  c_RuntimeException::os_get_call_info
};
void c_RuntimeException::init() {
  c_Exception::init();
}
/* SRC: classes/exception.php line 10 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Exception
Variant c_Exception::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_RETURN_NAMSTR(0x0B197E8F85F4DA21LL, NAMSTR(s_sys_ss90291821, "previous"),
                         null, 8);
      break;
    case 7:
      HASH_RETURN_NAMSTR(0x3CCB986B2CF0A747LL, NAMSTR(s_sys_ss94c9ce77, "trace"),
                         null, 5);
      break;
    case 9:
      HASH_RETURN_NAMSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ssab7a1dec, "code"),
                         0LL, 4);
      break;
    case 10:
      HASH_RETURN_NAMSTR(0x04AB35CACF8C8C9ALL, NAMSTR(s_sys_ssddf8728c, "line"),
                         null, 4);
      break;
    case 11:
      HASH_RETURN_NAMSTR(0x0247CDBB94C9D47BLL, NAMSTR(s_sys_ss155366df, "message"),
                         NAMSTR(s_sys_ss00000000, ""), 7);
      break;
    case 15:
      HASH_RETURN_NAMSTR(0x7863294A8F33D14FLL, NAMSTR(s_sys_ss8ce7db5b, "file"),
                         null, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Exception
Variant c_Exception::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Exception
Variant &c_Exception::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Exception
void c_Exception::o_getArray(Array &props, bool pubOnly) const {
  if (!pubOnly) if (isInitialized(m_message)) props.lvalAt(NAMSTR(s_sys_ss155366df, "message"), AccessFlags::Key).setWithRef(m_message);
  if (!pubOnly) if (isInitialized(m_code)) props.lvalAt(NAMSTR(s_sys_ssab7a1dec, "code"), AccessFlags::Key).setWithRef(m_code);
  if (!pubOnly) if (isInitialized(m_previous)) props.lvalAt(NAMSTR(s_sys_ss90291821, "previous"), AccessFlags::Key).setWithRef(m_previous);
  if (!pubOnly) if (isInitialized(m_file)) props.lvalAt(NAMSTR(s_sys_ss8ce7db5b, "file"), AccessFlags::Key).setWithRef(m_file);
  if (!pubOnly) if (isInitialized(m_line)) props.lvalAt(NAMSTR(s_sys_ssddf8728c, "line"), AccessFlags::Key).setWithRef(m_line);
  if (!pubOnly) if (isInitialized(m_trace)) props.lvalAt(NAMSTR(s_sys_ss94c9ce77, "trace"), AccessFlags::Key).setWithRef(m_trace);
  c_ObjectData::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Exception
void c_Exception::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Exception
Variant * c_Exception::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Exception
Variant * c_Exception::o_realPropPublic(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_REALPROP_STRING(0x0B197E8F85F4DA21LL, "previous", 8, previous);
      break;
    case 7:
      HASH_REALPROP_STRING(0x3CCB986B2CF0A747LL, "trace", 5, trace);
      break;
    case 9:
      HASH_REALPROP_STRING(0x58C72230857ACDB9LL, "code", 4, code);
      break;
    case 10:
      HASH_REALPROP_STRING(0x04AB35CACF8C8C9ALL, "line", 4, line);
      break;
    case 11:
      HASH_REALPROP_STRING(0x0247CDBB94C9D47BLL, "message", 7, message);
      break;
    case 15:
      HASH_REALPROP_STRING(0x7863294A8F33D14FLL, "file", 4, file);
      break;
    default:
      break;
  }
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Exception
Variant * c_Exception::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Exception
Variant c_Exception::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Exception
IMPLEMENT_CLASS(Exception)
bool c_Exception::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 0:
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_Exception::cloneImpl() {
  c_Exception *obj = NEWOBJ(c_Exception)();
  c_Exception::cloneSet(obj);
  return obj;
}
void c_Exception::cloneSet(ObjectData *cl) {
  c_Exception *clone = static_cast<c_Exception*>(cl);
  ObjectData::cloneSet(clone);
  clone->m_message.setWithRef(m_message);
  clone->m_code.setWithRef(m_code);
  clone->m_previous.setWithRef(m_previous);
  clone->m_file.setWithRef(m_file);
  clone->m_line.setWithRef(m_line);
  clone->m_trace.setWithRef(m_trace);
}
CallInfo c_Exception::ci_getmessage((void*)&c_Exception::i_getmessage, (void*)&c_Exception::ifa_getmessage, 0, 4, 0x0000000000000000LL);
CallInfo c_Exception::ci___tostring((void*)&c_Exception::i___tostring, (void*)&c_Exception::ifa___tostring, 0, 4, 0x0000000000000000LL);
CallInfo c_Exception::ci___construct((void*)&c_Exception::i___construct, (void*)&c_Exception::ifa___construct, 3, 4, 0x0000000000000000LL);
CallInfo c_Exception::ci_getcode((void*)&c_Exception::i_getcode, (void*)&c_Exception::ifa_getcode, 0, 4, 0x0000000000000000LL);
CallInfo c_Exception::ci_getprevious((void*)&c_Exception::i_getprevious, (void*)&c_Exception::ifa_getprevious, 0, 4, 0x0000000000000000LL);
CallInfo c_Exception::ci_getline((void*)&c_Exception::i_getline, (void*)&c_Exception::ifa_getline, 0, 4, 0x0000000000000000LL);
CallInfo c_Exception::ci___init__((void*)&c_Exception::i___init__, (void*)&c_Exception::ifa___init__, 0, 4, 0x0000000000000000LL);
CallInfo c_Exception::ci_getfile((void*)&c_Exception::i_getfile, (void*)&c_Exception::ifa_getfile, 0, 4, 0x0000000000000000LL);
CallInfo c_Exception::ci_gettraceasstring((void*)&c_Exception::i_gettraceasstring, (void*)&c_Exception::ifa_gettraceasstring, 0, 4, 0x0000000000000000LL);
CallInfo c_Exception::ci_gettrace((void*)&c_Exception::i_gettrace, (void*)&c_Exception::ifa_gettrace, 0, 4, 0x0000000000000000LL);
Variant c_Exception::i_getmessage(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
  return (self->t_getmessage());
}
Variant c_Exception::i___tostring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
  return (self->t___tostring());
}
Variant c_Exception::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("Exception::__construct", 3, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2), null);
  }
}
Variant c_Exception::i_getcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
  return (self->t_getcode());
}
Variant c_Exception::i_getprevious(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getPrevious", 0, 1);
  return (self->t_getprevious());
}
Variant c_Exception::i_getline(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
  return (self->t_getline());
}
Variant c_Exception::i___init__(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
  return (self->t___init__(), null);
}
Variant c_Exception::i_getfile(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
  return (self->t_getfile());
}
Variant c_Exception::i_gettraceasstring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
  return (self->t_gettraceasstring());
}
Variant c_Exception::i_gettrace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
  return (self->t_gettrace());
}
Variant c_Exception::ifa_getmessage(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
  return (self->t_getmessage());
}
Variant c_Exception::ifa___tostring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
  return (self->t___tostring());
}
Variant c_Exception::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("Exception::__construct", 3, 2);
  if (count <= 0) return (self->t___construct(), null);
  CVarRef arg0((a0));
  if (count <= 1) return (self->t___construct(arg0), null);
  CVarRef arg1((a1));
  if (count <= 2) return (self->t___construct(arg0, arg1), null);
  CVarRef arg2((a2));
  return (self->t___construct(arg0, arg1, arg2), null);
}
Variant c_Exception::ifa_getcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
  return (self->t_getcode());
}
Variant c_Exception::ifa_getprevious(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getPrevious", 0, 1);
  return (self->t_getprevious());
}
Variant c_Exception::ifa_getline(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
  return (self->t_getline());
}
Variant c_Exception::ifa___init__(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
  return (self->t___init__(), null);
}
Variant c_Exception::ifa_getfile(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
  return (self->t_getfile());
}
Variant c_Exception::ifa_gettraceasstring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
  return (self->t_gettraceasstring());
}
Variant c_Exception::ifa_gettrace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Exception *self = NULL;
  p_Exception pobj;
  if (mcp.obj) {
    self = static_cast<c_Exception*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
  return (self->t_gettrace());
}
bool c_Exception::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ssa26bedd7, "__init__")) {
        mcp.ci = &c_Exception::ci___init__;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ssb0933c52, "getLine")) {
        mcp.ci = &c_Exception::ci_getline;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss7854bd7b, "getTraceAsString")) {
        mcp.ci = &c_Exception::ci_gettraceasstring;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss6c5c70db, "getCode")) {
        mcp.ci = &c_Exception::ci_getcode;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss4f2f48c7, "getMessage")) {
        mcp.ci = &c_Exception::ci_getmessage;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6974a1cc, "__toString")) {
        mcp.ci = &c_Exception::ci___tostring;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x7DB5D49CF5DC0795LL, NAMSTR(s_sys_ssb0aae83f, "getPrevious")) {
        mcp.ci = &c_Exception::ci_getprevious;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ssccbba71e, "getTrace")) {
        mcp.ci = &c_Exception::ci_gettrace;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ssf401cc22, "getFile")) {
        mcp.ci = &c_Exception::ci_getfile;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ssa1b87da7, "__construct")) {
        mcp.ci = &c_Exception::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_Exception::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_Exception *c_Exception::create(Variant v_message //  = NAMSTR(s_sys_ss00000000, "")
, Variant v_code //  = 0LL
, Variant v_previous //  = null
) {
  CountableHelper h(this);
  init();
  t___construct(v_message, v_code, v_previous);
  return this;
}
void c_Exception::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 3) throw_toomany_arguments("Exception::__construct", 3, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2));
  } while (false);
}
void c_Exception::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Exception::ci___construct;
  mcp.obj = this;
}
void c_Exception::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  unsigned int i = 0;
  do {
    if (i == params.size()) break;
    a0.assignVal(params[i]->eval(env));
    i++;
    if (i == params.size()) break;
    a1.assignVal(params[i]->eval(env));
    i++;
    if (i == params.size()) break;
    a2.assignVal(params[i]->eval(env));
    i++;
  } while(false);
  for (; i != params.size(); ++i) {
    params[i]->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 3) throw_toomany_arguments("Exception::__construct", 3, 1);
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else (t___construct(a0, a1, a2), null);
}
struct ObjectStaticCallbacks cw_Exception = {
  c_Exception::os_getInit,
  c_Exception::os_get,
  c_Exception::os_lval,
  c_Exception::os_invoke,
  c_Exception::os_constant,
  c_Exception::os_get_call_info
};
void c_Exception::init() {
  m_message = NAMSTR(s_sys_ss00000000, "");
  m_code = 0LL;
  m_previous = null;
  m_file = null;
  m_line = null;
  m_trace = null;
  {CountableHelper h(this); t___init__();}
}
/* SRC: classes/exception.php line 24 */
void c_Exception::t___init__() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::__init__);
  Variant v_top;
  Variant v_frame;

  {
    const Array &tmp0((x_debug_backtrace()));
    m_trace = tmp0;
  }
  LOOP_COUNTER(1);
  {
    while (!(empty(m_trace))) {
      LOOP_COUNTER_CHECK(1);
      {
        {
          Variant tmp0((m_trace.rvalAt(0LL, AccessFlags::Error)));
          v_top.assignVal(tmp0);
        }
        {
          bool tmp0;
          {
            bool tmp1 = (empty(v_top, NAMSTR(s_sys_ssc82dbd12, "class"), true));
            if (!tmp1) {
              bool tmp2 = ((toBoolean(x_strcasecmp(toString(v_top.rvalAt(NAMSTR(s_sys_ss52403931, "function"), AccessFlags::Error_Key)), NAMSTR(s_sys_ssa26bedd7, "__init__"))) && toBoolean(x_strcasecmp(toString(v_top.rvalAt(NAMSTR(s_sys_ss52403931, "function"), AccessFlags::Error_Key)), NAMSTR(s_sys_ssa1b87da7, "__construct")))));
              if (tmp2) {
                const String &tmp3((toString(v_top.rvalAt(NAMSTR(s_sys_ss52403931, "function"), AccessFlags::Error_Key))));
                const String &tmp4((toString(v_top.rvalAt(NAMSTR(s_sys_ssc82dbd12, "class"), AccessFlags::Error_Key))));
                tmp2 = (toBoolean(x_strcasecmp(tmp3, tmp4)));
              }
              tmp1 = (tmp2);
            }
            bool tmp5 = (tmp1);
            if (!tmp5) {
              bool tmp6 = (toBoolean(x_strcasecmp(toString(v_top.rvalAt(NAMSTR(s_sys_ssc82dbd12, "class"), AccessFlags::Error_Key)), NAMSTR(s_sys_ssae8717ad, "exception"))));
              if (tmp6) {
                bool tmp7((x_is_subclass_of(v_top.rvalAt(NAMSTR(s_sys_ssc82dbd12, "class"), AccessFlags::Error_Key), NAMSTR(s_sys_ssae8717ad, "exception"))));
                tmp6 = (!(tmp7));
              }
              tmp5 = (tmp6);
            }
            tmp0 = (tmp5);
          }
          if (tmp0) {
            {
              break;
            }
          }
        }
        {
          const Variant &tmp0((x_array_shift(ref(m_trace))));
          v_frame.assignVal(tmp0);
        }
      }
    }
  }
  if (isset(v_frame, NAMSTR(s_sys_ss8ce7db5b, "file"), true)) {
    {
      Variant tmp0((v_frame.rvalAt(NAMSTR(s_sys_ss8ce7db5b, "file"), AccessFlags::Error_Key)));
      m_file.assignVal(tmp0);
    }
  }
  if (isset(v_frame, NAMSTR(s_sys_ssddf8728c, "line"), true)) {
    {
      Variant tmp0((v_frame.rvalAt(NAMSTR(s_sys_ssddf8728c, "line"), AccessFlags::Error_Key)));
      m_line.assignVal(tmp0);
    }
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 45 */
void c_Exception::t___construct(Variant v_message //  = NAMSTR(s_sys_ss00000000, "")
, Variant v_code //  = 0LL
, Variant v_previous //  = null
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::__construct);
  bool oldInCtor = gasInCtor(true);
  if(!f_is_null(v_previous) && !v_previous.instanceof(NAMSTR(s_sys_ssae8717ad, "exception"))) {
    throw_unexpected_argument_type(3,"Exception::__construct()","exception",v_previous);
    return;
  }
  m_message.assignVal(v_message);
  m_code.assignVal(v_code);
  m_previous.assignVal(v_previous);
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 60 */
Variant c_Exception::t_getmessage() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getMessage);
  return m_message;
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 73 */
Variant c_Exception::t_getprevious() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getPrevious);
  return m_previous;
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 86 */
Variant c_Exception::t_getcode() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getCode);
  return m_code;
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 100 */
Variant c_Exception::t_getfile() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getFile);
  return m_file;
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 114 */
Variant c_Exception::t_getline() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getLine);
  return m_line;
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 127 */
Variant c_Exception::t_gettrace() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getTrace);
  return m_trace;
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 140 */
String c_Exception::t_gettraceasstring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getTraceAsString);
  int64 v_i = 0;
  String v_s;
  Variant v_frame;

  v_i = 0LL;
  v_s = NAMSTR(s_sys_ss00000000, "");
  {
    LOOP_COUNTER(1);
    Variant map2 = t_gettrace();
    {
      StringBuffer tmp_sbuf_v_s(512);
      for (ArrayIter iter3 = map2.begin(s_class_name, true); !iter3.end(); iter3.next()) {
        LOOP_COUNTER_CHECK(1);
        iter3.second(v_frame);
        {
          if (!(x_is_array(v_frame))) {
            continue;
          }
          {
            StringBuffer tmp0_buf;
            tmp0_buf.append("#", 1);
            tmp0_buf.append(toString(v_i));
            tmp0_buf.append(" ", 1);
            tmp0_buf.append(toString((isset(v_frame, NAMSTR(s_sys_ss8ce7db5b, "file"), true) ? ((Variant)(v_frame.rvalAt(NAMSTR(s_sys_ss8ce7db5b, "file"), AccessFlags::Error_Key))) : ((Variant)(NAMSTR(s_sys_ss00000000, ""))))));
            tmp0_buf.append("(", 1);
            tmp0_buf.append(toString((isset(v_frame, NAMSTR(s_sys_ssddf8728c, "line"), true) ? ((Variant)(v_frame.rvalAt(NAMSTR(s_sys_ssddf8728c, "line"), AccessFlags::Error_Key))) : ((Variant)(NAMSTR(s_sys_ss00000000, ""))))));
            tmp0_buf.append("): ", 3);
            Variant tmp1;
            if (isset(v_frame, NAMSTR(s_sys_ssc82dbd12, "class"), true)) {
              const String &tmp2((toString(v_frame.rvalAt(NAMSTR(s_sys_ssc82dbd12, "class"), AccessFlags::Error_Key))));
              const String &tmp3((toString(v_frame.rvalAt(NAMSTR(s_sys_ss724a760a, "type"), AccessFlags::Error_Key))));
              tmp1 = (concat(tmp2, tmp3));
            } else {
              tmp1 = (NAMSTR(s_sys_ss00000000, ""));
            }
            tmp0_buf.append(toString(tmp1));
            tmp0_buf.append(toString(v_frame.rvalAt(NAMSTR(s_sys_ss52403931, "function"), AccessFlags::Error_Key)));
            tmp0_buf.append("()\n", 3);
            CStrRef tmp0(tmp0_buf.detach());
            tmp_sbuf_v_s.add(tmp0);
          }
          v_i++;
        }
      }
      concat_assign(v_s, tmp_sbuf_v_s.detach());
    }
  }
  concat_assign(v_s, concat3(NAMSTR(s_sys_ss8dc355aa, "#"), toString(v_i), NAMSTR(s_sys_ssfab32402, " {main}")));
  return v_s;
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 159 */
String c_Exception::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::__toString);
  {
    StringBuffer tmp0_buf;
    tmp0_buf.append("exception '", 11);
    tmp0_buf.append(toString(x_get_class(VarNR(GET_THIS_TYPED(Exception)))));
    tmp0_buf.append("' with message '", 16);
    tmp0_buf.append(toString(t_getmessage()));
    tmp0_buf.append("' in ", 5);
    tmp0_buf.append(toString(t_getfile()));
    tmp0_buf.append(":", 1);
    tmp0_buf.append(toString(t_getline()));
    tmp0_buf.append("\nStack trace:\n", 14);
    tmp0_buf.append(t_gettraceasstring());
    CStrRef tmp0(tmp0_buf.detach());
    return tmp0;
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 286 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ErrorException
Variant c_ErrorException::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_RETURN_NAMSTR(0x4FDAA620FA5F15F9LL, NAMSTR(s_sys_ssb84c8cfa, "severity"),
                         null, 8);
      break;
    default:
      break;
  }
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ErrorException
Variant c_ErrorException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ErrorException
Variant &c_ErrorException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ErrorException
void c_ErrorException::o_getArray(Array &props, bool pubOnly) const {
  if (!pubOnly) if (isInitialized(m_severity)) props.lvalAt(NAMSTR(s_sys_ssb84c8cfa, "severity"), AccessFlags::Key).setWithRef(m_severity);
  c_Exception::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ErrorException
void c_ErrorException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ErrorException
Variant * c_ErrorException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ErrorException
Variant * c_ErrorException::o_realPropPublic(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_REALPROP_STRING(0x4FDAA620FA5F15F9LL, "severity", 8, severity);
      break;
    default:
      break;
  }
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ErrorException
Variant * c_ErrorException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ErrorException
Variant c_ErrorException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ErrorException
IMPLEMENT_CLASS(ErrorException)
bool c_ErrorException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 3) {
    case 0:
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      break;
    case 3:
      HASH_INSTANCEOF(0x69EDCA1CC29CFE0BLL, NAMSTR(s_sys_ssac0b0f60, "ErrorException"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_ErrorException::cloneImpl() {
  c_ErrorException *obj = NEWOBJ(c_ErrorException)();
  c_ErrorException::cloneSet(obj);
  return obj;
}
void c_ErrorException::cloneSet(ObjectData *cl) {
  c_ErrorException *clone = static_cast<c_ErrorException*>(cl);
  c_Exception::cloneSet(clone);
  clone->m_severity.setWithRef(m_severity);
}
CallInfo c_ErrorException::ci___construct((void*)&c_ErrorException::i___construct, (void*)&c_ErrorException::ifa___construct, 5, 4, 0x0000000000000000LL);
CallInfo c_ErrorException::ci_getseverity((void*)&c_ErrorException::i_getseverity, (void*)&c_ErrorException::ifa_getseverity, 0, 4, 0x0000000000000000LL);
Variant c_ErrorException::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ErrorException *self = NULL;
  p_ErrorException pobj;
  if (mcp.obj) {
    self = static_cast<c_ErrorException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (self->t___construct(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant c_ErrorException::i_getseverity(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ErrorException *self = NULL;
  p_ErrorException pobj;
  if (mcp.obj) {
    self = static_cast<c_ErrorException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
  return (self->t_getseverity());
}
Variant c_ErrorException::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ErrorException *self = NULL;
  p_ErrorException pobj;
  if (mcp.obj) {
    self = static_cast<c_ErrorException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
  if (count <= 0) return (self->t___construct(), null);
  CVarRef arg0((a0));
  if (count <= 1) return (self->t___construct(arg0), null);
  CVarRef arg1((a1));
  if (count <= 2) return (self->t___construct(arg0, arg1), null);
  CVarRef arg2((a2));
  if (count <= 3) return (self->t___construct(arg0, arg1, arg2), null);
  CVarRef arg3((a3));
  if (count <= 4) return (self->t___construct(arg0, arg1, arg2, arg3), null);
  CVarRef arg4((a4));
  return (self->t___construct(arg0, arg1, arg2, arg3, arg4), null);
}
Variant c_ErrorException::ifa_getseverity(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ErrorException *self = NULL;
  p_ErrorException pobj;
  if (mcp.obj) {
    self = static_cast<c_ErrorException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
  return (self->t_getseverity());
}
bool c_ErrorException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ssa1b87da7, "__construct")) {
        mcp.ci = &c_ErrorException::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x4B378D0258AF461FLL, NAMSTR(s_sys_ssd323f9f4, "getSeverity")) {
        mcp.ci = &c_ErrorException::ci_getseverity;
        return true;
      }
      break;
    default:
      break;
  }
  return c_Exception::os_get_call_info(mcp, hash);
}
bool c_ErrorException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_ErrorException *c_ErrorException::create(Variant v_message //  = NAMSTR(s_sys_ss00000000, "")
, Variant v_code //  = 0LL
, Variant v_severity //  = 0LL
, Variant v_filename //  = null
, Variant v_lineno //  = null
) {
  CountableHelper h(this);
  init();
  t___construct(v_message, v_code, v_severity, v_filename, v_lineno);
  return this;
}
void c_ErrorException::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 5) throw_toomany_arguments("ErrorException::__construct", 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_ErrorException::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_ErrorException::ci___construct;
  mcp.obj = this;
}
void c_ErrorException::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  unsigned int i = 0;
  do {
    if (i == params.size()) break;
    a0.assignVal(params[i]->eval(env));
    i++;
    if (i == params.size()) break;
    a1.assignVal(params[i]->eval(env));
    i++;
    if (i == params.size()) break;
    a2.assignVal(params[i]->eval(env));
    i++;
    if (i == params.size()) break;
    a3.assignVal(params[i]->eval(env));
    i++;
    if (i == params.size()) break;
    a4.assignVal(params[i]->eval(env));
    i++;
  } while(false);
  for (; i != params.size(); ++i) {
    params[i]->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 5) throw_toomany_arguments("ErrorException::__construct", 5, 1);
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
struct ObjectStaticCallbacks cw_ErrorException = {
  c_ErrorException::os_getInit,
  c_ErrorException::os_get,
  c_ErrorException::os_lval,
  c_ErrorException::os_invoke,
  c_ErrorException::os_constant,
  c_ErrorException::os_get_call_info
};
void c_ErrorException::init() {
  c_Exception::init();
  m_severity = null;
}
/* SRC: classes/exception.php line 288 */
void c_ErrorException::t___construct(Variant v_message //  = NAMSTR(s_sys_ss00000000, "")
, Variant v_code //  = 0LL
, Variant v_severity //  = 0LL
, Variant v_filename //  = null
, Variant v_lineno //  = null
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ErrorException, ErrorException::__construct);
  bool oldInCtor = gasInCtor(true);
  c_Exception::t___construct(v_message, v_code);
  m_severity.assignVal(v_severity);
  if (!(x_is_null(v_filename))) {
    {
      m_file.assignVal(v_filename);
    }
  }
  if (!(x_is_null(v_lineno))) {
    {
      m_line.assignVal(v_lineno);
    }
  }
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 308 */
Variant c_ErrorException::t_getseverity() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ErrorException, ErrorException::getSeverity);
  return m_severity;
}
namespace hphp_impl_splitter {}
/* SRC: classes/exception.php line 183 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_BadFunctionCallException
Variant c_BadFunctionCallException::os_getInit(CStrRef s) {
  return c_LogicException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_BadFunctionCallException
Variant c_BadFunctionCallException::os_get(CStrRef s) {
  return c_LogicException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_BadFunctionCallException
Variant &c_BadFunctionCallException::os_lval(CStrRef s) {
  return c_LogicException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_BadFunctionCallException
void c_BadFunctionCallException::o_getArray(Array &props, bool pubOnly) const {
  c_LogicException::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_BadFunctionCallException
void c_BadFunctionCallException::o_setArray(CArrRef props) {
  c_LogicException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_BadFunctionCallException
Variant * c_BadFunctionCallException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_BadFunctionCallException
Variant * c_BadFunctionCallException::o_realPropPublic(CStrRef s, int flags) const {
  return c_LogicException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_BadFunctionCallException
Variant * c_BadFunctionCallException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_BadFunctionCallException
Variant c_BadFunctionCallException::os_constant(const char *s) {
  return c_LogicException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_BadFunctionCallException
IMPLEMENT_CLASS(BadFunctionCallException)
bool c_BadFunctionCallException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_INSTANCEOF(0x4860DC2F9B0E6D4BLL, NAMSTR(s_sys_ssa37fe34e, "LogicException"));
      break;
    case 4:
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      break;
    case 6:
      HASH_INSTANCEOF(0x66282FC8E4EF4E46LL, NAMSTR(s_sys_ss57956ee3, "BadFunctionCallException"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_BadFunctionCallException::cloneImpl() {
  c_BadFunctionCallException *obj = NEWOBJ(c_BadFunctionCallException)();
  c_BadFunctionCallException::cloneSet(obj);
  return obj;
}
void c_BadFunctionCallException::cloneSet(ObjectData *cl) {
  c_BadFunctionCallException *clone = static_cast<c_BadFunctionCallException*>(cl);
  c_LogicException::cloneSet(clone);
}
bool c_BadFunctionCallException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_LogicException::os_get_call_info(mcp, hash);
}
bool c_BadFunctionCallException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_BadFunctionCallException = {
  c_BadFunctionCallException::os_getInit,
  c_BadFunctionCallException::os_get,
  c_BadFunctionCallException::os_lval,
  c_BadFunctionCallException::os_invoke,
  c_BadFunctionCallException::os_constant,
  c_BadFunctionCallException::os_get_call_info
};
void c_BadFunctionCallException::init() {
  c_LogicException::init();
}
/* SRC: classes/exception.php line 219 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LengthException
Variant c_LengthException::os_getInit(CStrRef s) {
  return c_LogicException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_LengthException
Variant c_LengthException::os_get(CStrRef s) {
  return c_LogicException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LengthException
Variant &c_LengthException::os_lval(CStrRef s) {
  return c_LogicException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_LengthException
void c_LengthException::o_getArray(Array &props, bool pubOnly) const {
  c_LogicException::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_LengthException
void c_LengthException::o_setArray(CArrRef props) {
  c_LogicException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_LengthException
Variant * c_LengthException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LengthException
Variant * c_LengthException::o_realPropPublic(CStrRef s, int flags) const {
  return c_LogicException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LengthException
Variant * c_LengthException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_LengthException
Variant c_LengthException::os_constant(const char *s) {
  return c_LogicException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_LengthException
IMPLEMENT_CLASS(LengthException)
bool c_LengthException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_INSTANCEOF(0x3CAE91CFA2AAD16BLL, NAMSTR(s_sys_ssadd5fee2, "LengthException"));
      HASH_INSTANCEOF(0x4860DC2F9B0E6D4BLL, NAMSTR(s_sys_ssa37fe34e, "LogicException"));
      break;
    case 4:
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_LengthException::cloneImpl() {
  c_LengthException *obj = NEWOBJ(c_LengthException)();
  c_LengthException::cloneSet(obj);
  return obj;
}
void c_LengthException::cloneSet(ObjectData *cl) {
  c_LengthException *clone = static_cast<c_LengthException*>(cl);
  c_LogicException::cloneSet(clone);
}
bool c_LengthException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_LogicException::os_get_call_info(mcp, hash);
}
bool c_LengthException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_LengthException = {
  c_LengthException::os_getInit,
  c_LengthException::os_get,
  c_LengthException::os_lval,
  c_LengthException::os_invoke,
  c_LengthException::os_constant,
  c_LengthException::os_get_call_info
};
void c_LengthException::init() {
  c_LogicException::init();
}
/* SRC: classes/exception.php line 202 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DomainException
Variant c_DomainException::os_getInit(CStrRef s) {
  return c_LogicException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DomainException
Variant c_DomainException::os_get(CStrRef s) {
  return c_LogicException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DomainException
Variant &c_DomainException::os_lval(CStrRef s) {
  return c_LogicException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DomainException
void c_DomainException::o_getArray(Array &props, bool pubOnly) const {
  c_LogicException::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DomainException
void c_DomainException::o_setArray(CArrRef props) {
  c_LogicException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DomainException
Variant * c_DomainException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DomainException
Variant * c_DomainException::o_realPropPublic(CStrRef s, int flags) const {
  return c_LogicException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DomainException
Variant * c_DomainException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DomainException
Variant c_DomainException::os_constant(const char *s) {
  return c_LogicException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DomainException
IMPLEMENT_CLASS(DomainException)
bool c_DomainException::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_INSTANCEOF(0x4860DC2F9B0E6D4BLL, NAMSTR(s_sys_ssa37fe34e, "LogicException"));
      break;
    case 4:
      HASH_INSTANCEOF(0x70D4A29DE6A7BA84LL, NAMSTR(s_sys_ssb65737a4, "DomainException"));
      HASH_INSTANCEOF(0x47D93E6F80B66A94LL, NAMSTR(s_sys_sseacf71c9, "Exception"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_DomainException::cloneImpl() {
  c_DomainException *obj = NEWOBJ(c_DomainException)();
  c_DomainException::cloneSet(obj);
  return obj;
}
void c_DomainException::cloneSet(ObjectData *cl) {
  c_DomainException *clone = static_cast<c_DomainException*>(cl);
  c_LogicException::cloneSet(clone);
}
bool c_DomainException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  return c_LogicException::os_get_call_info(mcp, hash);
}
bool c_DomainException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
struct ObjectStaticCallbacks cw_DomainException = {
  c_DomainException::os_getInit,
  c_DomainException::os_get,
  c_DomainException::os_lval,
  c_DomainException::os_invoke,
  c_DomainException::os_constant,
  c_DomainException::os_get_call_info
};
void c_DomainException::init() {
  c_LogicException::init();
}
Object co_UnexpectedValueException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_UnexpectedValueException)())->dynCreate(params, init));
}
Object coo_UnexpectedValueException() {
  Object r(NEWOBJ(c_UnexpectedValueException)());
  r->init();
  return r;
}
Object co_OverflowException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_OverflowException)())->dynCreate(params, init));
}
Object coo_OverflowException() {
  Object r(NEWOBJ(c_OverflowException)());
  r->init();
  return r;
}
Object co_OutOfBoundsException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_OutOfBoundsException)())->dynCreate(params, init));
}
Object coo_OutOfBoundsException() {
  Object r(NEWOBJ(c_OutOfBoundsException)());
  r->init();
  return r;
}
Object co_LogicException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_LogicException)())->dynCreate(params, init));
}
Object coo_LogicException() {
  Object r(NEWOBJ(c_LogicException)());
  r->init();
  return r;
}
Object co_RangeException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_RangeException)())->dynCreate(params, init));
}
Object coo_RangeException() {
  Object r(NEWOBJ(c_RangeException)());
  r->init();
  return r;
}
Object co_InvalidArgumentException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_InvalidArgumentException)())->dynCreate(params, init));
}
Object coo_InvalidArgumentException() {
  Object r(NEWOBJ(c_InvalidArgumentException)());
  r->init();
  return r;
}
Object co_UnderflowException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_UnderflowException)())->dynCreate(params, init));
}
Object coo_UnderflowException() {
  Object r(NEWOBJ(c_UnderflowException)());
  r->init();
  return r;
}
Object co_OutOfRangeException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_OutOfRangeException)())->dynCreate(params, init));
}
Object coo_OutOfRangeException() {
  Object r(NEWOBJ(c_OutOfRangeException)());
  r->init();
  return r;
}
Object co_BadMethodCallException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_BadMethodCallException)())->dynCreate(params, init));
}
Object coo_BadMethodCallException() {
  Object r(NEWOBJ(c_BadMethodCallException)());
  r->init();
  return r;
}
Object co_RuntimeException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_RuntimeException)())->dynCreate(params, init));
}
Object coo_RuntimeException() {
  Object r(NEWOBJ(c_RuntimeException)());
  r->init();
  return r;
}
Object co_Exception(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_Exception)())->dynCreate(params, init));
}
Object coo_Exception() {
  Object r(NEWOBJ(c_Exception)());
  r->init();
  return r;
}
Object co_ErrorException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_ErrorException)())->dynCreate(params, init));
}
Object coo_ErrorException() {
  Object r(NEWOBJ(c_ErrorException)());
  r->init();
  return r;
}
Object co_BadFunctionCallException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_BadFunctionCallException)())->dynCreate(params, init));
}
Object coo_BadFunctionCallException() {
  Object r(NEWOBJ(c_BadFunctionCallException)());
  r->init();
  return r;
}
Object co_LengthException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_LengthException)())->dynCreate(params, init));
}
Object coo_LengthException() {
  Object r(NEWOBJ(c_LengthException)());
  r->init();
  return r;
}
Object co_DomainException(CArrRef params, bool init /* = true */) {
  return Object((NEWOBJ(c_DomainException)())->dynCreate(params, init));
}
Object coo_DomainException() {
  Object r(NEWOBJ(c_DomainException)());
  r->init();
  return r;
}
Variant pm_php$classes$exception_php(bool incOnce /* = false */, LVariableTable* variables /* = NULL */, Globals *globals /* = get_globals() */) {
  PSEUDOMAIN_INJECTION_BUILTIN(run_init::classes/exception.php, pm_php$classes$exception_php);
  LVariableTable *gVariables __attribute__((__unused__)) = (LVariableTable *)g;
  return true;
}
namespace hphp_impl_splitter {}

///////////////////////////////////////////////////////////////////////////////
}
