// @generated by Thrift for thrift/compiler/test/fixtures/stream/src/module.thrift
// This file is probably not the place you want to edit!

//! Mock definitions for `module`.
//!
//! Client mocks. For every service, a struct TheService that implements
//! client::TheService.
//!
//! As an example of the generated API, for the following thrift service in
//! example.thrift:
//!
//! ```thrift
//! service MyService {
//!     FunctionResponse myFunction(
//!         1: FunctionRequest request,
//!     ) throws {
//!         1: StorageException s,
//!         2: NotFoundException n,
//!     ),
//!
//!     // other functions
//! }
//! ```
//!
//! we would end up with this mock object in an `example_mocks` crate:
//!
//! ```
//! # const _: &str = stringify! {
//! impl example_clients::MyService for MyService<'mock> {...}
//!
//! pub struct MyService<'mock> {
//!     pub myFunction: myFunction<'mock>,
//!     // ...
//! }
//!
//! impl myFunction<'mock> {
//!     // directly return the given success response
//!     pub fn ret(&self, value: FunctionResponse);
//!
//!     // invoke closure to compute success response
//!     pub fn mock(
//!         &self,
//!         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
//!     );
//!
//!     // invoke closure to compute response
//!     pub fn mock_result(
//!         &self,
//!         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, example_services::errors::MyFunctionExn> + Send + Sync + 'mock,
//!     );
//!
//!     // return one of the function's declared exceptions
//!     pub fn throw<E>(&self, exception: E)
//!     where
//!         E: Clone + Into<example_services::errors::MyFunctionExn> + Send + Sync + 'mock;
//! }
//! # };
//! ```
//!
//! The intended usage from a test would be:
//!
//! ```
//! # const _: &str = stringify! {
//! use std::sync::Arc;
//! use example_clients::MyService;
//!
//! #[tokio::test]
//! async fn test_my_client() {
//!     let mock = Arc::new(example_mocks::new::<dyn MyService>());
//!
//!     // directly return a success response
//!     let resp = FunctionResponse {...};
//!     mock.myFunction.ret(resp);
//!
//!     // or give a closure to compute the success response
//!     mock.myFunction.mock(|request| FunctionResponse {...});
//!
//!     // or throw one of the function's exceptions
//!     mock.myFunction.throw(StorageException::ItFailed);
//!
//!     // or compute a Result (useful if your exceptions aren't Clone)
//!     mock.myFunction.mock_result(|request| Err(...));
//!
//!     let out = do_the_thing(mock).await.unwrap();
//!     assert!(out.what_i_expected());
//! }
//!
//! async fn do_the_thing(
//!     client: Arc<dyn MyService + Send + Sync + 'static>,
//! ) -> Out {...}
//! # };
//! ```

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, unused_imports, clippy::all)]

pub(crate) use :: as types;
pub(crate) use :: as client;
pub(crate) use ::::errors;

pub fn new<'mock, Client>() -> Client::Mock<'mock>
where
    Client: ?::std::marker::Sized + DynClient,
{
    Client::mock()
}

pub trait DynClient {
    type Mock<'mock>;
    fn mock<'mock>() -> Self::Mock<'mock>;
}

pub struct PubSubStreamingService<'mock> {
    pub returnstream: r#impl::pub_sub_streaming_service::returnstream<'mock>,
    pub streamthrows: r#impl::pub_sub_streaming_service::streamthrows<'mock>,
    pub servicethrows: r#impl::pub_sub_streaming_service::servicethrows<'mock>,
    pub servicethrows2: r#impl::pub_sub_streaming_service::servicethrows2<'mock>,
    pub boththrows: r#impl::pub_sub_streaming_service::boththrows<'mock>,
    pub responseandstreamstreamthrows: r#impl::pub_sub_streaming_service::responseandstreamstreamthrows<'mock>,
    pub responseandstreamservicethrows: r#impl::pub_sub_streaming_service::responseandstreamservicethrows<'mock>,
    pub responseandstreamboththrows: r#impl::pub_sub_streaming_service::responseandstreamboththrows<'mock>,
    pub returnstreamFast: r#impl::pub_sub_streaming_service::returnstreamFast<'mock>,
    _marker: ::std::marker::PhantomData<&'mock ()>,
}

impl crate::DynClient for dyn ::::PubSubStreamingService {
    type Mock<'mock> = PubSubStreamingService<'mock>;
    fn mock<'mock>() -> Self::Mock<'mock> {
        PubSubStreamingService {
            returnstream: r#impl::pub_sub_streaming_service::returnstream::unimplemented(),
            streamthrows: r#impl::pub_sub_streaming_service::streamthrows::unimplemented(),
            servicethrows: r#impl::pub_sub_streaming_service::servicethrows::unimplemented(),
            servicethrows2: r#impl::pub_sub_streaming_service::servicethrows2::unimplemented(),
            boththrows: r#impl::pub_sub_streaming_service::boththrows::unimplemented(),
            responseandstreamstreamthrows: r#impl::pub_sub_streaming_service::responseandstreamstreamthrows::unimplemented(),
            responseandstreamservicethrows: r#impl::pub_sub_streaming_service::responseandstreamservicethrows::unimplemented(),
            responseandstreamboththrows: r#impl::pub_sub_streaming_service::responseandstreamboththrows::unimplemented(),
            returnstreamFast: r#impl::pub_sub_streaming_service::returnstreamFast::unimplemented(),
            _marker: ::std::marker::PhantomData,
        }
    }
}

impl<'mock> ::::PubSubStreamingService for PubSubStreamingService<'mock> {
    fn returnstream(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamError>> {
        let mut closure = self.returnstream.closure.lock().unwrap();
        let closure: &mut dyn ::std::ops::FnMut(::std::primitive::i32, ::std::primitive::i32) -> _ = &mut **closure;
        ::std::boxed::Box::pin(::futures::future::ready(closure(arg_i32_from.clone(), arg_i32_to.clone())))
    }
    fn streamthrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>, crate::errors::pub_sub_streaming_service::StreamthrowsError>> {
        let mut closure = self.streamthrows.closure.lock().unwrap();
        let closure: &mut dyn ::std::ops::FnMut(::std::primitive::i32) -> _ = &mut **closure;
        ::std::boxed::Box::pin(::futures::future::ready(closure(arg_foo.clone())))
    }
    fn servicethrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>, crate::errors::pub_sub_streaming_service::ServicethrowsError>> {
        let mut closure = self.servicethrows.closure.lock().unwrap();
        let closure: &mut dyn ::std::ops::FnMut(::std::primitive::i32) -> _ = &mut **closure;
        ::std::boxed::Box::pin(::futures::future::ready(closure(arg_foo.clone())))
    }
    fn servicethrows2(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>, crate::errors::pub_sub_streaming_service::Servicethrows2Error>> {
        let mut closure = self.servicethrows2.closure.lock().unwrap();
        let closure: &mut dyn ::std::ops::FnMut(::std::primitive::i32) -> _ = &mut **closure;
        ::std::boxed::Box::pin(::futures::future::ready(closure(arg_foo.clone())))
    }
    fn boththrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>, crate::errors::pub_sub_streaming_service::BoththrowsError>> {
        let mut closure = self.boththrows.closure.lock().unwrap();
        let closure: &mut dyn ::std::ops::FnMut(::std::primitive::i32) -> _ = &mut **closure;
        ::std::boxed::Box::pin(::futures::future::ready(closure(arg_foo.clone())))
    }
    fn responseandstreamstreamthrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError>> {
        let mut closure = self.responseandstreamstreamthrows.closure.lock().unwrap();
        let closure: &mut dyn ::std::ops::FnMut(::std::primitive::i32) -> _ = &mut **closure;
        ::std::boxed::Box::pin(::futures::future::ready(closure(arg_foo.clone())))
    }
    fn responseandstreamservicethrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError>> {
        let mut closure = self.responseandstreamservicethrows.closure.lock().unwrap();
        let closure: &mut dyn ::std::ops::FnMut(::std::primitive::i32) -> _ = &mut **closure;
        ::std::boxed::Box::pin(::futures::future::ready(closure(arg_foo.clone())))
    }
    fn responseandstreamboththrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError>> {
        let mut closure = self.responseandstreamboththrows.closure.lock().unwrap();
        let closure: &mut dyn ::std::ops::FnMut(::std::primitive::i32) -> _ = &mut **closure;
        ::std::boxed::Box::pin(::futures::future::ready(closure(arg_foo.clone())))
    }
    fn returnstreamFast(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamFastError>> {
        let mut closure = self.returnstreamFast.closure.lock().unwrap();
        let closure: &mut dyn ::std::ops::FnMut(::std::primitive::i32, ::std::primitive::i32) -> _ = &mut **closure;
        ::std::boxed::Box::pin(::futures::future::ready(closure(arg_i32_from.clone(), arg_i32_to.clone())))
    }
}

impl<'mock, T> ::::PubSubStreamingServiceExt<T> for PubSubStreamingService<'mock>
where
    T: ::fbthrift::Transport,
{    fn returnstream_with_rpc_opts(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
        _rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamError>> {
        <Self as ::::PubSubStreamingService>::returnstream(
            self,
            arg_i32_from,
            arg_i32_to,
        )
    }
    fn streamthrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        _rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>, crate::errors::pub_sub_streaming_service::StreamthrowsError>> {
        <Self as ::::PubSubStreamingService>::streamthrows(
            self,
            arg_foo,
        )
    }
    fn servicethrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        _rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>, crate::errors::pub_sub_streaming_service::ServicethrowsError>> {
        <Self as ::::PubSubStreamingService>::servicethrows(
            self,
            arg_foo,
        )
    }
    fn servicethrows2_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        _rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>, crate::errors::pub_sub_streaming_service::Servicethrows2Error>> {
        <Self as ::::PubSubStreamingService>::servicethrows2(
            self,
            arg_foo,
        )
    }
    fn boththrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        _rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>, crate::errors::pub_sub_streaming_service::BoththrowsError>> {
        <Self as ::::PubSubStreamingService>::boththrows(
            self,
            arg_foo,
        )
    }
    fn responseandstreamstreamthrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        _rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError>> {
        <Self as ::::PubSubStreamingService>::responseandstreamstreamthrows(
            self,
            arg_foo,
        )
    }
    fn responseandstreamservicethrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        _rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError>> {
        <Self as ::::PubSubStreamingService>::responseandstreamservicethrows(
            self,
            arg_foo,
        )
    }
    fn responseandstreamboththrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        _rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError>> {
        <Self as ::::PubSubStreamingService>::responseandstreamboththrows(
            self,
            arg_foo,
        )
    }
    fn returnstreamFast_with_rpc_opts(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
        _rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamFastError>> {
        <Self as ::::PubSubStreamingService>::returnstreamFast(
            self,
            arg_i32_from,
            arg_i32_to,
        )
    }

    fn transport(&self) -> &T {
        ::fbthrift::help::GetTransport::transport(self)
    }
}

impl<'mock, T> ::fbthrift::help::GetTransport<T> for PubSubStreamingService<'mock>
where
    T: ::fbthrift::Transport,
{
    fn transport(&self) -> &T {
        unimplemented!("PubSubStreamingServiceExt::transport is not implemented for mock client")
    }
}

pub mod r#impl {
    pub mod pub_sub_streaming_service {

        pub struct returnstream<'mock> {
            pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                dyn ::std::ops::FnMut(::std::primitive::i32, ::std::primitive::i32) -> ::std::result::Result<
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>,
                    ::::errors::pub_sub_streaming_service::ReturnstreamError,
                > + ::std::marker::Send + ::std::marker::Sync + 'mock,
            >>,
        }

        #[allow(clippy::redundant_closure)]
        impl<'mock> returnstream<'mock> {
            pub(crate) fn unimplemented() -> Self {
                Self {
                    closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::primitive::i32, _: ::std::primitive::i32| panic!(
                        "{}::{} is not mocked",
                        "PubSubStreamingService",
                        "returnstream",
                    ))),
                }
            }

            pub fn ret(&self, _value: ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>) {
                unimplemented!("Mocking streams is not yet implemented, as value isn't cloneable");
            }

            pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32, ::std::primitive::i32) -> ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |i32_from, i32_to| ::std::result::Result::Ok(mock(i32_from, i32_to)));
            }

            pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32, ::std::primitive::i32) -> ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>, ::::errors::pub_sub_streaming_service::ReturnstreamError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |i32_from, i32_to| mock(i32_from, i32_to));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: ::std::convert::Into<::::errors::pub_sub_streaming_service::ReturnstreamError>,
                E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |_: ::std::primitive::i32, _: ::std::primitive::i32| ::std::result::Result::Err(exception.clone().into()));
            }
        }

        pub struct streamthrows<'mock> {
            pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                dyn ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>,
                    ::::errors::pub_sub_streaming_service::StreamthrowsError,
                > + ::std::marker::Send + ::std::marker::Sync + 'mock,
            >>,
        }

        #[allow(clippy::redundant_closure)]
        impl<'mock> streamthrows<'mock> {
            pub(crate) fn unimplemented() -> Self {
                Self {
                    closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::primitive::i32| panic!(
                        "{}::{} is not mocked",
                        "PubSubStreamingService",
                        "streamthrows",
                    ))),
                }
            }

            pub fn ret(&self, _value: ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>) {
                unimplemented!("Mocking streams is not yet implemented, as value isn't cloneable");
            }

            pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| ::std::result::Result::Ok(mock(foo)));
            }

            pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>, ::::errors::pub_sub_streaming_service::StreamthrowsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| mock(foo));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: ::std::convert::Into<::::errors::pub_sub_streaming_service::StreamthrowsError>,
                E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |_: ::std::primitive::i32| ::std::result::Result::Err(exception.clone().into()));
            }
        }

        pub struct servicethrows<'mock> {
            pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                dyn ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>,
                    ::::errors::pub_sub_streaming_service::ServicethrowsError,
                > + ::std::marker::Send + ::std::marker::Sync + 'mock,
            >>,
        }

        #[allow(clippy::redundant_closure)]
        impl<'mock> servicethrows<'mock> {
            pub(crate) fn unimplemented() -> Self {
                Self {
                    closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::primitive::i32| panic!(
                        "{}::{} is not mocked",
                        "PubSubStreamingService",
                        "servicethrows",
                    ))),
                }
            }

            pub fn ret(&self, _value: ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>) {
                unimplemented!("Mocking streams is not yet implemented, as value isn't cloneable");
            }

            pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| ::std::result::Result::Ok(mock(foo)));
            }

            pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>, ::::errors::pub_sub_streaming_service::ServicethrowsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| mock(foo));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: ::std::convert::Into<::::errors::pub_sub_streaming_service::ServicethrowsError>,
                E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |_: ::std::primitive::i32| ::std::result::Result::Err(exception.clone().into()));
            }
        }

        pub struct servicethrows2<'mock> {
            pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                dyn ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>,
                    ::::errors::pub_sub_streaming_service::Servicethrows2Error,
                > + ::std::marker::Send + ::std::marker::Sync + 'mock,
            >>,
        }

        #[allow(clippy::redundant_closure)]
        impl<'mock> servicethrows2<'mock> {
            pub(crate) fn unimplemented() -> Self {
                Self {
                    closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::primitive::i32| panic!(
                        "{}::{} is not mocked",
                        "PubSubStreamingService",
                        "servicethrows2",
                    ))),
                }
            }

            pub fn ret(&self, _value: ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>) {
                unimplemented!("Mocking streams is not yet implemented, as value isn't cloneable");
            }

            pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| ::std::result::Result::Ok(mock(foo)));
            }

            pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>, ::::errors::pub_sub_streaming_service::Servicethrows2Error> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| mock(foo));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: ::std::convert::Into<::::errors::pub_sub_streaming_service::Servicethrows2Error>,
                E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |_: ::std::primitive::i32| ::std::result::Result::Err(exception.clone().into()));
            }
        }

        pub struct boththrows<'mock> {
            pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                dyn ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>,
                    ::::errors::pub_sub_streaming_service::BoththrowsError,
                > + ::std::marker::Send + ::std::marker::Sync + 'mock,
            >>,
        }

        #[allow(clippy::redundant_closure)]
        impl<'mock> boththrows<'mock> {
            pub(crate) fn unimplemented() -> Self {
                Self {
                    closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::primitive::i32| panic!(
                        "{}::{} is not mocked",
                        "PubSubStreamingService",
                        "boththrows",
                    ))),
                }
            }

            pub fn ret(&self, _value: ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>) {
                unimplemented!("Mocking streams is not yet implemented, as value isn't cloneable");
            }

            pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| ::std::result::Result::Ok(mock(foo)));
            }

            pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>, ::::errors::pub_sub_streaming_service::BoththrowsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| mock(foo));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: ::std::convert::Into<::::errors::pub_sub_streaming_service::BoththrowsError>,
                E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |_: ::std::primitive::i32| ::std::result::Result::Err(exception.clone().into()));
            }
        }

        pub struct responseandstreamstreamthrows<'mock> {
            pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                dyn ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<
                    (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>),
                    ::::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError,
                > + ::std::marker::Send + ::std::marker::Sync + 'mock,
            >>,
        }

        #[allow(clippy::redundant_closure)]
        impl<'mock> responseandstreamstreamthrows<'mock> {
            pub(crate) fn unimplemented() -> Self {
                Self {
                    closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::primitive::i32| panic!(
                        "{}::{} is not mocked",
                        "PubSubStreamingService",
                        "responseandstreamstreamthrows",
                    ))),
                }
            }

            pub fn ret(&self, _value: (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>)) {
                unimplemented!("Mocking streams is not yet implemented, as value isn't cloneable");
            }

            pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>) + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| ::std::result::Result::Ok(mock(foo)));
            }

            pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>), ::::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| mock(foo));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: ::std::convert::Into<::::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError>,
                E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |_: ::std::primitive::i32| ::std::result::Result::Err(exception.clone().into()));
            }
        }

        pub struct responseandstreamservicethrows<'mock> {
            pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                dyn ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<
                    (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>),
                    ::::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError,
                > + ::std::marker::Send + ::std::marker::Sync + 'mock,
            >>,
        }

        #[allow(clippy::redundant_closure)]
        impl<'mock> responseandstreamservicethrows<'mock> {
            pub(crate) fn unimplemented() -> Self {
                Self {
                    closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::primitive::i32| panic!(
                        "{}::{} is not mocked",
                        "PubSubStreamingService",
                        "responseandstreamservicethrows",
                    ))),
                }
            }

            pub fn ret(&self, _value: (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>)) {
                unimplemented!("Mocking streams is not yet implemented, as value isn't cloneable");
            }

            pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>) + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| ::std::result::Result::Ok(mock(foo)));
            }

            pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>), ::::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| mock(foo));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: ::std::convert::Into<::::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError>,
                E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |_: ::std::primitive::i32| ::std::result::Result::Err(exception.clone().into()));
            }
        }

        pub struct responseandstreamboththrows<'mock> {
            pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                dyn ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<
                    (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>),
                    ::::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError,
                > + ::std::marker::Send + ::std::marker::Sync + 'mock,
            >>,
        }

        #[allow(clippy::redundant_closure)]
        impl<'mock> responseandstreamboththrows<'mock> {
            pub(crate) fn unimplemented() -> Self {
                Self {
                    closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::primitive::i32| panic!(
                        "{}::{} is not mocked",
                        "PubSubStreamingService",
                        "responseandstreamboththrows",
                    ))),
                }
            }

            pub fn ret(&self, _value: (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>)) {
                unimplemented!("Mocking streams is not yet implemented, as value isn't cloneable");
            }

            pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> (::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>) + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| ::std::result::Result::Ok(mock(foo)));
            }

            pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32) -> ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>), ::::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |foo| mock(foo));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: ::std::convert::Into<::::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError>,
                E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |_: ::std::primitive::i32| ::std::result::Result::Err(exception.clone().into()));
            }
        }

        pub struct returnstreamFast<'mock> {
            pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                dyn ::std::ops::FnMut(::std::primitive::i32, ::std::primitive::i32) -> ::std::result::Result<
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>,
                    ::::errors::pub_sub_streaming_service::ReturnstreamFastError,
                > + ::std::marker::Send + ::std::marker::Sync + 'mock,
            >>,
        }

        #[allow(clippy::redundant_closure)]
        impl<'mock> returnstreamFast<'mock> {
            pub(crate) fn unimplemented() -> Self {
                Self {
                    closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::primitive::i32, _: ::std::primitive::i32| panic!(
                        "{}::{} is not mocked",
                        "PubSubStreamingService",
                        "returnstreamFast",
                    ))),
                }
            }

            pub fn ret(&self, _value: ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>) {
                unimplemented!("Mocking streams is not yet implemented, as value isn't cloneable");
            }

            pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32, ::std::primitive::i32) -> ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |i32_from, i32_to| ::std::result::Result::Ok(mock(i32_from, i32_to)));
            }

            pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i32, ::std::primitive::i32) -> ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>, ::::errors::pub_sub_streaming_service::ReturnstreamFastError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |i32_from, i32_to| mock(i32_from, i32_to));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: ::std::convert::Into<::::errors::pub_sub_streaming_service::ReturnstreamFastError>,
                E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |_: ::std::primitive::i32, _: ::std::primitive::i32| ::std::result::Result::Err(exception.clone().into()));
            }
        }
    }
}
