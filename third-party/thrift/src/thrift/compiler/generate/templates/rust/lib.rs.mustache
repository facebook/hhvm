{{!

  Copyright (c) Meta Platforms, Inc. and its affiliates.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

}}// @{{}}generated by Thrift for {{program:autogen_path}}
// This file is probably not the place you want to edit!

{{#program:docs?}}
#![doc = {{program:docs}}]
{{/program:docs?}}
{{^program:multifile?}}
#![recursion_limit = "100000000"]
{{/program:multifile?}}
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals{{!
}}{{^program:multifile?}}, unused_crate_dependencies{{/program:multifile?}}{{!
}}, clippy::all)]
{{#program:include_srcs}}
include!("{{program:include_src}}");
{{/program:include_srcs}}

{{#program:serde?}}
{{! work around https://github.com/rust-lang/rust/issues/46991 }}
extern crate serde;
{{/program:serde?}}
{{#program:constants?}}
pub use self::consts::*;
{{/program:constants?}}
pub use self::errors::*;{{!
}}{{#program:types?}}
pub use self::types::*;{{!
}}{{/program:types?}}{{!
}}{{#program:constants?}}

/// Constant definitions for `{{program:name}}`.
pub mod consts {{>lib/block}}{{>lib/mod.consts}}}{{!
}}{{/program:constants?}}{{!
}}{{#program:types?}}

pub mod types;{{!
}}{{/program:types?}}{{!
}}{{#program:services?}}

#[doc(hidden)]
pub mod dependencies {{>lib/block}}{{>lib/mod.dependencies}}}

pub mod services {{>lib/block}}{{>lib/mod.services}}}

/// Client implementation for each service in `{{program:name}}`.
pub mod client {{>lib/block}}{{>lib/mod.client}}}

{{#program:server?}}
/// Server definitions for `{{program:name}}`.
pub mod server {{>lib/block}}{{>lib/mod.server}}}
{{/program:server?}}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
/// ```thrift
/// service MyService {
///     FunctionResponse myFunction(
///         1: FunctionRequest request,
///     ) throws {
///         1: StorageException s,
///         2: NotFoundException n,
///     ),
///
///     // other functions
/// }
/// ```
///
/// we would end up with this mock object under crate::mock::MyService:
///
/// ```
/// # const _: &str = stringify! {
/// impl crate::client::MyService for MyService<'mock> {...}
///
/// pub struct MyService<'mock> {
///     pub myFunction: myFunction<'mock>,
///     // ...
/// }
///
/// impl dyn crate::client::MyService {
///     pub fn mock<'mock>() -> MyService<'mock>;
/// }
///
/// impl myFunction<'mock> {
///     // directly return the given success response
///     pub fn ret(&self, value: FunctionResponse);
///
///     // invoke closure to compute success response
///     pub fn mock(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///     );
///
///     // invoke closure to compute response
///     pub fn mock_result(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock,
///     );
///
///     // return one of the function's declared exceptions
///     pub fn throw<E>(&self, exception: E)
///     where
///         E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
/// }
///
/// impl From<StorageException> for MyFunctionExn {...}
/// impl From<NotFoundException> for MyFunctionExn {...}
/// # };
/// ```
///
/// The intended usage from a test would be:
///
/// ```
/// # const _: &str = stringify! {
/// use std::sync::Arc;
/// use thrift_if::client::MyService;
///
/// #[test]
/// fn test_my_client() {
///     let mock = Arc::new(<dyn MyService>::mock());
///
///     // directly return a success response
///     let resp = FunctionResponse {...};
///     mock.myFunction.ret(resp);
///
///     // or give a closure to compute the success response
///     mock.myFunction.mock(|request| FunctionResponse {...});
///
///     // or throw one of the function's exceptions
///     mock.myFunction.throw(StorageException::ItFailed);
///
///     // or compute a Result (useful if your exceptions aren't Clone)
///     mock.myFunction.mock_result(|request| Err(...));
///
///     let out = do_the_thing(mock).wait().unwrap();
///     assert!(out.what_i_expected());
/// }
///
/// fn do_the_thing(
///     client: Arc<dyn MyService + Send + Sync + 'static>,
/// ) -> impl Future<Item = Out> {...}
/// # };
/// ```
pub mod mock {{>lib/block}}{{>lib/mod.mock}}}{{!
}}{{/program:services?}}

/// Error return types.
pub mod errors {{>lib/block}}{{>lib/mod.errors}}}{{!

}}{{#program:nonstandardTypes?}}

mod r#impl {{>lib/block}}{{>lib/mod.impl}}}{{!
}}{{/program:nonstandardTypes?}}
