#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/mcpp2-compare/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import thrift.py3.types
import importlib
from collections.abc import Mapping, Sequence, Set

"""
    This is a helper module to define py3 container types.
    All types defined here are re-exported in the parent `.types` module.
    Only `import` types defined here via the parent `.types` module.
    If you `import` them directly from here, you will get nasty import errors.
"""

_fbthrift__module_name__ = "module.types"

import module.types as _module_types
import includes.types as _includes_types
from thrift.py3.types import _ensure_py3_or_raise

def get_types_reflection():
    return importlib.import_module(
        "module.types_reflection"
    )

__all__ = []

class Map__string_i64(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_i64):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_i64._check_key_type_or_raise
            check_val = Map__string_i64._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_i64)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_i64()


Mapping.register(Map__string_i64)
__all__.append('Map__string_i64')


class Map__Empty_MyStruct(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__Empty_MyStruct):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__Empty_MyStruct._check_key_type_or_raise
            check_val = Map__Empty_MyStruct._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__Empty_MyStruct)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, _module_types.Empty)
        ):
            raise TypeError(f"{key!r} is not of type _module_types.Empty")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, _module_types.Empty):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, _module_types.MyStruct)
        ):
            raise TypeError(f"{item!r} is not of type _module_types.MyStruct")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__Empty_MyStruct()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> "Map__Empty_MyStruct":
        _keys = (
            _ensure_py3_or_raise(key, "key", _module_types.Empty)
            for key in python_map.keys()
        )
        _values = (
            _ensure_py3_or_raise(value, "value", _module_types.MyStruct)
            for value in python_map.values()
        )
        return Map__Empty_MyStruct(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )

Mapping.register(Map__Empty_MyStruct)
__all__.append('Map__Empty_MyStruct')


class List__Map__Empty_MyStruct(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Map__Empty_MyStruct):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Map__Empty_MyStruct._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Map__Empty_MyStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[_module_types.Empty, _module_types.MyStruct]")
        if not isinstance(item, _module_types.Map__Empty_MyStruct):
            item = _module_types.Map__Empty_MyStruct(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.Map__Empty_MyStruct):
            return item
        try:
            return _module_types.Map__Empty_MyStruct(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Map__Empty_MyStruct()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> "List__Map__Empty_MyStruct":
        _items = [
            _module_types.Map__Empty_MyStruct.from_python(item)
            for item in python_list
        ]
        return List__Map__Empty_MyStruct(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )

Sequence.register(List__Map__Empty_MyStruct)

__all__.append('List__Map__Empty_MyStruct')


class List__List__Map__Empty_MyStruct(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__List__Map__Empty_MyStruct):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__List__Map__Empty_MyStruct._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__List__Map__Empty_MyStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[_typing.Mapping[_module_types.Empty, _module_types.MyStruct]]")
        if not isinstance(item, _module_types.List__Map__Empty_MyStruct):
            item = _module_types.List__Map__Empty_MyStruct(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.List__Map__Empty_MyStruct):
            return item
        try:
            return _module_types.List__Map__Empty_MyStruct(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__List__Map__Empty_MyStruct()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> "List__List__Map__Empty_MyStruct":
        _items = [
            _module_types.List__Map__Empty_MyStruct.from_python(item)
            for item in python_list
        ]
        return List__List__Map__Empty_MyStruct(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )

Sequence.register(List__List__Map__Empty_MyStruct)

__all__.append('List__List__Map__Empty_MyStruct')


class List__List__List__Map__Empty_MyStruct(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__List__List__Map__Empty_MyStruct):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__List__List__Map__Empty_MyStruct._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__List__List__Map__Empty_MyStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[_typing.Mapping[_module_types.Empty, _module_types.MyStruct]]]")
        if not isinstance(item, _module_types.List__List__Map__Empty_MyStruct):
            item = _module_types.List__List__Map__Empty_MyStruct(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.List__List__Map__Empty_MyStruct):
            return item
        try:
            return _module_types.List__List__Map__Empty_MyStruct(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__List__List__Map__Empty_MyStruct()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> "List__List__List__Map__Empty_MyStruct":
        _items = [
            _module_types.List__List__Map__Empty_MyStruct.from_python(item)
            for item in python_list
        ]
        return List__List__List__Map__Empty_MyStruct(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )

Sequence.register(List__List__List__Map__Empty_MyStruct)

__all__.append('List__List__List__Map__Empty_MyStruct')


class List__MyEnumA(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__MyEnumA):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__MyEnumA._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__MyEnumA)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, _module_types.MyEnumA) or
            isinstance(item, thrift.py3.types.BadEnum)
        ):
            raise TypeError(f"{item!r} is not of type _module_types.MyEnumA")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.MyEnumA):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__MyEnumA()


Sequence.register(List__MyEnumA)

__all__.append('List__MyEnumA')


class Set__MyStruct(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__MyStruct):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__MyStruct._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__MyStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, _module_types.MyStruct)
        ):
            raise TypeError(f"{item!r} is not of type _module_types.MyStruct")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.MyStruct):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__MyStruct()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> "Set__MyStruct":
        _items = frozenset(
            _ensure_py3_or_raise(item, "item", _module_types.MyStruct)
            for item in python_set
        )
        return Set__MyStruct(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )

Set.register(Set__MyStruct)

__all__.append('Set__MyStruct')


class List__ComplexUnion(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__ComplexUnion):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__ComplexUnion._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__ComplexUnion)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, _module_types.ComplexUnion)
        ):
            raise TypeError(f"{item!r} is not of type _module_types.ComplexUnion")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.ComplexUnion):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__ComplexUnion()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> "List__ComplexUnion":
        _items = [
            _ensure_py3_or_raise(item, "item", _module_types.ComplexUnion)
            for item in python_list
        ]
        return List__ComplexUnion(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )

Sequence.register(List__ComplexUnion)

__all__.append('List__ComplexUnion')


class List__string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.Sequence[str] field, explicitly convert it first.")
            check_method = List__string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, str):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__string()


Sequence.register(List__string)

__all__.append('List__string')


class Set__List__string(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__List__string):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__List__string._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__List__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[str]")
        if not isinstance(item, _module_types.List__string):
            item = _module_types.List__string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.List__string):
            return item
        try:
            return _module_types.List__string(item)
        except:
            return None

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__List__string()


Set.register(Set__List__string)

__all__.append('Set__List__string')


class Set__List__List__Map__Empty_MyStruct(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__List__List__Map__Empty_MyStruct):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__List__List__Map__Empty_MyStruct._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__List__List__Map__Empty_MyStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[_typing.Mapping[_module_types.Empty, _module_types.MyStruct]]]")
        if not isinstance(item, _module_types.List__List__Map__Empty_MyStruct):
            item = _module_types.List__List__Map__Empty_MyStruct(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.List__List__Map__Empty_MyStruct):
            return item
        try:
            return _module_types.List__List__Map__Empty_MyStruct(item)
        except:
            return None

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__List__List__Map__Empty_MyStruct()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> "Set__List__List__Map__Empty_MyStruct":
        _items = frozenset(
            _module_types.List__List__Map__Empty_MyStruct.from_python(item)
            for item in python_set
        )
        return Set__List__List__Map__Empty_MyStruct(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )

Set.register(Set__List__List__Map__Empty_MyStruct)

__all__.append('Set__List__List__Map__Empty_MyStruct')


class Map__i32_List__string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_List__string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_List__string._check_key_type_or_raise
            check_val = Map__i32_List__string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_List__string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[str]")
        if not isinstance(item, _module_types.List__string):
            item = _module_types.List__string(item)
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_List__string()


Mapping.register(Map__i32_List__string)
__all__.append('Map__i32_List__string')


class List__bool(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__bool):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__bool._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__bool)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, bool)
        ):
            raise TypeError(f"{item!r} is not of type bool")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, bool):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__bool()


Sequence.register(List__bool)

__all__.append('List__bool')


class List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i32()


Sequence.register(List__i32)

__all__.append('List__i32')


class List__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[int]")
        if not isinstance(item, _module_types.List__i32):
            item = _module_types.List__i32(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.List__i32):
            return item
        try:
            return _module_types.List__i32(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__List__i32()


Sequence.register(List__List__i32)

__all__.append('List__List__i32')


class List__List__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__List__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__List__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__List__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[int]]")
        if not isinstance(item, _module_types.List__List__i32):
            item = _module_types.List__List__i32(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.List__List__i32):
            return item
        try:
            return _module_types.List__List__i32(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__List__List__i32()


Sequence.register(List__List__List__i32)

__all__.append('List__List__List__i32')


class List__List__List__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__List__List__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__List__List__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__List__List__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]")
        if not isinstance(item, _module_types.List__List__List__i32):
            item = _module_types.List__List__List__i32(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.List__List__List__i32):
            return item
        try:
            return _module_types.List__List__List__i32(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__List__List__List__i32()


Sequence.register(List__List__List__List__i32)

__all__.append('List__List__List__List__i32')


class Set__List__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__List__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__List__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[int]")
        if not isinstance(item, _module_types.List__i32):
            item = _module_types.List__i32(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.List__i32):
            return item
        try:
            return _module_types.List__i32(item)
        except:
            return None

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__List__i32()


Set.register(Set__List__i32)

__all__.append('Set__List__i32')


class Set__string(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__string):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[str] field, explicitly convert it first.")
            check_method = Set__string._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, str):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__string()


Set.register(Set__string)

__all__.append('Set__string')


class List__Set__string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Set__string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Set__string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Set__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.AbstractSet[str]")
        if not isinstance(item, _module_types.Set__string):
            item = _module_types.Set__string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.Set__string):
            return item
        try:
            return _module_types.Set__string(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Set__string()


Sequence.register(List__Set__string)

__all__.append('List__Set__string')


class Map__List__Set__string_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__List__Set__string_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__List__Set__string_string._check_key_type_or_raise
            check_val = Map__List__Set__string_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__List__Set__string_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if key is None:
            raise TypeError("None is not of the type _typing.Sequence[_typing.AbstractSet[str]]")
        if not isinstance(key, _module_types.List__Set__string):
            key = _module_types.List__Set__string(key)
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, _module_types.List__Set__string):
            return key
        try:
            return _module_types.List__Set__string(key)
        except:
            return None

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__List__Set__string_string()


Mapping.register(Map__List__Set__string_string)
__all__.append('Map__List__Set__string_string')


class Map__Set__List__i32_Map__List__Set__string_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__Set__List__i32_Map__List__Set__string_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__Set__List__i32_Map__List__Set__string_string._check_key_type_or_raise
            check_val = Map__Set__List__i32_Map__List__Set__string_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__Set__List__i32_Map__List__Set__string_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if key is None:
            raise TypeError("None is not of the type _typing.AbstractSet[_typing.Sequence[int]]")
        if not isinstance(key, _module_types.Set__List__i32):
            key = _module_types.Set__List__i32(key)
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, _module_types.Set__List__i32):
            return key
        try:
            return _module_types.Set__List__i32(key)
        except:
            return None

    @staticmethod
    def _check_val_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]")
        if not isinstance(item, _module_types.Map__List__Set__string_string):
            item = _module_types.Map__List__Set__string_string(item)
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__Set__List__i32_Map__List__Set__string_string()


Mapping.register(Map__Set__List__i32_Map__List__Set__string_string)
__all__.append('Map__Set__List__i32_Map__List__Set__string_string')


class Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__i32()


Set.register(Set__i32)

__all__.append('Set__i32')


class folly_small_vector_int64_t_8__List__i64(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_small_vector_int64_t_8__List__i64):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = folly_small_vector_int64_t_8__List__i64._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, folly_small_vector_int64_t_8__List__i64)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_small_vector_int64_t_8__List__i64()


Sequence.register(folly_small_vector_int64_t_8__List__i64)

__all__.append('folly_small_vector_int64_t_8__List__i64')


class folly_sorted_vector_set_std_string__Set__string(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_sorted_vector_set_std_string__Set__string):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[str] field, explicitly convert it first.")
            check_method = folly_sorted_vector_set_std_string__Set__string._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, folly_sorted_vector_set_std_string__Set__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, str):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_sorted_vector_set_std_string__Set__string()


Set.register(folly_sorted_vector_set_std_string__Set__string)

__all__.append('folly_sorted_vector_set_std_string__Set__string')


class FakeMap__Map__i64_double(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, FakeMap__Map__i64_double):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = FakeMap__Map__i64_double._check_key_type_or_raise
            check_val = FakeMap__Map__i64_double._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, FakeMap__Map__i64_double)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, (float, int))
        ):
            raise TypeError(f"{item!r} is not of type float")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__FakeMap__Map__i64_double()


Mapping.register(FakeMap__Map__i64_double)
__all__.append('FakeMap__Map__i64_double')


class std_unordered_map_std_string_containerStruct__Map__string_containerStruct(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, std_unordered_map_std_string_containerStruct__Map__string_containerStruct):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = std_unordered_map_std_string_containerStruct__Map__string_containerStruct._check_key_type_or_raise
            check_val = std_unordered_map_std_string_containerStruct__Map__string_containerStruct._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, std_unordered_map_std_string_containerStruct__Map__string_containerStruct)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, _module_types.containerStruct)
        ):
            raise TypeError(f"{item!r} is not of type _module_types.containerStruct")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_unordered_map_std_string_containerStruct__Map__string_containerStruct()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> "std_unordered_map_std_string_containerStruct__Map__string_containerStruct":
        _keys = python_map.keys()
        _values = (
            _ensure_py3_or_raise(value, "value", _module_types.containerStruct)
            for value in python_map.values()
        )
        return std_unordered_map_std_string_containerStruct__Map__string_containerStruct(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )

Mapping.register(std_unordered_map_std_string_containerStruct__Map__string_containerStruct)
__all__.append('std_unordered_map_std_string_containerStruct__Map__string_containerStruct')


class Map__i64_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i64_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i64_string._check_key_type_or_raise
            check_val = Map__i64_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i64_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i64_string()


Mapping.register(Map__i64_string)
__all__.append('Map__i64_string')


class std_list__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, std_list__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = std_list__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, std_list__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_list__List__i32()


Sequence.register(std_list__List__i32)

__all__.append('std_list__List__i32')


class std_deque__List__string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, std_deque__List__string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.Sequence[str] field, explicitly convert it first.")
            check_method = std_deque__List__string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, std_deque__List__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, str):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_deque__List__string()


Sequence.register(std_deque__List__string)

__all__.append('std_deque__List__string')


class folly_sorted_vector_set__Set__string(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_sorted_vector_set__Set__string):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[str] field, explicitly convert it first.")
            check_method = folly_sorted_vector_set__Set__string._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, folly_sorted_vector_set__Set__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, str):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_sorted_vector_set__Set__string()


Set.register(folly_sorted_vector_set__Set__string)

__all__.append('folly_sorted_vector_set__Set__string')


class folly_sorted_vector_map__Map__i64_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = False

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_sorted_vector_map__Map__i64_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = folly_sorted_vector_map__Map__i64_string._check_key_type_or_raise
            check_val = folly_sorted_vector_map__Map__i64_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, folly_sorted_vector_map__Map__i64_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_sorted_vector_map__Map__i64_string()


Mapping.register(folly_sorted_vector_map__Map__i64_string)
__all__.append('folly_sorted_vector_map__Map__i64_string')


class List__binary(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__binary):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.Sequence[bytes] field, explicitly convert it first.")
            check_method = List__binary._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__binary)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, bytes)
        ):
            raise TypeError(f"{item!r} is not of type bytes")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, bytes):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__binary()


Sequence.register(List__binary)

__all__.append('List__binary')


class Map__MyEnumA_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__MyEnumA_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__MyEnumA_string._check_key_type_or_raise
            check_val = Map__MyEnumA_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__MyEnumA_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, _module_types.MyEnumA) or
            isinstance(key, thrift.py3.types.BadEnum)
        ):
            raise TypeError(f"{key!r} is not of type _module_types.MyEnumA")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, _module_types.MyEnumA):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__MyEnumA_string()


Mapping.register(Map__MyEnumA_string)
__all__.append('Map__MyEnumA_string')


class Set__i64(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__i64):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__i64._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__i64)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__i64()


Set.register(Set__i64)

__all__.append('Set__i64')


class Map__string_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_i32._check_key_type_or_raise
            check_val = Map__string_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_i32()


Mapping.register(Map__string_i32)
__all__.append('Map__string_i32')


class List__SimpleUnion(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__SimpleUnion):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__SimpleUnion._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__SimpleUnion)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, _module_types.SimpleUnion)
        ):
            raise TypeError(f"{item!r} is not of type _module_types.SimpleUnion")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.SimpleUnion):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__SimpleUnion()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> "List__SimpleUnion":
        _items = [
            _ensure_py3_or_raise(item, "item", _module_types.SimpleUnion)
            for item in python_list
        ]
        return List__SimpleUnion(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )

Sequence.register(List__SimpleUnion)

__all__.append('List__SimpleUnion')


class Set__SimpleUnion(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__SimpleUnion):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__SimpleUnion._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__SimpleUnion)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, _module_types.SimpleUnion)
        ):
            raise TypeError(f"{item!r} is not of type _module_types.SimpleUnion")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.SimpleUnion):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__SimpleUnion()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> "Set__SimpleUnion":
        _items = frozenset(
            _ensure_py3_or_raise(item, "item", _module_types.SimpleUnion)
            for item in python_set
        )
        return Set__SimpleUnion(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )

Set.register(Set__SimpleUnion)

__all__.append('Set__SimpleUnion')


class List__Set__SimpleUnion(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Set__SimpleUnion):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Set__SimpleUnion._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Set__SimpleUnion)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.AbstractSet[_module_types.SimpleUnion]")
        if not isinstance(item, _module_types.Set__SimpleUnion):
            item = _module_types.Set__SimpleUnion(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.Set__SimpleUnion):
            return item
        try:
            return _module_types.Set__SimpleUnion(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Set__SimpleUnion()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> "List__Set__SimpleUnion":
        _items = [
            _module_types.Set__SimpleUnion.from_python(item)
            for item in python_list
        ]
        return List__Set__SimpleUnion(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )

Sequence.register(List__Set__SimpleUnion)

__all__.append('List__Set__SimpleUnion')


class Map__string_bool(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_bool):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_bool._check_key_type_or_raise
            check_val = Map__string_bool._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_bool)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, bool)
        ):
            raise TypeError(f"{item!r} is not of type bool")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_bool()


Mapping.register(Map__string_bool)
__all__.append('Map__string_bool')


class Map__string_Map__string_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_Map__string_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_Map__string_i32._check_key_type_or_raise
            check_val = Map__string_Map__string_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_Map__string_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[str, int]")
        if not isinstance(item, _module_types.Map__string_i32):
            item = _module_types.Map__string_i32(item)
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_Map__string_i32()


Mapping.register(Map__string_Map__string_i32)
__all__.append('Map__string_Map__string_i32')


class Map__string_Map__string_Map__string_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_Map__string_Map__string_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_Map__string_Map__string_i32._check_key_type_or_raise
            check_val = Map__string_Map__string_Map__string_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_Map__string_Map__string_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[str, _typing.Mapping[str, int]]")
        if not isinstance(item, _module_types.Map__string_Map__string_i32):
            item = _module_types.Map__string_Map__string_i32(item)
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_Map__string_Map__string_i32()


Mapping.register(Map__string_Map__string_Map__string_i32)
__all__.append('Map__string_Map__string_Map__string_i32')


class List__Set__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Set__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Set__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.AbstractSet[int]")
        if not isinstance(item, _module_types.Set__i32):
            item = _module_types.Set__i32(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.Set__i32):
            return item
        try:
            return _module_types.Set__i32(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Set__i32()


Sequence.register(List__Set__i32)

__all__.append('List__Set__i32')


class Map__string_List__i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_List__i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_List__i32._check_key_type_or_raise
            check_val = Map__string_List__i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_List__i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[int]")
        if not isinstance(item, _module_types.List__i32):
            item = _module_types.List__i32(item)
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_List__i32()


Mapping.register(Map__string_List__i32)
__all__.append('Map__string_List__i32')


class Set__bool(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__bool):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__bool._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__bool)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, bool)
        ):
            raise TypeError(f"{item!r} is not of type bool")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, bool):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__bool()


Set.register(Set__bool)

__all__.append('Set__bool')


class Set__Set__bool(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__Set__bool):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__Set__bool._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__Set__bool)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.AbstractSet[bool]")
        if not isinstance(item, _module_types.Set__bool):
            item = _module_types.Set__bool(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.Set__bool):
            return item
        try:
            return _module_types.Set__bool(item)
        except:
            return None

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__Set__bool()


Set.register(Set__Set__bool)

__all__.append('Set__Set__bool')


class Set__Set__Set__bool(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__Set__Set__bool):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__Set__Set__bool._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__Set__Set__bool)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.AbstractSet[_typing.AbstractSet[bool]]")
        if not isinstance(item, _module_types.Set__Set__bool):
            item = _module_types.Set__Set__bool(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.Set__Set__bool):
            return item
        try:
            return _module_types.Set__Set__bool(item)
        except:
            return None

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__Set__Set__bool()


Set.register(Set__Set__Set__bool)

__all__.append('Set__Set__Set__bool')


class Map__string_folly_IOBuf__binary(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_folly_IOBuf__binary):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_folly_IOBuf__binary._check_key_type_or_raise
            check_val = Map__string_folly_IOBuf__binary._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_folly_IOBuf__binary)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, _fbthrift_iobuf.IOBuf)
        ):
            raise TypeError(f"{item!r} is not of type _fbthrift_iobuf.IOBuf")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_folly_IOBuf__binary()


Mapping.register(Map__string_folly_IOBuf__binary)
__all__.append('Map__string_folly_IOBuf__binary')


class Map__string_std_unique_ptr_folly_IOBuf__binary(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_std_unique_ptr_folly_IOBuf__binary):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_std_unique_ptr_folly_IOBuf__binary._check_key_type_or_raise
            check_val = Map__string_std_unique_ptr_folly_IOBuf__binary._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_std_unique_ptr_folly_IOBuf__binary)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, _fbthrift_iobuf.IOBuf)
        ):
            raise TypeError(f"{item!r} is not of type _fbthrift_iobuf.IOBuf")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_std_unique_ptr_folly_IOBuf__binary()


Mapping.register(Map__string_std_unique_ptr_folly_IOBuf__binary)
__all__.append('Map__string_std_unique_ptr_folly_IOBuf__binary')


class Map__i32_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_string._check_key_type_or_raise
            check_val = Map__i32_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_string()


Mapping.register(Map__i32_string)
__all__.append('Map__i32_string')


class List__Map__string_i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Map__string_i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Map__string_i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Map__string_i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[str, int]")
        if not isinstance(item, _module_types.Map__string_i32):
            item = _module_types.Map__string_i32(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.Map__string_i32):
            return item
        try:
            return _module_types.Map__string_i32(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Map__string_i32()


Sequence.register(List__Map__string_i32)

__all__.append('List__Map__string_i32')


class Map__i16_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i16_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i16_string._check_key_type_or_raise
            check_val = Map__i16_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i16_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i16_string()


Mapping.register(Map__i16_string)
__all__.append('Map__i16_string')


class List__Map__i16_string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Map__i16_string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Map__i16_string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Map__i16_string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[int, str]")
        if not isinstance(item, _module_types.Map__i16_string):
            item = _module_types.Map__i16_string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.Map__i16_string):
            return item
        try:
            return _module_types.Map__i16_string(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Map__i16_string()


Sequence.register(List__Map__i16_string)

__all__.append('List__Map__i16_string')


class List__MyStruct(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__MyStruct):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__MyStruct._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__MyStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, _module_types.MyStruct)
        ):
            raise TypeError(f"{item!r} is not of type _module_types.MyStruct")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, _module_types.MyStruct):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__MyStruct()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> "List__MyStruct":
        _items = [
            _ensure_py3_or_raise(item, "item", _module_types.MyStruct)
            for item in python_list
        ]
        return List__MyStruct(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )

Sequence.register(List__MyStruct)

__all__.append('List__MyStruct')


