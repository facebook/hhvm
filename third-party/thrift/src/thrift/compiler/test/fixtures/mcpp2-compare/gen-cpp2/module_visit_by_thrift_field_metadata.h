/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/mcpp2-compare/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#pragma once

#include <thrift/lib/cpp2/visitation/visit_by_thrift_field_metadata.h>
#include "thrift/compiler/test/fixtures/mcpp2-compare/gen-cpp2/module_metadata.h"

namespace apache {
namespace thrift {
namespace detail {

template <>
struct VisitByFieldId<::some::valid::ns::Empty> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::Empty");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::ASimpleStruct> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).boolField_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::ASimpleStruct");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::ASimpleStructNoexcept> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).boolField_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::ASimpleStructNoexcept");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::MyStruct> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).MyBoolField_ref());
    case 2:
      return f(1, static_cast<T&&>(t).MyIntField_ref());
    case 3:
      return f(2, static_cast<T&&>(t).MyStringField_ref());
    case 4:
      return f(3, static_cast<T&&>(t).MyStringField2_ref());
    case 5:
      return f(4, static_cast<T&&>(t).MyBinaryField_ref());
    case 6:
      return f(5, static_cast<T&&>(t).MyBinaryField2_ref());
    case 7:
      return f(6, static_cast<T&&>(t).MyBinaryField3_ref());
    case 8:
      return f(7, static_cast<T&&>(t).MyBinaryListField4_ref());
    case 9:
      return f(8, static_cast<T&&>(t).MyMapEnumAndInt_ref());
    case 10:
      return f(9, static_cast<T&&>(t).MyCustomField_ref());
    case 11:
      return f(10, static_cast<T&&>(t).MyOptCustomField_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::MyStruct");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::SimpleUnion> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 7:
      return f(0, static_cast<T&&>(t).intValue_ref());
    case 2:
      return f(1, static_cast<T&&>(t).stringValue_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::SimpleUnion");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::ComplexUnion> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).intValue_ref());
    case 201:
      return f(1, static_cast<T&&>(t).opt_intValue_ref());
    case 3:
      return f(2, static_cast<T&&>(t).stringValue_ref());
    case 203:
      return f(3, static_cast<T&&>(t).opt_stringValue_ref());
    case 4:
      return f(4, static_cast<T&&>(t).intValue2_ref());
    case 6:
      return f(5, static_cast<T&&>(t).intValue3_ref());
    case 7:
      return f(6, static_cast<T&&>(t).doubelValue_ref());
    case 8:
      return f(7, static_cast<T&&>(t).boolValue_ref());
    case 9:
      return f(8, static_cast<T&&>(t).union_list_ref());
    case 10:
      return f(9, static_cast<T&&>(t).union_set_ref());
    case 11:
      return f(10, static_cast<T&&>(t).union_map_ref());
    case 211:
      return f(11, static_cast<T&&>(t).opt_union_map_ref());
    case 12:
      return f(12, static_cast<T&&>(t).enum_field_ref());
    case 13:
      return f(13, static_cast<T&&>(t).enum_container_ref());
    case 14:
      return f(14, static_cast<T&&>(t).a_struct_ref());
    case 15:
      return f(15, static_cast<T&&>(t).a_set_struct_ref());
    case 16:
      return f(16, static_cast<T&&>(t).a_union_ref());
    case 216:
      return f(17, static_cast<T&&>(t).opt_a_union_ref());
    case 17:
      return f(18, static_cast<T&&>(t).a_union_list_ref());
    case 18:
      return f(19, static_cast<T&&>(t).a_union_typedef_ref());
    case 19:
      return f(20, static_cast<T&&>(t).a_union_typedef_list_ref());
    case 20:
      return f(21, static_cast<T&&>(t).MyBinaryField_ref());
    case 21:
      return f(22, static_cast<T&&>(t).MyBinaryField2_ref());
    case 23:
      return f(23, static_cast<T&&>(t).MyBinaryListField4_ref());
    case 24:
      return f(24, static_cast<T&&>(t).ref_field_ref());
    case 25:
      return f(25, static_cast<T&&>(t).ref_field2_ref());
    case 26:
      return f(26, static_cast<T&&>(t).excp_field_ref());
    case 27:
      return f(27, static_cast<T&&>(t).MyCustomField_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::ComplexUnion");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::AnException> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 101:
      return f(1, static_cast<T&&>(t).req_code_ref());
    case 2:
      return f(2, static_cast<T&&>(t).message2_ref());
    case 102:
      return f(3, static_cast<T&&>(t).req_message_ref());
    case 3:
      return f(4, static_cast<T&&>(t).exception_list_ref());
    case 4:
      return f(5, static_cast<T&&>(t).exception_set_ref());
    case 5:
      return f(6, static_cast<T&&>(t).exception_map_ref());
    case 105:
      return f(7, static_cast<T&&>(t).req_exception_map_ref());
    case 6:
      return f(8, static_cast<T&&>(t).enum_field_ref());
    case 7:
      return f(9, static_cast<T&&>(t).enum_container_ref());
    case 8:
      return f(10, static_cast<T&&>(t).a_struct_ref());
    case 9:
      return f(11, static_cast<T&&>(t).a_set_struct_ref());
    case 10:
      return f(12, static_cast<T&&>(t).a_union_list_ref());
    case 11:
      return f(13, static_cast<T&&>(t).union_typedef_ref());
    case 19:
      return f(14, static_cast<T&&>(t).a_union_typedef_list_ref());
    case 20:
      return f(15, static_cast<T&&>(t).MyCustomField_ref());
    case 21:
      return f(16, static_cast<T&&>(t).MyOptCustomField_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::AnException");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::AnotherException> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).code_ref());
    case 101:
      return f(1, static_cast<T&&>(t).req_code_ref());
    case 2:
      return f(2, static_cast<T&&>(t).message_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::AnotherException");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::containerStruct> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).fieldA_ref());
    case 101:
      return f(1, static_cast<T&&>(t).req_fieldA_ref());
    case 201:
      return f(2, static_cast<T&&>(t).opt_fieldA_ref());
    case 2:
      return f(3, static_cast<T&&>(t).fieldB_ref());
    case 102:
      return f(4, static_cast<T&&>(t).req_fieldB_ref());
    case 202:
      return f(5, static_cast<T&&>(t).opt_fieldB_ref());
    case 3:
      return f(6, static_cast<T&&>(t).fieldC_ref());
    case 103:
      return f(7, static_cast<T&&>(t).req_fieldC_ref());
    case 203:
      return f(8, static_cast<T&&>(t).opt_fieldC_ref());
    case 4:
      return f(9, static_cast<T&&>(t).fieldD_ref());
    case 5:
      return f(10, static_cast<T&&>(t).fieldE_ref());
    case 105:
      return f(11, static_cast<T&&>(t).req_fieldE_ref());
    case 205:
      return f(12, static_cast<T&&>(t).opt_fieldE_ref());
    case 6:
      return f(13, static_cast<T&&>(t).fieldF_ref());
    case 7:
      return f(14, static_cast<T&&>(t).fieldG_ref());
    case 8:
      return f(15, static_cast<T&&>(t).fieldH_ref());
    case 9:
      return f(16, static_cast<T&&>(t).fieldI_ref());
    case 10:
      return f(17, static_cast<T&&>(t).fieldJ_ref());
    case 11:
      return f(18, static_cast<T&&>(t).fieldK_ref());
    case 12:
      return f(19, static_cast<T&&>(t).fieldL_ref());
    case 13:
      return f(20, static_cast<T&&>(t).fieldM_ref());
    case 14:
      return f(21, static_cast<T&&>(t).fieldN_ref());
    case 15:
      return f(22, static_cast<T&&>(t).fieldO_ref());
    case 16:
      return f(23, static_cast<T&&>(t).fieldP_ref());
    case 17:
      return f(24, static_cast<T&&>(t).fieldQ_ref());
    case 18:
      return f(25, static_cast<T&&>(t).fieldR_ref());
    case 118:
      return f(26, static_cast<T&&>(t).req_fieldR_ref());
    case 218:
      return f(27, static_cast<T&&>(t).opt_fieldR_ref());
    case 19:
      return f(28, static_cast<T&&>(t).fieldS_ref());
    case 21:
      return f(29, static_cast<T&&>(t).fieldT_ref());
    case 22:
      return f(30, static_cast<T&&>(t).fieldU_ref());
    case 23:
      return f(31, static_cast<T&&>(t).fieldV_ref());
    case 123:
      return f(32, static_cast<T&&>(t).req_fieldV_ref());
    case 223:
      return f(33, static_cast<T&&>(t).opt_fieldV_ref());
    case 24:
      return f(34, static_cast<T&&>(t).fieldW_ref());
    case 25:
      return f(35, static_cast<T&&>(t).fieldX_ref());
    case 125:
      return f(36, static_cast<T&&>(t).req_fieldX_ref());
    case 225:
      return f(37, static_cast<T&&>(t).opt_fieldX_ref());
    case 26:
      return f(38, static_cast<T&&>(t).fieldY_ref());
    case 27:
      return f(39, static_cast<T&&>(t).fieldZ_ref());
    case 28:
      return f(40, static_cast<T&&>(t).fieldAA_ref());
    case 29:
      return f(41, static_cast<T&&>(t).fieldAB_ref());
    case 30:
      return f(42, static_cast<T&&>(t).fieldAC_ref());
    case 31:
      return f(43, static_cast<T&&>(t).fieldAD_ref());
    case 32:
      return f(44, static_cast<T&&>(t).fieldAE_ref());
    case 33:
      return f(45, static_cast<T&&>(t).fieldSD_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::containerStruct");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::MyIncludedStruct> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).MyIncludedInt_ref());
    case 2:
      return f(1, static_cast<T&&>(t).MyIncludedStruct_ref());
    case 3:
      return f(2, static_cast<T&&>(t).ARefField_ref());
    case 4:
      return f(3, static_cast<T&&>(t).ARequiredField_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::MyIncludedStruct");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::AnnotatedStruct> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).no_annotation_ref());
    case 2:
      return f(1, static_cast<T&&>(t).cpp_unique_ref_ref());
    case 3:
      return f(2, static_cast<T&&>(t).cpp2_unique_ref_ref());
    case 4:
      return f(3, static_cast<T&&>(t).container_with_ref_ref());
    case 5:
      return f(4, static_cast<T&&>(t).req_cpp_unique_ref_ref());
    case 6:
      return f(5, static_cast<T&&>(t).req_cpp2_unique_ref_ref());
    case 7:
      return f(6, static_cast<T&&>(t).req_container_with_ref_ref());
    case 8:
      return f(7, static_cast<T&&>(t).opt_cpp_unique_ref_ref());
    case 9:
      return f(8, static_cast<T&&>(t).opt_cpp2_unique_ref_ref());
    case 10:
      return f(9, static_cast<T&&>(t).opt_container_with_ref_ref());
    case 11:
      return f(10, static_cast<T&&>(t).ref_type_unique_ref());
    case 12:
      return f(11, static_cast<T&&>(t).ref_type_shared_ref());
    case 13:
      return f(12, static_cast<T&&>(t).ref_type_const_ref());
    case 14:
      return f(13, static_cast<T&&>(t).req_ref_type_shared_ref());
    case 15:
      return f(14, static_cast<T&&>(t).req_ref_type_const_ref());
    case 16:
      return f(15, static_cast<T&&>(t).req_ref_type_unique_ref());
    case 17:
      return f(16, static_cast<T&&>(t).opt_ref_type_const_ref());
    case 18:
      return f(17, static_cast<T&&>(t).opt_ref_type_unique_ref());
    case 19:
      return f(18, static_cast<T&&>(t).opt_ref_type_shared_ref());
    case 20:
      return f(19, static_cast<T&&>(t).base_type_ref());
    case 21:
      return f(20, static_cast<T&&>(t).list_type_ref());
    case 22:
      return f(21, static_cast<T&&>(t).set_type_ref());
    case 23:
      return f(22, static_cast<T&&>(t).map_type_ref());
    case 24:
      return f(23, static_cast<T&&>(t).map_struct_type_ref());
    case 25:
      return f(24, static_cast<T&&>(t).iobuf_type_ref());
    case 26:
      return f(25, static_cast<T&&>(t).iobuf_ptr_ref());
    case 27:
      return f(26, static_cast<T&&>(t).list_i32_template_ref());
    case 28:
      return f(27, static_cast<T&&>(t).list_string_template_ref());
    case 29:
      return f(28, static_cast<T&&>(t).set_template_ref());
    case 30:
      return f(29, static_cast<T&&>(t).map_template_ref());
    case 31:
      return f(30, static_cast<T&&>(t).typedef_list_template_ref());
    case 32:
      return f(31, static_cast<T&&>(t).typedef_deque_template_ref());
    case 33:
      return f(32, static_cast<T&&>(t).typedef_set_template_ref());
    case 34:
      return f(33, static_cast<T&&>(t).typedef_map_template_ref());
    case 35:
      return f(34, static_cast<T&&>(t).indirection_a_ref());
    case 36:
      return f(35, static_cast<T&&>(t).indirection_b_ref());
    case 37:
      return f(36, static_cast<T&&>(t).indirection_c_ref());
    case 38:
      return f(37, static_cast<T&&>(t).iobuf_type_val_ref());
    case 39:
      return f(38, static_cast<T&&>(t).iobuf_ptr_val_ref());
    case 40:
      return f(39, static_cast<T&&>(t).struct_struct_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::AnnotatedStruct");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::ComplexContainerStruct> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).map_of_iobufs_ref());
    case 2:
      return f(1, static_cast<T&&>(t).map_of_iobuf_ptrs_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::ComplexContainerStruct");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::FloatStruct> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).floatField_ref());
    case 2:
      return f(1, static_cast<T&&>(t).doubleField_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::FloatStruct");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::FloatUnion> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).floatSide_ref());
    case 2:
      return f(1, static_cast<T&&>(t).doubleSide_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::FloatUnion");
    }
  }
};

template <>
struct VisitByFieldId<::some::valid::ns::AllRequiredNoExceptMoveCtrStruct> {
  template <typename F, typename T>
  void operator()([[maybe_unused]] F&& f, int32_t fieldId, [[maybe_unused]] T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).intField_ref());
    default:
      throwInvalidThriftId(fieldId, "::some::valid::ns::AllRequiredNoExceptMoveCtrStruct");
    }
  }
};
} // namespace detail
} // namespace thrift
} // namespace apache
