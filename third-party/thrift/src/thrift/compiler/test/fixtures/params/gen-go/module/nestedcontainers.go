// Autogenerated by Thrift Compiler (facebook)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
// @generated

package module

import (
	"bytes"
	"context"
	"sync"
	"fmt"
	thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = sync.Mutex{}
var _ = bytes.Equal
var _ = context.Background

type NestedContainers interface {
  // Parameters:
  //  - Foo
  MapList(foo map[int32][]int32) (err error)
  // Parameters:
  //  - Foo
  MapSet(foo map[int32][]int32) (err error)
  // Parameters:
  //  - Foo
  ListMap(foo []map[int32]int32) (err error)
  // Parameters:
  //  - Foo
  ListSet(foo [][]int32) (err error)
  // Parameters:
  //  - Foo
  Turtles(foo [][]map[int32]map[int32][]int32) (err error)
}

type NestedContainersClientInterface interface {
  thrift.ClientInterface
  // Parameters:
  //  - Foo
  MapList(foo map[int32][]int32) (err error)
  // Parameters:
  //  - Foo
  MapSet(foo map[int32][]int32) (err error)
  // Parameters:
  //  - Foo
  ListMap(foo []map[int32]int32) (err error)
  // Parameters:
  //  - Foo
  ListSet(foo [][]int32) (err error)
  // Parameters:
  //  - Foo
  Turtles(foo [][]map[int32]map[int32][]int32) (err error)
}

type NestedContainersClient struct {
  NestedContainersClientInterface
  CC thrift.ClientConn
}

func(client *NestedContainersClient) Open() error {
  return client.CC.Open()
}

func(client *NestedContainersClient) Close() error {
  return client.CC.Close()
}

func(client *NestedContainersClient) IsOpen() bool {
  return client.CC.IsOpen()
}

func NewNestedContainersClientFactory(t thrift.Transport, f thrift.ProtocolFactory) *NestedContainersClient {
  return &NestedContainersClient{ CC: thrift.NewClientConn(t, f) }
}

func NewNestedContainersClient(t thrift.Transport, iprot thrift.Protocol, oprot thrift.Protocol) *NestedContainersClient {
  return &NestedContainersClient{ CC: thrift.NewClientConnWithProtocols(t, iprot, oprot) }
}

func NewNestedContainersClientProtocol(prot thrift.Protocol) *NestedContainersClient {
  return NewNestedContainersClient(prot.Transport(), prot, prot)
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) MapList(foo map[int32][]int32) (err error) {
  args := NestedContainersMapListArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("mapList", &args, thrift.CALL)
  if err != nil { return }
  return p.recvMapList()
}


func (p *NestedContainersClient) recvMapList() (err error) {
  var __result NestedContainersMapListResult
  return p.CC.RecvMsg("mapList", &__result)
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) MapSet(foo map[int32][]int32) (err error) {
  args := NestedContainersMapSetArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("mapSet", &args, thrift.CALL)
  if err != nil { return }
  return p.recvMapSet()
}


func (p *NestedContainersClient) recvMapSet() (err error) {
  var __result NestedContainersMapSetResult
  return p.CC.RecvMsg("mapSet", &__result)
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) ListMap(foo []map[int32]int32) (err error) {
  args := NestedContainersListMapArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("listMap", &args, thrift.CALL)
  if err != nil { return }
  return p.recvListMap()
}


func (p *NestedContainersClient) recvListMap() (err error) {
  var __result NestedContainersListMapResult
  return p.CC.RecvMsg("listMap", &__result)
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) ListSet(foo [][]int32) (err error) {
  args := NestedContainersListSetArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("listSet", &args, thrift.CALL)
  if err != nil { return }
  return p.recvListSet()
}


func (p *NestedContainersClient) recvListSet() (err error) {
  var __result NestedContainersListSetResult
  return p.CC.RecvMsg("listSet", &__result)
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) Turtles(foo [][]map[int32]map[int32][]int32) (err error) {
  args := NestedContainersTurtlesArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("turtles", &args, thrift.CALL)
  if err != nil { return }
  return p.recvTurtles()
}


func (p *NestedContainersClient) recvTurtles() (err error) {
  var __result NestedContainersTurtlesResult
  return p.CC.RecvMsg("turtles", &__result)
}


type NestedContainersThreadsafeClient struct {
  NestedContainersClientInterface
  CC thrift.ClientConn
  Mu sync.Mutex
}

func(client *NestedContainersThreadsafeClient) Open() error {
  client.Mu.Lock()
  defer client.Mu.Unlock()
  return client.CC.Open()
}

func(client *NestedContainersThreadsafeClient) Close() error {
  client.Mu.Lock()
  defer client.Mu.Unlock()
  return client.CC.Close()
}

func(client *NestedContainersThreadsafeClient) IsOpen() bool {
  client.Mu.Lock()
  defer client.Mu.Unlock()
  return client.CC.IsOpen()
}

func NewNestedContainersThreadsafeClientFactory(t thrift.Transport, f thrift.ProtocolFactory) *NestedContainersThreadsafeClient {
  return &NestedContainersThreadsafeClient{ CC: thrift.NewClientConn(t, f) }
}

func NewNestedContainersThreadsafeClient(t thrift.Transport, iprot thrift.Protocol, oprot thrift.Protocol) *NestedContainersThreadsafeClient {
  return &NestedContainersThreadsafeClient{ CC: thrift.NewClientConnWithProtocols(t, iprot, oprot) }
}

func NewNestedContainersThreadsafeClientProtocol(prot thrift.Protocol) *NestedContainersThreadsafeClient {
  return NewNestedContainersThreadsafeClient(prot.Transport(), prot, prot)
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) MapList(foo map[int32][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  args := NestedContainersMapListArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("mapList", &args, thrift.CALL)
  if err != nil { return }
  return p.recvMapList()
}


func (p *NestedContainersThreadsafeClient) recvMapList() (err error) {
  var __result NestedContainersMapListResult
  return p.CC.RecvMsg("mapList", &__result)
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) MapSet(foo map[int32][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  args := NestedContainersMapSetArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("mapSet", &args, thrift.CALL)
  if err != nil { return }
  return p.recvMapSet()
}


func (p *NestedContainersThreadsafeClient) recvMapSet() (err error) {
  var __result NestedContainersMapSetResult
  return p.CC.RecvMsg("mapSet", &__result)
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) ListMap(foo []map[int32]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  args := NestedContainersListMapArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("listMap", &args, thrift.CALL)
  if err != nil { return }
  return p.recvListMap()
}


func (p *NestedContainersThreadsafeClient) recvListMap() (err error) {
  var __result NestedContainersListMapResult
  return p.CC.RecvMsg("listMap", &__result)
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) ListSet(foo [][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  args := NestedContainersListSetArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("listSet", &args, thrift.CALL)
  if err != nil { return }
  return p.recvListSet()
}


func (p *NestedContainersThreadsafeClient) recvListSet() (err error) {
  var __result NestedContainersListSetResult
  return p.CC.RecvMsg("listSet", &__result)
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) Turtles(foo [][]map[int32]map[int32][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  args := NestedContainersTurtlesArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("turtles", &args, thrift.CALL)
  if err != nil { return }
  return p.recvTurtles()
}


func (p *NestedContainersThreadsafeClient) recvTurtles() (err error) {
  var __result NestedContainersTurtlesResult
  return p.CC.RecvMsg("turtles", &__result)
}


type NestedContainersChannelClient struct {
  RequestChannel thrift.RequestChannel
}

func (c *NestedContainersChannelClient) Close() error {
  return c.RequestChannel.Close()
}

func (c *NestedContainersChannelClient) IsOpen() bool {
  return c.RequestChannel.IsOpen()
}

func (c *NestedContainersChannelClient) Open() error {
  return c.RequestChannel.Open()
}

func NewNestedContainersChannelClient(channel thrift.RequestChannel) *NestedContainersChannelClient {
  return &NestedContainersChannelClient{RequestChannel: channel}
}

// Parameters:
//  - Foo
func (p *NestedContainersChannelClient) MapList(ctx context.Context, foo map[int32][]int32) (err error) {
  args := NestedContainersMapListArgs{
    Foo : foo,
  }
  var __result NestedContainersMapListResult
  err = p.RequestChannel.Call(ctx, "mapList", &args, &__result)
  if err != nil { return }

  return nil
}

// Parameters:
//  - Foo
func (p *NestedContainersChannelClient) MapSet(ctx context.Context, foo map[int32][]int32) (err error) {
  args := NestedContainersMapSetArgs{
    Foo : foo,
  }
  var __result NestedContainersMapSetResult
  err = p.RequestChannel.Call(ctx, "mapSet", &args, &__result)
  if err != nil { return }

  return nil
}

// Parameters:
//  - Foo
func (p *NestedContainersChannelClient) ListMap(ctx context.Context, foo []map[int32]int32) (err error) {
  args := NestedContainersListMapArgs{
    Foo : foo,
  }
  var __result NestedContainersListMapResult
  err = p.RequestChannel.Call(ctx, "listMap", &args, &__result)
  if err != nil { return }

  return nil
}

// Parameters:
//  - Foo
func (p *NestedContainersChannelClient) ListSet(ctx context.Context, foo [][]int32) (err error) {
  args := NestedContainersListSetArgs{
    Foo : foo,
  }
  var __result NestedContainersListSetResult
  err = p.RequestChannel.Call(ctx, "listSet", &args, &__result)
  if err != nil { return }

  return nil
}

// Parameters:
//  - Foo
func (p *NestedContainersChannelClient) Turtles(ctx context.Context, foo [][]map[int32]map[int32][]int32) (err error) {
  args := NestedContainersTurtlesArgs{
    Foo : foo,
  }
  var __result NestedContainersTurtlesResult
  err = p.RequestChannel.Call(ctx, "turtles", &args, &__result)
  if err != nil { return }

  return nil
}


type NestedContainersProcessor struct {
  processorMap map[string]thrift.ProcessorFunction
  functionServiceMap map[string]string
  handler NestedContainers
}

func (p *NestedContainersProcessor) AddToProcessorMap(key string, processor thrift.ProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *NestedContainersProcessor) AddToFunctionServiceMap(key, service string) {
  p.functionServiceMap[key] = service
}

func (p *NestedContainersProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction, err error) {
  if processor, ok := p.processorMap[key]; ok {
    return processor, nil
  }
  return nil, nil // generic error message will be sent
}

func (p *NestedContainersProcessor) ProcessorMap() map[string]thrift.ProcessorFunction {
  return p.processorMap
}

func (p *NestedContainersProcessor) FunctionServiceMap() map[string]string {
  return p.functionServiceMap
}

func NewNestedContainersProcessor(handler NestedContainers) *NestedContainersProcessor {
  self0 := &NestedContainersProcessor{handler:handler, processorMap:make(map[string]thrift.ProcessorFunction), functionServiceMap:make(map[string]string)}
  self0.processorMap["mapList"] = &nestedContainersProcessorMapList{handler:handler}
  self0.processorMap["mapSet"] = &nestedContainersProcessorMapSet{handler:handler}
  self0.processorMap["listMap"] = &nestedContainersProcessorListMap{handler:handler}
  self0.processorMap["listSet"] = &nestedContainersProcessorListSet{handler:handler}
  self0.processorMap["turtles"] = &nestedContainersProcessorTurtles{handler:handler}
  self0.functionServiceMap["mapList"] = "NestedContainers"
  self0.functionServiceMap["mapSet"] = "NestedContainers"
  self0.functionServiceMap["listMap"] = "NestedContainers"
  self0.functionServiceMap["listSet"] = "NestedContainers"
  self0.functionServiceMap["turtles"] = "NestedContainers"
  return self0
}

type nestedContainersProcessorMapList struct {
  handler NestedContainers
}

func (p *NestedContainersMapListResult) Exception() thrift.WritableException {
  if p == nil { return nil }
  return nil
}

func (p *nestedContainersProcessorMapList) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersMapListArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorMapList) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("mapList", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorMapList) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersMapListArgs)
  var __result NestedContainersMapListResult
  if err := p.handler.MapList(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing mapList: " + err.Error(), err)
      return x, x
    }
  }
  return &__result, nil
}

type nestedContainersProcessorMapSet struct {
  handler NestedContainers
}

func (p *NestedContainersMapSetResult) Exception() thrift.WritableException {
  if p == nil { return nil }
  return nil
}

func (p *nestedContainersProcessorMapSet) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersMapSetArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorMapSet) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("mapSet", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorMapSet) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersMapSetArgs)
  var __result NestedContainersMapSetResult
  if err := p.handler.MapSet(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing mapSet: " + err.Error(), err)
      return x, x
    }
  }
  return &__result, nil
}

type nestedContainersProcessorListMap struct {
  handler NestedContainers
}

func (p *NestedContainersListMapResult) Exception() thrift.WritableException {
  if p == nil { return nil }
  return nil
}

func (p *nestedContainersProcessorListMap) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersListMapArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorListMap) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("listMap", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorListMap) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersListMapArgs)
  var __result NestedContainersListMapResult
  if err := p.handler.ListMap(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing listMap: " + err.Error(), err)
      return x, x
    }
  }
  return &__result, nil
}

type nestedContainersProcessorListSet struct {
  handler NestedContainers
}

func (p *NestedContainersListSetResult) Exception() thrift.WritableException {
  if p == nil { return nil }
  return nil
}

func (p *nestedContainersProcessorListSet) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersListSetArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorListSet) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("listSet", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorListSet) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersListSetArgs)
  var __result NestedContainersListSetResult
  if err := p.handler.ListSet(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing listSet: " + err.Error(), err)
      return x, x
    }
  }
  return &__result, nil
}

type nestedContainersProcessorTurtles struct {
  handler NestedContainers
}

func (p *NestedContainersTurtlesResult) Exception() thrift.WritableException {
  if p == nil { return nil }
  return nil
}

func (p *nestedContainersProcessorTurtles) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersTurtlesArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorTurtles) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("turtles", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorTurtles) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersTurtlesArgs)
  var __result NestedContainersTurtlesResult
  if err := p.handler.Turtles(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationExceptionCause(thrift.INTERNAL_ERROR, "Internal error processing turtles: " + err.Error(), err)
      return x, x
    }
  }
  return &__result, nil
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Foo
type NestedContainersMapListArgs struct {
  thrift.IRequest
  Foo map[int32][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersMapListArgs() *NestedContainersMapListArgs {
  return &NestedContainersMapListArgs{}
}


func (p *NestedContainersMapListArgs) GetFoo() map[int32][]int32 {
  return p.Foo
}
type NestedContainersMapListArgsBuilder struct {
  obj *NestedContainersMapListArgs
}

func NewNestedContainersMapListArgsBuilder() *NestedContainersMapListArgsBuilder{
  return &NestedContainersMapListArgsBuilder{
    obj: NewNestedContainersMapListArgs(),
  }
}

func (p NestedContainersMapListArgsBuilder) Emit() *NestedContainersMapListArgs{
  return &NestedContainersMapListArgs{
    Foo: p.obj.Foo,
  }
}

func (n *NestedContainersMapListArgsBuilder) Foo(foo map[int32][]int32) *NestedContainersMapListArgsBuilder {
  n.obj.Foo = foo
  return n
}

func (n *NestedContainersMapListArgs) SetFoo(foo map[int32][]int32) *NestedContainersMapListArgs {
  n.Foo = foo
  return n
}

func (p *NestedContainersMapListArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapListArgs)  ReadField1(iprot thrift.Protocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[int32][]int32, size)
  p.Foo =  tMap
  for i := 0; i < size; i ++ {
    var _key2 int32
    if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
    } else {
      _key2 = v
    }
    _, size, err := iprot.ReadListBegin()
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make([]int32, 0, size)
    _val3 :=  tSlice
    for i := 0; i < size; i ++ {
      var _elem4 int32
      if v, err := iprot.ReadI32(); err != nil {
        return thrift.PrependError("error reading field 0: ", err)
      } else {
        _elem4 = v
      }
      _val3 = append(_val3, _elem4)
    }
    if err := iprot.ReadListEnd(); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Foo[_key2] = _val3
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *NestedContainersMapListArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapList_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapListArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.I32, thrift.LIST, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Foo {
    if err := oprot.WriteI32(int32(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteListBegin(thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersMapListArgs) String() string {
  if p == nil {
    return "<nil>"
  }

  fooVal := fmt.Sprintf("%v", p.Foo)
  return fmt.Sprintf("NestedContainersMapListArgs({Foo:%s})", fooVal)
}

type NestedContainersMapListResult struct {
  thrift.IResponse
}

func NewNestedContainersMapListResult() *NestedContainersMapListResult {
  return &NestedContainersMapListResult{}
}

type NestedContainersMapListResultBuilder struct {
  obj *NestedContainersMapListResult
}

func NewNestedContainersMapListResultBuilder() *NestedContainersMapListResultBuilder{
  return &NestedContainersMapListResultBuilder{
    obj: NewNestedContainersMapListResult(),
  }
}

func (p NestedContainersMapListResultBuilder) Emit() *NestedContainersMapListResult{
  return &NestedContainersMapListResult{
  }
}

func (p *NestedContainersMapListResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapListResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapList_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapListResult) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NestedContainersMapListResult({})")
}

// Attributes:
//  - Foo
type NestedContainersMapSetArgs struct {
  thrift.IRequest
  Foo map[int32][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersMapSetArgs() *NestedContainersMapSetArgs {
  return &NestedContainersMapSetArgs{}
}


func (p *NestedContainersMapSetArgs) GetFoo() map[int32][]int32 {
  return p.Foo
}
type NestedContainersMapSetArgsBuilder struct {
  obj *NestedContainersMapSetArgs
}

func NewNestedContainersMapSetArgsBuilder() *NestedContainersMapSetArgsBuilder{
  return &NestedContainersMapSetArgsBuilder{
    obj: NewNestedContainersMapSetArgs(),
  }
}

func (p NestedContainersMapSetArgsBuilder) Emit() *NestedContainersMapSetArgs{
  return &NestedContainersMapSetArgs{
    Foo: p.obj.Foo,
  }
}

func (n *NestedContainersMapSetArgsBuilder) Foo(foo map[int32][]int32) *NestedContainersMapSetArgsBuilder {
  n.obj.Foo = foo
  return n
}

func (n *NestedContainersMapSetArgs) SetFoo(foo map[int32][]int32) *NestedContainersMapSetArgs {
  n.Foo = foo
  return n
}

func (p *NestedContainersMapSetArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapSetArgs)  ReadField1(iprot thrift.Protocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[int32][]int32, size)
  p.Foo =  tMap
  for i := 0; i < size; i ++ {
    var _key5 int32
    if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
    } else {
      _key5 = v
    }
    _, size, err := iprot.ReadSetBegin()
    if err != nil {
      return thrift.PrependError("error reading set begin: ", err)
    }
    tSet := make([]int32, 0, size)
    _val6 :=  tSet
    for i := 0; i < size; i ++ {
      var _elem7 int32
      if v, err := iprot.ReadI32(); err != nil {
        return thrift.PrependError("error reading field 0: ", err)
      } else {
        _elem7 = v
      }
      _val6 = append(_val6, _elem7)
    }
    if err := iprot.ReadSetEnd(); err != nil {
      return thrift.PrependError("error reading set end: ", err)
    }
    p.Foo[_key5] = _val6
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *NestedContainersMapSetArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapSet_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapSetArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.I32, thrift.SET, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Foo {
    if err := oprot.WriteI32(int32(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteSetBegin(thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    set := make(map[int32]bool, len(v))
    for _, v := range v {
      if ok := set[v]; ok {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", v))
      }
      set[v] = true
    }
    for _, v := range v {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersMapSetArgs) String() string {
  if p == nil {
    return "<nil>"
  }

  fooVal := fmt.Sprintf("%v", p.Foo)
  return fmt.Sprintf("NestedContainersMapSetArgs({Foo:%s})", fooVal)
}

type NestedContainersMapSetResult struct {
  thrift.IResponse
}

func NewNestedContainersMapSetResult() *NestedContainersMapSetResult {
  return &NestedContainersMapSetResult{}
}

type NestedContainersMapSetResultBuilder struct {
  obj *NestedContainersMapSetResult
}

func NewNestedContainersMapSetResultBuilder() *NestedContainersMapSetResultBuilder{
  return &NestedContainersMapSetResultBuilder{
    obj: NewNestedContainersMapSetResult(),
  }
}

func (p NestedContainersMapSetResultBuilder) Emit() *NestedContainersMapSetResult{
  return &NestedContainersMapSetResult{
  }
}

func (p *NestedContainersMapSetResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapSetResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapSet_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapSetResult) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NestedContainersMapSetResult({})")
}

// Attributes:
//  - Foo
type NestedContainersListMapArgs struct {
  thrift.IRequest
  Foo []map[int32]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersListMapArgs() *NestedContainersListMapArgs {
  return &NestedContainersListMapArgs{}
}


func (p *NestedContainersListMapArgs) GetFoo() []map[int32]int32 {
  return p.Foo
}
type NestedContainersListMapArgsBuilder struct {
  obj *NestedContainersListMapArgs
}

func NewNestedContainersListMapArgsBuilder() *NestedContainersListMapArgsBuilder{
  return &NestedContainersListMapArgsBuilder{
    obj: NewNestedContainersListMapArgs(),
  }
}

func (p NestedContainersListMapArgsBuilder) Emit() *NestedContainersListMapArgs{
  return &NestedContainersListMapArgs{
    Foo: p.obj.Foo,
  }
}

func (n *NestedContainersListMapArgsBuilder) Foo(foo []map[int32]int32) *NestedContainersListMapArgsBuilder {
  n.obj.Foo = foo
  return n
}

func (n *NestedContainersListMapArgs) SetFoo(foo []map[int32]int32) *NestedContainersListMapArgs {
  n.Foo = foo
  return n
}

func (p *NestedContainersListMapArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListMapArgs)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]map[int32]int32, 0, size)
  p.Foo =  tSlice
  for i := 0; i < size; i ++ {
    _, _, size, err := iprot.ReadMapBegin()
    if err != nil {
      return thrift.PrependError("error reading map begin: ", err)
    }
    tMap := make(map[int32]int32, size)
    _elem8 :=  tMap
    for i := 0; i < size; i ++ {
      var _key9 int32
      if v, err := iprot.ReadI32(); err != nil {
        return thrift.PrependError("error reading field 0: ", err)
      } else {
        _key9 = v
      }
      var _val10 int32
      if v, err := iprot.ReadI32(); err != nil {
        return thrift.PrependError("error reading field 0: ", err)
      } else {
        _val10 = v
      }
      _elem8[_key9] = _val10
    }
    if err := iprot.ReadMapEnd(); err != nil {
      return thrift.PrependError("error reading map end: ", err)
    }
    p.Foo = append(p.Foo, _elem8)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NestedContainersListMapArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listMap_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListMapArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteListBegin(thrift.MAP, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Foo {
    if err := oprot.WriteMapBegin(thrift.I32, thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range v {
      if err := oprot.WriteI32(int32(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersListMapArgs) String() string {
  if p == nil {
    return "<nil>"
  }

  fooVal := fmt.Sprintf("%v", p.Foo)
  return fmt.Sprintf("NestedContainersListMapArgs({Foo:%s})", fooVal)
}

type NestedContainersListMapResult struct {
  thrift.IResponse
}

func NewNestedContainersListMapResult() *NestedContainersListMapResult {
  return &NestedContainersListMapResult{}
}

type NestedContainersListMapResultBuilder struct {
  obj *NestedContainersListMapResult
}

func NewNestedContainersListMapResultBuilder() *NestedContainersListMapResultBuilder{
  return &NestedContainersListMapResultBuilder{
    obj: NewNestedContainersListMapResult(),
  }
}

func (p NestedContainersListMapResultBuilder) Emit() *NestedContainersListMapResult{
  return &NestedContainersListMapResult{
  }
}

func (p *NestedContainersListMapResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListMapResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listMap_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListMapResult) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NestedContainersListMapResult({})")
}

// Attributes:
//  - Foo
type NestedContainersListSetArgs struct {
  thrift.IRequest
  Foo [][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersListSetArgs() *NestedContainersListSetArgs {
  return &NestedContainersListSetArgs{}
}


func (p *NestedContainersListSetArgs) GetFoo() [][]int32 {
  return p.Foo
}
type NestedContainersListSetArgsBuilder struct {
  obj *NestedContainersListSetArgs
}

func NewNestedContainersListSetArgsBuilder() *NestedContainersListSetArgsBuilder{
  return &NestedContainersListSetArgsBuilder{
    obj: NewNestedContainersListSetArgs(),
  }
}

func (p NestedContainersListSetArgsBuilder) Emit() *NestedContainersListSetArgs{
  return &NestedContainersListSetArgs{
    Foo: p.obj.Foo,
  }
}

func (n *NestedContainersListSetArgsBuilder) Foo(foo [][]int32) *NestedContainersListSetArgsBuilder {
  n.obj.Foo = foo
  return n
}

func (n *NestedContainersListSetArgs) SetFoo(foo [][]int32) *NestedContainersListSetArgs {
  n.Foo = foo
  return n
}

func (p *NestedContainersListSetArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListSetArgs)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]int32, 0, size)
  p.Foo =  tSlice
  for i := 0; i < size; i ++ {
    _, size, err := iprot.ReadSetBegin()
    if err != nil {
      return thrift.PrependError("error reading set begin: ", err)
    }
    tSet := make([]int32, 0, size)
    _elem11 :=  tSet
    for i := 0; i < size; i ++ {
      var _elem12 int32
      if v, err := iprot.ReadI32(); err != nil {
        return thrift.PrependError("error reading field 0: ", err)
      } else {
        _elem12 = v
      }
      _elem11 = append(_elem11, _elem12)
    }
    if err := iprot.ReadSetEnd(); err != nil {
      return thrift.PrependError("error reading set end: ", err)
    }
    p.Foo = append(p.Foo, _elem11)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NestedContainersListSetArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listSet_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListSetArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteListBegin(thrift.SET, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Foo {
    if err := oprot.WriteSetBegin(thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    set := make(map[int32]bool, len(v))
    for _, v := range v {
      if ok := set[v]; ok {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", v))
      }
      set[v] = true
    }
    for _, v := range v {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersListSetArgs) String() string {
  if p == nil {
    return "<nil>"
  }

  fooVal := fmt.Sprintf("%v", p.Foo)
  return fmt.Sprintf("NestedContainersListSetArgs({Foo:%s})", fooVal)
}

type NestedContainersListSetResult struct {
  thrift.IResponse
}

func NewNestedContainersListSetResult() *NestedContainersListSetResult {
  return &NestedContainersListSetResult{}
}

type NestedContainersListSetResultBuilder struct {
  obj *NestedContainersListSetResult
}

func NewNestedContainersListSetResultBuilder() *NestedContainersListSetResultBuilder{
  return &NestedContainersListSetResultBuilder{
    obj: NewNestedContainersListSetResult(),
  }
}

func (p NestedContainersListSetResultBuilder) Emit() *NestedContainersListSetResult{
  return &NestedContainersListSetResult{
  }
}

func (p *NestedContainersListSetResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListSetResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listSet_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListSetResult) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NestedContainersListSetResult({})")
}

// Attributes:
//  - Foo
type NestedContainersTurtlesArgs struct {
  thrift.IRequest
  Foo [][]map[int32]map[int32][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersTurtlesArgs() *NestedContainersTurtlesArgs {
  return &NestedContainersTurtlesArgs{}
}


func (p *NestedContainersTurtlesArgs) GetFoo() [][]map[int32]map[int32][]int32 {
  return p.Foo
}
type NestedContainersTurtlesArgsBuilder struct {
  obj *NestedContainersTurtlesArgs
}

func NewNestedContainersTurtlesArgsBuilder() *NestedContainersTurtlesArgsBuilder{
  return &NestedContainersTurtlesArgsBuilder{
    obj: NewNestedContainersTurtlesArgs(),
  }
}

func (p NestedContainersTurtlesArgsBuilder) Emit() *NestedContainersTurtlesArgs{
  return &NestedContainersTurtlesArgs{
    Foo: p.obj.Foo,
  }
}

func (n *NestedContainersTurtlesArgsBuilder) Foo(foo [][]map[int32]map[int32][]int32) *NestedContainersTurtlesArgsBuilder {
  n.obj.Foo = foo
  return n
}

func (n *NestedContainersTurtlesArgs) SetFoo(foo [][]map[int32]map[int32][]int32) *NestedContainersTurtlesArgs {
  n.Foo = foo
  return n
}

func (p *NestedContainersTurtlesArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersTurtlesArgs)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]map[int32]map[int32][]int32, 0, size)
  p.Foo =  tSlice
  for i := 0; i < size; i ++ {
    _, size, err := iprot.ReadListBegin()
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make([]map[int32]map[int32][]int32, 0, size)
    _elem13 :=  tSlice
    for i := 0; i < size; i ++ {
      _, _, size, err := iprot.ReadMapBegin()
      if err != nil {
        return thrift.PrependError("error reading map begin: ", err)
      }
      tMap := make(map[int32]map[int32][]int32, size)
      _elem14 :=  tMap
      for i := 0; i < size; i ++ {
        var _key15 int32
        if v, err := iprot.ReadI32(); err != nil {
          return thrift.PrependError("error reading field 0: ", err)
        } else {
          _key15 = v
        }
        _, _, size, err := iprot.ReadMapBegin()
        if err != nil {
          return thrift.PrependError("error reading map begin: ", err)
        }
        tMap := make(map[int32][]int32, size)
        _val16 :=  tMap
        for i := 0; i < size; i ++ {
          var _key17 int32
          if v, err := iprot.ReadI32(); err != nil {
            return thrift.PrependError("error reading field 0: ", err)
          } else {
            _key17 = v
          }
          _, size, err := iprot.ReadSetBegin()
          if err != nil {
            return thrift.PrependError("error reading set begin: ", err)
          }
          tSet := make([]int32, 0, size)
          _val18 :=  tSet
          for i := 0; i < size; i ++ {
            var _elem19 int32
            if v, err := iprot.ReadI32(); err != nil {
              return thrift.PrependError("error reading field 0: ", err)
            } else {
              _elem19 = v
            }
            _val18 = append(_val18, _elem19)
          }
          if err := iprot.ReadSetEnd(); err != nil {
            return thrift.PrependError("error reading set end: ", err)
          }
          _val16[_key17] = _val18
        }
        if err := iprot.ReadMapEnd(); err != nil {
          return thrift.PrependError("error reading map end: ", err)
        }
        _elem14[_key15] = _val16
      }
      if err := iprot.ReadMapEnd(); err != nil {
        return thrift.PrependError("error reading map end: ", err)
      }
      _elem13 = append(_elem13, _elem14)
    }
    if err := iprot.ReadListEnd(); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Foo = append(p.Foo, _elem13)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NestedContainersTurtlesArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("turtles_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersTurtlesArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteListBegin(thrift.LIST, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Foo {
    if err := oprot.WriteListBegin(thrift.MAP, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := oprot.WriteMapBegin(thrift.I32, thrift.MAP, len(v)); err != nil {
        return thrift.PrependError("error writing map begin: ", err)
      }
      for k, v := range v {
        if err := oprot.WriteI32(int32(k)); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
        if err := oprot.WriteMapBegin(thrift.I32, thrift.SET, len(v)); err != nil {
          return thrift.PrependError("error writing map begin: ", err)
        }
        for k, v := range v {
          if err := oprot.WriteI32(int32(k)); err != nil {
          return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
          if err := oprot.WriteSetBegin(thrift.I32, len(v)); err != nil {
            return thrift.PrependError("error writing set begin: ", err)
          }
          set := make(map[int32]bool, len(v))
          for _, v := range v {
            if ok := set[v]; ok {
              return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", v))
            }
            set[v] = true
          }
          for _, v := range v {
            if err := oprot.WriteI32(int32(v)); err != nil {
            return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
          }
          if err := oprot.WriteSetEnd(); err != nil {
            return thrift.PrependError("error writing set end: ", err)
          }
        }
        if err := oprot.WriteMapEnd(); err != nil {
          return thrift.PrependError("error writing map end: ", err)
        }
      }
      if err := oprot.WriteMapEnd(); err != nil {
        return thrift.PrependError("error writing map end: ", err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersTurtlesArgs) String() string {
  if p == nil {
    return "<nil>"
  }

  fooVal := fmt.Sprintf("%v", p.Foo)
  return fmt.Sprintf("NestedContainersTurtlesArgs({Foo:%s})", fooVal)
}

type NestedContainersTurtlesResult struct {
  thrift.IResponse
}

func NewNestedContainersTurtlesResult() *NestedContainersTurtlesResult {
  return &NestedContainersTurtlesResult{}
}

type NestedContainersTurtlesResultBuilder struct {
  obj *NestedContainersTurtlesResult
}

func NewNestedContainersTurtlesResultBuilder() *NestedContainersTurtlesResultBuilder{
  return &NestedContainersTurtlesResultBuilder{
    obj: NewNestedContainersTurtlesResult(),
  }
}

func (p NestedContainersTurtlesResultBuilder) Emit() *NestedContainersTurtlesResult{
  return &NestedContainersTurtlesResult{
  }
}

func (p *NestedContainersTurtlesResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersTurtlesResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("turtles_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersTurtlesResult) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NestedContainersTurtlesResult({})")
}


