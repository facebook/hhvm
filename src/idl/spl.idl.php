<?php
/**
 * Automatically generated by running "php schema.php spl".
 *
 * You may modify the file, but re-running schema.php against this file will
 * standardize the format without losing your schema changes. It does lose
 * any changes that are not part of schema. Use "note" field to comment on
 * schema itself, and "note" fields are not used in any code generation but
 * only staying within this file.
 *
 * @nolint
 */
///////////////////////////////////////////////////////////////////////////////
// Preamble: C++ code inserted at beginning of ext_{name}.h

DefinePreamble(<<<CPP

CPP
);

///////////////////////////////////////////////////////////////////////////////
// Constants
//
// array (
//   'name' => name of the constant
//   'type' => type of the constant
//   'note' => additional note about this constant's schema
// )


///////////////////////////////////////////////////////////////////////////////
// Functions
//
// array (
//   'name'   => name of the function
//   'desc'   => description of the function's purpose
//   'flags'  => attributes of the function, see base.php for possible values
//   'opt'    => optimization callback function's name for compiler
//   'note'   => additional note about this function's schema
//   'return' =>
//      array (
//        'type'  => return type, use Reference for ref return
//        'desc'  => description of the return value
//      )
//   'args'   => arguments
//      array (
//        'name'  => name of the argument
//        'type'  => type of the argument, use Reference for output parameter
//        'value' => default value of the argument
//        'desc'  => description of the argument
//      )
// )

DefineFunction(
  array(
    'name'   => "spl_classes",
    'desc'   => "This function returns an array with the current available SPL classes.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => StringMap,
      'desc'   => "Returns an array containing the currently available SPL classes.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "spl_object_hash",
    'desc'   => "This function returns a unique identifier for the object. This id can be used as a hash key for storing objects or for identifying an object.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "A string that is unique for each currently existing object and is always the same for each object.",
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Object,
        'desc'   => "Any object.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "hphp_object_pointer",
    'desc'   => "This function returns low level raw pointer the object. Used by closure and internal purposes.",
    'flags'  =>  HasDocComment | NoInjection,
    'return' => array(
      'type'   => Int64,
      'desc'   => "Low level ObjectData pointer.",
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Object,
        'desc'   => "Any object.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "hphp_get_this",
    'desc'   => "This function returns this object if present, or NULL.",
    'flags'  =>  HasDocComment | NoInjection,
    'return' => array(
      'type'   => Variant,
      'desc'   => "This object.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "class_implements",
    'desc'   => "This function returns an array with the names of the interfaces that the given class and its parents implement.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "An array on success, or FALSE on error.",
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
        'desc'   => "An object (class instance) or a string (class name).",
      ),
      array(
        'name'   => "autoload",
        'type'   => Boolean,
        'value'  => "true",
        'desc'   => "Whether to allow this function to load the class automatically through the __autoload magic method.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "class_parents",
    'desc'   => "This function returns an array with the name of the parent classes of the given class.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "An array on success, or FALSE on error.",
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
        'desc'   => "An object (class instance) or a string (class name).",
      ),
      array(
        'name'   => "autoload",
        'type'   => Boolean,
        'value'  => "true",
        'desc'   => "Whether to allow this function to load the class automatically through the __autoload magic method.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "iterator_apply",
    'desc'   => "Calls a function for every element in an iterator.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the iteration count.",
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
        'desc'   => "The class to iterate over.",
      ),
      array(
        'name'   => "func",
        'type'   => Variant,
        'desc'   => "The callback function to call on every element. The function must return TRUE in order to continue iterating over the iterator.",
      ),
      array(
        'name'   => "params",
        'type'   => VariantMap,
        'value'  => "null_array",
        'desc'   => "Arguments to pass to the callback function.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "iterator_count",
    'desc'   => "Count the elements in an iterator.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The number of elements in iterator.",
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
        'desc'   => "The iterator being counted.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "iterator_to_array",
    'desc'   => "Copy the elements of an iterator into an array.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "An array containing the elements of the iterator.",
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
        'desc'   => "The iterator being copied.",
      ),
      array(
        'name'   => "use_keys",
        'type'   => Boolean,
        'value'  => "true",
        'desc'   => "Whether to use the iterator element keys as index.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "spl_autoload_call",
    'desc'   => "This function can be used to manually search for a class or interface using the registered __autoload functions.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => null,
      'desc'   => "No value is returned.",
    ),
    'args'   => array(
      array(
        'name'   => "class_name",
        'type'   => String,
        'desc'   => "The class name being searched.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "spl_autoload_extensions",
    'desc'   => "This function can modify and check the file extensions that the built in __autoload() fallback function spl_autoload() will be using.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "A comma delimited list of default file extensions for spl_autoload().",
    ),
    'args'   => array(
      array(
        'name'   => "file_extensions",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "When calling without an argument, it simply returns the current list of extensions each separated by comma. To modify the list of file extensions, simply invoke the functions with the new list of file extensions to use in a single string with each extensions separated by comma.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "spl_autoload_functions",
    'desc'   => "Get all registered __autoload() functions.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "An array of all registered __autoload functions. If the autoload stack is not activated then the return value is FALSE. If no function is registered the return value will be an empty array.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "spl_autoload_register",
    'desc'   => "Register a function with the spl provided __autoload stack. If the stack is not yet activated it will be activated.\n\nIf your code has an existing __autoload function then this function must be explicitly registered on the __autoload stack. This is because spl_autoload_register() will effectively replace the engine cache for the __autoload function by either spl_autoload() or spl_autoload_call().\n\nIf there must be multiple autoload functions, spl_autoload_register() allows for this. It effectively creates a queue of autoload functions, and runs through each of them in the order they are defined. By contrast, __autoload() may only be defined once.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "autoload_function",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "The autoload function being registered. If no parameter is provided, then the default implementation of spl_autoload() will be registered.",
      ),
      array(
        'name'   => "throws",
        'type'   => Boolean,
        'value'  => "true",
        'desc'   => "This parameter specifies whether spl_autoload_register() should throw exceptions on error.",
      ),
      array(
        'name'   => "prepend",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "If true, spl_autoload_register() will prepend the autoloader on the autoload stack instead of appending it.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "spl_autoload_unregister",
    'desc'   => "Unregister a function from the spl provided __autoload stack. If the stack is activated and empty after unregistering the given function then it will be deactivated.\n\nWhen this function results in the autoload stack being deactivated, any __autoload function that previously existed will not be reactivated.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "autoload_function",
        'type'   => Variant,
        'desc'   => "The autoload function being unregistered.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "spl_autoload",
    'desc'   => "This function is intended to be used as a default implementation for __autoload(). If nothing else is specified and spl_autoload_register() is called without any parameters then this functions will be used for any later call to __autoload().",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => null,
      'desc'   => "No value is returned.",
    ),
    'args'   => array(
      array(
        'name'   => "class_name",
        'type'   => String,
      ),
      array(
        'name'   => "file_extensions",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "By default it checks all include paths to contain filenames built up by the lowercase class name appended by the filename extensions .inc and .php.",
      ),
    ),
  ));


///////////////////////////////////////////////////////////////////////////////
// Classes
//
// BeginClass
// array (
//   'name'   => name of the class
//   'desc'   => description of the class's purpose
//   'flags'  => attributes of the class, see base.php for possible values
//   'note'   => additional note about this class's schema
//   'parent' => parent class name, if any
//   'ifaces' => array of interfaces tihs class implements
//   'bases'  => extra internal and special base classes this class requires
//   'footer' => extra C++ inserted at end of class declaration
// )
//
// DefineConstant(..)
// DefineConstant(..)
// ...
// DefineFunction(..)
// DefineFunction(..)
// ...
// DefineProperty
// DefineProperty
//
// array (
//   'name'  => name of the property
//   'type'  => type of the property
//   'flags' => attributes of the property
//   'desc'  => description of the property
//   'note'  => additional note about this property's schema
// )
//
// EndClass()

