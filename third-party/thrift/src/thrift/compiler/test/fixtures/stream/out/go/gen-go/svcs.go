// Autogenerated by Thrift for thrift/compiler/test/fixtures/stream/src/module.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package module

import (
    "context"
    "errors"
    "fmt"
    "io"
    "iter"
    "reflect"
    "sync"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift/types"
    metadata "github.com/facebook/fbthrift/thrift/lib/thrift/metadata"
)

// (needed to ensure safety because of naive import list construction)
var _ = context.Background
var _ = errors.New
var _ = fmt.Printf
var _ = io.EOF
var _ = iter.Pull[bool]
var _ = reflect.Ptr
var _ = sync.OnceFunc
var _ = thrift.VOID
var _ = metadata.GoUnusedProtection__


type PubSubStreamingService interface {
    Returnstream(ctx context.Context, i32From int32, i32To int32) (func(context.Context, chan<- int32) error, error)
    Streamthrows(ctx context.Context, foo int32) (func(context.Context, chan<- int32) error, error)
    Servicethrows(ctx context.Context, foo int32) (func(context.Context, chan<- int32) error, error)
    Servicethrows2(ctx context.Context, foo int32) (func(context.Context, chan<- int32) error, error)
    Boththrows(ctx context.Context, foo int32) (func(context.Context, chan<- int32) error, error)
    Responseandstreamstreamthrows(ctx context.Context, foo int32) (int32, func(context.Context, chan<- int32) error, error)
    Responseandstreamservicethrows(ctx context.Context, foo int32) (int32, func(context.Context, chan<- int32) error, error)
    Responseandstreamboththrows(ctx context.Context, foo int32) (int32, func(context.Context, chan<- int32) error, error)
    ReturnstreamFast(ctx context.Context, i32From int32, i32To int32) (func(context.Context, chan<- int32) error, error)
}

type PubSubStreamingServiceClient interface {
    io.Closer
    Returnstream(ctx context.Context, i32From int32, i32To int32) (iter.Seq2[int32, error], error)
    Streamthrows(ctx context.Context, foo int32) (iter.Seq2[int32, error], error)
    Servicethrows(ctx context.Context, foo int32) (iter.Seq2[int32, error], error)
    Servicethrows2(ctx context.Context, foo int32) (iter.Seq2[int32, error], error)
    Boththrows(ctx context.Context, foo int32) (iter.Seq2[int32, error], error)
    Responseandstreamstreamthrows(ctx context.Context, foo int32) (int32, iter.Seq2[int32, error], error)
    Responseandstreamservicethrows(ctx context.Context, foo int32) (int32, iter.Seq2[int32, error], error)
    Responseandstreamboththrows(ctx context.Context, foo int32) (int32, iter.Seq2[int32, error], error)
    ReturnstreamFast(ctx context.Context, i32From int32, i32To int32) (iter.Seq2[int32, error], error)
}

type pubSubStreamingServiceClientImpl struct {
    ch thrift.RequestChannel
}
// Compile time interface enforcer
var _ PubSubStreamingServiceClient = (*pubSubStreamingServiceClientImpl)(nil)

func NewPubSubStreamingServiceChannelClient(channel thrift.RequestChannel) PubSubStreamingServiceClient {
    return &pubSubStreamingServiceClientImpl{
        ch: channel,
    }
}

func init() {
    thrift.InternalRegisterClientConstructor[PubSubStreamingServiceClient](NewPubSubStreamingServiceChannelClient)
}

func (c *pubSubStreamingServiceClientImpl) Close() error {
    return c.ch.Close()
}

func (c *pubSubStreamingServiceClientImpl) Returnstream(ctx context.Context, i32From int32, i32To int32) (iter.Seq2[int32, error], error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceReturnstream{
        I32From: i32From,
        I32To: i32To,
    }
    fbthriftResp := newRespPubSubStreamingServiceReturnstream()

    fbthriftChannel := c.ch

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftNewStreamElemFn := func() thrift.ReadableResult {
        return newStreamPubSubStreamingServiceReturnstream()
    }
    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceReturnstream()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftStreamSeq := func(yield func(int32, error) bool) {
        for elem := range fbthriftElemChan {
            if !yield(elem, nil) {
                return
            }
        }
        for err := range fbthriftErrChan {
            if !yield(0, err) {
                return
            }
        }
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    _, fbthriftErr := fbthriftChannel.SendRequestStream(
        fbthriftStreamCtx,
        "returnstream",
        fbthriftReq,
        fbthriftResp,
        fbthriftNewStreamElemFn,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, fbthriftEx
    }
    return fbthriftStreamSeq, nil
}

func (c *pubSubStreamingServiceClientImpl) Streamthrows(ctx context.Context, foo int32) (iter.Seq2[int32, error], error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceStreamthrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceStreamthrows()

    fbthriftChannel := c.ch

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftNewStreamElemFn := func() thrift.ReadableResult {
        return newStreamPubSubStreamingServiceStreamthrows()
    }
    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceStreamthrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftStreamSeq := func(yield func(int32, error) bool) {
        for elem := range fbthriftElemChan {
            if !yield(elem, nil) {
                return
            }
        }
        for err := range fbthriftErrChan {
            if !yield(0, err) {
                return
            }
        }
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    _, fbthriftErr := fbthriftChannel.SendRequestStream(
        fbthriftStreamCtx,
        "streamthrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftNewStreamElemFn,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, fbthriftEx
    }
    return fbthriftStreamSeq, nil
}

func (c *pubSubStreamingServiceClientImpl) Servicethrows(ctx context.Context, foo int32) (iter.Seq2[int32, error], error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceServicethrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceServicethrows()

    fbthriftChannel := c.ch

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftNewStreamElemFn := func() thrift.ReadableResult {
        return newStreamPubSubStreamingServiceServicethrows()
    }
    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceServicethrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftStreamSeq := func(yield func(int32, error) bool) {
        for elem := range fbthriftElemChan {
            if !yield(elem, nil) {
                return
            }
        }
        for err := range fbthriftErrChan {
            if !yield(0, err) {
                return
            }
        }
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    _, fbthriftErr := fbthriftChannel.SendRequestStream(
        fbthriftStreamCtx,
        "servicethrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftNewStreamElemFn,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, fbthriftEx
    }
    return fbthriftStreamSeq, nil
}

func (c *pubSubStreamingServiceClientImpl) Servicethrows2(ctx context.Context, foo int32) (iter.Seq2[int32, error], error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceServicethrows2{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceServicethrows2()

    fbthriftChannel := c.ch

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftNewStreamElemFn := func() thrift.ReadableResult {
        return newStreamPubSubStreamingServiceServicethrows2()
    }
    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceServicethrows2()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftStreamSeq := func(yield func(int32, error) bool) {
        for elem := range fbthriftElemChan {
            if !yield(elem, nil) {
                return
            }
        }
        for err := range fbthriftErrChan {
            if !yield(0, err) {
                return
            }
        }
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    _, fbthriftErr := fbthriftChannel.SendRequestStream(
        fbthriftStreamCtx,
        "servicethrows2",
        fbthriftReq,
        fbthriftResp,
        fbthriftNewStreamElemFn,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, fbthriftEx
    }
    return fbthriftStreamSeq, nil
}

func (c *pubSubStreamingServiceClientImpl) Boththrows(ctx context.Context, foo int32) (iter.Seq2[int32, error], error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceBoththrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceBoththrows()

    fbthriftChannel := c.ch

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftNewStreamElemFn := func() thrift.ReadableResult {
        return newStreamPubSubStreamingServiceBoththrows()
    }
    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceBoththrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftStreamSeq := func(yield func(int32, error) bool) {
        for elem := range fbthriftElemChan {
            if !yield(elem, nil) {
                return
            }
        }
        for err := range fbthriftErrChan {
            if !yield(0, err) {
                return
            }
        }
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    _, fbthriftErr := fbthriftChannel.SendRequestStream(
        fbthriftStreamCtx,
        "boththrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftNewStreamElemFn,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, fbthriftEx
    }
    return fbthriftStreamSeq, nil
}

func (c *pubSubStreamingServiceClientImpl) Responseandstreamstreamthrows(ctx context.Context, foo int32) (int32, iter.Seq2[int32, error], error) {
    var fbthriftRespZero int32
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return fbthriftRespZero, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceResponseandstreamstreamthrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceResponseandstreamstreamthrows()

    fbthriftChannel := c.ch

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftNewStreamElemFn := func() thrift.ReadableResult {
        return newStreamPubSubStreamingServiceResponseandstreamstreamthrows()
    }
    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceResponseandstreamstreamthrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftStreamSeq := func(yield func(int32, error) bool) {
        for elem := range fbthriftElemChan {
            if !yield(elem, nil) {
                return
            }
        }
        for err := range fbthriftErrChan {
            if !yield(0, err) {
                return
            }
        }
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    _, fbthriftErr := fbthriftChannel.SendRequestStream(
        fbthriftStreamCtx,
        "responseandstreamstreamthrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftNewStreamElemFn,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), fbthriftStreamSeq, nil
}

func (c *pubSubStreamingServiceClientImpl) Responseandstreamservicethrows(ctx context.Context, foo int32) (int32, iter.Seq2[int32, error], error) {
    var fbthriftRespZero int32
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return fbthriftRespZero, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceResponseandstreamservicethrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceResponseandstreamservicethrows()

    fbthriftChannel := c.ch

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftNewStreamElemFn := func() thrift.ReadableResult {
        return newStreamPubSubStreamingServiceResponseandstreamservicethrows()
    }
    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceResponseandstreamservicethrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftStreamSeq := func(yield func(int32, error) bool) {
        for elem := range fbthriftElemChan {
            if !yield(elem, nil) {
                return
            }
        }
        for err := range fbthriftErrChan {
            if !yield(0, err) {
                return
            }
        }
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    _, fbthriftErr := fbthriftChannel.SendRequestStream(
        fbthriftStreamCtx,
        "responseandstreamservicethrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftNewStreamElemFn,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), fbthriftStreamSeq, nil
}

func (c *pubSubStreamingServiceClientImpl) Responseandstreamboththrows(ctx context.Context, foo int32) (int32, iter.Seq2[int32, error], error) {
    var fbthriftRespZero int32
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return fbthriftRespZero, nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceResponseandstreamboththrows{
        Foo: foo,
    }
    fbthriftResp := newRespPubSubStreamingServiceResponseandstreamboththrows()

    fbthriftChannel := c.ch

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftNewStreamElemFn := func() thrift.ReadableResult {
        return newStreamPubSubStreamingServiceResponseandstreamboththrows()
    }
    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceResponseandstreamboththrows()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftStreamSeq := func(yield func(int32, error) bool) {
        for elem := range fbthriftElemChan {
            if !yield(elem, nil) {
                return
            }
        }
        for err := range fbthriftErrChan {
            if !yield(0, err) {
                return
            }
        }
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    _, fbthriftErr := fbthriftChannel.SendRequestStream(
        fbthriftStreamCtx,
        "responseandstreamboththrows",
        fbthriftReq,
        fbthriftResp,
        fbthriftNewStreamElemFn,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return fbthriftRespZero, nil, fbthriftEx
    }
    return fbthriftResp.GetSuccess(), fbthriftStreamSeq, nil
}

func (c *pubSubStreamingServiceClientImpl) ReturnstreamFast(ctx context.Context, i32From int32, i32To int32) (iter.Seq2[int32, error], error) {
    // Must be a cancellable context to prevent goroutine leaks
    if ctx.Done() == nil {
		return nil, errors.New("context does not support cancellation")
	}
    fbthriftStreamCtx, fbthriftStreamCancel := context.WithCancel(ctx)

    fbthriftReq := &reqPubSubStreamingServiceReturnstreamFast{
        I32From: i32From,
        I32To: i32To,
    }
    fbthriftResp := newRespPubSubStreamingServiceReturnstreamFast()

    fbthriftChannel := c.ch

    fbthriftErrChan := make(chan error, 1)
    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)

    fbthriftNewStreamElemFn := func() thrift.ReadableResult {
        return newStreamPubSubStreamingServiceReturnstreamFast()
    }
    fbthriftOnStreamNextFn := func(d thrift.Decoder) error {
        fbthriftStreamValue := newStreamPubSubStreamingServiceReturnstreamFast()
        fbthriftSpecErr := fbthriftStreamValue.Read(d)
        if fbthriftSpecErr != nil {
            return fbthriftSpecErr
        } else if fbthriftStreamEx := fbthriftStreamValue.Exception(); fbthriftStreamEx != nil {
            return fbthriftStreamEx
        }
        fbthriftElemChan <- fbthriftStreamValue.GetSuccess()
        return nil
    }
    fbthriftStreamSeq := func(yield func(int32, error) bool) {
        for elem := range fbthriftElemChan {
            if !yield(elem, nil) {
                return
            }
        }
        for err := range fbthriftErrChan {
            if !yield(0, err) {
                return
            }
        }
    }
    fbthriftOnStreamErrorFn := func(err error) {
        fbthriftErrChan <- err
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }
    fbthriftOnStreamCompleteFn := func() {
        close(fbthriftElemChan)
        close(fbthriftErrChan)
    }

    _, fbthriftErr := fbthriftChannel.SendRequestStream(
        fbthriftStreamCtx,
        "returnstreamFast",
        fbthriftReq,
        fbthriftResp,
        fbthriftNewStreamElemFn,
        fbthriftOnStreamNextFn,
        fbthriftOnStreamErrorFn,
        fbthriftOnStreamCompleteFn,
    )
    if fbthriftErr != nil {
        fbthriftStreamCancel()
        return nil, fbthriftErr
    } else if fbthriftEx := fbthriftResp.Exception(); fbthriftEx != nil {
        fbthriftStreamCancel()
        return nil, fbthriftEx
    }
    return fbthriftStreamSeq, nil
}


type PubSubStreamingServiceProcessor struct {
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler              PubSubStreamingService
}

func NewPubSubStreamingServiceProcessor(handler PubSubStreamingService) *PubSubStreamingServiceProcessor {
    p := &PubSubStreamingServiceProcessor{
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    }
    p.AddToProcessorFunctionMap("returnstream", &procFuncPubSubStreamingServiceReturnstream{handler: handler})
    p.AddToProcessorFunctionMap("streamthrows", &procFuncPubSubStreamingServiceStreamthrows{handler: handler})
    p.AddToProcessorFunctionMap("servicethrows", &procFuncPubSubStreamingServiceServicethrows{handler: handler})
    p.AddToProcessorFunctionMap("servicethrows2", &procFuncPubSubStreamingServiceServicethrows2{handler: handler})
    p.AddToProcessorFunctionMap("boththrows", &procFuncPubSubStreamingServiceBoththrows{handler: handler})
    p.AddToProcessorFunctionMap("responseandstreamstreamthrows", &procFuncPubSubStreamingServiceResponseandstreamstreamthrows{handler: handler})
    p.AddToProcessorFunctionMap("responseandstreamservicethrows", &procFuncPubSubStreamingServiceResponseandstreamservicethrows{handler: handler})
    p.AddToProcessorFunctionMap("responseandstreamboththrows", &procFuncPubSubStreamingServiceResponseandstreamboththrows{handler: handler})
    p.AddToProcessorFunctionMap("returnstreamFast", &procFuncPubSubStreamingServiceReturnstreamFast{handler: handler})
    p.AddToFunctionServiceMap("returnstream", "PubSubStreamingService")
    p.AddToFunctionServiceMap("streamthrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("servicethrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("servicethrows2", "PubSubStreamingService")
    p.AddToFunctionServiceMap("boththrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("responseandstreamstreamthrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("responseandstreamservicethrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("responseandstreamboththrows", "PubSubStreamingService")
    p.AddToFunctionServiceMap("returnstreamFast", "PubSubStreamingService")

    return p
}

func (p *PubSubStreamingServiceProcessor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *PubSubStreamingServiceProcessor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *PubSubStreamingServiceProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *PubSubStreamingServiceProcessor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *PubSubStreamingServiceProcessor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *PubSubStreamingServiceProcessor) PackageName() string {
    return "module"
}

func (p *PubSubStreamingServiceProcessor) GetThriftMetadata() *metadata.ThriftMetadata {
    return GetThriftMetadataForService("module.PubSubStreamingService")
}


type procFuncPubSubStreamingServiceReturnstream struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceReturnstream)(nil)

func (p *procFuncPubSubStreamingServiceReturnstream) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceReturnstream()
}

func (p *procFuncPubSubStreamingServiceReturnstream) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncPubSubStreamingServiceReturnstream) RunStreamContext(
    ctx context.Context,
    reqStruct thrift.ReadableStruct,
    onFirstResponse func(thrift.WritableStruct),
    onStreamNext func(thrift.WritableStruct),
    onStreamComplete func(),
) {
    args := reqStruct.(*reqPubSubStreamingServiceReturnstream)
    firstResponse := newRespPubSubStreamingServiceReturnstream()
    elemProducerFunc, initialErr := p.handler.Returnstream(ctx, args.I32From, args.I32To)
    if initialErr != nil {
        internalErr := fmt.Errorf("Internal error processing Returnstream: %w", initialErr)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        onFirstResponse(x)
        onStreamComplete()
        return
    }

    onFirstResponse(firstResponse)

    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)
    var senderWg sync.WaitGroup
    senderWg.Add(1)
    // Sender goroutine (receives elements on the channel and sends them out via onStreamNext)
    go func() {
        defer senderWg.Done()
        for elem := range fbthriftElemChan {
            streamWrapStruct := newStreamPubSubStreamingServiceReturnstream()
            streamWrapStruct.Success = &elem
            onStreamNext(streamWrapStruct)
        }
    }()

    streamErr := elemProducerFunc(ctx, fbthriftElemChan)
    // Stream is complete. Close the channel and wait for the sender goroutine to finish.
    close(fbthriftElemChan)
    senderWg.Wait()
    if streamErr != nil {
        internalErr := fmt.Errorf("Internal stream handler error Returnstream: %w", streamErr)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        onStreamNext(x)
    }
    onStreamComplete()
}

type procFuncPubSubStreamingServiceStreamthrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceStreamthrows)(nil)

func (p *procFuncPubSubStreamingServiceStreamthrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceStreamthrows()
}

func (p *procFuncPubSubStreamingServiceStreamthrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncPubSubStreamingServiceStreamthrows) RunStreamContext(
    ctx context.Context,
    reqStruct thrift.ReadableStruct,
    onFirstResponse func(thrift.WritableStruct),
    onStreamNext func(thrift.WritableStruct),
    onStreamComplete func(),
) {
    args := reqStruct.(*reqPubSubStreamingServiceStreamthrows)
    firstResponse := newRespPubSubStreamingServiceStreamthrows()
    elemProducerFunc, initialErr := p.handler.Streamthrows(ctx, args.Foo)
    if initialErr != nil {
        internalErr := fmt.Errorf("Internal error processing Streamthrows: %w", initialErr)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        onFirstResponse(x)
        onStreamComplete()
        return
    }

    onFirstResponse(firstResponse)

    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)
    var senderWg sync.WaitGroup
    senderWg.Add(1)
    // Sender goroutine (receives elements on the channel and sends them out via onStreamNext)
    go func() {
        defer senderWg.Done()
        for elem := range fbthriftElemChan {
            streamWrapStruct := newStreamPubSubStreamingServiceStreamthrows()
            streamWrapStruct.Success = &elem
            onStreamNext(streamWrapStruct)
        }
    }()

    streamErr := elemProducerFunc(ctx, fbthriftElemChan)
    // Stream is complete. Close the channel and wait for the sender goroutine to finish.
    close(fbthriftElemChan)
    senderWg.Wait()
    if streamErr != nil {
        streamWrapStruct := newStreamPubSubStreamingServiceStreamthrows()
        switch v := streamErr.(type) {
        case *FooStreamEx:
            streamWrapStruct.E = v
            onStreamNext(streamWrapStruct)
        default:
            internalErr := fmt.Errorf("Internal stream handler error Streamthrows: %w", streamErr)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            onStreamNext(x)
        }
    }
    onStreamComplete()
}

type procFuncPubSubStreamingServiceServicethrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceServicethrows)(nil)

func (p *procFuncPubSubStreamingServiceServicethrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceServicethrows()
}

func (p *procFuncPubSubStreamingServiceServicethrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncPubSubStreamingServiceServicethrows) RunStreamContext(
    ctx context.Context,
    reqStruct thrift.ReadableStruct,
    onFirstResponse func(thrift.WritableStruct),
    onStreamNext func(thrift.WritableStruct),
    onStreamComplete func(),
) {
    args := reqStruct.(*reqPubSubStreamingServiceServicethrows)
    firstResponse := newRespPubSubStreamingServiceServicethrows()
    elemProducerFunc, initialErr := p.handler.Servicethrows(ctx, args.Foo)
    if initialErr != nil {
        switch v := initialErr.(type) {
        case *FooEx:
            firstResponse.E = v
            onFirstResponse(firstResponse)
        default:
            internalErr := fmt.Errorf("Internal error processing Servicethrows: %w", initialErr)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            onFirstResponse(x)
        }
        onStreamComplete()
        return
    }

    onFirstResponse(firstResponse)

    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)
    var senderWg sync.WaitGroup
    senderWg.Add(1)
    // Sender goroutine (receives elements on the channel and sends them out via onStreamNext)
    go func() {
        defer senderWg.Done()
        for elem := range fbthriftElemChan {
            streamWrapStruct := newStreamPubSubStreamingServiceServicethrows()
            streamWrapStruct.Success = &elem
            onStreamNext(streamWrapStruct)
        }
    }()

    streamErr := elemProducerFunc(ctx, fbthriftElemChan)
    // Stream is complete. Close the channel and wait for the sender goroutine to finish.
    close(fbthriftElemChan)
    senderWg.Wait()
    if streamErr != nil {
        internalErr := fmt.Errorf("Internal stream handler error Servicethrows: %w", streamErr)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        onStreamNext(x)
    }
    onStreamComplete()
}

type procFuncPubSubStreamingServiceServicethrows2 struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceServicethrows2)(nil)

func (p *procFuncPubSubStreamingServiceServicethrows2) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceServicethrows2()
}

func (p *procFuncPubSubStreamingServiceServicethrows2) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncPubSubStreamingServiceServicethrows2) RunStreamContext(
    ctx context.Context,
    reqStruct thrift.ReadableStruct,
    onFirstResponse func(thrift.WritableStruct),
    onStreamNext func(thrift.WritableStruct),
    onStreamComplete func(),
) {
    args := reqStruct.(*reqPubSubStreamingServiceServicethrows2)
    firstResponse := newRespPubSubStreamingServiceServicethrows2()
    elemProducerFunc, initialErr := p.handler.Servicethrows2(ctx, args.Foo)
    if initialErr != nil {
        switch v := initialErr.(type) {
        case *FooEx:
            firstResponse.E1 = v
            onFirstResponse(firstResponse)
        case *FooEx2:
            firstResponse.E2 = v
            onFirstResponse(firstResponse)
        default:
            internalErr := fmt.Errorf("Internal error processing Servicethrows2: %w", initialErr)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            onFirstResponse(x)
        }
        onStreamComplete()
        return
    }

    onFirstResponse(firstResponse)

    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)
    var senderWg sync.WaitGroup
    senderWg.Add(1)
    // Sender goroutine (receives elements on the channel and sends them out via onStreamNext)
    go func() {
        defer senderWg.Done()
        for elem := range fbthriftElemChan {
            streamWrapStruct := newStreamPubSubStreamingServiceServicethrows2()
            streamWrapStruct.Success = &elem
            onStreamNext(streamWrapStruct)
        }
    }()

    streamErr := elemProducerFunc(ctx, fbthriftElemChan)
    // Stream is complete. Close the channel and wait for the sender goroutine to finish.
    close(fbthriftElemChan)
    senderWg.Wait()
    if streamErr != nil {
        internalErr := fmt.Errorf("Internal stream handler error Servicethrows2: %w", streamErr)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        onStreamNext(x)
    }
    onStreamComplete()
}

type procFuncPubSubStreamingServiceBoththrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceBoththrows)(nil)

func (p *procFuncPubSubStreamingServiceBoththrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceBoththrows()
}

func (p *procFuncPubSubStreamingServiceBoththrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncPubSubStreamingServiceBoththrows) RunStreamContext(
    ctx context.Context,
    reqStruct thrift.ReadableStruct,
    onFirstResponse func(thrift.WritableStruct),
    onStreamNext func(thrift.WritableStruct),
    onStreamComplete func(),
) {
    args := reqStruct.(*reqPubSubStreamingServiceBoththrows)
    firstResponse := newRespPubSubStreamingServiceBoththrows()
    elemProducerFunc, initialErr := p.handler.Boththrows(ctx, args.Foo)
    if initialErr != nil {
        switch v := initialErr.(type) {
        case *FooEx:
            firstResponse.E = v
            onFirstResponse(firstResponse)
        default:
            internalErr := fmt.Errorf("Internal error processing Boththrows: %w", initialErr)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            onFirstResponse(x)
        }
        onStreamComplete()
        return
    }

    onFirstResponse(firstResponse)

    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)
    var senderWg sync.WaitGroup
    senderWg.Add(1)
    // Sender goroutine (receives elements on the channel and sends them out via onStreamNext)
    go func() {
        defer senderWg.Done()
        for elem := range fbthriftElemChan {
            streamWrapStruct := newStreamPubSubStreamingServiceBoththrows()
            streamWrapStruct.Success = &elem
            onStreamNext(streamWrapStruct)
        }
    }()

    streamErr := elemProducerFunc(ctx, fbthriftElemChan)
    // Stream is complete. Close the channel and wait for the sender goroutine to finish.
    close(fbthriftElemChan)
    senderWg.Wait()
    if streamErr != nil {
        streamWrapStruct := newStreamPubSubStreamingServiceBoththrows()
        switch v := streamErr.(type) {
        case *FooStreamEx:
            streamWrapStruct.E = v
            onStreamNext(streamWrapStruct)
        default:
            internalErr := fmt.Errorf("Internal stream handler error Boththrows: %w", streamErr)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            onStreamNext(x)
        }
    }
    onStreamComplete()
}

type procFuncPubSubStreamingServiceResponseandstreamstreamthrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceResponseandstreamstreamthrows)(nil)

func (p *procFuncPubSubStreamingServiceResponseandstreamstreamthrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceResponseandstreamstreamthrows()
}

func (p *procFuncPubSubStreamingServiceResponseandstreamstreamthrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncPubSubStreamingServiceResponseandstreamstreamthrows) RunStreamContext(
    ctx context.Context,
    reqStruct thrift.ReadableStruct,
    onFirstResponse func(thrift.WritableStruct),
    onStreamNext func(thrift.WritableStruct),
    onStreamComplete func(),
) {
    args := reqStruct.(*reqPubSubStreamingServiceResponseandstreamstreamthrows)
    firstResponse := newRespPubSubStreamingServiceResponseandstreamstreamthrows()
    retval, elemProducerFunc, initialErr := p.handler.Responseandstreamstreamthrows(ctx, args.Foo)
    if initialErr != nil {
        internalErr := fmt.Errorf("Internal error processing Responseandstreamstreamthrows: %w", initialErr)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        onFirstResponse(x)
        onStreamComplete()
        return
    }

    firstResponse.Success = &retval
    onFirstResponse(firstResponse)

    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)
    var senderWg sync.WaitGroup
    senderWg.Add(1)
    // Sender goroutine (receives elements on the channel and sends them out via onStreamNext)
    go func() {
        defer senderWg.Done()
        for elem := range fbthriftElemChan {
            streamWrapStruct := newStreamPubSubStreamingServiceResponseandstreamstreamthrows()
            streamWrapStruct.Success = &elem
            onStreamNext(streamWrapStruct)
        }
    }()

    streamErr := elemProducerFunc(ctx, fbthriftElemChan)
    // Stream is complete. Close the channel and wait for the sender goroutine to finish.
    close(fbthriftElemChan)
    senderWg.Wait()
    if streamErr != nil {
        streamWrapStruct := newStreamPubSubStreamingServiceResponseandstreamstreamthrows()
        switch v := streamErr.(type) {
        case *FooStreamEx:
            streamWrapStruct.E = v
            onStreamNext(streamWrapStruct)
        default:
            internalErr := fmt.Errorf("Internal stream handler error Responseandstreamstreamthrows: %w", streamErr)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            onStreamNext(x)
        }
    }
    onStreamComplete()
}

type procFuncPubSubStreamingServiceResponseandstreamservicethrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceResponseandstreamservicethrows)(nil)

func (p *procFuncPubSubStreamingServiceResponseandstreamservicethrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceResponseandstreamservicethrows()
}

func (p *procFuncPubSubStreamingServiceResponseandstreamservicethrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncPubSubStreamingServiceResponseandstreamservicethrows) RunStreamContext(
    ctx context.Context,
    reqStruct thrift.ReadableStruct,
    onFirstResponse func(thrift.WritableStruct),
    onStreamNext func(thrift.WritableStruct),
    onStreamComplete func(),
) {
    args := reqStruct.(*reqPubSubStreamingServiceResponseandstreamservicethrows)
    firstResponse := newRespPubSubStreamingServiceResponseandstreamservicethrows()
    retval, elemProducerFunc, initialErr := p.handler.Responseandstreamservicethrows(ctx, args.Foo)
    if initialErr != nil {
        switch v := initialErr.(type) {
        case *FooEx:
            firstResponse.E = v
            onFirstResponse(firstResponse)
        default:
            internalErr := fmt.Errorf("Internal error processing Responseandstreamservicethrows: %w", initialErr)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            onFirstResponse(x)
        }
        onStreamComplete()
        return
    }

    firstResponse.Success = &retval
    onFirstResponse(firstResponse)

    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)
    var senderWg sync.WaitGroup
    senderWg.Add(1)
    // Sender goroutine (receives elements on the channel and sends them out via onStreamNext)
    go func() {
        defer senderWg.Done()
        for elem := range fbthriftElemChan {
            streamWrapStruct := newStreamPubSubStreamingServiceResponseandstreamservicethrows()
            streamWrapStruct.Success = &elem
            onStreamNext(streamWrapStruct)
        }
    }()

    streamErr := elemProducerFunc(ctx, fbthriftElemChan)
    // Stream is complete. Close the channel and wait for the sender goroutine to finish.
    close(fbthriftElemChan)
    senderWg.Wait()
    if streamErr != nil {
        internalErr := fmt.Errorf("Internal stream handler error Responseandstreamservicethrows: %w", streamErr)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        onStreamNext(x)
    }
    onStreamComplete()
}

type procFuncPubSubStreamingServiceResponseandstreamboththrows struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceResponseandstreamboththrows)(nil)

func (p *procFuncPubSubStreamingServiceResponseandstreamboththrows) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceResponseandstreamboththrows()
}

func (p *procFuncPubSubStreamingServiceResponseandstreamboththrows) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncPubSubStreamingServiceResponseandstreamboththrows) RunStreamContext(
    ctx context.Context,
    reqStruct thrift.ReadableStruct,
    onFirstResponse func(thrift.WritableStruct),
    onStreamNext func(thrift.WritableStruct),
    onStreamComplete func(),
) {
    args := reqStruct.(*reqPubSubStreamingServiceResponseandstreamboththrows)
    firstResponse := newRespPubSubStreamingServiceResponseandstreamboththrows()
    retval, elemProducerFunc, initialErr := p.handler.Responseandstreamboththrows(ctx, args.Foo)
    if initialErr != nil {
        switch v := initialErr.(type) {
        case *FooEx:
            firstResponse.E = v
            onFirstResponse(firstResponse)
        default:
            internalErr := fmt.Errorf("Internal error processing Responseandstreamboththrows: %w", initialErr)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            onFirstResponse(x)
        }
        onStreamComplete()
        return
    }

    firstResponse.Success = &retval
    onFirstResponse(firstResponse)

    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)
    var senderWg sync.WaitGroup
    senderWg.Add(1)
    // Sender goroutine (receives elements on the channel and sends them out via onStreamNext)
    go func() {
        defer senderWg.Done()
        for elem := range fbthriftElemChan {
            streamWrapStruct := newStreamPubSubStreamingServiceResponseandstreamboththrows()
            streamWrapStruct.Success = &elem
            onStreamNext(streamWrapStruct)
        }
    }()

    streamErr := elemProducerFunc(ctx, fbthriftElemChan)
    // Stream is complete. Close the channel and wait for the sender goroutine to finish.
    close(fbthriftElemChan)
    senderWg.Wait()
    if streamErr != nil {
        streamWrapStruct := newStreamPubSubStreamingServiceResponseandstreamboththrows()
        switch v := streamErr.(type) {
        case *FooStreamEx:
            streamWrapStruct.E = v
            onStreamNext(streamWrapStruct)
        default:
            internalErr := fmt.Errorf("Internal stream handler error Responseandstreamboththrows: %w", streamErr)
            x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
            onStreamNext(x)
        }
    }
    onStreamComplete()
}

type procFuncPubSubStreamingServiceReturnstreamFast struct {
    handler PubSubStreamingService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncPubSubStreamingServiceReturnstreamFast)(nil)

func (p *procFuncPubSubStreamingServiceReturnstreamFast) NewReqArgs() thrift.ReadableStruct {
    return newReqPubSubStreamingServiceReturnstreamFast()
}

func (p *procFuncPubSubStreamingServiceReturnstreamFast) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncPubSubStreamingServiceReturnstreamFast) RunStreamContext(
    ctx context.Context,
    reqStruct thrift.ReadableStruct,
    onFirstResponse func(thrift.WritableStruct),
    onStreamNext func(thrift.WritableStruct),
    onStreamComplete func(),
) {
    args := reqStruct.(*reqPubSubStreamingServiceReturnstreamFast)
    firstResponse := newRespPubSubStreamingServiceReturnstreamFast()
    elemProducerFunc, initialErr := p.handler.ReturnstreamFast(ctx, args.I32From, args.I32To)
    if initialErr != nil {
        internalErr := fmt.Errorf("Internal error processing ReturnstreamFast: %w", initialErr)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        onFirstResponse(x)
        onStreamComplete()
        return
    }

    onFirstResponse(firstResponse)

    fbthriftElemChan := make(chan int32, thrift.DefaultStreamBufferSize)
    var senderWg sync.WaitGroup
    senderWg.Add(1)
    // Sender goroutine (receives elements on the channel and sends them out via onStreamNext)
    go func() {
        defer senderWg.Done()
        for elem := range fbthriftElemChan {
            streamWrapStruct := newStreamPubSubStreamingServiceReturnstreamFast()
            streamWrapStruct.Success = &elem
            onStreamNext(streamWrapStruct)
        }
    }()

    streamErr := elemProducerFunc(ctx, fbthriftElemChan)
    // Stream is complete. Close the channel and wait for the sender goroutine to finish.
    close(fbthriftElemChan)
    senderWg.Wait()
    if streamErr != nil {
        internalErr := fmt.Errorf("Internal stream handler error ReturnstreamFast: %w", streamErr)
        x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, internalErr.Error())
        onStreamNext(x)
    }
    onStreamComplete()
}

