/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/method_decorators/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include <thrift/lib/cpp2/gen/module_metadata_cpp.h>
#include "thrift/compiler/test/fixtures/method_decorators/gen-cpp2/module_metadata.h"
#include "thrift/compiler/test/fixtures/method_decorators/gen-cpp2/module_data.h"

// some of these functions can be so large that the compiler gives up optimizing
// them - and issues a warning which may be treated as an error!
//
// these functions are so rarely called that it is probably okay for them not to
// be optimized in practice
FOLLY_CLANG_DISABLE_WARNING("-Wignored-optimization-argument")

namespace apache {
namespace thrift {
namespace detail {
template <> struct TSchemaAssociation<::cpp2::DecoratedService, false> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -7896720196583643065;
  static constexpr ::std::string_view definitionKey = {"\xd1\x44\x52\x11\x2f\xc7\x1d\x23\xd8\x24\x12\xd8\xd4\x37\xdf\xe7", 16};
};
template <> struct TSchemaAssociation<::cpp2::UndecoratedService, false> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -7896720196583643065;
  static constexpr ::std::string_view definitionKey = {"\x8d\xfa\xf4\xc5\x87\xb9\x4e\xf1\x30\x60\xe6\xb9\x4e\xe2\x55\x98", 16};
};
template <> struct TSchemaAssociation<::cpp2::DecoratedService_ExtendsUndecoratedService, false> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -7896720196583643065;
  static constexpr ::std::string_view definitionKey = {"\x00\xf8\x19\x31\x00\xa6\xc2\xc8\xf4\x48\x29\xb0\x5c\xc1\x03\x9d", 16};
};
template <> struct TSchemaAssociation<::cpp2::DecoratedService_ExtendsDecoratedService, false> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -7896720196583643065;
  static constexpr ::std::string_view definitionKey = {"\xbe\x01\xa1\x22\xd0\x33\xd3\xa3\x12\xe6\x3f\x43\x70\xda\x3d\x4c", 16};
};
template <> struct TSchemaAssociation<::cpp2::UndecoratedService_ExtendsDecoratedService, false> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -7896720196583643065;
  static constexpr ::std::string_view definitionKey = {"\x44\x7c\x5c\x76\x45\x8e\xab\x3c\x6d\xe7\x3a\xfb\xd5\x12\xfc\x27", 16};
};
template <> struct TSchemaAssociation<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService, false> {
  static constexpr ::folly::Range<const ::std::string_view*>(*bundle)() = nullptr;
  static constexpr int64_t programId = -7896720196583643065;
  static constexpr ::std::string_view definitionKey = {"\xa3\x0c\xe2\xd7\x03\x5d\xc4\x45\x5f\xca\x1c\xe1\x14\xd7\x4c\x9b", 16};
};
namespace md {
using ThriftMetadata = ::apache::thrift::metadata::ThriftMetadata;
using ThriftPrimitiveType = ::apache::thrift::metadata::ThriftPrimitiveType;
using ThriftType = ::apache::thrift::metadata::ThriftType;
using ThriftService = ::apache::thrift::metadata::ThriftService;
using ThriftServiceContext = ::apache::thrift::metadata::ThriftServiceContext;
using ThriftFunctionGenerator = void (*)(ThriftMetadata&, ThriftService&);


const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::Request>::gen(ThriftMetadata& metadata) {
  auto res = genStructMetadata<::cpp2::Request>(metadata);
  if (res.preExists) {
    return res.metadata;
  }
  ::apache::thrift::metadata::ThriftStruct& module_Request = res.metadata;
  module_Request.is_union() = false;
  static const auto* const
  module_Request_fields = new std::array<EncodedThriftField, 1>{ {
    { 1, "id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{ }},  }};
  std::size_t i = 0;
  for (const auto& f : *module_Request_fields) {
    auto& field = module_Request.fields()[i];
    DCHECK_EQ(*field.id(), f.id);
    field.name() = f.name;
    field.is_optional() = f.is_optional;
    field.structured_annotations().emplace().assign(
        f.structured_annotations.begin(),
        f.structured_annotations.end());

    // writeAndGenType will modify metadata, which might invalidate `field` reference
    // We need to store the result in a separate `type` variable.
    apache::thrift::metadata::ThriftType type;
    f.metadata_type_interface->writeAndGenType(type, metadata);
    module_Request.fields()[i++].type() = std::move(type);
  }
  return res.metadata;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::detail::AdaptedRequest>::gen(ThriftMetadata& metadata) {
  auto res = genStructMetadata<::cpp2::detail::AdaptedRequest>(metadata);
  if (res.preExists) {
    return res.metadata;
  }
  ::apache::thrift::metadata::ThriftStruct& module_AdaptedRequest = res.metadata;
  module_AdaptedRequest.is_union() = false;
  static const auto* const
  module_AdaptedRequest_fields = new std::array<EncodedThriftField, 1>{ {
    { 1, "id", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{ }},  }};
  std::size_t i = 0;
  for (const auto& f : *module_AdaptedRequest_fields) {
    auto& field = module_AdaptedRequest.fields()[i];
    DCHECK_EQ(*field.id(), f.id);
    field.name() = f.name;
    field.is_optional() = f.is_optional;
    field.structured_annotations().emplace().assign(
        f.structured_annotations.begin(),
        f.structured_annotations.end());

    // writeAndGenType will modify metadata, which might invalidate `field` reference
    // We need to store the result in a separate `type` variable.
    apache::thrift::metadata::ThriftType type;
    f.metadata_type_interface->writeAndGenType(type, metadata);
    module_AdaptedRequest.fields()[i++].type() = std::move(type);
  }
  module_AdaptedRequest.structured_annotations()->push_back(*cvStruct("cpp.Adapter", { {"name", cvString("::apache::thrift::test::AdaptedStruct<MyAdapter>") } }).cv_struct());
  return res.metadata;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::Response>::gen(ThriftMetadata& metadata) {
  auto res = genStructMetadata<::cpp2::Response>(metadata);
  if (res.preExists) {
    return res.metadata;
  }
  ::apache::thrift::metadata::ThriftStruct& module_Response = res.metadata;
  module_Response.is_union() = false;
  static const auto* const
  module_Response_fields = new std::array<EncodedThriftField, 1>{ {
    { 1, "text", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{ }},  }};
  std::size_t i = 0;
  for (const auto& f : *module_Response_fields) {
    auto& field = module_Response.fields()[i];
    DCHECK_EQ(*field.id(), f.id);
    field.name() = f.name;
    field.is_optional() = f.is_optional;
    field.structured_annotations().emplace().assign(
        f.structured_annotations.begin(),
        f.structured_annotations.end());

    // writeAndGenType will modify metadata, which might invalidate `field` reference
    // We need to store the result in a separate `type` variable.
    apache::thrift::metadata::ThriftType type;
    f.metadata_type_interface->writeAndGenType(type, metadata);
    module_Response.fields()[i++].type() = std::move(type);
  }
  return res.metadata;
}

void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_noop([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "noop";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_VOID_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_echo([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "echo";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_DecoratedService_echo_text_1;
  module_DecoratedService_echo_text_1.id() = 1;
  module_DecoratedService_echo_text_1.name() = "text";
  module_DecoratedService_echo_text_1.is_optional() = false;
  auto module_DecoratedService_echo_text_1_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE);
  module_DecoratedService_echo_text_1_type->writeAndGenType(*module_DecoratedService_echo_text_1.type(), metadata);
  func.arguments()->push_back(std::move(module_DecoratedService_echo_text_1));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_increment([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "increment";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_DecoratedService_increment_num_1;
  module_DecoratedService_increment_num_1.id() = 1;
  module_DecoratedService_increment_num_1.name() = "num";
  module_DecoratedService_increment_num_1.is_optional() = false;
  auto module_DecoratedService_increment_num_1_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE);
  module_DecoratedService_increment_num_1_type->writeAndGenType(*module_DecoratedService_increment_num_1.type(), metadata);
  func.arguments()->push_back(std::move(module_DecoratedService_increment_num_1));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_sum([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "sum";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_DecoratedService_sum_nums_1;
  module_DecoratedService_sum_nums_1.id() = 1;
  module_DecoratedService_sum_nums_1.name() = "nums";
  module_DecoratedService_sum_nums_1.is_optional() = false;
  auto module_DecoratedService_sum_nums_1_type = std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE));
  module_DecoratedService_sum_nums_1_type->writeAndGenType(*module_DecoratedService_sum_nums_1.type(), metadata);
  func.arguments()->push_back(std::move(module_DecoratedService_sum_nums_1));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_withStruct([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "withStruct";
  auto func_ret_type = std::make_unique<Struct<::cpp2::Response>>("module.Response");
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_DecoratedService_withStruct_request_1;
  module_DecoratedService_withStruct_request_1.id() = 1;
  module_DecoratedService_withStruct_request_1.name() = "request";
  module_DecoratedService_withStruct_request_1.is_optional() = false;
  auto module_DecoratedService_withStruct_request_1_type = std::make_unique<Struct<::cpp2::Request>>("module.Request");
  module_DecoratedService_withStruct_request_1_type->writeAndGenType(*module_DecoratedService_withStruct_request_1.type(), metadata);
  func.arguments()->push_back(std::move(module_DecoratedService_withStruct_request_1));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_multiParam([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "multiParam";
  auto func_ret_type = std::make_unique<Struct<::cpp2::Response>>("module.Response");
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_DecoratedService_multiParam_text_1;
  module_DecoratedService_multiParam_text_1.id() = 1;
  module_DecoratedService_multiParam_text_1.name() = "text";
  module_DecoratedService_multiParam_text_1.is_optional() = false;
  auto module_DecoratedService_multiParam_text_1_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE);
  module_DecoratedService_multiParam_text_1_type->writeAndGenType(*module_DecoratedService_multiParam_text_1.type(), metadata);
  func.arguments()->push_back(std::move(module_DecoratedService_multiParam_text_1));
  ::apache::thrift::metadata::ThriftField module_DecoratedService_multiParam_num_2;
  module_DecoratedService_multiParam_num_2.id() = 2;
  module_DecoratedService_multiParam_num_2.name() = "num";
  module_DecoratedService_multiParam_num_2.is_optional() = false;
  auto module_DecoratedService_multiParam_num_2_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE);
  module_DecoratedService_multiParam_num_2_type->writeAndGenType(*module_DecoratedService_multiParam_num_2.type(), metadata);
  func.arguments()->push_back(std::move(module_DecoratedService_multiParam_num_2));
  ::apache::thrift::metadata::ThriftField module_DecoratedService_multiParam_request_3;
  module_DecoratedService_multiParam_request_3.id() = 3;
  module_DecoratedService_multiParam_request_3.name() = "request";
  module_DecoratedService_multiParam_request_3.is_optional() = false;
  auto module_DecoratedService_multiParam_request_3_type = std::make_unique<Struct<::cpp2::Request>>("module.Request");
  module_DecoratedService_multiParam_request_3_type->writeAndGenType(*module_DecoratedService_multiParam_request_3.type(), metadata);
  func.arguments()->push_back(std::move(module_DecoratedService_multiParam_request_3));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_echoInteraction([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "echoInteraction";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_VOID_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}

void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen(::apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  const ::apache::thrift::metadata::ThriftServiceContextRef* self = genRecurse(*response.metadata(), *response.services());
  DCHECK(self != nullptr);
  // TODO(praihan): Remove ThriftServiceContext from response. But in the meantime, we need to fill the field with the result of looking up in ThriftMetadata.
  ::apache::thrift::metadata::ThriftServiceContext context;
  context.module() = *self->module();
  context.service_info() = response.metadata()->services()->at(*self->service_name());
  response.context() = std::move(context);
}

const ThriftServiceContextRef* ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::genRecurse([[maybe_unused]] ThriftMetadata& metadata, std::vector<ThriftServiceContextRef>& services) {
  ::apache::thrift::metadata::ThriftService module_DecoratedService = genServiceMetadata<::cpp2::DecoratedService>();
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_noop,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_echo,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_increment,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_sum,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_withStruct,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_multiParam,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::gen_echoInteraction,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, module_DecoratedService);
  }
  // We need to keep the index around because a reference or iterator could be invalidated.
  auto selfIndex = services.size();
  services.emplace_back();
  module_DecoratedService.structured_annotations()->push_back(*cvStruct("cpp.GenerateServiceMethodDecorator", {  }).cv_struct());
  ThriftServiceContextRef& context = services[selfIndex];
  metadata.services()->emplace("module.DecoratedService", std::move(module_DecoratedService));
  context.service_name() = "module.DecoratedService";
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name() = "module";
  context.module() = std::move(module);
  return &context;
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_noop([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "noop";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_VOID_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_echo([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "echo";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_UndecoratedService_echo_text_1;
  module_UndecoratedService_echo_text_1.id() = 1;
  module_UndecoratedService_echo_text_1.name() = "text";
  module_UndecoratedService_echo_text_1.is_optional() = false;
  auto module_UndecoratedService_echo_text_1_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE);
  module_UndecoratedService_echo_text_1_type->writeAndGenType(*module_UndecoratedService_echo_text_1.type(), metadata);
  func.arguments()->push_back(std::move(module_UndecoratedService_echo_text_1));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_increment([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "increment";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_UndecoratedService_increment_num_1;
  module_UndecoratedService_increment_num_1.id() = 1;
  module_UndecoratedService_increment_num_1.name() = "num";
  module_UndecoratedService_increment_num_1.is_optional() = false;
  auto module_UndecoratedService_increment_num_1_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE);
  module_UndecoratedService_increment_num_1_type->writeAndGenType(*module_UndecoratedService_increment_num_1.type(), metadata);
  func.arguments()->push_back(std::move(module_UndecoratedService_increment_num_1));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_sum([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "sum";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_UndecoratedService_sum_nums_1;
  module_UndecoratedService_sum_nums_1.id() = 1;
  module_UndecoratedService_sum_nums_1.name() = "nums";
  module_UndecoratedService_sum_nums_1.is_optional() = false;
  auto module_UndecoratedService_sum_nums_1_type = std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE));
  module_UndecoratedService_sum_nums_1_type->writeAndGenType(*module_UndecoratedService_sum_nums_1.type(), metadata);
  func.arguments()->push_back(std::move(module_UndecoratedService_sum_nums_1));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_withStruct([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "withStruct";
  auto func_ret_type = std::make_unique<Struct<::cpp2::Response>>("module.Response");
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_UndecoratedService_withStruct_request_1;
  module_UndecoratedService_withStruct_request_1.id() = 1;
  module_UndecoratedService_withStruct_request_1.name() = "request";
  module_UndecoratedService_withStruct_request_1.is_optional() = false;
  auto module_UndecoratedService_withStruct_request_1_type = std::make_unique<Struct<::cpp2::Request>>("module.Request");
  module_UndecoratedService_withStruct_request_1_type->writeAndGenType(*module_UndecoratedService_withStruct_request_1.type(), metadata);
  func.arguments()->push_back(std::move(module_UndecoratedService_withStruct_request_1));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_multiParam([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "multiParam";
  auto func_ret_type = std::make_unique<Struct<::cpp2::Response>>("module.Response");
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_UndecoratedService_multiParam_text_1;
  module_UndecoratedService_multiParam_text_1.id() = 1;
  module_UndecoratedService_multiParam_text_1.name() = "text";
  module_UndecoratedService_multiParam_text_1.is_optional() = false;
  auto module_UndecoratedService_multiParam_text_1_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE);
  module_UndecoratedService_multiParam_text_1_type->writeAndGenType(*module_UndecoratedService_multiParam_text_1.type(), metadata);
  func.arguments()->push_back(std::move(module_UndecoratedService_multiParam_text_1));
  ::apache::thrift::metadata::ThriftField module_UndecoratedService_multiParam_num_2;
  module_UndecoratedService_multiParam_num_2.id() = 2;
  module_UndecoratedService_multiParam_num_2.name() = "num";
  module_UndecoratedService_multiParam_num_2.is_optional() = false;
  auto module_UndecoratedService_multiParam_num_2_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE);
  module_UndecoratedService_multiParam_num_2_type->writeAndGenType(*module_UndecoratedService_multiParam_num_2.type(), metadata);
  func.arguments()->push_back(std::move(module_UndecoratedService_multiParam_num_2));
  ::apache::thrift::metadata::ThriftField module_UndecoratedService_multiParam_request_3;
  module_UndecoratedService_multiParam_request_3.id() = 3;
  module_UndecoratedService_multiParam_request_3.name() = "request";
  module_UndecoratedService_multiParam_request_3.is_optional() = false;
  auto module_UndecoratedService_multiParam_request_3_type = std::make_unique<Struct<::cpp2::Request>>("module.Request");
  module_UndecoratedService_multiParam_request_3_type->writeAndGenType(*module_UndecoratedService_multiParam_request_3.type(), metadata);
  func.arguments()->push_back(std::move(module_UndecoratedService_multiParam_request_3));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_adaptedRequest([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "adaptedRequest";
  auto func_ret_type = std::make_unique<Struct<::cpp2::Response>>("module.Response");
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_UndecoratedService_adaptedRequest_request_1;
  module_UndecoratedService_adaptedRequest_request_1.id() = 1;
  module_UndecoratedService_adaptedRequest_request_1.name() = "request";
  module_UndecoratedService_adaptedRequest_request_1.is_optional() = false;
  auto module_UndecoratedService_adaptedRequest_request_1_type = std::make_unique<Struct<::cpp2::detail::AdaptedRequest>>("module.AdaptedRequest");
  module_UndecoratedService_adaptedRequest_request_1_type->writeAndGenType(*module_UndecoratedService_adaptedRequest_request_1.type(), metadata);
  func.arguments()->push_back(std::move(module_UndecoratedService_adaptedRequest_request_1));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}

void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen(::apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  const ::apache::thrift::metadata::ThriftServiceContextRef* self = genRecurse(*response.metadata(), *response.services());
  DCHECK(self != nullptr);
  // TODO(praihan): Remove ThriftServiceContext from response. But in the meantime, we need to fill the field with the result of looking up in ThriftMetadata.
  ::apache::thrift::metadata::ThriftServiceContext context;
  context.module() = *self->module();
  context.service_info() = response.metadata()->services()->at(*self->service_name());
  response.context() = std::move(context);
}

const ThriftServiceContextRef* ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::genRecurse([[maybe_unused]] ThriftMetadata& metadata, std::vector<ThriftServiceContextRef>& services) {
  ::apache::thrift::metadata::ThriftService module_UndecoratedService = genServiceMetadata<::cpp2::UndecoratedService>();
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_noop,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_echo,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_increment,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_sum,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_withStruct,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_multiParam,
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::gen_adaptedRequest,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, module_UndecoratedService);
  }
  // We need to keep the index around because a reference or iterator could be invalidated.
  auto selfIndex = services.size();
  services.emplace_back();
  ThriftServiceContextRef& context = services[selfIndex];
  metadata.services()->emplace("module.UndecoratedService", std::move(module_UndecoratedService));
  context.service_name() = "module.UndecoratedService";
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name() = "module";
  context.module() = std::move(module);
  return &context;
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>>::gen_extension([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "extension";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_VOID_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}

void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>>::gen(::apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  const ::apache::thrift::metadata::ThriftServiceContextRef* self = genRecurse(*response.metadata(), *response.services());
  DCHECK(self != nullptr);
  // TODO(praihan): Remove ThriftServiceContext from response. But in the meantime, we need to fill the field with the result of looking up in ThriftMetadata.
  ::apache::thrift::metadata::ThriftServiceContext context;
  context.module() = *self->module();
  context.service_info() = response.metadata()->services()->at(*self->service_name());
  response.context() = std::move(context);
}

const ThriftServiceContextRef* ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>>::genRecurse([[maybe_unused]] ThriftMetadata& metadata, std::vector<ThriftServiceContextRef>& services) {
  ::apache::thrift::metadata::ThriftService module_DecoratedService_ExtendsUndecoratedService = genServiceMetadata<::cpp2::DecoratedService_ExtendsUndecoratedService>();
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService>>::gen_extension,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, module_DecoratedService_ExtendsUndecoratedService);
  }
  // We need to keep the index around because a reference or iterator could be invalidated.
  auto selfIndex = services.size();
  services.emplace_back();
  DCHECK_EQ(*module_DecoratedService_ExtendsUndecoratedService.parent(), "module.UndecoratedService");
  ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService>>::genRecurse(metadata, services);
  module_DecoratedService_ExtendsUndecoratedService.structured_annotations()->push_back(*cvStruct("cpp.GenerateServiceMethodDecorator", {  }).cv_struct());
  ThriftServiceContextRef& context = services[selfIndex];
  metadata.services()->emplace("module.DecoratedService_ExtendsUndecoratedService", std::move(module_DecoratedService_ExtendsUndecoratedService));
  context.service_name() = "module.DecoratedService_ExtendsUndecoratedService";
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name() = "module";
  context.module() = std::move(module);
  return &context;
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>>::gen_extension([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "extension";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_VOID_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}

void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>>::gen(::apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  const ::apache::thrift::metadata::ThriftServiceContextRef* self = genRecurse(*response.metadata(), *response.services());
  DCHECK(self != nullptr);
  // TODO(praihan): Remove ThriftServiceContext from response. But in the meantime, we need to fill the field with the result of looking up in ThriftMetadata.
  ::apache::thrift::metadata::ThriftServiceContext context;
  context.module() = *self->module();
  context.service_info() = response.metadata()->services()->at(*self->service_name());
  response.context() = std::move(context);
}

const ThriftServiceContextRef* ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>>::genRecurse([[maybe_unused]] ThriftMetadata& metadata, std::vector<ThriftServiceContextRef>& services) {
  ::apache::thrift::metadata::ThriftService module_DecoratedService_ExtendsDecoratedService = genServiceMetadata<::cpp2::DecoratedService_ExtendsDecoratedService>();
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsDecoratedService>>::gen_extension,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, module_DecoratedService_ExtendsDecoratedService);
  }
  // We need to keep the index around because a reference or iterator could be invalidated.
  auto selfIndex = services.size();
  services.emplace_back();
  DCHECK_EQ(*module_DecoratedService_ExtendsDecoratedService.parent(), "module.DecoratedService");
  ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::genRecurse(metadata, services);
  module_DecoratedService_ExtendsDecoratedService.structured_annotations()->push_back(*cvStruct("cpp.GenerateServiceMethodDecorator", {  }).cv_struct());
  ThriftServiceContextRef& context = services[selfIndex];
  metadata.services()->emplace("module.DecoratedService_ExtendsDecoratedService", std::move(module_DecoratedService_ExtendsDecoratedService));
  context.service_name() = "module.DecoratedService_ExtendsDecoratedService";
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name() = "module";
  context.module() = std::move(module);
  return &context;
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>>::gen_extension([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "extension";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_VOID_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}

void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>>::gen(::apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  const ::apache::thrift::metadata::ThriftServiceContextRef* self = genRecurse(*response.metadata(), *response.services());
  DCHECK(self != nullptr);
  // TODO(praihan): Remove ThriftServiceContext from response. But in the meantime, we need to fill the field with the result of looking up in ThriftMetadata.
  ::apache::thrift::metadata::ThriftServiceContext context;
  context.module() = *self->module();
  context.service_info() = response.metadata()->services()->at(*self->service_name());
  response.context() = std::move(context);
}

const ThriftServiceContextRef* ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>>::genRecurse([[maybe_unused]] ThriftMetadata& metadata, std::vector<ThriftServiceContextRef>& services) {
  ::apache::thrift::metadata::ThriftService module_UndecoratedService_ExtendsDecoratedService = genServiceMetadata<::cpp2::UndecoratedService_ExtendsDecoratedService>();
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>>::gen_extension,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, module_UndecoratedService_ExtendsDecoratedService);
  }
  // We need to keep the index around because a reference or iterator could be invalidated.
  auto selfIndex = services.size();
  services.emplace_back();
  DCHECK_EQ(*module_UndecoratedService_ExtendsDecoratedService.parent(), "module.DecoratedService");
  ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService>>::genRecurse(metadata, services);
  ThriftServiceContextRef& context = services[selfIndex];
  metadata.services()->emplace("module.UndecoratedService_ExtendsDecoratedService", std::move(module_UndecoratedService_ExtendsDecoratedService));
  context.service_name() = "module.UndecoratedService_ExtendsDecoratedService";
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name() = "module";
  context.module() = std::move(module);
  return &context;
}
void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>>::gen_secondExtension([[maybe_unused]] ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  func.name() = "secondExtension";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE);
  func_ret_type->writeAndGenType(*func.return_type(), metadata);
  ::apache::thrift::metadata::ThriftField module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService_secondExtension_input_1;
  module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService_secondExtension_input_1.id() = 1;
  module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService_secondExtension_input_1.name() = "input";
  module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService_secondExtension_input_1.is_optional() = false;
  auto module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService_secondExtension_input_1_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE);
  module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService_secondExtension_input_1_type->writeAndGenType(*module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService_secondExtension_input_1.type(), metadata);
  func.arguments()->push_back(std::move(module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService_secondExtension_input_1));
  func.is_oneway() = false;
  service.functions()->push_back(std::move(func));
}

void ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>>::gen(::apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  const ::apache::thrift::metadata::ThriftServiceContextRef* self = genRecurse(*response.metadata(), *response.services());
  DCHECK(self != nullptr);
  // TODO(praihan): Remove ThriftServiceContext from response. But in the meantime, we need to fill the field with the result of looking up in ThriftMetadata.
  ::apache::thrift::metadata::ThriftServiceContext context;
  context.module() = *self->module();
  context.service_info() = response.metadata()->services()->at(*self->service_name());
  response.context() = std::move(context);
}

const ThriftServiceContextRef* ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>>::genRecurse([[maybe_unused]] ThriftMetadata& metadata, std::vector<ThriftServiceContextRef>& services) {
  ::apache::thrift::metadata::ThriftService module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService = genServiceMetadata<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>();
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService>>::gen_secondExtension,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService);
  }
  // We need to keep the index around because a reference or iterator could be invalidated.
  auto selfIndex = services.size();
  services.emplace_back();
  DCHECK_EQ(*module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService.parent(), "module.UndecoratedService_ExtendsDecoratedService");
  ServiceMetadata<::apache::thrift::ServiceHandler<::cpp2::UndecoratedService_ExtendsDecoratedService>>::genRecurse(metadata, services);
  module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService.structured_annotations()->push_back(*cvStruct("cpp.GenerateServiceMethodDecorator", {  }).cv_struct());
  ThriftServiceContextRef& context = services[selfIndex];
  metadata.services()->emplace("module.DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService", std::move(module_DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService));
  context.service_name() = "module.DecoratedService_ExtendsUndecoratedService_ExtendsDecoratedService";
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name() = "module";
  context.module() = std::move(module);
  return &context;
}
} // namespace md
} // namespace detail
} // namespace thrift
} // namespace apache
