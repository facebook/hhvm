/*
 *  Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 *  This source code is licensed under the MIT license found in the LICENSE
 *  file in the root directory of this source tree.
 *
 */

/*
 *  THIS FILE IS AUTOGENERATED. DO NOT MODIFY IT; ALL CHANGES WILL BE LOST IN
 *  VAIN.
 *
 *  @generated
 */
#pragma once

#include <exception>
#include <memory>

#include <mcrouter/lib/network/RpcStatsContext.h>
#include <mcrouter/lib/network/ThriftTransport.h>
#include <mcrouter/McrouterFiberContext.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <thrift/lib/cpp/transport/TTransportException.h>
#include <thrift/lib/cpp2/async/RequestChannel.h>

#include "mcrouter/lib/network/gen/gen-cpp2/MemcacheAsyncClient.h"

namespace facebook {
namespace memcache {

template <>
class ThriftTransportMethods<MemcacheRouterInfo> : public ThriftTransportUtil {
 public:
  ThriftTransportMethods() = default;
  virtual ~ThriftTransportMethods() override = default;

folly::Try<apache::thrift::RpcResponseComplete<McAddReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McAddRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcAdd(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McAppendReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McAppendRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcAppend(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McCasReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McCasRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcCas(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McDecrReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McDecrRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcDecr(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McDeleteReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McDeleteRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcDelete(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McFlushAllReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McFlushAllRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcFlushAll(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McFlushReReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McFlushReRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcFlushRe(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McGatReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McGatRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcGat(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McGatsReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McGatsRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcGats(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McGetReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McGetRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcGet(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McGetsReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McGetsRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcGets(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McIncrReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McIncrRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcIncr(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McLeaseGetReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McLeaseGetRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcLeaseGet(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McLeaseSetReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McLeaseSetRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcLeaseSet(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McMetagetReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McMetagetRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcMetaget(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McPrependReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McPrependRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcPrepend(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McReplaceReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McReplaceRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcReplace(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McSetReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McSetRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcSet(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McTouchReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McTouchRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcTouch(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

folly::Try<apache::thrift::RpcResponseComplete<McVersionReply>> sendSyncHelper(
    typename MemcacheRouterInfo::RouteHandleAsyncClient* thriftClient,
    const McVersionRequest& request,
    apache::thrift::RpcOptions& rpcOptions,
    RpcStatsContext* rpcStatsContext = nullptr) {
  bool needServerLoad = mcrouter::fiber_local<MemcacheRouterInfo>::getThriftServerLoadEnabled();
  if (UNLIKELY(needServerLoad)) {
    rpcOptions.setWriteHeader(kLoadHeader, kDefaultLoadCounter);
  }
  if (UNLIKELY(request.getCryptoAuthToken().has_value())) {
    rpcOptions.setWriteHeader(
        std::string{carbon::MessageCommon::kCryptoAuthTokenHeader}, request.getCryptoAuthToken().value());
  }
  rpcOptions.setContextPropMask(0);

#ifndef LIBMC_FBTRACE_DISABLE
  traceRequest(request, rpcOptions);
#endif
  auto reply = thriftClient->sync_complete_mcVersion(
      std::move(rpcOptions), request);
  if (rpcStatsContext && reply.hasValue()) {
      auto& stats = reply->responseContext.rpcSizeStats;
      rpcStatsContext->requestBodySize = stats.requestSerializedSizeBytes;
      rpcStatsContext->replySizeBeforeCompression = stats.responseSerializedSizeBytes;
      rpcStatsContext->replySizeAfterCompression = stats.responseWireSizeBytes;
      if (UNLIKELY(needServerLoad && reply->responseContext.serverLoad)) {
        rpcStatsContext->serverLoad = ServerLoad(
            static_cast<int32_t>(*reply->responseContext.serverLoad));
      }
  }
#ifndef LIBMC_FBTRACE_DISABLE
  traceResponse(request, reply);
#endif
  return reply;
}

 protected:
  std::optional<apache::thrift::Client<facebook::memcache::thrift::Memcache>> thriftClient_;
};

template <>
class ThriftTransport<MemcacheRouterInfo> : public ThriftTransportMethods<MemcacheRouterInfo>,
                                       public ThriftTransportBase {
 public:
  ThriftTransport(folly::EventBase& eventBase, ConnectionOptions options)
      : ThriftTransportBase(eventBase, std::move(options)) {}
  ThriftTransport(folly::VirtualEventBase& eventBase, ConnectionOptions options)
      : ThriftTransportBase(eventBase.getEventBase(), std::move(options)) {}
  ~ThriftTransport() override {
    resetClient();
  }

  void setFlushList(FlushList* flushList) override final {
    flushList_ = flushList;
    if (thriftClient_) {
      auto* channel = static_cast<apache::thrift::RocketClientChannel*>(
          thriftClient_->getChannel());
      channel->setFlushList(flushList_);
    }
  }

  McAddReply sendSync(
      const McAddRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McAddReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McAppendReply sendSync(
      const McAppendRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McAppendReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McCasReply sendSync(
      const McCasRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McCasReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McDecrReply sendSync(
      const McDecrRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McDecrReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McDeleteReply sendSync(
      const McDeleteRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McDeleteReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McFlushAllReply sendSync(
      const McFlushAllRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McFlushAllReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McFlushReReply sendSync(
      const McFlushReRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McFlushReReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McGatReply sendSync(
      const McGatRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McGatReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McGatsReply sendSync(
      const McGatsRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McGatsReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McGetReply sendSync(
      const McGetRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McGetReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McGetsReply sendSync(
      const McGetsRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McGetsReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McIncrReply sendSync(
      const McIncrRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McIncrReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McLeaseGetReply sendSync(
      const McLeaseGetRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McLeaseGetReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McLeaseSetReply sendSync(
      const McLeaseSetRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McLeaseSetReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McMetagetReply sendSync(
      const McMetagetRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McMetagetReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McPrependReply sendSync(
      const McPrependRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McPrependReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McReplaceReply sendSync(
      const McReplaceRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McReplaceReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McSetReply sendSync(
      const McSetRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McSetReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McTouchReply sendSync(
      const McTouchRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McTouchReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

  McVersionReply sendSync(
      const McVersionRequest& request,
      std::chrono::milliseconds timeout,
      RpcStatsContext* rpcStatsContext = nullptr) {

    return sendSyncImpl([this, &request, timeout, rpcStatsContext] {
      auto* thriftClient = getThriftClient();
      if (LIKELY(thriftClient != nullptr)) {
        auto rpcOptions = getRpcOptions(timeout);
        return sendSyncHelper(thriftClient, request, rpcOptions, rpcStatsContext);
      } else {
        return folly::Try<apache::thrift::RpcResponseComplete<McVersionReply>>(
            folly::make_exception_wrapper<apache::thrift::transport::TTransportException>(
              apache::thrift::transport::TTransportException::NOT_OPEN,
              "Error creating thrift client."));
      }
    });
  }

 private:
  FlushList* flushList_{nullptr};

  apache::thrift::Client<facebook::memcache::thrift::Memcache>* getThriftClient() {
    if (UNLIKELY(!thriftClient_)) {
      thriftClient_ = createThriftClient<apache::thrift::Client<facebook::memcache::thrift::Memcache>>();
      if (flushList_) {
        auto* channel = static_cast<apache::thrift::RocketClientChannel*>(
            thriftClient_->getChannel());
        channel->setFlushList(flushList_);
      }
    }
    if (LIKELY(thriftClient_.has_value())) {
      return &thriftClient_.value();
    }
    return nullptr;
  }

  void resetClient() override final {
    if (thriftClient_) {
      if (auto channel = thriftClient_->getChannel()) {
        // Reset the callback to avoid the following cycle:
        //  ~ThriftAsyncClient() -> ~RocketClientChannel() ->
        //  channelClosed() -> ~ThriftAsyncClient()
        channel->setCloseCallback(nullptr);
      }
      thriftClient_.reset();
    }
  }
};

} // namespace memcache
} // namespace facebook